/**********************************************************************************
 * (c) 2016-2023, Master Technology
 * Licensed under the MIT license or contact me for a Support or Commercial License
 *
 * I do contract work in most languages, so let me solve your problems!
 *
 * Any questions please feel free to email me or put a issue up on the github repo
 * Version 2.5.3                                      Nathan@master-technology.com
 *********************************************************************************/
"use strict";

/* jshint camelcase: false */
/* global global, require, UIDevice, UIDeviceOrientation, UIView, getElementsByTagName, android */

const application = require('@nativescript/core/application');
const viewbase = require('@nativescript/core/ui/core/view-base');

// Broken in some versions of NS8, so we will just define them here....
const enums = {
	DeviceOrientation: { portrait: 'portrait', landscape: 'landscape', unknown: 'unknown' }
};

const frame = require('@nativescript/core/ui/frame');
const Page = require('@nativescript/core/ui/page').Page;


// Load the helper plugins
require('@proplugins/nativescript-dom');

let allowRotation = true, forceRotation = false, forcingRotation = -1, fullScreen = false, displayedWarning=false;
let orientation = { };
let orientationAppliers = [];

module.exports = orientation;

/**
 * Function to add a new orientation applier callback
 */
orientation.addOrientationApplier = function(newOrientationApplier) {
    if (!newOrientationApplier) return;

    const existingApplier = orientationAppliers.find(function(oa) { return oa === newOrientationApplier; });
    if (existingApplier) return;

    orientationAppliers.push(newOrientationApplier);
};

/**
 * Function to remove an orientation applier callback
 */
orientation.removeOrientationApplier = function(orientationApplier) {
    if (!orientationApplier) return;

    orientationAppliers = orientationAppliers.filter(function (oa) { return oa !== orientationApplier; });
};

orientation.getRotationLocked = function() { return !allowRotation; };


/**
 * Helper function hooked to the Application to get the current orientation
 */
if (global.android) {
	orientation.getOrientation = function () {
        const context = getContext();

        // These both lie on Tablets, The orientation is opposite, so it is safer to use .orientation value
        // context.getSystemService("window").getDefaultDisplay().getOrientation();
        // context.getSystemService("window").getDefaultDisplay().getRotation();

        const currentOrientation = getContext().getResources().getConfiguration().orientation;

        switch (currentOrientation) {
            case 2: /* LANDSCAPE */
                return enums.DeviceOrientation.landscape;
            case 1: /* PORTRAIT */
                return enums.DeviceOrientation.portrait;
            default:
                break;
        }


        // If for some reason the orientation code above doesn't figure it out; we use sizes
        const metrics = new android.util.DisplayMetrics();
        context.getSystemService(android.content.Context.WINDOW_SERVICE).getDefaultDisplay().getRealMetrics(metrics);
        if (metrics.widthPixels > metrics.heightPixels) {
            return enums.DeviceOrientation.landscape;
        }
        return enums.DeviceOrientation.portrait;

    };

	orientation.enableRotation = function() {
		if (!application.android || !application.android.foregroundActivity) {
			setTimeout(orientation.enableRotation, 100);
			return;
		}

		const activity = application.android.foregroundActivity;
		activity.setRequestedOrientation(13);  // SCREEN_ORIENTATION_FULL_USER = 13
		allowRotation = true;
	};

	orientation.disableRotation = function() {
		if (!application.android || !application.android.foregroundActivity) {
			setTimeout(orientation.disableRotation, 100);
			return;
		}

		const activity = application.android.foregroundActivity;
        activity.setRequestedOrientation(14); // SCREEN_ORIENTATION_LOCKED = 14
		allowRotation = false;
	};

	orientation.setOrientation = function(value, animation) {
		if (!application.android || !application.android.foregroundActivity) {
			setTimeout(function() { orientation.setOrientation(value, animation); }, 100);
			return;
		}

		const activity = application.android.foregroundActivity;

		const val = value.toLowerCase();
		let newOrientation;
		switch (val) {
			case 'landscape':
				newOrientation = 6; // SCREEN_ORIENTATION_SENSOR_LANDSCAPE = 6
                break;

			case 'landscaperight':
				newOrientation = 0; // SCREEN_ORIENTATION_LANDSCAPE = 0
				break;

			case 'landscapeleft':
				newOrientation = 8; // SCREEN_ORIENTATION_REVERSE_LANDSCAPE = 9
				break;

			case 'portrait':
			default:
				newOrientation = 1; // SCREEN_ORIENTATION_PORTRAIT = 1
				break;
		}
		activity.setRequestedOrientation(newOrientation);
		allowRotation = false;

		// Animation: https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#ROTATION_ANIMATION_JUMPCUT
		// and https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#rotationAnimation

	};

	orientation.setFullScreen = function(value) {

            const View = android.view.View;
            const WindowManager = android.view.WindowManager;
            const window = application.android.startActivity.getWindow();

            fullScreen = !!value;

            if (fullScreen) {
                window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
                window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                        | View.SYSTEM_UI_FLAG_FULLSCREEN
                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY );
            } else {
                    window.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
                    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
            }
    };

} else if (global.NSObject && global.UIDevice) {
    const iOSNeedsExtraCode = getIOSis16orLater();
	setupiOSController();
	orientation.getOrientation = function (forcedValue= false) {
		const device = UIDevice.currentDevice;
		if (forcedValue && forcingRotation > 0) {
			switch (forcingRotation) {
				case 3:
				case 4: return  enums.DeviceOrientation.landscape;
				case 1:
				case 2: return enums.DeviceOrientation.portrait;
			}
		}

		switch (device.orientation) {
			case UIDeviceOrientation.UIDeviceOrientationLandscapeRight:
			case UIDeviceOrientation.UIDeviceOrientationLandscapeLeft:
				return enums.DeviceOrientation.landscape;
			case UIDeviceOrientation.UIDeviceOrientationPortraitUpsideDown:
			case UIDeviceOrientation.UIDeviceOrientationPortrait:
				return enums.DeviceOrientation.portrait;
			default:
				// Since we have an up/Down orientation, we need to see what the statusbar is set to get the actual current device orientation
				const appOrientation = UIApplication.sharedApplication.statusBarOrientation;
				if (appOrientation === 1 || appOrientation === 2) { return enums.DeviceOrientation.portrait; }
				else { return enums.DeviceOrientation.landscape; }
		}
	};

	orientation.setOrientation = function(value, animation) {
		let newOrientation, val = value.toLowerCase();
		if (val === 'landscape' || val === 'landscaperight') {
			newOrientation = NSNumber.numberWithInt(UIInterfaceOrientationLandscapeRight);
		} else if (val === 'landscapeleft') {
			newOrientation = NSNumber.numberWithInt(UIInterfaceOrientationLandscapeLeft);
		} else {
			newOrientation = NSNumber.numberWithInt(UIInterfaceOrientationPortrait);
		}
		const device = UIDevice.currentDevice;
		if (animation === false) {
			UIView.setAnimationsEnabled(false);
		}
		allowRotation = false; // disable rotations...
		forceRotation = true;
		forcingRotation = newOrientation;
		if (iOSNeedsExtraCode) {
			// device.setValueForKey(newOrientation, "orientation");
			// We have to call this first to make sure the orientations are allowed to be set
			getIOSController()?.setNeedsUpdateOfSupportedInterfaceOrientations();
		}

		//  const currentOrientation = device.orientation;
		// We have to swap to a different orientation FIRST, if the current orientation matches

		// This code seems to be now broken on iPAD's under the new OS versions, we are disabling but commenting it because
		// see https://git.proplugins.org/proplugins/nativescript-orientation/issues/1
		// this code was needed in the past, so we are just commenting it out in case we can figure out what instances this was actually needed.
		/*		if (newOrientation === currentOrientation) {
			let tempOrientation = newOrientation-1;
			if (tempOrientation < 1) { tempOrientation += 2; }
			device.setValueForKey(tempOrientation, "orientation");
		} */

		device.setValueForKey(newOrientation, "orientation");
		forceRotation = false;

		if (iOSNeedsExtraCode) {
			// We have to call this after words to make sure the orientations are correct
			getIOSController()?.setNeedsUpdateOfSupportedInterfaceOrientations();
		}


		if (animation === false) {
			UIView.setAnimationsEnabled(true);
		}

		handleOrientationChange();
	};

	orientation.enableRotation = function() {
		allowRotation = true;
		forcingRotation = -1;
		if (iOSNeedsExtraCode) {
			getIOSController()?.setNeedsUpdateOfSupportedInterfaceOrientations()
		}
	};

	orientation.disableRotation = function() {
		allowRotation = false;
		switch (getDeviceOrientationMask()) {
			case UIInterfaceOrientationMaskLandscapeLeft: forcingRotation = 4; break;
			case UIInterfaceOrientationMaskLandscapeRight: forcingRotation = 3; break;
			case UIInterfaceOrientationMaskPortrait: forcingRotation = 1; break;
			case UIInterfaceOrientationMaskPortraitUpsideDown: forcingRotation = 2; break;
			default:
				forcingRotation = -1;
		}
		if (iOSNeedsExtraCode) {
			getIOSController()?.setNeedsUpdateOfSupportedInterfaceOrientations();
		}
	};

	orientation.setFullScreen = function(setFullScreen) {
	    fullScreen = !!setFullScreen;
	    UIApplication.sharedApplication.setStatusBarHiddenWithAnimation(fullScreen, UIStatusBarAnimation.Slide);
    };

	let resetLandscapedLock = false;
	application.on('suspend', function() {
		if (allowRotation === false && orientation.getOrientation(true) === 'landscape') {
			orientation.enableRotation();
			resetLandscapedLock = true;
		}
	});

	application.on('resume', function() {
		if (resetLandscapedLock) {
			resetLandscapedLock = false;
			orientation.setOrientation('landscape', false);
		}
	});


}

// Depreciated; but supported for backwards compatibility
application.getOrientation = orientation.getOrientation;


/**
 * Searches for a prototype in the prototype chain
 * @param source - Source element
 * @param name - the name of the element
 * @returns {*}
 */
function findRootPrototype(source, name) {
	let proto = source;
	do {
		proto = Object.getPrototypeOf(proto);
	} while (proto !== null && !proto.hasOwnProperty(name) );
	return proto;
}

function getIOSController() {
	return topmost()?.ios?.controller;
}

function getDeviceOrientationMask() {
	const device = UIDevice.currentDevice;
	switch (device.orientation) {
		// This is really weird, need to test on real device but Simulators return Opposite for UIMask?
		case UIDeviceOrientation.UIDeviceOrientationLandscapeRight:
			return UIInterfaceOrientationMaskLandscapeLeft;
		case UIDeviceOrientation.UIDeviceOrientationLandscapeLeft:
			return UIInterfaceOrientationMaskLandscapeRight;
		case UIDeviceOrientation.UIDeviceOrientationPortraitUpsideDown:
			return UIInterfaceOrientationMaskPortraitUpsideDown;
		case UIDeviceOrientation.UIDeviceOrientationPortrait:
			return UIInterfaceOrientationMaskPortrait;
		default:
			// Since we don't know, we need to see what the statusbar is, to get the actual current device orientation
			const appOrientation = UIApplication.sharedApplication.statusBarOrientation;
			if (appOrientation === 1) {
				return UIInterfaceOrientationMaskPortrait;
			} else if (appOrientation === 2) {
				return UIInterfaceOrientationMaskPortraitUpsideDown;
			} else if (appOrientation === 3) {
				return UIInterfaceOrientationMaskLandscapeRight;
			} else if (appOrientation === 4) {
				return UIInterfaceOrientationMaskLandscapeLeft;
			}
	}
	return 0; // Unknown;
}

function getIOSis16orLater() {
	const version = parseInt(UIDevice.currentDevice.systemVersion, 10);
	return version >= 16;
}

/**
 * Sets up the iOS Controller configuration
 */
function setupiOSController() {
	const app = getIOSController();
	if (!app) {
		setTimeout(setupiOSController, 100);
		return;
	}

	try {
		let proto = findRootPrototype(app, "shouldAutorotate");
		if (proto === null) {
			// Since "ShouldAutorotate" is now depreciated, we will search for another item in the
			// root in case ShouldAutorotate vanishes in the future...
			proto = findRootPrototype(app, "supportedInterfaceOrientations");
		}
		if (proto ===  null) {
			console.error("Unable to find rotations system, disabling orientation system.");
			return;
		}
		Object.defineProperty(proto, "shouldAutorotate", {
			get: function() {
				return forceRotation || allowRotation;
			}, enumerable: true, configurable: true
		});
		Object.defineProperty(proto, "supportedInterfaceOrientations", {
			get: function() {

				// console.log("Getting SupportedInterfaceOrientations", forceRotation, allowRotation, forcingRotation);
				const device = UIDevice.currentDevice;

				if (forcingRotation > 0) {
					switch (forcingRotation) {
						case 3:
						   return UIInterfaceOrientationMaskLandscapeRight;
						case 4:
							return UIInterfaceOrientationMaskLandscapeLeft;
						case 1:
							return UIInterfaceOrientationMaskPortrait;
						case 2:
							return UIInterfaceOrientationMaskPortraitUpsideDown;
					}
				}

				// If we allow Rotation, then we will return the default orientation...
				if (allowRotation || forceRotation) {
					// This is the Default Orientation allowed on the device by type: see https://developer.apple.com/documentation/uikit/uiviewcontroller/1621435-supportedinterfaceorientations...
					return device.userInterfaceIdiom === UIUserInterfaceIdiom.Phone ? UIInterfaceOrientationMaskAllButUpsideDown : UIInterfaceOrientationMaskAll;
				}

				const curOrientation = getDeviceOrientationMask();
				if (curOrientation > 0) { return curOrientation; }

				console.log("Falling thru to allow all rotations since we can't determine orientation");
				return device.userInterfaceIdiom === UIUserInterfaceIdiom.Phone ? UIInterfaceOrientationMaskAllButUpsideDown : UIInterfaceOrientationMaskAll;
			}, enumerable: true, configurable: true
		});


	} catch (err) {
		console.log("Unable to setup Rotation",err);
	}
}

/**
 * Helper function to look for children that have refresh (i.e. like ListView's) and call their refresh since the
 * CSS changes will probably impact them
 * @param child
 * @returns {boolean}
 */
function resetChildrenRefreshes(child) {
	if (typeof child.refresh === 'function') {
		child.refresh();
	}
	return true;
}

/**
 * Function that does the majority of the work
 * @param page
 * @param args
 */
const applyOrientationToPage = function(page, args) {
	// If orientation is locked on iOS, we need to get our Locked orientation as getOrientation
	// will by default return physical device orientation...
	const currentOrientation = orientation.getOrientation(!allowRotation);

	if (!displayedWarning) {
		console.warn("[nativescript-orientation] .landscape rule is depreciated; use .ns-landscape instead.")
		displayedWarning=true;
	}

	// If somehow we didn't get the orientation we don't do anything!
	if (!currentOrientation) return;

	// Check what the current rotation vs the existing page rotation is
	const isLandscape = currentOrientation === enums.DeviceOrientation.landscape;
	if (!args || !args.force) {
		const containsLandScape = page.classList.contains("landscape");

		// No need to run the swap if it already has the correct orientation
		if (isLandscape === containsLandScape) { return; }
	}

	// Change Orientation
	page.classList.toggle('landscape', isLandscape);

	// Unfortunately there is a bug in the NS CSS parser, so we have to work around it
	let i;
	if (page.classList.contains('android')) {
		for (i=0;i<page.classList.length;i++) {
			if (page.classList[i].indexOf('android') === 0) {
				if (page.classList[i].indexOf('.') >= 0) { continue; }
				page.classList.toggle(page.classList[i]+".landscape", isLandscape);
			}
		}
	} else if (page.classList.contains('ios')) {
		for (i=0;i<page.classList.length;i++) {
			if (page.classList[i].indexOf('ios') === 0) {
				if (page.classList[i].indexOf('.') >= 0) { continue; }
				page.classList.toggle(page.classList[i]+".landscape", isLandscape);
			}
		}
	} else if (page.classList.contains('windows')) {
		page.classList.toggle('windows.landscape', isLandscape);
	}
	// --- End NS Bug Patch ---

    // _refreshCSS will verify against the Scope to make sure all the correct styles are
    // applied. If they are already applied, it will short circuit and not
    // do anything more.
    if (typeof page._refreshCss === 'function') {
	    // TNS 3.2-
        page._refreshCss();
    } else {
	    // TNS 3.3+
	    page._onCssStateChange();
    }

	if (args != null) {
		viewbase.eachDescendant(page, resetChildrenRefreshes);
	}
	if (page.exports && typeof page.exports.orientation === "function") {
		page.exports.orientation({landscape: isLandscape, object: page});
	}

	callOrientationAppliers(page, isLandscape);
};

/**
 * This handles an Orientation change event
 * @param args
 */
function handleOrientationChange(args) {
	// If the topmost frame doesn't exist we can't do anything...
	if (!topmost()) { return; }
	const currentPage = topmost().currentPage;

	if (currentPage) {
		applyOrientationToPage(currentPage, args);
	}
}

function handleNavigatingTo(args) {
    const targetPage = args.object;
	if (targetPage){
		applyOrientationToPage(targetPage, {force: true});
	}
}

function callOrientationAppliers(page, isLandscape) {
    if (!orientationAppliers || orientationAppliers.length <= 0) { return; }

    for (let i=0;i<orientationAppliers.length;i++) {
    	orientationAppliers[i]({landscape: isLandscape, object: page});
	}
}

function getContext() {
	let ctx = java.lang.Class.forName("android.app.AppGlobals").getMethod("getInitialApplication", null).invoke(null, null);
	if (ctx) { return ctx; }

	return java.lang.Class.forName("android.app.ActivityThread").getMethod("currentApplication", null).invoke(null, null);
}

/**
 * Deal with NS 6.x "warning" changes
 * @returns {*}
 */
function topmost() {
	return frame.Frame && frame.Frame.topmost ? frame.Frame.topmost() : frame.topmost();
}


// Setup Events
console.log(Page.navigatingToEvent)
Page.on(Page.navigatingToEvent, handleNavigatingTo);
application.on(application.orientationChangedEvent, handleOrientationChange);

