import * as commonModule from "./ui-chart.common";
import { ObservableArray, Color, borderLeftWidthProperty, borderRightWidthProperty, borderTopWidthProperty, borderBottomWidthProperty, paddingBottomProperty, paddingTopProperty, paddingLeftProperty, paddingRightProperty } from "@nativescript/core";
import * as publicEnumModule from "./misc/chart-public-enum";
import * as trackBallCommonModule from "./visualization/parts/chart-track-ball.common";
import * as seriesModule from "./visualization/views/chart-series";
import * as cartesianChartGridModule from "./visualization/parts/chart-cartesian-chart-grid";
export * from "./ui-chart.common";
export * from "./misc/chart-public-enum";
export * from "./misc/chart-event-data.common";
export * from './visualization/views/chart-legend-view';
export * from "./visualization/views/chart-axis";
export * from "./visualization/parts/chart-label-style.common";
export * from "./visualization/views/chart-series";
export * from "./visualization/parts/chart-palette.common";
export * from "./visualization/parts/chart-annotation";
export * from "./visualization/parts/chart-cartesian-chart-grid.common";
export { RadCartesianChartGrid } from "./visualization/parts/chart-cartesian-chart-grid";
export * from "./visualization/parts/chart-track-ball";
var ChartDelegateImpl = /** @class */ (function (_super) {
    __extends(ChartDelegateImpl, _super);
    function ChartDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ChartDelegateImpl.new = function () {
        return _super.new.call(this);
    };
    ChartDelegateImpl.prototype.initWithOwner = function (owner) {
        this._owner = owner;
        return this;
    };
    ChartDelegateImpl.prototype.chartTrackballLabelForDatapointInSeries = function (chart, point, series) {
        if (this._owner instanceof commonModule.RadCartesianChart) {
            var cartesianChart = this._owner;
            if (cartesianChart.trackball) {
                var chartSeries = this._owner.series.getItem ? this._owner.series.getItem(series.index) : this._owner.series[series.index];
                var pointIndex = series.items.indexOfObject(point);
                var eventData = {
                    object: cartesianChart.trackball,
                    eventName: trackBallCommonModule.Trackball.trackBallContentRequestedEvent,
                    pointIndex: pointIndex,
                    seriesIndex: series.index,
                    series: chartSeries,
                    pointData: chartSeries.getItemAtIndex(pointIndex),
                    content: undefined
                };
                cartesianChart.trackball.notify(eventData);
                return eventData.content;
            }
        }
        return undefined;
    };
    ChartDelegateImpl.prototype.chartDidSelectSeries = function (chart, series) {
        var selectedSeries = null;
        for (var i = 0; i < this._owner.series.length; i++) {
            if (this._owner.series.getItem(i).ios.index === series.index) {
                selectedSeries = this._owner.series.getItem(i);
                break;
            }
        }
        var args = {
            eventName: commonModule.RadChartBase.seriesSelectedEvent,
            object: this._owner,
            series: selectedSeries,
            pointIndex: null,
            pointData: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidDeselectSeries = function (chart, series) {
        var deselectedSeries = null;
        for (var i = 0; i < this._owner.series.length; i++) {
            if (this._owner.series.getItem(i).ios.index === series.index) {
                deselectedSeries = this._owner.series.getItem(i);
                break;
            }
        }
        var args = {
            eventName: commonModule.RadChartBase.seriesDeselectedEvent,
            object: this._owner,
            series: deselectedSeries,
            pointIndex: null,
            pointData: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidSelectPointInSeriesAtIndex = function (chart, point, series, index) {
        var args = {
            eventName: commonModule.RadChartBase.pointSelectedEvent,
            object: this._owner,
            series: series,
            pointIndex: index,
            pointData: point
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidDeselectPointInSeriesAtIndex = function (chart, point, series, index) {
        var args = {
            eventName: commonModule.RadChartBase.pointDeselectedEvent,
            object: this._owner,
            series: series,
            pointIndex: index,
            pointData: point
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidZoom = function (chart) {
        var args = {
            eventName: commonModule.RadChartBase.chartZoomedEvent,
            object: this._owner,
            pointData: null,
            pointIndex: null,
            series: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidPan = function (chart) {
        var args = {
            eventName: commonModule.RadChartBase.chartPannedEvent,
            object: this._owner,
            pointData: null,
            pointIndex: null,
            series: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartTrackballDidTrackSelection = function (chart, selection) {
        var args = {
            eventName: commonModule.RadChartBase.trackballTrackedSelectionEvent,
            object: this._owner,
            selection: selection
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartPaletteItemForSeriesAtIndex = function (chart, series, index) {
        var paletteIndex = index;
        if (series.style.paletteMode === TKChartSeriesStylePaletteMode.UseSeriesIndex) {
            var seriesName = this._owner.series.getItem(series.index).seriesName;
            paletteIndex = this._owner.findConsequentIndexOfSeries(seriesName, series.index);
        }
        // check and return palette items if any for SELECTED state from top to low priority of property values
        if (series.isSelected &&
            (TKChartSeriesSelection.Series === series.selection ||
                TKChartSelectionMode.None !== chart.seriesSelectionMode)) {
            return this._owner.getPaletteItemWithIndexForStateOfSeries("selected", paletteIndex, series.tag);
        }
        if (series.pointIsSelected(index) &&
            (TKChartSeriesSelection.DataPoint === series.selection ||
                TKChartSeriesSelection.DataPointMultiple === series.selection)) {
            if (this._owner instanceof RadPieChart) {
                if (this._owner.chartSelectionPalette) {
                    return this._owner.chartSelectionPalette.items[paletteIndex % this._owner.chartSelectionPalette.items.count];
                }
                else {
                    return null;
                }
            }
            return this._owner.getPaletteItemWithIndexForStateOfSeries("selected", paletteIndex, series.tag);
        }
        // check and return palette items if any for NORMAL state
        var retVal = null;
        if (this._owner instanceof RadPieChart) {
            retVal = (this._owner.chartPalette) ? this._owner.chartPalette.items[paletteIndex % this._owner.chartPalette.items.count] : null;
        }
        else {
            retVal = this._owner.getPaletteItemWithIndexForStateOfSeries("normal", paletteIndex, series.tag);
        }
        return retVal;
    };
    ChartDelegateImpl.ObjCProtocols = [TKChartDelegate];
    return ChartDelegateImpl;
}(NSObject));
export class RadPieChart extends commonModule.RadPieChart {
    constructor() {
        super();
        this._loaded = false;
        this._ios = TKChart.new();
        this._ios.dataPointSelectionMode = 0 /* None */;
        this._ios.seriesSelectionMode = 0 /* None */;
        this._delegate = ChartDelegateImpl.new().initWithOwner(this);
        this._ios.allowAnimations = true;
    }
    get _nativeView() {
        return this._ios;
    }
    addSeries(newSeries) {
        this._nativeView.removeAllData();
        this._nativeView.addSeries(newSeries);
        if (this.palettes) {
            this.loadPalette(this.palettes);
        }
        if (this.chartPalette) {
            this.series.getItem(0).ios.style.paletteMode = 1 /* UseItemIndex */;
            this._nativeView.legend.update();
        }
    }
    createNativeView() {
        return this._nativeView;
    }
    initNativeView() {
        super.initNativeView();
        this.updateLegend();
    }
    updateChart() {
        if (this._loaded) {
            this._nativeView.update();
        }
    }
    updateLegend() {
        if (this._loaded && this.legend) {
            this.legend.updateLegendView(this);
        }
    }
    onLoaded() {
        super.onLoaded();
        this._ios.delegate = this._delegate;
        this._loaded = true;
        this.updateLegend();
    }
    onUnloaded() {
        super.onUnloaded();
        this._ios.delegate = null;
        this._loaded = false;
    }
    [commonModule.RadChartBase.legendProperty.setNative](newValue) {
        this.updateLegend();
    }
    onSeriesChanged(oldValue, newValue) {
        super.onSeriesChanged(oldValue, newValue);
        if (oldValue) {
            for (let i = 0; i < oldValue.length; ++i) {
                oldValue[i].owner = undefined;
                this._removeView(oldValue[i]);
            }
        }
        if (this.series) {
            for (let i = 0; i < this.series.length; ++i) {
                this.series.getItem(i).owner = this;
                this._addView(this.series.getItem(i));
                if (this.series.getItem(i).ios) {
                    // if this is not a series instance from xml we must add it
                    this.addSeries(this.series.getItem(i).ios);
                }
            }
        }
        this.updateChart();
    }
    onPalettesChanged(oldValue, newValue) {
        super.onPalettesChanged(oldValue, newValue);
        if (newValue instanceof ObservableArray) {
            let newPalettes = newValue;
            for (let i = 0; i < newPalettes.length; ++i) {
                newPalettes.getItem(i).owner = this;
            }
        }
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    reloadPalettes() {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    loadPalette(newPalettes) {
        if (!this._nativeView || !this.series) {
            return;
        }
        if (newPalettes) {
            for (let i = 0; i < this.series.length; ++i) {
                let palettesForSeries = this.getPalettesForSeries(newPalettes, this.series.getItem(i));
                if (palettesForSeries.length > 0) {
                    this.applyPalettesToSeries(palettesForSeries, this.series.getItem(i));
                }
            }
        }
    }
    PalettesCollectionChangedInternal(data) {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    getPalettesForSeries(source, series) {
        const palettes = [];
        for (let i = 0; i < source.length; i++) {
            let palette = source.getItem(i);
            if (palette.seriesName === series[publicEnumModule.seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    }
    applyPalettesToSeries(palette, series) {
        if (!series.ios) {
            return;
        }
        let selectionPalette, normalPalette;
        for (let i = 0; i < palette.length; ++i) {
            if (palette[i].seriesState === publicEnumModule.ChartPaletteSeriesState.Selected) {
                selectionPalette = palette[i];
            }
            else {
                normalPalette = palette[i];
            }
        }
        this.chartPalette = (normalPalette) ? this.buildNativePaletteForSeries(normalPalette, series) : null;
        this.chartSelectionPalette = (selectionPalette) ? this.buildNativePaletteForSeries(selectionPalette, series) : null;
        if (this.chartPalette && this.series && this.series.length > 0) {
            this.series.getItem(0).ios.style.paletteMode = 1 /* UseItemIndex */;
            this._nativeView.legend.update();
        }
    }
    buildNativePaletteForSeries(palette, series) {
        let seriesPalette = TKChartPalette.new();
        let paletteEntry;
        let currentPaletteEntry;
        for (let i = 0; i < palette.entries.length; ++i) {
            currentPaletteEntry = (series.ios.style.palette) ? series.ios.style.palette.items[i % series.ios.style.palette.itemsCount] : null;
            paletteEntry = palette.entries.getItem(i);
            let stroke = TKStroke.new();
            if (!isNaN(paletteEntry.strokeWidth)) {
                stroke.width = paletteEntry.strokeWidth;
            }
            else {
                stroke.width = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.width : 2;
            }
            if (paletteEntry.strokeColor) {
                stroke.color = paletteEntry.strokeColor.ios;
            }
            else {
                stroke.color = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.color : (new Color("Black")).ios;
            }
            let solidFill = TKSolidFill.new();
            if (paletteEntry.fillColor) {
                solidFill.color = paletteEntry.fillColor.ios;
            }
            else {
                solidFill.color = (currentPaletteEntry && currentPaletteEntry.fill) ? currentPaletteEntry.fill.color : (new Color("Blue")).ios;
            }
            seriesPalette.addPaletteItem(TKChartPaletteItem.paletteItemWithStrokeAndFill(stroke, solidFill));
        }
        return seriesPalette;
    }
    onSeriesSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (newValue) {
            if (publicEnumModule.ChartSelectionMode.Single === newValue) {
                this._nativeView.seriesSelectionMode = 1 /* Single */;
            }
            else if (publicEnumModule.ChartSelectionMode.Multiple === newValue) {
                this._nativeView.seriesSelectionMode = 2 /* Multiple */;
            }
            else if (publicEnumModule.ChartSelectionMode.None === newValue) {
                this._nativeView.seriesSelectionMode = 0 /* None */;
            }
        }
    }
    onPointSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (newValue) {
            if (publicEnumModule.ChartSelectionMode.Single === newValue) {
                this._nativeView.dataPointSelectionMode = 1 /* Single */;
            }
            else if (publicEnumModule.ChartSelectionMode.Multiple === newValue) {
                this._nativeView.dataPointSelectionMode = 2 /* Multiple */;
            }
            else if (publicEnumModule.ChartSelectionMode.None === newValue) {
                this._nativeView.dataPointSelectionMode = 0 /* None */;
            }
        }
    }
    onAllowAnimationsChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        this._nativeView.allowAnimations = newValue;
    }
}
export class RadCartesianChart extends commonModule.RadCartesianChart {
    constructor() {
        super();
        this._ios = TKChart.new();
        this._ios.dataPointSelectionMode = 0 /* None */;
        this._ios.seriesSelectionMode = 0 /* None */;
        this._ios.allowAnimations = true;
        this._delegate = ChartDelegateImpl.new().initWithOwner(this);
        this._chartNormalPalettesMap = new Map();
        this._chartSelectionPalettesMap = new Map();
    }
    get _nativeView() {
        return this._ios;
    }
    createNativeView() {
        this._ngKey = Object.keys(this).find(key => key.startsWith('_ngcontent'));
        this._vueKey = Object.keys(this).find(key => key.startsWith('data-v'));
        return this._nativeView;
    }
    initNativeView() {
        super.initNativeView();
    }
    onLoaded() {
        super.onLoaded();
        this._ios.delegate = this._delegate;
        this._loaded = true;
        this.updateLegend();
    }
    onUnloaded() {
        super.onUnloaded();
        this._ios.delegate = null;
        this._loaded = false;
    }
    [commonModule.RadCartesianChart.horizontalAxisProperty.setNative](value) {
        this.updateNativeHorizontalAxis(this.horizontalAxis.ios, this.horizontalAxis);
    }
    [commonModule.RadCartesianChart.verticalAxisProperty.setNative](value) {
        this.updateNativeVerticalAxis(this.verticalAxis.ios, this.verticalAxis);
    }
    updateChart() {
        if (this._loaded) {
            this._nativeView.update();
        }
    }
    updateLegend() {
        if (this._loaded && this.legend) {
            this.legend.updateLegendView(this);
        }
    }
    reloadPalettes() {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    [commonModule.RadChartBase.legendProperty.setNative](newValue) {
        this.updateLegend();
    }
    SeriesCollectionChangedInternal(data) {
        let curSeries;
        for (let i = 0; i < this.series.length; ++i) {
            curSeries = this.series.getItem(i);
            curSeries.owner = this;
            // in case of bar series we need to recreate the ios instance according to the owner structure
            if (curSeries instanceof seriesModule.BarSeries || curSeries instanceof seriesModule.RangeBarSeries) {
                curSeries['updateNative']();
            }
        }
        this.loadChart();
    }
    onSeriesChanged(oldValue, newValue) {
        super.onSeriesChanged(oldValue, newValue);
        if (oldValue) {
            for (let i = 0; i < oldValue.length; ++i) {
                oldValue.getItem(i).owner = undefined;
                this._removeView(oldValue.getItem(i));
            }
        }
        if (this.series) {
            let curSeries;
            for (let i = 0; i < this.series.length; ++i) {
                curSeries = this.series.getItem(i);
                curSeries.owner = this;
                this._addView(curSeries);
                // in case of bar series we need to recreate the ios instance according to the owner structure
                if (curSeries instanceof seriesModule.BarSeries || curSeries instanceof seriesModule.RangeBarSeries) {
                    curSeries['updateNative']();
                }
            }
        }
        this.loadChart();
    }
    addSeries(newSeries) {
        this.loadChart();
    }
    getAxisByID(axisID) {
        if (this.horizontalAxis && this.horizontalAxis.id === axisID) {
            return this.horizontalAxis;
        }
        if (this.verticalAxis && this.verticalAxis.id === axisID) {
            return this.verticalAxis;
        }
        if (this.series) {
            let axes;
            for (let i = 0; i < this.series.length; ++i) {
                axes = this.series.getItem(i).horizontalAxis;
                if (axes && axes.id === axisID) {
                    return axes;
                }
                axes = this.series.getItem(i).verticalAxis;
                if (axes && axes.id === axisID) {
                    return axes;
                }
            }
        }
        return null;
    }
    [paddingLeftProperty.getDefault]() {
        return this._ios.insets.left;
    }
    [paddingLeftProperty.setNative](value) {
        let borderLeft = isNaN(+this.style.borderLeftWidth) ? 0 : +this.style.borderLeftWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: value + borderLeft,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [borderLeftWidthProperty.getDefault]() {
        return 0;
    }
    [borderLeftWidthProperty.setNative](value) {
        let paddingLeft = isNaN(+this.style.paddingLeft) ? 0 : +this.style.paddingLeft;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: value + paddingLeft,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [paddingTopProperty.getDefault]() {
        return this._ios.insets.top;
    }
    [paddingTopProperty.setNative](value) {
        let borderTop = isNaN(+this.style.borderTopWidth) ? 0 : +this.style.borderTopWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: value + borderTop,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [borderTopWidthProperty.getDefault]() {
        return 0;
    }
    [borderTopWidthProperty.setNative](value) {
        let paddingTop = isNaN(+this.style.paddingTop) ? 0 : +this.style.paddingTop;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: value + paddingTop,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [paddingRightProperty.getDefault]() {
        return this._ios.insets.right;
    }
    [paddingRightProperty.setNative](value) {
        let borderRight = isNaN(+this.style.borderRightWidth) ? 0 : +this.style.borderRightWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: value + borderRight,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [borderRightWidthProperty.getDefault]() {
        return 0;
    }
    [borderRightWidthProperty.setNative](value) {
        let paddingRight = isNaN(+this.style.paddingRight) ? 0 : +this.style.paddingRight;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: value + paddingRight,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [paddingBottomProperty.getDefault]() {
        return this._ios.insets.bottom;
    }
    [paddingBottomProperty.setNative](value) {
        let borderBottom = isNaN(+this.style.borderBottomWidth) ? 0 : +this.style.borderBottomWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: value + borderBottom,
        });
        this._ios.insets = insets;
    }
    [borderBottomWidthProperty.getDefault]() {
        return 0;
    }
    [borderBottomWidthProperty.setNative](value) {
        let paddingBottom = isNaN(+this.style.paddingBottom) ? 0 : +this.style.paddingBottom;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: value + paddingBottom
        });
        this._ios.insets = insets;
    }
    AnnotationsCollectionChangedInternal(data) {
        if (data.eventName && data.eventName.toLowerCase() === "change") {
            if (data.action && data.action.toLowerCase() === "add") {
                if (this._nativeView && this.annotations) {
                    for (let i = 0; i < data.addedCount; i++) {
                        this._nativeView.addAnnotation(this.annotations.getItem(data.index + i).ios);
                        this.annotations.getItem(data.index + i).owner = this;
                    }
                }
                return;
            }
            if (data.action && data.action.toLowerCase() === "splice") {
                for (let annIdx = 0; annIdx < data.removed.length; annIdx++) {
                    this._nativeView.removeAnnotation(data.removed[annIdx].ios);
                }
                return;
            }
        }
    }
    onAnnotationsChanged(oldValue, newValue) {
        super.onAnnotationsChanged(oldValue, newValue);
        if (oldValue) {
            for (let i = 0; i < oldValue.length; ++i) {
                oldValue[i].owner = undefined;
            }
        }
        if (this.annotations) {
            for (let i = 0; i < this.annotations.length; ++i) {
                this.annotations.getItem(i).owner = this;
            }
        }
        this.loadChart();
    }
    onHorizontalAxisChanged(oldValue, newValue) {
        super.onHorizontalAxisChanged(oldValue, newValue);
        if (oldValue) {
            this._removeView(oldValue);
        }
        if (newValue) {
            this._addView(newValue);
        }
        // since label alignment requires info about horizontal or vertical the axis is, we set appropriate values here
        let theAxis = newValue;
        if (theAxis && theAxis.labelLayoutMode) {
            if (theAxis.labelLayoutMode === publicEnumModule.ChartAxisLabelLayoutMode.Inner) {
                theAxis.ios.style.labelStyle.textAlignment = 4 /* Top */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 4 /* Top */;
            }
            else {
                theAxis.ios.style.labelStyle.textAlignment = 8 /* Bottom */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 8 /* Bottom */;
            }
        }
        // in case of oready added bar series we need to recreate the ios instance according to the owner structure
        if (this.series && this.series.length > 0) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i) instanceof seriesModule.BarSeries || this.series.getItem(i) instanceof seriesModule.RangeBarSeries) {
                    this.series.getItem(i).updateNative();
                }
            }
        }
        this.updateNativeHorizontalAxis(this._nativeView, theAxis);
    }
    onVerticalAxisChanged(oldValue, newValue) {
        super.onVerticalAxisChanged(oldValue, newValue);
        if (oldValue) {
            this._removeView(oldValue);
        }
        if (newValue) {
            this._addView(newValue);
        }
        let theAxis = newValue;
        if (theAxis && theAxis.labelLayoutMode) {
            if (theAxis.labelLayoutMode === publicEnumModule.ChartAxisLabelLayoutMode.Inner) {
                theAxis.ios.style.labelStyle.textAlignment = 2 /* Right */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 2 /* Right */;
            }
            else {
                theAxis.ios.style.labelStyle.textAlignment = 1 /* Left */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 1 /* Left */;
            }
        }
        // in case of oready added bar series we need to recreate the ios instance according to the owner structure
        if (this.series && this.series.length > 0) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i) instanceof seriesModule.BarSeries || this.series.getItem(i) instanceof seriesModule.RangeBarSeries) {
                    this.series.getItem(i).updateNative();
                }
            }
        }
        this.updateNativeVerticalAxis(this._nativeView, theAxis);
    }
    updateNativeVerticalAxis(nativeView, verticalAxis) {
        if (!nativeView || !verticalAxis) {
            return;
        }
        if (!verticalAxis.horizontalLocation) {
            verticalAxis.ios.position = 0 /* Left */;
        }
        nativeView.yAxis = verticalAxis.ios;
        verticalAxis.owner = this;
    }
    updateNativeHorizontalAxis(nativeView, horizontalAxis) {
        if (!nativeView || !horizontalAxis) {
            return;
        }
        if (!horizontalAxis.verticalLocation) {
            horizontalAxis.ios.position = 3 /* Bottom */;
        }
        nativeView.xAxis = horizontalAxis.ios;
        horizontalAxis.owner = this;
    }
    loadChart() {
        if (this._nativeView && this.series) {
            this._nativeView.removeAllData();
            this.updateNativeHorizontalAxis(this._nativeView, this.horizontalAxis);
            this.updateNativeVerticalAxis(this._nativeView, this.verticalAxis);
            let assignedChartHorizontalAxis = !!this.horizontalAxis;
            let assignedChartVerticalAxis = !!this.verticalAxis;
            for (let i = 0; i < this.series.length; ++i) {
                const currentSeries = this.series.getItem(i);
                if (!assignedChartHorizontalAxis && !!currentSeries.horizontalAxis) {
                    this.updateNativeHorizontalAxis(this._nativeView, currentSeries.horizontalAxis);
                    assignedChartHorizontalAxis = true;
                }
                if (!assignedChartVerticalAxis && !!currentSeries.verticalAxis) {
                    this.updateNativeVerticalAxis(this._nativeView, currentSeries.verticalAxis);
                    assignedChartVerticalAxis = true;
                }
                if (currentSeries.ios) {
                    this.updateNativeHorizontalAxis(currentSeries.ios, currentSeries.horizontalAxis);
                    this.updateNativeVerticalAxis(currentSeries.ios, currentSeries.verticalAxis);
                    this._nativeView.addSeries(currentSeries.ios);
                }
            }
            if (this.horizontalZoom || this.verticalZoom) {
                this.updateZoom();
            }
            if (this.palettes) {
                this.loadPalette(this.palettes);
            }
            if (this.grid) {
                this.grid.applyGridStyle();
            }
            if (this.annotations) {
                for (let i = 0; i < this.annotations.length; ++i) {
                    if (this.annotations.getItem(i).ios && this.annotations.getItem(i).axisId) {
                        this._nativeView.addAnnotation(this.annotations.getItem(i).ios);
                    }
                }
            }
            this._nativeView.update();
        }
    }
    updateZoom() {
        if (!this.horizontalZoom && !this.verticalZoom) {
            return;
        }
        if (this.horizontalZoom && this.horizontalAxis) {
            this.horizontalAxis.ios.zoom = this.horizontalZoom;
        }
        if (this.verticalZoom && this.verticalAxis) {
            this.verticalAxis.ios.zoom = this.verticalZoom;
        }
        if (this.series) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i).ios) {
                    if (this.series.getItem(i).horizontalAxis && this.horizontalZoom) {
                        this.series.getItem(i).horizontalAxis.ios.zoom = this.horizontalZoom;
                    }
                    if (this.series.getItem(i).verticalAxis && this.verticalZoom) {
                        this.series.getItem(i).verticalAxis.ios.zoom = this.verticalZoom;
                    }
                }
            }
        }
    }
    onGridChanged(oldValue, newValue) {
        if (newValue instanceof cartesianChartGridModule.RadCartesianChartGrid) {
            newValue.owner = this;
        }
    }
    onPalettesChanged(oldValue, newValue) {
        super.onPalettesChanged(oldValue, newValue);
        if (newValue instanceof ObservableArray) {
            let newPalettes = newValue;
            for (let i = 0; i < newPalettes.length; ++i) {
                newPalettes.getItem(i).owner = this;
            }
        }
        this.loadPalette(this.palettes);
    }
    PalettesCollectionChangedInternal(data) {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    loadPalette(palettes) {
        if (!this._nativeView || !this.series) {
            return;
        }
        if (this.palettes && this.palettes.length > 0) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i).ios) {
                    // tag will keep the number of series in current collection
                    this.series.getItem(i).ios.tag = i;
                }
            }
            for (let i = 0; i < this.series.length; ++i) {
                let entriesForSeries = this.getPalettesForSeries(palettes, this.series.getItem(i));
                if (entriesForSeries.length > 0) {
                    this.applyPalettesToSeries(entriesForSeries, this.series.getItem(i));
                }
            }
        }
    }
    getPalettesForSeries(source, series) {
        const palettes = [];
        for (let i = 0; i < source.length; i++) {
            let palette = source.getItem(i);
            if (palette.seriesName === series[publicEnumModule.seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    }
    applyPalettesToSeries(palettes, series) {
        if (!series.ios) {
            return;
        }
        let selectionPalette, normalPalette;
        for (let i = 0; i < palettes.length; ++i) {
            if (palettes[i].seriesState === publicEnumModule.ChartPaletteSeriesState.Selected) {
                selectionPalette = palettes[i];
            }
            else {
                normalPalette = palettes[i];
            }
        }
        let normal = (normalPalette) ? this.buildNativePaletteForSeries(normalPalette, series) : null;
        if (normal) {
            if (normal) {
                this._chartNormalPalettesMap.set(normalPalette.seriesName, normal);
            }
        }
        let tmp = (selectionPalette) ? this._chartSelectionPalettesMap.get(selectionPalette.seriesName) : null;
        if (!tmp) {
            let selection = (selectionPalette) ? this.buildNativePaletteForSeries(selectionPalette, series) : null;
            if (selection) {
                this._chartSelectionPalettesMap.set(selectionPalette.seriesName, selection);
            }
        }
    }
    buildNativePaletteForSeries(palette, series) {
        let seriesPalette = TKChartPalette.new();
        let paletteEntry;
        let currentPaletteEntry;
        for (let i = 0; i < palette.entries.length; ++i) {
            currentPaletteEntry = (series.ios.style.palette) ? series.ios.style.palette.items.objectAtIndex(i % series.ios.style.palette.itemsCount) : null;
            paletteEntry = palette.entries.getItem(i);
            let stroke = TKStroke.new();
            if (!isNaN(paletteEntry.strokeWidth)) {
                stroke.width = paletteEntry.strokeWidth;
            }
            else {
                stroke.width = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.width : 2;
            }
            if (paletteEntry.strokeColor) {
                stroke.color = paletteEntry.strokeColor.ios;
            }
            else {
                stroke.color = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.color : (new Color("Black")).ios;
            }
            let solidFill = TKSolidFill.new();
            if (paletteEntry.fillColor) {
                solidFill.color = paletteEntry.fillColor.ios;
            }
            else {
                solidFill.color = (currentPaletteEntry && currentPaletteEntry.fill) ? currentPaletteEntry.fill.color : (new Color("Blue")).ios;
            }
            seriesPalette.addPaletteItem(TKChartPaletteItem.paletteItemWithStrokeAndFill(stroke, solidFill));
        }
        return seriesPalette;
    }
    /** Finds the corresponding palette item for selected series
     * @param index - the index of the palette item that should be used
     * @param seriesIndex - the index of series in {N} chart's series collection
     */
    getPaletteItemWithIndexForStateOfSeries(state, index, seriesIndex) {
        let item = null;
        let map = (state === "selected") ? this._chartSelectionPalettesMap : this._chartNormalPalettesMap;
        let palette = (this.series.getItem(seriesIndex)) ? map.get(this.series.getItem(seriesIndex).seriesName) : null;
        if (palette) {
            item = palette.items[index % palette.items.count];
        }
        return item;
    }
    /**
     * Finds the series' consequent number in group of series with the same seriesName value
     */
    findConsequentIndexOfSeries(groupName, nativeIndex) {
        let itemIndex = 0;
        let seriesName;
        for (let i = 0; i < this.series.length; ++i) {
            seriesName = this.series.getItem(i).seriesName;
            if (seriesName === groupName && this.series.getItem(i).ios && this.series.getItem(i).ios.index < nativeIndex) {
                itemIndex++;
            }
        }
        return itemIndex;
    }
    onSeriesSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        switch (newValue) {
            case publicEnumModule.ChartSelectionMode.Single:
                this._nativeView.seriesSelectionMode = 1 /* Single */;
                break;
            case publicEnumModule.ChartSelectionMode.Multiple:
                this._nativeView.seriesSelectionMode = 2 /* Multiple */;
                break;
            case publicEnumModule.ChartSelectionMode.None:
                this._nativeView.seriesSelectionMode = 0 /* None */;
                break;
        }
    }
    onPointSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        switch (newValue) {
            case publicEnumModule.ChartSelectionMode.Single:
                this._nativeView.dataPointSelectionMode = 1 /* Single */;
                break;
            case publicEnumModule.ChartSelectionMode.Multiple:
                this._nativeView.dataPointSelectionMode = 2 /* Multiple */;
                break;
            case publicEnumModule.ChartSelectionMode.None:
                this._nativeView.dataPointSelectionMode = 0 /* None */;
                break;
        }
    }
    onAllowAnimationsChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        this._nativeView.allowAnimations = newValue;
    }
    onHorizontalZoomChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (!isNaN(+newValue) && newValue > 1) {
            this.updateZoom();
        }
        else {
            console.log("WARNING: Horizontal zoom must be a number greater or equal to 1");
        }
    }
    onVerticalZoomChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (!isNaN(+newValue) && newValue > 1) {
            this.updateZoom();
        }
        else {
            console.log("WARNING: Vertical zoom must be a number greater or equal to 1");
        }
    }
    onTrackballChanged(oldValue, newValue) {
        super.onTrackballChanged(oldValue, newValue);
        if (newValue && (newValue instanceof trackBallCommonModule.Trackball)) {
            this._nativeView.allowTrackball = true;
            this.trackball.ios = this._nativeView.trackball;
        }
        else {
            this._nativeView.allowTrackball = false;
        }
    }
}
//# sourceMappingURL=ui-chart.ios.js.map