import { View, Property, booleanConverter, CSSType, Color, Font } from '@nativescript/core';
import * as initializersImpl from '../../initializers/chart-initializers';
import { ChartAxisLabelVisibility, ChartAxisDateTimeComponent, ChartAxisLabelFitMode, ChartAxisLabelLayoutMode, ChartAxisVerticalLocation, ChartAxisHorizontalLocation, ChartAxisPlotMode, toPascalCase } from '../../misc/chart-public-enum';
import { setupCssScope } from '../../common';
/**
 * Represents an axis in a Cartesian chart. This class is a base class for all
 * axes that can be used within a RadCartesianChart instance.
 */
export class CartesianAxis extends View {
    onLineColorPropertyChanged(oldValue, newValue) {
        this.onLineColorChanged(oldValue, newValue);
    }
    /*
     * Called when the lineColor property changes.
     * @param data an object containing information about the change event.
     */
    onLineColorChanged(oldValue, newValue) {
        this.initializer.onLineColorChanged(oldValue, newValue, this);
    }
    onLineThicknessPropertyChanged(oldValue, newValue) {
        this.onLineThicknessChanged(oldValue, newValue);
    }
    /*
     * Called when the lineThickness property changes.
     * @param data an object containing information about the change event.
     */
    onLineThicknessChanged(oldValue, newValue) {
        this.initializer.onLineThicknessChanged(oldValue, newValue, this);
    }
    onLineHiddenPropertyChanged(oldValue, newValue) {
        this.onLineHiddenChanged(oldValue, newValue);
    }
    /*
     * Called when the lineHidden property changes.
     * @param data an object containing information about the change event.
     */
    onLineHiddenChanged(oldValue, newValue) {
        this.initializer.onLineHiddenChanged(oldValue, newValue, this);
    }
    onLabelTextColorPropertyChanged(oldValue, newValue) {
        this.onLabelTextColorChanged(oldValue, newValue);
    }
    /*
     * Called when the labelTextColor property changes.
     * @param data an object containing information about the change event.
     */
    onLabelTextColorChanged(oldValue, newValue) {
        this.initializer.onLabelTextColorChanged(oldValue, newValue, this);
    }
    onLabelBackgroundColorPropertyChanged(oldValue, newValue) {
        this.onLabelBackgroundColorChanged(oldValue, newValue);
    }
    /*
     * Called when the labelBackgroundColor property changes.
     * @param data an object containing information about the change event.
     */
    onLabelBackgroundColorChanged(oldValue, newValue) {
        this.initializer.onLabelBackgroundColorChanged(oldValue, newValue, this);
    }
    onLabelBorderColorPropertyChanged(oldValue, newValue) {
        this.onLabelBorderColorChanged(oldValue, newValue);
    }
    /*
     * Called when the labelBorderColor property changes.
     * @param data an object containing information about the change event.
     */
    onLabelBorderColorChanged(oldValue, newValue) {
        this.initializer.onLabelBorderColorChanged(oldValue, newValue, this);
    }
    onLabelBorderWidthPropertyChanged(oldValue, newValue) {
        this.onLabelBorderWidthChanged(oldValue, newValue);
    }
    /*
     * Called when the labelBorderWidth property changes.
     * @param data an object containing information about the change event.
     */
    onLabelBorderWidthChanged(oldValue, newValue) {
        this.initializer.onLabelBorderWidthChanged(oldValue, newValue, this);
    }
    onLabelSizePropertyChanged(oldValue, newValue) {
        this.onLabelSizeChanged(oldValue, newValue);
    }
    /**
     * Called when the labelSize property changes.
     * @param data an object containing information about the change event.
     */
    onLabelSizeChanged(oldValue, newValue) {
        this.initializer.onLabelSizeChanged(oldValue, newValue, this);
    }
    onLabelFormatPropertyChanged(oldValue, newValue) {
        this.onLabelFormatChanged(oldValue, newValue);
    }
    /**
     * Called when the labelFormat property changes.
     * @param data an object containing information about the change event.
     */
    onLabelFormatChanged(oldValue, newValue) {
        this.initializer.onLabelFormatChanged(oldValue, newValue, this);
    }
    onLabelMarginPropertyChanged(oldValue, newValue) {
        this.onLabelMarginChanged(oldValue, newValue);
    }
    /**
     * Called when the labelMargin property changes.
     * @param data an object containing information about the change event.
     */
    onLabelMarginChanged(oldValue, newValue) {
        this.initializer.onLabelMarginChanged(oldValue, newValue, this);
    }
    onLabelRotationAnglePropertyChanged(oldValue, newValue) {
        this.onLabelRotationAngleChanged(oldValue, newValue);
    }
    /**
     * Called when the labelRotationAngle property changes.
     * @param data an object containing information about the change event.
     */
    onLabelRotationAngleChanged(oldValue, newValue) {
        this.initializer.onLabelRotationAngleChanged(oldValue, newValue, this);
    }
    onLabelFitModePropertyChanged(oldValue, newValue) {
        this.onLabelFitModeChanged(oldValue, newValue);
    }
    /**
     * Called when the labelFitMode property changes.
     * @param data an object containing information about the change event.
     */
    onLabelFitModeChanged(oldValue, newValue) {
        this.initializer.onLabelFitModeChanged(oldValue, newValue, this);
    }
    onLabelLayoutModePropertyChanged(oldValue, newValue) {
        this.onLabelLayoutModeChanged(oldValue, newValue);
    }
    /**
     * Called when the labelLayoutMode property changes.
     * @param data an object containing information about the change event.
     */
    onLabelLayoutModeChanged(oldValue, newValue) {
        this.initializer.onLabelLayoutModeChanged(oldValue, newValue, this);
    }
    onTicksThicknessPropertyChanged(oldValue, newValue) {
        this.onTicksThicknessChanged(oldValue, newValue);
    }
    /*
     * Called when the ticksThickness property changes.
     */
    onTicksThicknessChanged(oldValue, newValue) {
        this.initializer.onTicksThicknessChanged(oldValue, newValue, this);
    }
    onTicksLengthPropertyChanged(oldValue, newValue) {
        this.onTicksLengthChanged(oldValue, newValue);
    }
    /*
     * Called when the ticksLength property changes.
     */
    onTicksLengthChanged(oldValue, newValue) {
        this.initializer.onTicksLengthChanged(oldValue, newValue, this);
    }
    onTicksOffsetPropertyChanged(oldValue, newValue) {
        this.onTicksOffsetChanged(oldValue, newValue);
    }
    /*
     * Called when the ticksOffset property changes.
     */
    onTicksOffsetChanged(oldValue, newValue) {
        this.initializer.onTicksOffsetChanged(oldValue, newValue, this);
    }
    onTicksHiddenPropertyChanged(oldValue, newValue) {
        this.onTicksHiddenChanged(oldValue, newValue);
    }
    /*
     * Called when the ticksHidden property changes.
     */
    onTicksHiddenChanged(oldValue, newValue) {
        this.initializer.onTicksHiddenChanged(oldValue, newValue, this);
    }
    onTicksColorPropertyChanged(oldValue, newValue) {
        this.onTicksColorChanged(oldValue, newValue);
    }
    /*
     * Called when the ticksColor property changes.
     */
    onTicksColorChanged(oldValue, newValue) {
        this.initializer.onTicksColorChanged(oldValue, newValue, this);
    }
    onHorizontalLocationPropertyChanged(oldValue, newValue) {
        this.onHorizontalLocationChanged(oldValue, newValue);
    }
    /**
     * Called when the horizontalLocation property changes.
     * @param data an object containing information about the change event.
     */
    onHorizontalLocationChanged(oldValue, newValue) {
        this.initializer.onHorizontalLocationChanged(oldValue, newValue, this);
    }
    onVerticalLocationPropertyChanged(oldValue, newValue) {
        this.onVerticalLocationChanged(oldValue, newValue);
    }
    /**
     * Called when the verticalLocation property changes.
     */
    onVerticalLocationChanged(oldValue, newValue) {
        this.initializer.onVerticalLocationChanged(oldValue, newValue, this);
    }
    onAllowPanPropertyChanged(oldValue, newValue) {
        this.onAllowPanChanged(oldValue, newValue);
    }
    /**
     * Called when the allowPan property changes.
     */
    onAllowPanChanged(oldValue, newValue) {
        this.initializer.onAllowPanChanged(oldValue, newValue, this);
    }
    onAllowZoomPropertyChanged(oldValue, newValue) {
        this.onAllowZoomChanged(oldValue, newValue);
    }
    /**
     * Called when the allowZoom property changes.
     */
    onAllowZoomChanged(oldValue, newValue) {
        this.initializer.onAllowZoomChanged(oldValue, newValue, this);
    }
    onHiddenPropertyChanged(oldValue, newValue) {
        this.onHiddenChanged(oldValue, newValue);
    }
    /**
     * Called when the hidden property changes.
     */
    onHiddenChanged(oldValue, newValue) {
        this.initializer.onHiddenChanged(oldValue, newValue, this);
    }
    eachChild(callback) {
        if (this._label) {
            callback(this._label);
        }
    }
    get label() {
        return this._label;
    }
    onLoaded() {
        if (!this._label) {
            const label = new ChartAxisLabel();
            this._label = label;
            setupCssScope(this.owner, this._label);
            this._addView(this._label);
        }
        super.onLoaded();
        this._labelPropertyChangeHandler =
            this._labelPropertyChangeHandler ||
                ((args) => {
                    this.applyLabelPropertyFromStyle(args.propertyName);
                });
        this.attachLabelChangeListeners();
        this.applyLabelPropertyFromStyle();
    }
    onUnloaded() {
        super.onUnloaded();
        this.detachLabelChangeListeners();
    }
    updateLabelColorFromStyle() {
        const labelTextColor = this._label.style.color;
        if (labelTextColor !== undefined) {
            this.labelTextColor = labelTextColor;
        }
    }
    updateLabelFontFromStyle() {
        const fontInternal = this._label.style.fontInternal;
        if (fontInternal && fontInternal !== Font.default) {
            this.initializer.onFontInternalChanged(null, fontInternal, this);
        }
    }
    updateLabelMarginFromStyle() {
        const labelMargin = this._label.style.marginLeft;
        if (labelMargin !== undefined && !isNaN(+labelMargin)) {
            this.labelMargin = +labelMargin;
        }
    }
    updateLabelFitModeFromStyle() {
        const labelFitMode = this._label.fitMode;
        if (labelFitMode !== undefined) {
            this.labelFitMode = labelFitMode;
        }
    }
    updateLabelLayoutModeFromStyle() {
        const labelLayoutMode = this._label.layoutMode;
        if (labelLayoutMode !== undefined) {
            this.labelLayoutMode = labelLayoutMode;
        }
    }
    updateLabelRotationAngleFromStyle() {
        const labelRotationAngle = this._label.rotationAngle;
        if (labelRotationAngle !== undefined && !isNaN(+labelRotationAngle)) {
            this.labelRotationAngle = labelRotationAngle;
        }
    }
    updateLabelFormatFromStyle() {
        const labelFormat = this._label.format;
        if (labelFormat !== undefined) {
            this.labelFormat = labelFormat;
        }
    }
    updateLabelPaddingFromStyle(propertyName) {
        this.initializer.onLabelPaddingChanged(null, propertyName, this);
    }
    updateLabelBackgroundColorFromStyle() {
        const labelBackgroundColor = this._label.style.backgroundColor;
        if (labelBackgroundColor !== undefined) {
            this.labelBackgroundColor = labelBackgroundColor;
        }
    }
    updateLabelBorderWidthFromStyle() {
        const labelBorderWidth = +this._label.style.borderLeftWidth;
        if (labelBorderWidth !== undefined && !isNaN(+labelBorderWidth)) {
            this.labelBorderWidth = labelBorderWidth;
        }
    }
    updateLabelBorderColorFromStyle() {
        const labelBorderColor = this._label.style.borderLeftColor;
        if (labelBorderColor !== undefined) {
            if (labelBorderColor instanceof Color) {
                this.labelBorderColor = labelBorderColor;
            }
            else {
                this.labelBorderColor = new Color(labelBorderColor);
            }
        }
    }
    applyLabelPropertyFromStyle(propertyName) {
        if (!propertyName || propertyName === 'color') {
            this.updateLabelColorFromStyle();
        }
        if (!propertyName || propertyName === 'fontInternal') {
            this.updateLabelFontFromStyle();
        }
        if (!propertyName || propertyName === 'fitMode') {
            this.updateLabelFitModeFromStyle();
        }
        if (!propertyName || propertyName === 'layoutMode') {
            this.updateLabelLayoutModeFromStyle();
        }
        if (!propertyName || propertyName === 'rotationAngle') {
            this.updateLabelRotationAngleFromStyle();
        }
        if (!propertyName || propertyName === 'format') {
            this.updateLabelFormatFromStyle();
        }
        if (!propertyName || propertyName.startsWith('padding')) {
            this.updateLabelPaddingFromStyle(propertyName);
        }
        if (!propertyName || propertyName === 'backgroundColor') {
            this.updateLabelBackgroundColorFromStyle();
        }
        if (!propertyName || propertyName === 'borderLeftWidth') {
            this.updateLabelBorderWidthFromStyle();
        }
        if (!propertyName || propertyName === 'borderLeftColor') {
            this.updateLabelBorderColorFromStyle();
        }
        if (!propertyName || propertyName === 'marginLeft') {
            this.updateLabelMarginFromStyle();
        }
    }
    attachLabelChangeListeners() {
        this._label.style.on('colorChange', this._labelPropertyChangeHandler);
        this._label.style.on('fontInternalChange', this._labelPropertyChangeHandler);
        this._label.style.on('paddingLeftChange', this._labelPropertyChangeHandler);
        this._label.style.on('paddingTopChange', this._labelPropertyChangeHandler);
        this._label.style.on('paddingRightChange', this._labelPropertyChangeHandler);
        this._label.style.on('paddingBottomChange', this._labelPropertyChangeHandler);
        this._label.style.on('backgroundColorChange', this._labelPropertyChangeHandler);
        this._label.style.on('borderLeftWidthChange', this._labelPropertyChangeHandler);
        this._label.style.on('borderLeftColorChange', this._labelPropertyChangeHandler);
        this._label.style.on('marginLeftChange', this._labelPropertyChangeHandler);
        this._label.on('fitModeChange', this._labelPropertyChangeHandler);
        this._label.on('layoutModeChange', this._labelPropertyChangeHandler);
        this._label.on('rotationAngleChange', this._labelPropertyChangeHandler);
        this._label.on('formatChange', this._labelPropertyChangeHandler);
    }
    detachLabelChangeListeners() {
        this._label.style.off('colorChange', this._labelPropertyChangeHandler);
        this._label.style.off('paddingLeftChange', this._labelPropertyChangeHandler);
        this._label.style.off('paddingTopChange', this._labelPropertyChangeHandler);
        this._label.style.off('paddingRightChange', this._labelPropertyChangeHandler);
        this._label.style.off('paddingBottomChange', this._labelPropertyChangeHandler);
        this._label.style.off('backgroundColorChange', this._labelPropertyChangeHandler);
        this._label.style.off('borderLeftWidthChange', this._labelPropertyChangeHandler);
        this._label.style.off('borderLeftColorChange', this._labelPropertyChangeHandler);
        this._label.style.off('marginLeftChange', this._labelPropertyChangeHandler);
        this._label.off('fitModeChange', this._labelPropertyChangeHandler);
        this._label.off('layoutModeChange', this._labelPropertyChangeHandler);
        this._label.off('rotationAngleChange', this._labelPropertyChangeHandler);
        this._label.off('formatChange', this._labelPropertyChangeHandler);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new initializersImpl.CartesianAxisValueMapper();
        }
        return this._initializer;
    }
    // @ts-ignore
    get android() {
        return undefined;
    }
    // @ts-ignore
    get ios() {
        return undefined;
    }
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
    }
    update() {
        if (!this.owner) {
            return;
        }
        if (this.ios) {
            this.owner.updateChart();
        }
    }
}
/*
 * Identifies the lineColor dependency property.
 */
CartesianAxis.idProperty = new Property({
    name: 'id',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => { }
});
/*
 * Identifies the lineColor dependency property.
 */
CartesianAxis.lineColorProperty = new Property({
    name: 'lineColor',
    defaultValue: undefined,
    equalityComparer: Color.equals,
    valueConverter: v => new Color(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLineColorPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the lineThickness dependency property.
 */
CartesianAxis.lineThicknessProperty = new Property({
    name: 'lineThickness',
    defaultValue: undefined,
    valueConverter: v => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLineThicknessPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the lineHidden dependency property.
 */
CartesianAxis.lineHiddenProperty = new Property({
    name: 'lineHidden',
    defaultValue: undefined,
    valueConverter: booleanConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.onLineHiddenPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the labelTextColor dependency property.
 */
CartesianAxis.labelTextColorProperty = new Property({
    name: 'labelTextColor',
    defaultValue: undefined,
    equalityComparer: Color.equals,
    valueConverter: v => new Color(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelTextColorPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the labelFillColor dependency property.
 */
CartesianAxis.labelBackgroundColorProperty = new Property({
    name: 'labelBackgroundColor',
    defaultValue: undefined,
    equalityComparer: Color.equals,
    valueConverter: v => new Color(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelBackgroundColorPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the labelBorderColor dependency property.
 */
CartesianAxis.labelBorderColorProperty = new Property({
    name: 'labelBorderColor',
    defaultValue: undefined,
    equalityComparer: Color.equals,
    valueConverter: v => new Color(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelBorderColorPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the labelBorderWidth dependency property.
 */
CartesianAxis.labelBorderWidthProperty = new Property({
    name: 'labelBorderWidth',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelBorderWidthPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the labelSize dependency property.
 */
CartesianAxis.labelSizeProperty = new Property({
    name: 'labelSize',
    defaultValue: undefined,
    valueConverter: parseInt,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelSizePropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies labelFormat dependency property.
 */
CartesianAxis.labelFormatProperty = new Property({
    name: 'labelFormat',
    defaultValue: undefined,
    valueConverter: v => trimQuotes(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelFormatPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the labelMargin dependency property.
 */
CartesianAxis.labelMarginProperty = new Property({
    name: 'labelMargin',
    defaultValue: undefined,
    valueConverter: parseInt,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelMarginPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the labelRotationAngle dependency property.
 */
CartesianAxis.labelRotationAngleProperty = new Property({
    name: 'labelRotationAngle',
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelRotationAnglePropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the labelFitMode dependency property.
 */
CartesianAxis.labelFitModeProperty = new Property({
    name: 'labelFitMode',
    defaultValue: undefined,
    valueConverter: value => ChartAxisLabelFitMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelFitModePropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the labelLayoutMode dependency property.
 */
CartesianAxis.labelLayoutModeProperty = new Property({
    name: 'labelLayoutMode',
    defaultValue: undefined,
    valueConverter: value => ChartAxisLabelLayoutMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelLayoutModePropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the ticksThickness dependency property.
 */
CartesianAxis.ticksThicknessProperty = new Property({
    name: 'ticksThickness',
    defaultValue: undefined,
    valueConverter: v => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksThicknessPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the ticksLength dependency property.
 */
CartesianAxis.ticksLengthProperty = new Property({
    name: 'ticksLength',
    defaultValue: undefined,
    valueConverter: v => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksLengthPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the ticksOffset dependency property.
 */
CartesianAxis.ticksOffsetProperty = new Property({
    name: 'ticksOffset',
    defaultValue: undefined,
    valueConverter: v => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksOffsetPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the ticksHidden dependency property.
 */
CartesianAxis.ticksHiddenProperty = new Property({
    name: 'ticksHidden',
    defaultValue: undefined,
    valueConverter: booleanConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksHiddenPropertyChanged(oldValue, newValue);
    }
});
/*
 * Identifies the ticksColor dependency property.
 */
CartesianAxis.ticksColorProperty = new Property({
    name: 'ticksColor',
    defaultValue: undefined,
    equalityComparer: Color.equals,
    valueConverter: v => new Color(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksColorPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the horizontalLocation dependency property.
 */
CartesianAxis.horizontalLocationProperty = new Property({
    name: 'horizontalLocation',
    defaultValue: ChartAxisHorizontalLocation.Left,
    valueConverter: value => ChartAxisHorizontalLocation[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onHorizontalLocationPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the verticalLocation dependency property.
 */
CartesianAxis.verticalLocationProperty = new Property({
    name: 'verticalLocation',
    defaultValue: ChartAxisVerticalLocation.Bottom,
    valueConverter: value => ChartAxisVerticalLocation[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onVerticalLocationPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the allowPan dependency property.
 */
CartesianAxis.allowPanProperty = new Property({
    name: 'allowPan',
    defaultValue: false,
    valueConverter: booleanConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.onAllowPanPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the allowZoom dependency property.
 */
CartesianAxis.allowZoomProperty = new Property({
    name: 'allowZoom',
    defaultValue: false,
    valueConverter: booleanConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.onAllowZoomPropertyChanged(oldValue, newValue);
    }
});
/**
 * Identifies the hidden dependency property.
 */
CartesianAxis.hiddenProperty = new Property({
    name: 'hidden',
    defaultValue: undefined,
    valueConverter: booleanConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.onHiddenPropertyChanged(oldValue, newValue);
    }
});
CartesianAxis.idProperty.register(CartesianAxis);
CartesianAxis.lineColorProperty.register(CartesianAxis);
CartesianAxis.lineThicknessProperty.register(CartesianAxis);
CartesianAxis.lineHiddenProperty.register(CartesianAxis);
CartesianAxis.labelTextColorProperty.register(CartesianAxis);
CartesianAxis.labelBackgroundColorProperty.register(CartesianAxis);
CartesianAxis.labelBorderWidthProperty.register(CartesianAxis);
CartesianAxis.labelBorderColorProperty.register(CartesianAxis);
CartesianAxis.labelSizeProperty.register(CartesianAxis);
CartesianAxis.labelFormatProperty.register(CartesianAxis);
CartesianAxis.labelMarginProperty.register(CartesianAxis);
CartesianAxis.labelRotationAngleProperty.register(CartesianAxis);
CartesianAxis.labelFitModeProperty.register(CartesianAxis);
CartesianAxis.labelLayoutModeProperty.register(CartesianAxis);
CartesianAxis.ticksThicknessProperty.register(CartesianAxis);
CartesianAxis.ticksLengthProperty.register(CartesianAxis);
CartesianAxis.ticksOffsetProperty.register(CartesianAxis);
CartesianAxis.ticksHiddenProperty.register(CartesianAxis);
CartesianAxis.ticksColorProperty.register(CartesianAxis);
CartesianAxis.horizontalLocationProperty.register(CartesianAxis);
CartesianAxis.verticalLocationProperty.register(CartesianAxis);
CartesianAxis.allowPanProperty.register(CartesianAxis);
CartesianAxis.allowZoomProperty.register(CartesianAxis);
CartesianAxis.hiddenProperty.register(CartesianAxis);
let CategoricalAxis = class CategoricalAxis extends CartesianAxis {
    onMajorTickIntervalPropertyChanged(oldValue, newValue) {
        this.onMajorTickIntervalChanged(oldValue, newValue);
    }
    onPlotModePropertyChanged(oldValue, newValue) {
        this.onPlotModeChanged(oldValue, newValue);
    }
    onLastLabelVisibilityPropertyChanged(oldValue, newValue) {
        this.onLastLabelVisibilityChanged(oldValue, newValue);
    }
    onFirstLabelVisibilityPropertyChanged(oldValue, newValue) {
        this.onFirstLabelVisibilityChanged(oldValue, newValue);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new initializersImpl.CategoricalAxisValueMapper();
        }
        return this._initializer;
    }
    onMajorTickIntervalChanged(oldValue, newValue) {
        this.initializer.onMajorTickIntervalChanged(oldValue, newValue, this);
    }
    onPlotModeChanged(oldValue, newValue) {
        this.initializer.onPlotModeChanged(oldValue, newValue, this);
    }
    onLastLabelVisibilityChanged(oldValue, newValue) {
        this.initializer.onLastLabelVisibilityChanged(oldValue, newValue, this);
    }
    onFirstLabelVisibilityChanged(oldValue, newValue) {
        this.initializer.onFirstLabelVisibilityChanged(oldValue, newValue, this);
    }
};
CategoricalAxis.majorTickIntervalProperty = new Property({
    name: 'majorTickInterval',
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onMajorTickIntervalPropertyChanged(oldValue, newValue);
    }
});
CategoricalAxis.plotModeProperty = new Property({
    name: 'plotMode',
    defaultValue: undefined,
    valueConverter: value => ChartAxisPlotMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPlotModePropertyChanged(oldValue, newValue);
    }
});
CategoricalAxis.lastLabelVisibilityProperty = new Property({
    name: 'lastLabelVisibility',
    defaultValue: ChartAxisLabelVisibility.Visible,
    valueConverter: value => ChartAxisLabelVisibility[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onLastLabelVisibilityPropertyChanged(oldValue, newValue);
    }
});
CategoricalAxis.firstLabelVisibilityProperty = new Property({
    name: 'firstLabelVisibility',
    defaultValue: ChartAxisLabelVisibility.Visible,
    valueConverter: value => ChartAxisLabelVisibility[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onFirstLabelVisibilityPropertyChanged(oldValue, newValue);
    }
});
CategoricalAxis = __decorate([
    CSSType('CategoricalAxis')
], CategoricalAxis);
export { CategoricalAxis };
CategoricalAxis.majorTickIntervalProperty.register(CategoricalAxis);
CategoricalAxis.plotModeProperty.register(CategoricalAxis);
CategoricalAxis.lastLabelVisibilityProperty.register(CategoricalAxis);
CategoricalAxis.firstLabelVisibilityProperty.register(CategoricalAxis);
let LinearAxis = class LinearAxis extends CartesianAxis {
    onMinimumPropertyChanged(oldValue, newValue) {
        this.onMinimumChanged(oldValue, newValue);
    }
    onMinimumChanged(oldValue, newValue) { }
    onMaximumPropertyChanged(oldValue, newValue) {
        this.onMaximumChanged(oldValue, newValue);
    }
    onMaximumChanged(oldValue, newValue) { }
    onMajorStepPropertyChanged(oldValue, newValue) {
        this.onMajorStepChanged(oldValue, newValue);
    }
    onMajorStepChanged(oldValue, newValue) { }
};
LinearAxis.majorStepProperty = new Property({
    name: 'majorStep',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMajorStepPropertyChanged(oldValue, newValue);
    }
});
LinearAxis.minimumProperty = new Property({
    name: 'minimum',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMinimumPropertyChanged(oldValue, newValue);
    }
});
LinearAxis.maximumProperty = new Property({
    name: 'maximum',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMaximumPropertyChanged(oldValue, newValue);
    }
});
LinearAxis = __decorate([
    CSSType('LinearAxis')
], LinearAxis);
export { LinearAxis };
LinearAxis.majorStepProperty.register(LinearAxis);
LinearAxis.minimumProperty.register(LinearAxis);
LinearAxis.maximumProperty.register(LinearAxis);
let DateTimeContinuousAxis = class DateTimeContinuousAxis extends LinearAxis {
    onPlotModePropertyChanged(oldValue, newValue) {
        this.onPlotModeChanged(oldValue, newValue);
    }
    onDateFormatPropertyChanged(oldValue, newValue) {
        this.onDateFormatChanged(oldValue, newValue);
    }
    onSourceDateFormatPropertyChanged(oldValue, newValue) {
        this.onSourceDateFormatChanged(oldValue, newValue);
    }
    onPlotModeChanged(oldValue, newValue) { }
    onDateFormatChanged(oldValue, newValue) { }
    onSourceDateFormatChanged(oldValue, newValue) { }
    onMajorStepUnitPropertyChanged(oldValue, newValue) {
        this.onMajorStepUnitChanged(oldValue, newValue);
    }
    onMajorStepUnitChanged(oldValue, newValue) { }
};
DateTimeContinuousAxis.plotModeProperty = new Property({
    name: 'plotMode',
    defaultValue: undefined,
    valueConverter: value => ChartAxisPlotMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPlotModePropertyChanged(oldValue, newValue);
    }
});
DateTimeContinuousAxis.dateFormatProperty = new Property({
    name: 'dateFormat',
    defaultValue: undefined,
    valueConverter: v => trimQuotes(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onDateFormatPropertyChanged(oldValue, newValue);
    }
});
DateTimeContinuousAxis.sourceDateFormatProperty = new Property({
    name: 'sourceDateFormat',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onSourceDateFormatPropertyChanged(oldValue, newValue);
    }
});
DateTimeContinuousAxis.majorStepUnitProperty = new Property({
    name: 'majorStepUnit',
    defaultValue: undefined,
    valueConverter: value => ChartAxisDateTimeComponent[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onMajorStepUnitPropertyChanged(oldValue, newValue);
    }
});
DateTimeContinuousAxis = __decorate([
    CSSType('DateTimeContinuousAxis')
], DateTimeContinuousAxis);
export { DateTimeContinuousAxis };
DateTimeContinuousAxis.plotModeProperty.register(DateTimeContinuousAxis);
DateTimeContinuousAxis.dateFormatProperty.register(DateTimeContinuousAxis);
DateTimeContinuousAxis.sourceDateFormatProperty.register(DateTimeContinuousAxis);
DateTimeContinuousAxis.majorStepUnitProperty.register(DateTimeContinuousAxis);
let DateTimeCategoricalAxis = class DateTimeCategoricalAxis extends CategoricalAxis {
    onDateTimeComponentPropertyChanged(oldValue, newValue) {
        this.onDateTimeComponentChanged(oldValue, newValue);
    }
    onDateFormatPropertyChanged(oldValue, newValue) {
        this.onDateFormatChanged(oldValue, newValue);
    }
    onDateTimeComponentChanged(oldValue, newValue) { }
    onDateFormatChanged(oldValue, newValue) { }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
};
DateTimeCategoricalAxis.dateTimeComponentProperty = new Property({
    name: 'dateTimeComponent',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onDateTimeComponentPropertyChanged(oldValue, newValue);
    }
});
DateTimeCategoricalAxis.dateFormatProperty = new Property({
    name: 'dateFormat',
    defaultValue: undefined,
    valueConverter: v => trimQuotes(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onDateFormatPropertyChanged(oldValue, newValue);
    }
});
DateTimeCategoricalAxis = __decorate([
    CSSType('DateTimeCategoricalAxis')
], DateTimeCategoricalAxis);
export { DateTimeCategoricalAxis };
DateTimeCategoricalAxis.dateTimeComponentProperty.register(DateTimeCategoricalAxis);
DateTimeCategoricalAxis.dateFormatProperty.register(DateTimeCategoricalAxis);
let LogarithmicAxis = class LogarithmicAxis extends LinearAxis {
    onExponentStepPropertyChanged(oldValue, newValue) {
        this.onExponentStepChanged(oldValue, newValue);
    }
    onLogarithmBasePropertyChanged(oldValue, newValue) {
        this.onLogarithmBaseChanged(oldValue, newValue);
    }
    onExponentStepChanged(oldValue, newValue) { }
    onLogarithmBaseChanged(oldValue, newValue) { }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
};
LogarithmicAxis.exponentStepProperty = new Property({
    name: 'exponentStep',
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onExponentStepPropertyChanged(oldValue, newValue);
    }
});
LogarithmicAxis.logarithmBaseProperty = new Property({
    name: 'logarithmBase',
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onLogarithmBasePropertyChanged(oldValue, newValue);
    }
});
LogarithmicAxis = __decorate([
    CSSType('LogarithmicAxis')
], LogarithmicAxis);
export { LogarithmicAxis };
LogarithmicAxis.exponentStepProperty.register(LogarithmicAxis);
LogarithmicAxis.logarithmBaseProperty.register(LogarithmicAxis);
let ChartAxisLabel = class ChartAxisLabel extends View {
};
ChartAxisLabel.fitModeProperty = new Property({
    name: 'fitMode',
    valueConverter: value => ChartAxisLabelFitMode[toPascalCase(value)]
});
ChartAxisLabel.layoutModeProperty = new Property({
    name: 'layoutMode',
    valueConverter: value => ChartAxisLabelLayoutMode[toPascalCase(value)]
});
ChartAxisLabel.rotationAngleProperty = new Property({
    name: 'rotationAngle'
});
ChartAxisLabel.formatProperty = new Property({
    name: 'format',
    valueConverter: v => trimQuotes(v)
});
ChartAxisLabel = __decorate([
    CSSType('ChartAxisLabel')
], ChartAxisLabel);
export { ChartAxisLabel };
ChartAxisLabel.fitModeProperty.register(ChartAxisLabel);
ChartAxisLabel.layoutModeProperty.register(ChartAxisLabel);
ChartAxisLabel.rotationAngleProperty.register(ChartAxisLabel);
ChartAxisLabel.formatProperty.register(ChartAxisLabel);
export function trimQuotes(value) {
    if (!value) {
        return value;
    }
    if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
        return value.substr(1, value.length - 2);
    }
    return value;
}
//# sourceMappingURL=chart-axis.common.js.map