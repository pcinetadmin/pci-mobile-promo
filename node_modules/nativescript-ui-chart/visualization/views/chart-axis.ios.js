import * as axisCommonModule from "./chart-axis.common";
import { ChartAxisDateTimeComponent, ChartAxisPlotMode } from "../../misc/chart-public-enum";
////////////////////////////////////////////////////////////////////////
// LinearAxis
////////////////////////////////////////////////////////////////////////
export class LinearAxis extends axisCommonModule.LinearAxis {
    constructor() {
        super();
        this._ios = TKChartNumericAxis.new();
        this._ios.offset = 0;
        this._ios.baseline = 0;
    }
    get ios() {
        return this._ios;
    }
    onMajorStepChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this.ios.majorTickInterval = +newValue;
            this.update();
        }
    }
    onMinimumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            const max = this.ios.range ? this.ios.range.maximum : null;
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(numValue, max);
        }
    }
    onMaximumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            const min = this.ios.range ? this.ios.range.minimum : null;
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(min, numValue);
        }
    }
}
////////////////////////////////////////////////////////////////////////
// CategoricalAxis
////////////////////////////////////////////////////////////////////////
export class CategoricalAxis extends axisCommonModule.CategoricalAxis {
    constructor() {
        super();
        this._ios = TKChartCategoryAxis.alloc().init();
        this._ios.offset = 0;
        this._ios.baseline = 0;
    }
    get ios() {
        return this._ios;
    }
}
////////////////////////////////////////////////////////////////////////
// DateTimeContinuousAxis
////////////////////////////////////////////////////////////////////////
export class DateTimeContinuousAxis extends axisCommonModule.DateTimeContinuousAxis {
    constructor() {
        super();
        this._ios = TKChartDateTimeAxis.new();
        this._ios.majorTickIntervalUnit = 5 /* Months */;
        this._ios.minorTickIntervalUnit = 5 /* Months */;
        this._ios.majorTickInterval = 1;
        this._ios.setPlotMode(1 /* BetweenTicks */);
    }
    get dateFormatter() {
        if (this._dateFormatter) {
            return this._dateFormatter;
        }
        this._dateFormatter = NSDateFormatter.alloc().init();
        // note: currently only this format is supported in xml
        this._dateFormatter.dateFormat = "dd/MM/yyyy";
        return this._dateFormatter;
    }
    get ios() {
        return this._ios;
    }
    onMinimumChanged(oldValue, newValue) {
        if (newValue && this.maximum) {
            this.updateRange();
        }
    }
    onMaximumChanged(oldValue, newValue) {
        if (newValue && this.minimum) {
            this.updateRange();
        }
    }
    updateRange() {
        let minDate = this.minimum;
        if (typeof this.minimum === "string") {
            minDate = this.dateFormatter.dateFromString(this.minimum);
        }
        let maxDate = this.maximum;
        if (typeof this.maximum === "string") {
            maxDate = this.dateFormatter.dateFromString(this.maximum);
        }
        this.ios.range = TKRange.rangeWithMinimumAndMaximum(minDate, maxDate);
        this.update();
    }
    onPlotModeChanged(oldValue, newValue) {
        if (newValue) {
            switch (newValue) {
                case ChartAxisPlotMode.BetweenTicks:
                    this.ios.setPlotMode(1 /* BetweenTicks */);
                    break;
                case ChartAxisPlotMode.OnTicks:
                    this.ios.setPlotMode(0 /* OnTicks */);
                    break;
            }
            this.update();
        }
    }
    onDateFormatChanged(oldValue, newValue) {
        if (newValue) {
            let dateFormatter = NSDateFormatter.alloc().init();
            dateFormatter.dateFormat = newValue;
            this.ios.labelFormatter = dateFormatter;
            this.update();
        }
    }
    onLabelFormatChanged(oldValue, newValue) {
        console.log("WARNING: labelFormat property is not supported for DateTimeContinuousAxis. Use dateFormat instead");
    }
    onMajorStepUnitChanged(oldValue, newValue) {
        if (newValue) {
            // todo: consider minorTickIntervalUnit property value. It is used for financial series and determins the width of candlesticks.
            switch (newValue) {
                case ChartAxisDateTimeComponent.Second:
                    this.ios.majorTickIntervalUnit = 0 /* Seconds */;
                    this.ios.minorTickIntervalUnit = 0 /* Seconds */;
                    break;
                case ChartAxisDateTimeComponent.Minute:
                    this.ios.majorTickIntervalUnit = 1 /* Minutes */;
                    this.ios.minorTickIntervalUnit = 1 /* Minutes */;
                    break;
                case ChartAxisDateTimeComponent.Hour:
                    this.ios.majorTickIntervalUnit = 2 /* Hours */;
                    this.ios.minorTickIntervalUnit = 2 /* Hours */;
                    break;
                case ChartAxisDateTimeComponent.Day:
                    this.ios.majorTickIntervalUnit = 3 /* Days */;
                    this.ios.minorTickIntervalUnit = 3 /* Days */;
                    break;
                case ChartAxisDateTimeComponent.Week:
                    this.ios.majorTickIntervalUnit = 4 /* Weeks */;
                    this.ios.minorTickIntervalUnit = 4 /* Weeks */;
                    break;
                case ChartAxisDateTimeComponent.Month:
                    this.ios.majorTickIntervalUnit = 5 /* Months */;
                    this.ios.minorTickIntervalUnit = 5 /* Months */;
                    break;
                case ChartAxisDateTimeComponent.Year:
                    this.ios.majorTickIntervalUnit = 6 /* Years */;
                    this.ios.minorTickIntervalUnit = 6 /* Years */;
                    break;
            }
            this.update();
        }
    }
    onMajorStepChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this.ios.majorTickInterval = +newValue;
            this.update();
        }
    }
}
////////////////////////////////////////////////////////////////////////
// DateTimeCategoricalAxis
////////////////////////////////////////////////////////////////////////
export class DateTimeCategoricalAxis extends axisCommonModule.DateTimeCategoricalAxis {
    constructor() {
        super();
        this._ios = TKChartDateTimeCategoryAxis.new();
    }
    get ios() {
        return this._ios;
    }
    onDateFormatChanged(oldValue, newValue) {
        if (newValue) {
            let dateFormatter = NSDateFormatter.alloc().init();
            dateFormatter.dateFormat = newValue;
            this.ios.labelFormatter = dateFormatter;
            this.update();
        }
    }
    onLabelFormatChanged(oldValue, newValue) {
        console.log("WARNING: labelFormat property is not supported for DateTimeCategoricalAxis. Use dateFormat instead.");
    }
    onDateTimeComponentChanged(oldValue, newValue) {
        if (newValue) {
            switch (newValue) {
                case ChartAxisDateTimeComponent.Second:
                    this.ios.dateComponent = 128 /* SecondCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Minute:
                    this.ios.dateComponent = 64 /* MinuteCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Hour:
                    this.ios.dateComponent = 32 /* HourCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Day:
                    this.ios.dateComponent = 16 /* DayCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Week:
                    this.ios.dateComponent = 4096 /* WeekOfMonthCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Month:
                    this.ios.dateComponent = 8 /* MonthCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Year:
                    this.ios.dateComponent = 4 /* YearCalendarUnit */;
                    break;
            }
            this.update();
        }
    }
}
////////////////////////////////////////////////////////////////////////
// LogarithmicAxis
////////////////////////////////////////////////////////////////////////
export class LogarithmicAxis extends axisCommonModule.LogarithmicAxis {
    constructor() {
        super();
        this._ios = TKChartLogarithmicAxis.new();
    }
    get ios() {
        return this._ios;
    }
    onExponentStepChanged(oldValue, newValue) {
        if (!isNaN(+newValue) && newValue > 0) {
            this._ios.exponentStep = newValue;
            this.update();
        }
    }
    onLogarithmBaseChanged(oldValue, newValue) {
        if (!isNaN(newValue)) {
            this._ios.logarithmBase = newValue;
            this.update();
        }
    }
    onMajorStepChanged(oldValue, newValue) {
        console.log("WARNING: majorStep property is not used for LogarithmicAxis. Use exponentStep property instead.");
    }
    onMinimumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            if (this.ios.range) {
                this.ios.range.minimum = numValue;
            }
            else {
                this.ios.range = TKRange.rangeWithMinimumAndMaximum(numValue, null);
            }
            this.update();
        }
    }
    onMaximumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            if (this.ios.range) {
                this.ios.range.maximum = numValue;
            }
            else {
                this.ios.range = TKRange.rangeWithMinimumAndMaximum(null, numValue);
            }
            this.update();
        }
    }
}
//# sourceMappingURL=chart-axis.ios.js.map