import { Color, Utils } from '@nativescript/core';
import * as annotationModule from './chart-annotation.common';
import { ChartAnnotationZPosition } from '../../misc/chart-public-enum';
export class ChartGridLineAnnotation extends annotationModule.ChartGridLineAnnotation {
    constructor() {
        super();
        this._ios = TKChartGridLineAnnotation.new();
        this._ios.style.stroke = TKStroke.strokeWithColor(new Color('Black').ios);
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    update() {
        if (this.owner && this.owner.nativeView) {
            this.owner.nativeView.updateAnnotations();
        }
    }
    onOwnerChanged() {
        if (!this.axisId) {
            console.log('WARNING: axisId property is mandatory for any annotation.');
            return;
        }
        if (!this.owner) {
            return;
        }
        let forAxis = this.owner.getAxisByID(this.axisId);
        if (forAxis) {
            this._ios.axis = forAxis.ios;
        }
        this.update();
    }
    onValueChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.value = newValue;
            this.update();
        }
    }
    onAxisIdChanged(oldValue, newValue) {
        if (newValue && this.owner) {
            let forAxis = this.owner.getAxisByID(this.axisId);
            if (forAxis) {
                this._ios.axis = forAxis.ios;
                this.update();
            }
        }
    }
    onZPositionChanged(oldValue, newValue) {
        switch (newValue) {
            case ChartAnnotationZPosition.BelowSeries:
                this._ios.zPosition = 0 /* TKChartAnnotationZPosition.BelowSeries */;
                break;
            case ChartAnnotationZPosition.AboveSeries:
                this._ios.zPosition = 1 /* TKChartAnnotationZPosition.AboveSeries */;
                break;
        }
    }
    onHiddenChanged(oldValue, newValue) {
        this._ios.hidden = newValue;
        this.update();
    }
    onStrokeWidthChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this._ios.style.stroke.width = Utils.layout.toDeviceIndependentPixels(newValue);
            this.update();
        }
    }
    onStrokeColorChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.style.stroke.color = newValue.ios;
            this.update();
        }
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
        if (newValue) {
            let array = JSON.parse('[' + newValue + ']');
            if (array instanceof Array) {
                let nativeSource = NSMutableArray.new();
                let item, name, value;
                for (let i = 0; i < array.length; i++) {
                    item = array[i];
                    nativeSource.addObject(item);
                }
                this._ios.style.stroke.dashPattern = nativeSource;
                this.update();
            }
        }
    }
}
export class ChartPlotBandAnnotation extends annotationModule.ChartPlotBandAnnotation {
    constructor() {
        super();
        this._ios = TKChartBandAnnotation.new();
        this._ios.style.stroke = TKStroke.strokeWithColor(new Color('Black').ios);
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    update() {
        if (this.owner && this.owner.nativeView) {
            this.owner.nativeView.updateAnnotations();
        }
    }
    onOwnerChanged() {
        if (!this.axisId) {
            console.log('WARNING: axisId property is mandatory for any annotation.');
            return;
        }
        if (!this.owner) {
            return;
        }
        let forAxis = this.owner.getAxisByID(this.axisId);
        if (forAxis) {
            this._ios.axis = forAxis.ios;
            this.update();
        }
    }
    onMinValueChanged(oldValue, newValue) {
        if (this.ios.range) {
            this.ios.range.minimum = newValue;
        }
        else {
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(newValue, this.maxValue !== undefined ? this.maxValue : newValue);
        }
        this.update();
    }
    onMaxValueChanged(oldValue, newValue) {
        if (this.ios.range) {
            this.ios.range.maximum = newValue;
        }
        else {
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(this.minValue !== undefined ? this.minValue : newValue, newValue);
        }
        this.update();
    }
    onFillColorChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.style.fill = TKSolidFill.solidFillWithColor(newValue.ios);
            this.update();
        }
    }
    onAxisIdChanged(oldValue, newValue) {
        if (newValue && this.owner) {
            let forAxis = this.owner.getAxisByID(this.axisId);
            if (forAxis) {
                this._ios.axis = forAxis.ios;
                this.update();
            }
        }
    }
    onZPositionChanged(oldValue, newValue) {
        if (newValue) {
            switch (newValue) {
                case ChartAnnotationZPosition.BelowSeries:
                    this._ios.zPosition = 0 /* TKChartAnnotationZPosition.BelowSeries */;
                    break;
                case ChartAnnotationZPosition.AboveSeries:
                    this._ios.zPosition = 1 /* TKChartAnnotationZPosition.AboveSeries */;
                    break;
            }
            this.update();
        }
    }
    onHiddenChanged(oldValue, newValue) {
        this._ios.hidden = newValue;
        this.update();
    }
    onStrokeWidthChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this._ios.style.stroke.width = newValue;
            this.update();
        }
    }
    onStrokeColorChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.style.stroke.color = newValue.ios;
            this.update();
        }
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
        if (newValue) {
            let array = JSON.parse('[' + newValue + ']');
            if (array instanceof Array) {
                let nativeSource = NSMutableArray.new();
                let item, name, value;
                for (let i = 0; i < array.length; i++) {
                    item = array[i];
                    nativeSource.addObject(item);
                }
                this._ios.style.stroke.dashPattern = nativeSource;
                this.update();
            }
        }
    }
}
//# sourceMappingURL=chart-annotation.ios.js.map