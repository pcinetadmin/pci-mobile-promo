import { Utils } from '@nativescript/core';
import * as annotationModule from './chart-annotation.common';
import * as chartModule from '../../';
import { ChartAnnotationZPosition } from '../../misc/chart-public-enum';
import * as dateHelperModule from '../../misc/chart-date-helper';
let floatType;
const getFloatType = () => {
    if (floatType) {
        return floatType;
    }
    floatType = java.lang.Float.class.getField('TYPE').get(null);
    return floatType;
};
export class ChartGridLineAnnotation extends annotationModule.ChartGridLineAnnotation {
    // @ts-ignore
    get android() {
        return this._android;
    }
    _init(owner) {
        this._owner = owner;
    }
    createAnnotation() {
        if (!this.axisId) {
            console.log('ERROR: axisId property is mandatory for any annotation.');
            return;
        }
        if (!this._owner || !this._owner.androidView) {
            console.log('ERROR: You cannot create annotation if owner chart is not set and native instance is not created');
            return;
        }
        let forAxis = this._owner.getAxisByID(this.axisId);
        if (typeof this.value === 'string') {
            if (forAxis instanceof chartModule.LinearAxis) {
                this._android = new com.telerik.widget.chart.visualization.annotations.cartesian.CartesianGridLineAnnotation(forAxis.android, new java.lang.Float(parseFloat(this.value)));
            }
            else {
                this._android = new com.telerik.widget.chart.visualization.annotations.cartesian.CartesianGridLineAnnotation(forAxis.android, new java.lang.String(this.value));
            }
        }
        else if (typeof this.value === 'number') {
            if (forAxis instanceof chartModule.DateTimeContinuousAxis) {
                this._android = new com.telerik.widget.chart.visualization.annotations.cartesian.CartesianGridLineAnnotation(forAxis.android, dateHelperModule.getCalendarFromMilliseconds(this.value));
            }
            else {
                this._android = new com.telerik.widget.chart.visualization.annotations.cartesian.CartesianGridLineAnnotation(forAxis.android, new java.lang.Float(this.value));
            }
        }
        else {
            console.log('ERROR: Unsupported value type for annotation');
            return;
        }
        this._android.setVisible(this.hidden ? false : true);
        if (this.value) {
            this.updateValue();
        }
        else {
            console.log('WARNING: value property is mandatory for grid line annotation.');
        }
        if (this.zPosition) {
            switch (this.zPosition) {
                case ChartAnnotationZPosition.AboveSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX + 100);
                    break;
                default:
                    // ChartAnnotationZPosition.BelowSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX - 100);
            }
        }
        if (this.strokeColor || !isNaN(+this.strokeWidth)) {
            let nvPalette = this._owner.androidView.getPalette().clone();
            let nvPaletteEntry = nvPalette.getEntry('CartesianGridLineAnnotation');
            this._android.setCanApplyPalette(false);
            if (this.strokeColor) {
                this._android.setStrokeColor(this.strokeColor.android);
            }
            else {
                this._android.setStrokeColor(nvPaletteEntry.getStroke());
            }
            if (!isNaN(+this.strokeWidth)) {
                this._android.setStrokeWidth(Utils.layout.toDevicePixels(this.strokeWidth));
            }
            else {
                this._android.setStrokeWidth(Utils.layout.toDevicePixels(2));
                // TODO: replace the statement above when bug with storke width getter of pallete entry is fixed
                // this._android.setStrokeWidth(nvPaletteEntry.getStrokeWidth())
            }
        }
        if (this.strokeDashPattern) {
            let array = JSON.parse('[' + this.strokeDashPattern + ']');
            let arrNative = java.lang.reflect.Array.newInstance(getFloatType(), array.length);
            for (let i = 0; i < array.length; ++i) {
                arrNative[i] = parseFloat(array[i]) * Utils.layout.getDisplayDensity();
            }
            let effect = new android.graphics.DashPathEffect(arrNative, 0);
            this._android.setStrokeEffect(effect);
        }
    }
    _onOwnerUICreated() {
        this.createAnnotation();
    }
    _createNative() {
        this.createAnnotation();
    }
    onValueChanged(oldValue, newValue) {
        if (newValue) {
            if (this._android) {
                this.updateValue();
            }
            else if (this.owner) {
                // try to create annotations if value binding is set too late (Angular)
                this.owner.initializer.onAnnotationsPropertyChanged(null, null, this.owner);
            }
        }
    }
    onAxisIdChanged(oldValue, newValue) {
        if (this._android && newValue) {
            let forAxis = this._owner.getAxisByID(newValue);
            this._android.setAxis(forAxis.android);
        }
    }
    onZPositionChanged(oldValue, newValue) {
        if (!this._android) {
            return;
        }
        if (newValue) {
            switch (newValue) {
                case ChartAnnotationZPosition.AboveSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX + 100);
                    break;
                default:
                    // ChartAnnotationZPosition.BelowSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX - 100);
            }
            this._android.requestLayout();
        }
    }
    onHiddenChanged(oldValue, newValue) {
        if (this._android) {
            this._android.setVisible(newValue ? false : true);
        }
    }
    onStrokeWidthChanged(oldValue, newValue) {
        if (this._android && !isNaN(+newValue)) {
            this._android.setStrokeWidth(newValue);
        }
    }
    onStrokeColorChanged(oldValue, newValue) {
        if (this._android && newValue) {
            this._android.setStrokeColor(newValue.android);
        }
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
        if (this._android && newValue) {
            let array = JSON.parse('[' + newValue + ']');
            let arrNative = java.lang.reflect.Array.newInstance(getFloatType(), array.length);
            for (let i = 0; i < array.length; ++i) {
                arrNative[i] = parseFloat(array[i]) * Utils.layout.getDisplayDensity();
            }
            let effect = new android.graphics.DashPathEffect(arrNative, 0);
            this._android.setStrokeEffect(effect);
        }
    }
    updateValue() {
        let forAxis = this._owner.getAxisByID(this.axisId);
        if (forAxis instanceof chartModule.DateTimeContinuousAxis) {
            this._android.setValue(dateHelperModule.getCalendarFromMilliseconds(new Number(this.value)));
        }
        else {
            if (this.value && !isNaN(this.value)) {
                this._android.setValue(new java.lang.Float(parseFloat(this.value)));
            }
            else {
                this._android.setValue(new java.lang.String(this.value));
            }
        }
    }
}
export class ChartPlotBandAnnotation extends annotationModule.ChartPlotBandAnnotation {
    // @ts-ignore
    get android() {
        return this._android;
    }
    _init(owner) {
        this._owner = owner;
    }
    createAnnotation() {
        if (!this.axisId) {
            console.log('ERROR: axisId property is mandatory for any anotation.');
            return;
        }
        if (!this._owner || !this._owner.androidView) {
            console.log('ERROR: You cannot create annotation if owner chart is not set and native instance is not created');
            return;
        }
        let forAxis = this._owner.getAxisByID(this.axisId);
        if (typeof this.minValue === 'string') {
            const currentMinValue = this.minValue;
            this._android = new com.telerik.widget.chart.visualization.annotations.cartesian.CartesianPlotBandAnnotation(forAxis.android, currentMinValue, this.maxValue);
        }
        else if (typeof this.minValue === 'number') {
            this._android = new com.telerik.widget.chart.visualization.annotations.cartesian.CartesianPlotBandAnnotation(forAxis.android, java.lang.Float.valueOf(this.minValue), java.lang.Float.valueOf(this.maxValue));
        }
        else {
            console.log('ERROR: Unsupported value type for annotation');
            return;
        }
        this._android.setVisible(this.hidden ? false : true);
        if (this.minValue) {
            if (!isNaN(this.minValue)) {
                this._android.setFrom(new java.lang.Float(parseFloat(this.minValue)));
            }
            else {
                this._android.setFrom(new java.lang.String(this.minValue));
            }
        }
        else {
            console.log('WARNING: minValue is mandatory for band annotation');
        }
        if (this.maxValue) {
            if (!isNaN(this.maxValue)) {
                this._android.setTo(new java.lang.Float(parseFloat(this.maxValue)));
            }
            else {
                this._android.setTo(new java.lang.String(this.maxValue));
            }
        }
        else {
            console.log('WARNING: maxValue is mandatory for band annotation');
        }
        if (this.zPosition) {
            switch (this.zPosition) {
                case ChartAnnotationZPosition.AboveSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX + 100);
                    break;
                default:
                    // ChartAnnotationZPosition.BelowSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX - 100);
            }
        }
        if (this.fillColor || this.strokeColor || !isNaN(this.strokeWidth)) {
            let nvPalette = this._owner.androidView.getPalette().clone();
            let nvPaletteEntry = nvPalette.getEntry('CartesianPlotBandAnnotation');
            this._android.setCanApplyPalette(false);
            if (this.fillColor) {
                this._android.setFillColor(this.fillColor.android);
            }
            else {
                this._android.setFillColor(nvPaletteEntry.getFill());
            }
            if (this.strokeColor) {
                this._android.setStrokeColor(this.strokeColor.android);
            }
            else {
                this._android.setStrokeColor(nvPaletteEntry.getStroke());
            }
            if (!isNaN(+this.strokeWidth)) {
                this._android.setStrokeWidth(this.strokeWidth * Utils.layout.getDisplayDensity());
            }
            else {
                this._android.setStrokeWidth(2 * Utils.layout.getDisplayDensity());
                // TODO: replace the statement above when bug with storke with getter of pallete entry is fixed
                // this._android.setStrokeWidth(nvPaletteEntry.getStrokeWidth())
            }
        }
        if (this.strokeDashPattern) {
            let array = JSON.parse('[' + this.strokeDashPattern + ']');
            let arrNative = java.lang.reflect.Array.newInstance(getFloatType(), array.length);
            for (let i = 0; i < array.length; ++i) {
                arrNative[i] = parseFloat(array[i]) * Utils.layout.getDisplayDensity();
            }
            let effect = new android.graphics.DashPathEffect(arrNative, 0);
            this._android.setStrokeEffect(effect);
        }
    }
    _onOwnerUICreated() {
        this.createAnnotation();
    }
    _createNative() {
        this.createAnnotation();
    }
    onMinValueChanged(oldValue, newValue) {
        if (this._android && newValue) {
            if (!isNaN(newValue)) {
                this._android.setFrom(new java.lang.Float(parseFloat(newValue)));
            }
            else {
                this._android.setFrom(new java.lang.String(newValue));
            }
        }
    }
    onMaxValueChanged(oldValue, newValue) {
        if (this._android && newValue) {
            if (!isNaN(newValue)) {
                this._android.setTo(new java.lang.Float(parseFloat(newValue)));
            }
            else {
                this._android.setTo(new java.lang.String(newValue));
            }
        }
    }
    onFillColorChanged(oldValue, newValue) {
        if (this._android && newValue) {
            this._android.setFillColor(newValue.android);
        }
    }
    onAxisIdChanged(oldValue, newValue) {
        if (this._android && newValue) {
            let forAxis = this._owner.getAxisByID(newValue);
            this._android.setAxis(forAxis.android);
        }
    }
    onZPositionChanged(oldValue, newValue) {
        if (!this._android) {
            return;
        }
        if (newValue) {
            switch (newValue) {
                case ChartAnnotationZPosition.AboveSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX + 100);
                    break;
                default:
                    // ChartAnnotationZPosition.BelowSeries:
                    this._android.setZIndex(com.telerik.widget.chart.visualization.common.ChartSeries.SERIES_Z_INDEX - 100);
            }
            this._android.requestLayout();
        }
    }
    onHiddenChanged(oldValue, newValue) {
        if (this._android) {
            this._android.setVisible(newValue ? false : true);
        }
    }
    onStrokeWidthChanged(oldValue, newValue) {
        if (this._android && !isNaN(+newValue)) {
            this._android.setStrokeWidth(newValue);
        }
    }
    onStrokeColorChanged(oldValue, newValue) {
        if (this._android && newValue) {
            this._android.setStrokeColor(newValue.android);
        }
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
        if (this._android && newValue) {
            let array = JSON.parse('[' + newValue + ']');
            let arrNative = java.lang.reflect.Array.newInstance(getFloatType(), array.length);
            for (let i = 0; i < array.length; ++i) {
                arrNative[i] = parseFloat(array[i]) * Utils.layout.getDisplayDensity();
            }
            let effect = new android.graphics.DashPathEffect(arrNative, 0);
            this._android.setStrokeEffect(effect);
        }
    }
}
//# sourceMappingURL=chart-annotation.android.js.map