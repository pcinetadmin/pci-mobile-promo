import { Color, Font, Utils } from '@nativescript/core';
import { CategoricalAxis } from '../visualization/views/chart-axis.common';
import { ChartAxisLabelFitMode, ChartAxisLabelLayoutMode, ChartAxisHorizontalLocation, ChartAxisVerticalLocation, ChartAxisPlotMode, ChartFontStyle, ChartSeriesSelectionMode, ChartSeriesStackMode, ChartAxisLabelVisibility } from '../misc/chart-public-enum';
import { CartesianSeries } from '../visualization/views/chart-series.common';
import { convertToIOSPaletteMode } from '../misc/chart-native-helper';
export class ChartBaseValueMapper {
    onLegendChanged(oldValue, newValue, chart) { }
    onPalettesChanged(data, chart) { }
    onPalettesPropertyChanged(oldValue, newValue, chart) { }
    onSeriesChanged(data, chart) { }
    onSeriesPropertyChanged(oldValue, newValue, chart) { }
    onAnnotationsChanged(data, chart) { }
    onAnnotationsPropertyChanged(oldValue, newValue, chart) { }
    onSelectionModeChanged(oldValue, newValue, chart) { }
    loadSeries(chart) { }
    loadAnnotations(chart) { }
    reloadPalettes(chart) { }
}
export class CartesianAxisValueMapper {
    onLineThicknessChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.lineStroke = TKStroke.strokeWithColorWidth(axis.lineColor ? axis.lineColor.ios : axis.ios.style.lineStroke.color, newValue);
            axis.update();
        }
    }
    onLineColorChanged(oldValue, newValue, axis) {
        if (newValue !== null && newValue !== undefined) {
            axis.ios.style.lineStroke = TKStroke.strokeWithColorWidth(newValue.ios, axis.lineThickness ? axis.lineThickness : axis.ios.style.lineStroke.width);
            axis.update();
        }
    }
    onLineHiddenChanged(oldValue, newValue, axis) {
        if (!newValue && !isNaN(+axis.lineThickness)) {
            axis.ios.style.lineStroke.width = axis.lineThickness;
        }
        axis.ios.style.lineHidden = newValue;
        axis.update();
    }
    onLabelTextColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.labelStyle.textColor = newValue.ios;
            axis.update();
        }
    }
    onLabelBackgroundColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.labelStyle.fill = TKSolidFill.solidFillWithColor(axis.labelBackgroundColor.ios);
            axis.update();
        }
    }
    onLabelBorderColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.labelStyle.stroke = axis.labelBorderWidth ? TKStroke.strokeWithColorWidth(newValue.ios, axis.labelBorderWidth) : TKStroke.strokeWithColorWidth(newValue.ios, axis.ios.style.labelStyle.stroke.width);
            axis.update();
        }
    }
    onLabelBorderWidthChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.labelStyle.stroke = axis.labelBorderColor ? TKStroke.strokeWithColorWidth(axis.labelBorderColor.ios, newValue) : TKStroke.strokeWithColorWidth(axis.ios.style.labelStyle.stroke.color, newValue);
            axis.update();
        }
    }
    onLabelMarginChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            const horizontalOffset = axis.ios.isVertical ? newValue : 0;
            const verticalOffset = axis.ios.isVertical ? 0 : newValue;
            axis.ios.style.labelStyle.textOffset = { horizontal: horizontalOffset, vertical: verticalOffset };
            axis.ios.style.labelStyle.firstLabelTextOffset = { horizontal: horizontalOffset, vertical: verticalOffset };
            axis.update();
        }
    }
    onLabelRotationAngleChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.labelStyle.rotationAngle = newValue;
            axis.update();
        }
    }
    onLabelFitModeChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisLabelFitMode.Multiline === newValue) {
                axis.ios.style.labelStyle.fitMode = 1 /* TKChartAxisLabelFitMode.Multiline */;
            }
            else if (ChartAxisLabelFitMode.Rotate === newValue) {
                axis.ios.style.labelStyle.fitMode = 2 /* TKChartAxisLabelFitMode.Rotate */;
            }
            else {
                axis.ios.style.labelStyle.fitMode = 0 /* TKChartAxisLabelFitMode.None */;
            }
            axis.update();
        }
    }
    // NOTE: initially we cannot set new mode to native object since initially we don't know if the axis is horizontal or vertical
    // that's why we set the mode in owner's axis changed call (see CartesianSeriesValueMapper::onHorizontalAxisChanged)
    // But, we need this update for cases when layout mode is changed from code after the chart is shown
    onLabelLayoutModeChanged(oldValue, newValue, axis) {
        if (!newValue) {
            return;
        }
        let textAlignment;
        if (axis.ios.isVertical) {
            textAlignment = newValue === ChartAxisLabelLayoutMode.Inner ? 2 /* TKChartAxisLabelAlignment.Right */ : 1 /* TKChartAxisLabelAlignment.Left */;
        }
        else {
            textAlignment = newValue === ChartAxisLabelLayoutMode.Inner ? 4 /* TKChartAxisLabelAlignment.Top */ : 8 /* TKChartAxisLabelAlignment.Bottom */;
        }
        axis.ios.style.labelStyle.textAlignment = textAlignment;
        axis.ios.style.labelStyle.firstLabelTextAlignment = textAlignment;
        axis.update();
    }
    onLabelFormatChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.labelFormat = newValue;
            axis.update();
        }
    }
    onTicksHiddenChanged(oldValue, newValue, axis) {
        axis.ios.style.majorTickStyle.ticksHidden = newValue;
        axis.update();
    }
    onTicksThicknessChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.majorTickStyle.ticksWidth = newValue;
            axis.update();
        }
    }
    onTicksLengthChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.majorTickStyle.ticksLength = newValue;
            axis.update();
        }
    }
    onTicksOffsetChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.majorTickStyle.ticksOffset = newValue;
            axis.update();
        }
    }
    onTicksColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            let newColor = newValue.ios;
            axis.ios.style.majorTickStyle.ticksFill = TKSolidFill.solidFillWithColor(newColor);
            axis.ios.style.majorTickStyle.ticksStroke = TKStroke.strokeWithColor(newColor);
            axis.update();
        }
    }
    onHorizontalLocationChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisHorizontalLocation.Left === newValue) {
                axis.ios.position = 0 /* TKChartAxisPosition.Left */;
            }
            else if (ChartAxisHorizontalLocation.Right === newValue) {
                axis.ios.position = 1 /* TKChartAxisPosition.Right */;
            }
            if (axis.owner && axis.owner.ios) {
                axis.owner.ios.update();
            }
        }
    }
    onVerticalLocationChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisVerticalLocation.Top === newValue) {
                axis.ios.position = 2 /* TKChartAxisPosition.Top */;
            }
            else if (ChartAxisVerticalLocation.Bottom === newValue) {
                axis.ios.position = 3 /* TKChartAxisPosition.Bottom */;
            }
            if (axis.owner && axis.owner.ios) {
                axis.owner.ios.update();
            }
        }
    }
    onFontInternalChanged(oldValue, newValue, axis) {
        if (newValue) {
            const defaultLabelSize = 12;
            const labelFontSize = newValue.fontSize || defaultLabelSize;
            const iosFont = newValue.getUIFont(UIFont.systemFontOfSize(labelFontSize));
            axis.ios.style.labelStyle.font = iosFont;
            axis.update();
        }
    }
    onLabelPaddingChanged(newValue, propertyName, axis) {
        const paddingLeftFromStyle = axis.label.style.paddingLeft;
        const paddingLeft = (!propertyName || propertyName === 'paddingLeft') && !isNaN(+paddingLeftFromStyle) ? +paddingLeftFromStyle : axis.ios.style.labelStyle.insets.left;
        const paddingTopFromStyle = axis.label.style.paddingTop;
        const paddingTop = (!propertyName || propertyName === 'paddingTop') && !isNaN(+paddingTopFromStyle) ? +paddingTopFromStyle : axis.ios.style.labelStyle.insets.top;
        const paddingRightFromStyle = axis.label.style.paddingRight;
        const paddingRight = (!propertyName || propertyName === 'paddingRight') && !isNaN(+paddingRightFromStyle) ? +paddingRightFromStyle : axis.ios.style.labelStyle.insets.right;
        const paddingBottomFromStyle = axis.label.style.paddingBottom;
        const paddingBottom = (!propertyName || propertyName === 'paddingBottom') && !isNaN(+paddingBottomFromStyle) ? +paddingBottomFromStyle : axis.ios.style.labelStyle.insets.bottom;
        let insets = new UIEdgeInsets({
            left: paddingLeft,
            top: paddingTop,
            right: paddingRight,
            bottom: paddingBottom
        });
        axis.ios.style.labelStyle.insets = insets;
        axis.update();
    }
    onLabelSizeChanged(oldValue, newValue, axis) {
        if (newValue) {
            let fontName = axis.ios.style.labelStyle.font.fontName;
            axis.ios.style.labelStyle.font = UIFont.fontWithNameSize(fontName, newValue);
            axis.update();
        }
    }
    onAllowZoomChanged(oldValue, newValue, axis) {
        axis.ios.allowZoom = newValue;
        axis.update();
    }
    onAllowPanChanged(oldValue, newValue, axis) {
        axis.ios.allowPan = newValue;
        axis.update();
    }
    onHiddenChanged(oldValue, newValue, axis) {
        axis.ios.hidden = newValue;
        axis.update();
    }
}
export class CategoricalAxisValueMapper extends CartesianAxisValueMapper {
    onMajorTickIntervalChanged(oldValue, newValue, axis) {
        if (!isNaN(+newValue)) {
            axis.ios.majorTickInterval = newValue;
            axis.update();
        }
    }
    onPlotModeChanged(oldValue, newValue, axis) {
        switch (newValue) {
            case ChartAxisPlotMode.BetweenTicks:
                axis.ios.setPlotMode(1 /* TKChartAxisPlotMode.BetweenTicks */);
                break;
            case ChartAxisPlotMode.OnTicks:
                axis.ios.setPlotMode(0 /* TKChartAxisPlotMode.OnTicks */);
                break;
        }
        axis.update();
    }
    onLastLabelVisibilityChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (axis.plotMode && axis.plotMode !== ChartAxisPlotMode.OnTicks) {
                console.log("WARNING: Setting the 'lastLabelVisibility' to 'Hidden' with 'plotMode' set to " + axis.plotMode + ' is not supported.');
                return;
            }
            switch (newValue) {
                case ChartAxisLabelVisibility.Hidden: {
                    axis.ios.style.majorTickStyle.maxTickClippingMode = 1 /* TKChartAxisClippingMode.Hidden */;
                    axis.ios.style.labelStyle.maxLabelClippingMode = 1 /* TKChartAxisClippingMode.Hidden */;
                    axis.update();
                    break;
                }
                case ChartAxisLabelVisibility.Clip:
                case ChartAxisLabelVisibility.Visible: {
                    axis.ios.style.majorTickStyle.maxTickClippingMode = 0 /* TKChartAxisClippingMode.Visible */;
                    axis.ios.style.labelStyle.maxLabelClippingMode = 0 /* TKChartAxisClippingMode.Visible */;
                    axis.update();
                    break;
                }
                default: {
                    console.log("WARNING: Unsupported 'lastLabelVisibility' set: " + newValue);
                    break;
                }
            }
        }
    }
    onFirstLabelVisibilityChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (axis.plotMode && axis.plotMode !== ChartAxisPlotMode.OnTicks) {
                console.log("WARNING: Setting the 'firstLabelVisibility' to 'Hidden' with 'plotMode' set to " + axis.plotMode + ' is not supported.');
                return;
            }
            switch (newValue) {
                case ChartAxisLabelVisibility.Hidden: {
                    axis.ios.style.majorTickStyle.minTickClippingMode = 1 /* TKChartAxisClippingMode.Hidden */;
                    axis.ios.style.labelStyle.minLabelClippingMode = 1 /* TKChartAxisClippingMode.Hidden */;
                    axis.update();
                    break;
                }
                case ChartAxisLabelVisibility.Clip:
                case ChartAxisLabelVisibility.Visible: {
                    axis.ios.style.majorTickStyle.minTickClippingMode = 0 /* TKChartAxisClippingMode.Visible */;
                    axis.ios.style.labelStyle.minLabelClippingMode = 0 /* TKChartAxisClippingMode.Visible */;
                    axis.update();
                    break;
                }
                default: {
                    console.log("WARNING: Unsupported 'firstLabelVisibility' set: " + newValue);
                    break;
                }
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////
//  Series value mappers
////////////////////////////////////////////////////////////////////////////////////////////
export class ChartSeriesValueMapper {
    onItemsChanged(oldValue, newValue, series) { }
    onValuePropertyChanged(oldValue, newValue, series) { }
    onShowLabelsChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelStyle(series);
        }
    }
    onLegendTitleChanged(newValue, series) {
        if (series.ios && newValue) {
            series.ios.title = newValue;
            if (series.owner) {
                series.owner.nativeView.legend.reloadItems();
            }
        }
    }
    onSelectionModeChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applySelectionMode(series);
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    onLabelPaddingChanged(newValue, propertyName, series) {
        this.applyLabelInsetsFromStyle(series);
    }
    onFontInternalChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelFontFromStyle(series);
        }
    }
    applySelectionMode(series) {
        switch (series.selectionMode) {
            case ChartSeriesSelectionMode.Series:
                series.ios.selection = 2 /* TKChartSeriesSelection.Series */;
                break;
            case ChartSeriesSelectionMode.DataPoint:
                series.ios.selection = 3 /* TKChartSeriesSelection.DataPoint */;
                break;
            case ChartSeriesSelectionMode.None:
                series.ios.selection = 1 /* TKChartSeriesSelection.None */;
                break;
            case ChartSeriesSelectionMode.NotSet:
                series.ios.selection = 0 /* TKChartSeriesSelection.NotSet */;
                break;
            case ChartSeriesSelectionMode.DataPointMultiple:
                series.ios.selection = 4 /* TKChartSeriesSelection.DataPointMultiple */;
                break;
        }
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelStyle(series);
        }
    }
    applyLabelFontFromStyle(series) {
        if (series.ios && series.label && series.label.style && series.label.style.fontInternal !== Font.default) {
            const defaultLabelSize = 10;
            const labelFontSize = series.label.style.fontInternal ? series.label.style.fontInternal.fontSize : defaultLabelSize;
            const uiFont = UIFont.systemFontOfSize(labelFontSize);
            const iosFont = series.label.style.fontInternal ? series.label.style.fontInternal.getUIFont(uiFont) : uiFont;
            series.ios.style.pointLabelStyle.font = iosFont;
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    applyLabelInsetsFromStyle(series) {
        if (!series.ios || !series.label) {
            return;
        }
        const paddingLeft = !isNaN(+series.label.style.paddingLeft) ? +series.label.style.paddingLeft : series.ios.style.pointLabelStyle.insets.left;
        const paddingTop = !isNaN(+series.label.style.paddingTop) ? +series.label.style.paddingTop : series.ios.style.pointLabelStyle.insets.top;
        const paddingRight = !isNaN(+series.label.style.paddingRight) ? +series.label.style.paddingRight : series.ios.style.pointLabelStyle.insets.right;
        const paddingBottom = !isNaN(+series.label.style.paddingBottom) ? +series.label.style.paddingBottom : series.ios.style.pointLabelStyle.insets.bottom;
        let insets = new UIEdgeInsets({
            left: paddingLeft,
            top: paddingTop,
            right: paddingRight,
            bottom: paddingBottom
        });
        series.ios.style.pointLabelStyle.insets = insets;
        if (series.owner) {
            series.updateOwnerChart();
        }
    }
    applyLabelStyle(series) {
        if (!series || !series.ios) {
            return;
        }
        series.ios.style.pointLabelStyle.textHidden = !series.showLabels;
        if (series.labelStyle) {
            if (series.labelStyle.textColor) {
                series.ios.style.pointLabelStyle.textColor = series.labelStyle.textColor.ios;
            }
            if (series.labelStyle.fillColor) {
                series.ios.style.pointLabelStyle.fill = TKSolidFill.solidFillWithColor(series.labelStyle.fillColor.ios);
            }
            if (series.labelStyle.strokeWidth || series.labelStyle.strokeColor) {
                const strokeColor = series.labelStyle.strokeColor ? series.labelStyle.strokeColor.ios : new Color('Black').ios;
                const stroke = TKStroke.strokeWithColor(strokeColor);
                if (series.labelStyle.strokeWidth) {
                    stroke.width = series.labelStyle.strokeWidth;
                }
                series.ios.style.pointLabelStyle.stroke = stroke;
            }
            if (series.labelStyle.margin) {
                let marginIsVertical = false;
                if (series instanceof CartesianSeries) {
                    if (series.horizontalAxis instanceof CategoricalAxis || (series.owner && series.owner.horizontalAxis instanceof CategoricalAxis)) {
                        marginIsVertical = true;
                    }
                }
                const horizontalOffset = marginIsVertical ? 0 : series.labelStyle.margin;
                const verticalOffset = marginIsVertical ? series.labelStyle.margin : 0;
                series.ios.style.pointLabelStyle.labelOffset = { horizontal: horizontalOffset, vertical: verticalOffset };
            }
            if (series.labelStyle.textFormat) {
                series.ios.style.pointLabelStyle.stringFormat = series.labelStyle.textFormat;
            }
            if (series.labelStyle.fontStyle || series.labelStyle.fontStyle || series.labelStyle.textSize) {
                let font = null;
                let fontSize = !isNaN(+series.labelStyle.textSize) ? series.labelStyle.textSize : 10;
                if (series.labelStyle.fontName) {
                    font = UIFont.fontWithNameSize(series.labelStyle.fontName, fontSize);
                    if (!font) {
                        console.log('WARNING: Cannot create font with given name: ' + series.labelStyle.fontName);
                        return;
                    }
                }
                if (!font) {
                    font = UIFont.systemFontOfSize(fontSize);
                }
                if (series.labelStyle.fontStyle) {
                    let traits = 0 /* UIFontDescriptorSymbolicTraits.ClassUnknown */;
                    let fontStyle = series.labelStyle.fontStyle;
                    switch (fontStyle) {
                        case ChartFontStyle.Bold:
                            traits = 2 /* UIFontDescriptorSymbolicTraits.TraitBold */;
                            break;
                        case ChartFontStyle.Italic:
                            traits = 1 /* UIFontDescriptorSymbolicTraits.TraitItalic */;
                            break;
                        case ChartFontStyle.BoldItalic:
                            traits = 2 /* UIFontDescriptorSymbolicTraits.TraitBold */ | 1 /* UIFontDescriptorSymbolicTraits.TraitItalic */;
                            break;
                    }
                    let newFont = UIFont.fontWithDescriptorSize(font.fontDescriptor.fontDescriptorWithSymbolicTraits(traits), fontSize);
                    if (newFont) {
                        font = newFont;
                    }
                }
                if (font) {
                    series.ios.style.pointLabelStyle.font = font;
                }
            }
        }
        this.applyLabelFontFromStyle(series);
        this.applyLabelInsetsFromStyle(series);
        if (series.owner) {
            series.updateOwnerChart();
        }
    }
    seriesCanBeBound(series) {
        return series && series.items;
    }
}
export class PieSeriesValueMapper extends ChartSeriesValueMapper {
    onShowLabelsChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            this.applyLabelStyle(series);
        }
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onItemsChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLabelPropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            this.applyLabelStyle(series);
        }
    }
    onExpandRadiusChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            let radius = newValue;
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log('WARNING : Expand radius factor must be number in range [0,1]');
            }
            else {
                series.ios.expandRadius = radius + 1;
            }
        }
    }
    onOuterRadiusFactorChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            let radius = newValue;
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log('WARNING : Outer radius factor must be number in range [0,1]');
            }
            else {
                series.ios.outerRadius = radius;
                series.updateOwnerChart();
            }
        }
    }
    onShowPercentageChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            series.ios.displayPercentage = newValue ? true : false;
            series.updateOwnerChart();
        }
    }
    onStartAngleChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            if (!isNaN(+newValue)) {
                series.ios.startAngle = (newValue * Math.PI) / 180;
                series.updateOwnerChart();
            }
        }
    }
    onEndAngleChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            if (!isNaN(+newValue)) {
                series.ios.endAngle = (series.endAngle * Math.PI) / 180;
                series.updateOwnerChart();
            }
        }
    }
    onLegendTitleChanged(newValue, series) {
        console.log("WARNING: legendTitle property is not applicable to Pie series. Use 'legendLabel' instead.");
    }
    onFillColorsChanged(oldValue, newValue, series) {
        this.applyFills(series);
    }
    onStrokeWidthChanged(oldValue, newValue, series) {
        this.applyStrokes(series);
    }
    onStrokeColorsChanged(oldValue, newValue, series) {
        this.applyStrokes(series);
    }
    applyFills(series) {
        if (series.ios && series.fillColors) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.fillColors.length);
            for (let i = 0; i < series.fillColors.length; i++) {
                nativeArray.addObject(TKSolidFill.solidFillWithColor(series.fillColors[i].ios));
            }
            series.ios.style.fills = nativeArray;
        }
    }
    applyStrokes(series) {
        if (series.ios && series.strokeColors && series.strokeWidth) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.strokeColors.length);
            for (let i = 0; i < series.strokeColors.length; i++) {
                nativeArray.addObject(TKStroke.strokeWithColorWidth(series.strokeColors[i].ios, series.strokeWidth));
            }
            series.ios.style.strokes = nativeArray;
        }
    }
    applyColors(series) {
        this.applyFills(series);
        this.applyStrokes(series);
    }
    getNativeData(series) {
        let length = series.items.length;
        let nativeSource = NSMutableArray.new();
        let item, name, value;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            value = item[series.valueProperty];
            if (series.legendLabel) {
                name = item[series.legendLabel];
            }
            else {
                name = 'Series ' + (i + 1);
            }
            nativeSource.addObject(TKChartDataPoint.alloc().initWithNameValue(name, value));
        }
        return nativeSource;
    }
    setCommonProperties(series) {
        let radius = series.expandRadius;
        if (radius) {
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log('WARNING : Expand radius factor must be number in range [0,1]');
            }
            else {
                series.ios.expandRadius = radius + 1;
            }
        }
        radius = series.outerRadiusFactor;
        if (radius) {
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log('WARNING : Outer radius factor must be number in range [0,1]');
            }
            else {
                series.ios.outerRadius = radius;
            }
        }
        if (!isNaN(series.startAngle)) {
            series.ios.startAngle = (series.startAngle * Math.PI) / 180;
        }
        if (!isNaN(series.endAngle)) {
            series.ios.endAngle = (series.endAngle * Math.PI) / 180;
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        series.ios = TKChartPieSeries.alloc().initWithItems(this.getNativeData(series));
        series.ios.adjustSizeToFit = false;
        this.setCommonProperties(series);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyColors(series);
        series.ios.labelDisplayMode = 2 /* TKChartPieSeriesLabelDisplayMode.Outside */;
        series.ios.visibleInLegend = true;
        series.ios.rotationEnabled = false;
        series.ios.displayPercentage = series.showPercentage === undefined ? true : series.showPercentage;
        if (series.owner && series.owner['addSeries']) {
            // only series from xml have owner, manually created series are added on series changed handler
            series.owner['addSeries'](series.ios);
        }
    }
}
export class DonutSeriesValueMapper extends PieSeriesValueMapper {
    onInnerRadiusFactorChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            let radius = newValue;
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log('WARNING : Inner radius factor must be number in range (0,1)');
            }
            else {
                series.ios.innerRadius = series.innerRadiusFactor ? series.innerRadiusFactor : 0.5;
                series.updateOwnerChart();
            }
        }
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        series.ios = TKChartDonutSeries.alloc().initWithItems(this.getNativeData(series));
        series.ios.adjustSizeToFit = false;
        let radius = series.innerRadiusFactor;
        if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
            console.log('WARNING : Inner radius factor must be number in range (0,1)');
        }
        else {
            series.ios.innerRadius = series.innerRadiusFactor ? series.innerRadiusFactor : 0.5;
        }
        this.setCommonProperties(series);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyColors(series);
        series.ios.labelDisplayMode = 2 /* TKChartPieSeriesLabelDisplayMode.Outside */;
        series.ios.visibleInLegend = true;
        series.ios.rotationEnabled = false;
        series.ios.displayPercentage = series.showPercentage === undefined ? true : series.showPercentage;
        if (series.owner && series.owner['addSeries']) {
            series.owner['addSeries'](series.ios);
        }
    }
}
export class CartesianSeriesValueMapper extends ChartSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        // since label alignment requires info about horizontal or vertical the axis is, we set appropriate values here
        let labelLayoutMode = series.horizontalAxis.labelLayoutMode;
        if (labelLayoutMode) {
            if (labelLayoutMode === ChartAxisLabelLayoutMode.Inner) {
                series.horizontalAxis.ios.style.labelStyle.textAlignment = 4 /* TKChartAxisLabelAlignment.Top */;
                series.horizontalAxis.ios.style.labelStyle.firstLabelTextAlignment = 4 /* TKChartAxisLabelAlignment.Top */;
            }
            else {
                series.horizontalAxis.ios.style.labelStyle.textAlignment = 8 /* TKChartAxisLabelAlignment.Bottom */;
                series.horizontalAxis.ios.style.labelStyle.firstLabelTextAlignment = 8 /* TKChartAxisLabelAlignment.Bottom */;
            }
        }
        this.updateNativeSeriesAxis(series, oldValue, newValue, false);
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        let labelLayoutMode = series.verticalAxis.labelLayoutMode;
        if (labelLayoutMode) {
            if (labelLayoutMode === ChartAxisLabelLayoutMode.Inner) {
                series.verticalAxis.ios.style.labelStyle.textAlignment = 2 /* TKChartAxisLabelAlignment.Right */;
                series.verticalAxis.ios.style.labelStyle.firstLabelTextAlignment = 2 /* TKChartAxisLabelAlignment.Right */;
            }
            else {
                series.verticalAxis.ios.style.labelStyle.textAlignment = 1 /* TKChartAxisLabelAlignment.Left */;
                series.verticalAxis.ios.style.labelStyle.firstLabelTextAlignment = 1 /* TKChartAxisLabelAlignment.Left */;
            }
        }
        this.updateNativeSeriesAxis(series, oldValue, newValue, true);
    }
    onPaletteModeChanged(oldValue, newValue, series) {
        if (series.ios) {
            this.applyPaletteMode(series);
        }
    }
    applyPaletteMode(series) {
        if (series.ios) {
            let nativePaletteMode = convertToIOSPaletteMode(series.paletteMode);
            if (nativePaletteMode !== null) {
                series.ios.style.paletteMode = nativePaletteMode;
                series.updateOwnerChart();
            }
        }
    }
    onFillColorChanged(oldValue, newValue, series) {
        this.applyFillColor(series);
    }
    onStrokeWidthChanged(oldValue, newValue, series) {
        this.applyStrokeWidth(series);
    }
    onStrokeColorChanged(oldValue, newValue, series) {
        this.applyStrokeColor(series);
    }
    applyFillColor(series) {
        if (series.ios && series.fillColor) {
            series.ios.style.fill = TKSolidFill.solidFillWithColor(series.fillColor.ios);
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    applyStrokeWidth(series) {
        this.applyStroke(series);
    }
    applyStrokeColor(series) {
        this.applyStroke(series);
    }
    applyStroke(series) {
        if (series.ios && series.strokeColor && series.strokeWidth) {
            series.ios.style.stroke = TKStroke.strokeWithColorWidth(series.strokeColor.ios, series.strokeWidth);
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    applyColors(series) {
        this.applyFillColor(series);
        this.applyStroke(series);
    }
    updateNativeSeriesAxis(series, oldAxis, newAxis, isVertical) {
        if (!series.ios || !series.ios.chart) {
            return;
        }
        const nativeSeries = series.ios;
        const nativeOldAxis = oldAxis ? oldAxis.ios : null;
        const nativeNewAxis = newAxis ? newAxis.ios : null;
        series.ios.chart.replaceSeriesAxisOldNewVertical(nativeSeries, nativeOldAxis, nativeNewAxis, isVertical);
    }
    bindSeriesAxes(series) {
        if (series.horizontalAxis) {
            this.updateNativeSeriesAxis(series, null, series.horizontalAxis, false);
        }
        if (series.verticalAxis) {
            this.updateNativeSeriesAxis(series, null, series.verticalAxis, true);
        }
    }
}
export class CategoricalSeriesValueMapper extends CartesianSeriesValueMapper {
    onCategoryPropertyChanged(oldValue, newValue, series) {
        if (series.horizontalAxis && series.verticalAxis && series.ios) {
            series.ios.setHorizontalAxis(series.horizontalAxis.ios);
            series.ios.setVerticalAxis(series.verticalAxis.ios);
        }
        this.bind(series);
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onItemsChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onShowLabelsChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            this.applyLabelStyle(series);
        }
    }
    onStackModePropertyChanged(oldValue, newValue, series) {
        if (!series.ios) {
            if (series.stackMode) {
                this.bind(series);
            }
        }
        else {
            this.setStackInfo(series);
        }
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelStyle(series);
        }
    }
    updateNative(series) {
        this.bind(series);
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.categoryProperty;
    }
    bind(series) {
        console.log('WARNING: You should override this bind in class specific initializer');
    }
    // This method must be called by every bind override at an appropriate place where the series should be given a combine mode
    setStackInfo(series) {
        if (!series.stackMode) {
            return;
        }
        switch (series.stackMode) {
            case ChartSeriesStackMode.Stack:
                series.ios.stackInfo = TKChartStackInfo.alloc().initWithIDWithStackMode(1, 0 /* TKChartStackMode.Stack */);
                break;
            case ChartSeriesStackMode.Stack100:
                series.ios.stackInfo = TKChartStackInfo.alloc().initWithIDWithStackMode(1, 1 /* TKChartStackMode.Stack100 */);
                break;
            case ChartSeriesStackMode.None:
                series.ios.stackInfo = null;
                break;
        }
        if (series.ios.chart) {
            series.ios.chart.reloadData();
        }
    }
    /**
     *  Cleans the axes from previous data categories if any.
     *  This method should be called if series items collection is changed.
     */
    cleanCategoryAxes(series) {
        if (series.ios && series.ios.items && series.owner) {
            series.ios.items.removeAllObjects();
            if (series.horizontalAxis && series.horizontalAxis instanceof CategoricalAxis) {
                series.horizontalAxis.ios.removeAllCategories();
            }
            else if (series.owner.horizontalAxis && series.owner.horizontalAxis instanceof CategoricalAxis) {
                series.owner.horizontalAxis.ios.removeAllCategories();
            }
            if (series.verticalAxis && series.verticalAxis instanceof CategoricalAxis) {
                series.verticalAxis.ios.removeAllCategories();
            }
            else if (series.owner.verticalAxis && series.owner.verticalAxis instanceof CategoricalAxis) {
                series.owner.verticalAxis.ios.removeAllCategories();
            }
        }
    }
}
export class BarSeriesValueMapper extends CategoricalSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onHorizontalAxisChanged(oldValue, newValue, series);
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onVerticalAxisChanged(oldValue, newValue, series);
    }
    onMinBarSizeChanged(oldValue, newValue, series) {
        if (series.ios) {
            if (!isNaN(newValue)) {
                series.ios.minBarHeight = Utils.layout.toDevicePixels(newValue);
                series.ios.minColumnWidth = Utils.layout.toDevicePixels(newValue);
            }
            else {
                series.ios.maxBarHeight = 0;
                series.ios.maxColumnWidth = 0;
            }
        }
    }
    onMaxBarSizeChanged(oldValue, newValue, series) {
        if (series.ios) {
            if (!isNaN(newValue)) {
                series.ios.maxBarHeight = Utils.layout.toDevicePixels(newValue);
                series.ios.maxColumnWidth = Utils.layout.toDevicePixels(newValue);
            }
            else {
                series.ios.maxBarHeight = 0;
                series.ios.maxColumnWidth = 0;
            }
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let useColumnSeries;
        if (series.horizontalAxis instanceof CategoricalAxis || (series.owner && series.owner.horizontalAxis instanceof CategoricalAxis)) {
            useColumnSeries = true;
        }
        this.cleanCategoryAxes(series);
        let nativeSource = NSMutableArray.new();
        if (series && series.items) {
            let length = series.items.length;
            for (let i = 0; i < length; i++) {
                let item = series.getItemAtIndex(i);
                let value = item[series.valueProperty];
                let category = item[series.categoryProperty];
                nativeSource.addObject(useColumnSeries ? TKChartDataPoint.alloc().initWithXY(category, value) : TKChartDataPoint.alloc().initWithXY(value, category));
            }
        }
        series.ios = useColumnSeries ? TKChartColumnSeries.alloc().initWithItems(nativeSource) : TKChartBarSeries.alloc().initWithItems(nativeSource);
        if (!isNaN(series.minBarSize)) {
            series.ios.minColumnWidth = Utils.layout.toDevicePixels(series.minBarSize);
            series.ios.minBarHeight = Utils.layout.toDevicePixels(series.minBarSize);
        }
        else {
            series.ios.minColumnWidth = 0;
            series.ios.minBarHeight = 0;
        }
        if (!isNaN(series.maxBarSize)) {
            series.ios.maxColumnWidth = Utils.layout.toDevicePixels(series.maxBarSize);
            series.ios.maxBarHeight = Utils.layout.toDevicePixels(series.maxBarSize);
        }
        else {
            series.ios.maxColumnWidth = 0;
            series.ios.maxBarHeight = 0;
        }
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class RangeBarSeriesValueMapper extends CategoricalSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onHorizontalAxisChanged(oldValue, newValue, series);
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onVerticalAxisChanged(oldValue, newValue, series);
    }
    onHighPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLowPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.highPropertyName && series.lowPropertyName;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let useColumnSeries = false;
        if (series.horizontalAxis instanceof CategoricalAxis || (series.owner && series.owner.horizontalAxis instanceof CategoricalAxis)) {
            useColumnSeries = true;
        }
        const length = series.items.length;
        let nativeSource = NSMutableArray.new();
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(useColumnSeries ? TKChartRangeDataPoint.alloc().initWithXLowHigh(item[series.categoryProperty], item[series.lowPropertyName], item[series.highPropertyName]) : TKChartRangeDataPoint.alloc().initWithYLowHigh(item[series.categoryProperty], item[series.lowPropertyName], item[series.highPropertyName]));
        }
        this.cleanCategoryAxes(series);
        series.ios = useColumnSeries ? TKChartRangeColumnSeries.alloc().initWithItems(nativeSource) : TKChartRangeBarSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class LineSeriesValueMapper extends CategoricalSeriesValueMapper {
    getDataPointsForSeries(series) {
        let isCatAxisVertical = false;
        if (series.verticalAxis instanceof CategoricalAxis || (series.owner && series.owner.verticalAxis instanceof CategoricalAxis)) {
            isCatAxisVertical = true;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(TKChartDataPoint.alloc().initWithXY(isCatAxisVertical ? item[series.valueProperty] : item[series.categoryProperty], isCatAxisVertical ? item[series.categoryProperty] : item[series.valueProperty]));
        }
        return nativeSource;
    }
    applyPaletteMode(series) {
        if (series.paletteMode !== undefined) {
            console.log('WARNING: Property paletteMode is not applicable for series of type: ' + series.constructor.name);
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartLineSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class SplineSeriesValueMapper extends LineSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartSplineSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class AreaSeriesValueMapper extends LineSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartAreaSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class SplineAreaSeriesValueMapper extends AreaSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartSplineAreaSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class BubbleSeriesValueMapper extends CategoricalSeriesValueMapper {
    onBubbleSizePropertyChanged(oldValue, newValue, series) {
        // todo: this property update should recreate the data point, that's why we will remove the current native instance and must create a new one
        this.bind(series);
    }
    onBubbleScalePropertyChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            if (!isNaN(+newValue))
                series.ios.scale = newValue;
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty && series.bubbleSizeProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(TKChartBubbleDataPoint.alloc().initWithXYArea(item[series.categoryProperty], item[series.valueProperty], item[series.bubbleSizeProperty]));
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartBubbleSeries.alloc().initWithItems(nativeSource);
        series.ios.scale = series.bubbleScale;
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class OhlcSeriesValueMapper extends CategoricalSeriesValueMapper {
    onHighPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLowPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onOpenPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onClosePropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        console.log("WARNING: OHLC series doesn't use valueProperty property.");
    }
    onStrokeColorsChanged(oldValue, newValue, series) {
        this.applyStrokes(series);
    }
    applyColors(series) {
        super.applyColors(series);
        this.applyStrokes(series);
    }
    applyStrokes(series) {
        if (series.ios && series.strokeColors) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.strokeColors.length);
            for (let i = 0; i < series.strokeColors.length; i++) {
                nativeArray.addObject(TKStroke.strokeWithColorWidth(series.strokeColors[i].ios, series.strokeWidth));
            }
            series.ios.style.strokes = nativeArray;
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.openPropertyName && series.highPropertyName && series.lowPropertyName && series.closePropertyName;
    }
    // public onShowLabelsChanged(data: PropertyChangeData, series: chartCommonModule.OhlcSeries) {
    //     if (series.items && series.categoryProperty) {
    //         this.bind(series);
    //     }
    // }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let currentItem = null;
        for (let i = 0; i < series.items.length; i++) {
            currentItem = series.getItemAtIndex(i);
            const categoryValue = currentItem[series.categoryProperty];
            let date = getDateObject(categoryValue);
            nativeSource.addObject(TKChartFinancialDataPoint.dataPointWithXOpenHighLowClose(date, currentItem[series.openPropertyName], currentItem[series.highPropertyName], currentItem[series.lowPropertyName], currentItem[series.closePropertyName]));
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartOhlcSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class CandlestickSeriesValueMapper extends OhlcSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let item = null;
        for (let i = 0; i < series.items.length; i++) {
            item = series.getItemAtIndex(i);
            const categoryValue = item[series.categoryProperty];
            let date = getDateObject(categoryValue);
            nativeSource.addObject(TKChartFinancialDataPoint.dataPointWithXOpenHighLowClose(date, item[series.openPropertyName], item[series.highPropertyName], item[series.lowPropertyName], item[series.closePropertyName]));
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartCandlestickSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
    onFillColorsChanged(oldValue, newValue, series) {
        this.applyFills(series);
    }
    applyColors(series) {
        super.applyColors(series);
        this.applyFills(series);
    }
    applyFills(series) {
        if (series.ios && series.fillColors) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.fillColors.length);
            for (let i = 0; i < series.fillColors.length; i++) {
                nativeArray.addObject(TKSolidFill.solidFillWithColor(series.fillColors[i].ios));
            }
            series.ios.style.fills = nativeArray;
            series.ios.style.paletteMode = 1 /* TKChartSeriesStylePaletteMode.UseItemIndex */;
        }
    }
}
export class ScatterSeriesValueMapper extends CartesianSeriesValueMapper {
    onXPropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onYPropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onItemsChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.xProperty && series.yProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            // NOTE: scatter series are intended for numeric data on X & Y
            nativeSource.addObject(TKChartDataPoint.alloc().initWithXY(item[series.xProperty], item[series.yProperty]));
        }
        series.ios = TKChartScatterSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
export class ScatterBubbleSeriesValueMapper extends ScatterSeriesValueMapper {
    onBubbleSizePropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onBubbleScaleChanged(oldValue, newValue, series) {
        if (series.ios) {
            if (!isNaN(+newValue))
                series.ios.scale = newValue;
        }
        else {
            this.bind(series);
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.xProperty && series.yProperty && series.bubbleSizeProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(TKChartBubbleDataPoint.alloc().initWithXYArea(item[series.xProperty], item[series.yProperty], item[series.bubbleSizeProperty]));
        }
        series.ios = TKChartBubbleSeries.alloc().initWithItems(nativeSource);
        series.ios.scale = series.bubbleScale;
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
function getDateObject(categoryValue) {
    let dateFormatter = NSDateFormatter.alloc().init();
    // todo: this date format have to be added as property
    dateFormatter.dateFormat = 'dd/MM/yyyy';
    if (typeof categoryValue === 'string') {
        return dateFormatter.dateFromString(categoryValue);
    }
    else {
        if (categoryValue instanceof Date) {
            return categoryValue;
        }
    }
    console.log("Error: Not supported value set to 'categoryProperty'");
    return undefined;
}
//# sourceMappingURL=chart-initializers.ios.js.map