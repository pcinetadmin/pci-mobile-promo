import { ObservableArray, Color, Utils } from "@nativescript/core";
import * as chartCommonModule from "../ui-chart.common";
import { ChartAxisLabelFitMode, ChartAxisLabelLayoutMode, ChartAxisHorizontalLocation, ChartAxisVerticalLocation, ChartAxisPlotMode, ChartPaletteSeriesState, ChartFontStyle, ChartAxisLabelVisibility, ChartSeriesPaletteMode, ChartSeriesSelectionMode, ChartSeriesStackMode, seriesName } from "../misc/chart-public-enum";
import { CartesianSeries, PieSeries } from "../visualization/views/chart-series.common";
import { convertToAndroidPaletteMode } from "../misc/chart-native-helper";
export class ChartBaseValueMapper {
    onLegendChanged(oldValue, newValue, chart) {
        if (!chart.legend) {
            if (chart.rootLayout) {
                chart.rootLayout.removeAllViews();
            }
            if (chart.androidView) {
                chart.rootLayout.addView(chart.androidView);
            }
        }
    }
    onPalettesChanged(data, chart) {
        if (data.eventName && data.eventName.toLowerCase() === "change") {
            this.loadPalette(chart.palettes, chart);
        }
    }
    onPalettesPropertyChanged(oldValue, newValue, chart) {
        for (let i = 0; i < newValue.length; ++i) {
            newValue.getItem(i).owner = chart;
        }
        this.loadPalette(newValue, chart);
    }
    loadPalette(palettes, chart) {
        if (!chart.androidView) {
            return;
        }
        this._currentChart = chart;
        let normalPalette = chart.androidView.getPalette().clone();
        let selectionPalette = chart.androidView.getSelectionPalette().clone();
        if (chart.palettes) {
            for (let i = 0; i < chart.series.length; i++) {
                let palettesForSeries = this.getPalettesForSeries(palettes, chart.series.getItem(i));
                if (palettesForSeries.length > 0) {
                    this.applyPalettesToSeries(palettesForSeries, chart.series.getItem(i), normalPalette, selectionPalette);
                }
            }
        }
        chart.androidView.setPalette(normalPalette);
        chart.androidView.setSelectionPalette(selectionPalette);
    }
    getPalettesForSeries(source, series) {
        const palettes = [];
        for (let i = 0; i < source.length; i++) {
            let palette = source.getItem(i);
            if (palette.seriesName === series[seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    }
    applyPalettesToSeries(palettes, series, normalPalette, selectionPalette) {
        let nativeNormalEntries = normalPalette.seriesEntries();
        let nativeSelectionEntries = selectionPalette.seriesEntries();
        if (!nativeNormalEntries || !nativeSelectionEntries) {
            return;
        }
        for (let i = 0; i < palettes.length; ++i) {
            if (palettes[i].seriesState === ChartPaletteSeriesState.Selected) {
                this.buildNewPaletteForSeries(palettes[i], series, nativeSelectionEntries);
            }
            else {
                this.buildNewPaletteForSeries(palettes[i], series, nativeNormalEntries);
            }
        }
    }
    buildNewPaletteForSeries(palette, series, nativePaletteEntries) {
        let currentEntryCollection = null;
        let sizeOfCurrentEntryCollection = 0;
        for (let i = 0; i < nativePaletteEntries.size(); i++) {
            if (nativePaletteEntries.get(i).getFamily() === series.android.paletteFamily()) {
                currentEntryCollection = nativePaletteEntries.get(i);
                sizeOfCurrentEntryCollection = currentEntryCollection.size();
                break;
            }
        }
        let newNativeEntries = new com.telerik.widget.palettes.PaletteEntryCollection();
        newNativeEntries.setFamily(series.android.paletteFamily());
        if (palette.entries && palette.entries.length > 0) {
            for (let i = 0; i < palette.entries.length; i++) {
                let nativeEntry = new com.telerik.widget.palettes.PaletteEntry();
                let paletteEntry = palette.entries.getItem(i);
                let currentNativeEntry = (currentEntryCollection ? currentEntryCollection.get(i % sizeOfCurrentEntryCollection) : null);
                if (paletteEntry) {
                    if (!isNaN(+paletteEntry.strokeWidth)) {
                        nativeEntry.setStrokeWidth(paletteEntry.strokeWidth);
                    }
                    else {
                        nativeEntry.setStrokeWidth((currentNativeEntry ? currentNativeEntry.getStrokeWidth() : 1));
                    }
                    if (paletteEntry.strokeColor) {
                        nativeEntry.setStroke(paletteEntry.strokeColor.android);
                    }
                    else {
                        nativeEntry.setStroke(currentNativeEntry ? currentNativeEntry.getStroke() : (new Color("Black")).android);
                    }
                    if (paletteEntry.fillColor) {
                        nativeEntry.setFill(paletteEntry.fillColor.android);
                    }
                    else {
                        nativeEntry.setFill(currentNativeEntry ? currentNativeEntry.getFill() : (new Color("Blue")).android);
                    }
                    newNativeEntries.add(nativeEntry);
                }
            }
        }
        else {
            return;
        }
        if (series instanceof PieSeries) {
            nativePaletteEntries.remove(currentEntryCollection);
            nativePaletteEntries.add(newNativeEntries);
            return;
        }
        if (series instanceof CartesianSeries) {
            if (series.paletteMode === ChartSeriesPaletteMode.Item) {
                currentEntryCollection.clear();
                currentEntryCollection.addAll(newNativeEntries);
                return;
            }
        }
        let index = this.getPaletteEntryIndexForSeries(series);
        if (index !== -1) {
            let entry = newNativeEntries.get(index % newNativeEntries.size());
            let i = currentEntryCollection.size();
            while (i < series.android.getCollectionIndex()) {
                // ensure that we have at least as many palette entries as number of series we have
                currentEntryCollection.add(i, entry);
                ++i;
            }
            currentEntryCollection.add(series.android.getCollectionIndex(), entry);
        }
        else {
            nativePaletteEntries.add(newNativeEntries);
        }
    }
    getPaletteEntryIndexForSeries(series) {
        if (!this._currentChart) {
            return -1;
        }
        let itemIndex = 0;
        for (let i = 0; i < this._currentChart.series.length; ++i) {
            if ((this._currentChart.series.getItem(i).seriesName === series.seriesName) && (this._currentChart.series.getItem(i).android.getCollectionIndex() < series.android.getCollectionIndex())) {
                itemIndex++;
            }
        }
        return itemIndex;
    }
    onSeriesChanged(data, chart) {
        if (data.eventName && data.eventName.toLowerCase() === "change") {
            const collectionData = data;
            if (collectionData.action && collectionData.action.toLowerCase() === "add") {
                if (chart.androidView && chart.series) {
                    for (let i = 0; i < collectionData.addedCount; i++) {
                        const currentSeries = chart.series.getItem(collectionData.index + i);
                        chart._addView(currentSeries);
                        chart.androidView.getSeries().add(currentSeries.android);
                        currentSeries.owner = chart;
                        currentSeries.initializer.applyLabelStyle(currentSeries, chart);
                    }
                }
                return;
            }
            if (collectionData.action && collectionData.action.toLowerCase() === "splice") {
                if (collectionData.removed instanceof ObservableArray) {
                    for (let serieIndex = 0; serieIndex < collectionData.removed.length; serieIndex++) {
                        const currentSeries = collectionData.removed.getItem(serieIndex);
                        chart._removeView(currentSeries);
                        if (chart.androidView.getSeries().indexOf(currentSeries.android) !== -1) {
                            chart.androidView.getSeries().remove(currentSeries.android);
                        }
                    }
                }
                else {
                    for (let serieIndex = 0; serieIndex < collectionData.removed.length; serieIndex++) {
                        const currentSeries = collectionData.removed[serieIndex];
                        chart._removeView(currentSeries);
                        if (chart.androidView.getSeries().indexOf(currentSeries.android) !== -1) {
                            chart.androidView.getSeries().remove(currentSeries.android);
                        }
                    }
                }
                return;
            }
        }
    }
    onSeriesPropertyChanged(oldValue, newValue, chart) {
        if (oldValue) {
            if (chart.androidView) {
                for (let serieIndex = 0; serieIndex < oldValue.length; serieIndex++) {
                    const currentSeries = oldValue.getItem(serieIndex);
                    chart._removeView(currentSeries);
                    if (chart.androidView.getSeries().indexOf(currentSeries.android) !== -1) {
                        chart.androidView.getSeries().remove(currentSeries.android);
                    }
                }
            }
        }
        this.loadSeries(chart);
    }
    loadSeries(chart) {
        if (chart.androidView && chart.series) {
            for (let i = 0; i < chart.series.length; i++) {
                const series = chart.series.getItem(i);
                chart.androidView.getSeries().add(series.android);
                series.owner = chart;
                chart._addView(series);
            }
            if (chart.palettes) {
                this.loadPalette(chart.palettes, chart);
            }
            for (let i = 0; i < chart.series.length; i++) {
                chart.series.getItem(i).initializer.applyLabelStyle(chart.series.getItem(i), chart);
            }
        }
    }
    reloadPalettes(chart) {
        if (chart.palettes) {
            this.loadPalette(chart.palettes, chart);
        }
    }
    loadAnnotations(chart) {
        if (chart.androidView && chart.annotations) {
            for (let i = 0; i < chart.annotations.length; i++) {
                chart.androidView.getAnnotations().add(chart.annotations.getItem(i).android);
            }
        }
    }
    onAnnotationsChanged(data, chart) {
        if (data.eventName && data.eventName.toLowerCase() === "change") {
            // var collectionData = <ChangedData<any>>data;
            if (data.action && data.action.toLowerCase() === "add") {
                if (chart.androidView && chart.annotations) {
                    for (let i = 0; i < data.addedCount; i++) {
                        chart.annotations.getItem(data.index + i)._init(chart);
                        chart.annotations.getItem(data.index + i)._createNative();
                        chart.androidView.getAnnotations().add(chart.annotations.getItem(data.index + i).android);
                    }
                }
                return;
            }
            if (data.action && data.action.toLowerCase() === "splice") {
                for (let annIdx = 0; annIdx < data.removed.length; annIdx++) {
                    if (chart.androidView.getAnnotations().indexOf(data.removed[annIdx].android) !== -1) {
                        chart.androidView.getAnnotations().remove(data.removed[annIdx].android);
                    }
                }
                return;
            }
        }
    }
    onAnnotationsPropertyChanged(oldValue, newValue, chart) {
        if (chart && chart.androidView) {
            chart.androidView.getAnnotations().clear();
            for (let i = 0; i < chart.annotations.length; i++) {
                chart.annotations.getItem(i)._init(chart);
                chart.annotations.getItem(i)._createNative();
            }
            this.loadAnnotations(chart);
        }
    }
    resolveVerticalAxisForSeries(series) {
        let chart = series.owner;
        if (series.verticalAxis) {
            return series.verticalAxis;
        }
        return chart.verticalAxis;
    }
}
export class CartesianAxisValueMapper {
    onLineThicknessChanged(oldValue, newValue, axis) {
        if (!isNaN(+newValue)) {
            axis.android.setLineThickness(newValue * Utils.layout.getDisplayDensity());
        }
    }
    onLineColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLineColor(newValue.android);
        }
    }
    onLineHiddenChanged(oldValue, newValue, axis) {
        axis.android.setShowLine(!newValue);
    }
    onLabelTextColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLabelTextColor(newValue.android);
        }
    }
    onLabelBackgroundColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLabelFillColor(newValue.android);
        }
    }
    onLabelBorderColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLabelStrokeColor(newValue.android);
        }
    }
    onLabelBorderWidthChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLabelStrokeWidth(newValue);
        }
    }
    onLabelMarginChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.android.setLabelMargin(newValue * Utils.layout.getDisplayDensity());
        }
    }
    onLabelRotationAngleChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            let M_PI = 3.14159265358979323846264338327950288;
            axis.android.setLabelRotationAngle(newValue * 180 / M_PI);
        }
    }
    onLabelFitModeChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (axis.labelLayoutMode === ChartAxisLabelLayoutMode.Inner && (newValue !== ChartAxisLabelFitMode.None)) {
                console.log("WARNING: Label fit mode is not supported when label layout mode is set to Inner");
                return;
            }
            if (ChartAxisLabelFitMode.Multiline === newValue) {
                axis.android.setLabelFitMode(com.telerik.widget.chart.engine.axes.common.AxisLabelFitMode.MULTI_LINE);
            }
            else if (ChartAxisLabelFitMode.Rotate === newValue) {
                axis.android.setLabelFitMode(com.telerik.widget.chart.engine.axes.common.AxisLabelFitMode.ROTATE);
            }
            else {
                axis.android.setLabelFitMode(com.telerik.widget.chart.engine.axes.common.AxisLabelFitMode.NONE);
            }
        }
    }
    onLabelLayoutModeChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisLabelLayoutMode.Outer === newValue) {
                axis.android.setLabelLayoutMode(com.telerik.widget.chart.engine.axes.AxisLabelLayoutMode.OUTER);
            }
            else if (ChartAxisLabelLayoutMode.Inner === newValue) {
                if (axis.android.getLabelFitMode() !== com.telerik.widget.chart.engine.axes.common.AxisLabelFitMode.NONE) {
                    console.log("WARNING: 'Inner' layout mode for axis labels can be combined only with fit mode 'None'.");
                }
                else {
                    axis.android.setLabelLayoutMode(com.telerik.widget.chart.engine.axes.AxisLabelLayoutMode.INNER);
                }
            }
        }
    }
    onLabelFormatChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLabelFormat(java.lang.String.valueOf(newValue));
        }
    }
    onTicksHiddenChanged(oldValue, newValue, axis) {
        axis.android.getModel().setMajorTickHidden(newValue);
    }
    onTicksThicknessChanged(oldValue, newValue, axis) {
        if (!isNaN(+newValue)) {
            axis.android.setTickThickness(newValue * Utils.layout.getDisplayDensity());
        }
    }
    onTicksLengthChanged(oldValue, newValue, axis) {
        if (!isNaN(+newValue)) {
            axis.android.getModel().setMajorTickLength(newValue * Utils.layout.getDisplayDensity());
        }
    }
    onTicksOffsetChanged(oldValue, newValue, axis) {
        if (!isNaN(+newValue)) {
            axis.android.getModel().setMajorTickTranslate(newValue * Utils.layout.getDisplayDensity());
        }
    }
    onTicksColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setTickColor(newValue.android);
        }
    }
    onHorizontalLocationChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisHorizontalLocation.Left === newValue) {
                axis.android.setHorizontalLocation(com.telerik.widget.chart.engine.axes.common.AxisHorizontalLocation.LEFT);
            }
            else if (ChartAxisHorizontalLocation.Right === newValue) {
                axis.android.setHorizontalLocation(com.telerik.widget.chart.engine.axes.common.AxisHorizontalLocation.RIGHT);
            }
        }
    }
    onVerticalLocationChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisVerticalLocation.Top === newValue) {
                axis.android.setVerticalLocation(com.telerik.widget.chart.engine.axes.common.AxisVerticalLocation.TOP);
            }
            else if (ChartAxisVerticalLocation.Bottom === newValue) {
                axis.android.setVerticalLocation(com.telerik.widget.chart.engine.axes.common.AxisVerticalLocation.BOTTOM);
            }
        }
    }
    onFontInternalChanged(oldValue, newValue, axis) {
        if (newValue) {
            const androidFont = newValue.getAndroidTypeface();
            axis.android.setLabelFont(androidFont);
            const androidSize = newValue.fontSize * Utils.layout.getDisplayDensity();
            axis.android.setLabelSize(androidSize);
        }
    }
    onLabelPaddingChanged(newValue, propertyName, axis) {
        const paddingLeftFromStyle = axis.label.style.paddingLeft;
        const paddingLeft = (!propertyName || propertyName === "paddingLeft") && !isNaN(+paddingLeftFromStyle) ?
            +paddingLeftFromStyle : axis.android.getLabelPaddingLeft();
        const paddingTopFromStyle = axis.label.style.paddingTop;
        const paddingTop = (!propertyName || propertyName === "paddingTop") && !isNaN(+paddingTopFromStyle) ?
            +paddingTopFromStyle : axis.android.getLabelPaddingTop();
        const paddingBottomFromStyle = axis.label.style.paddingBottom;
        const paddingBottom = (!propertyName || propertyName === "paddingBottom") && !isNaN(+paddingBottomFromStyle) ?
            +paddingBottomFromStyle : axis.android.getLabelPaddingBottom();
        const paddingRightFromStyle = axis.label.style.paddingRight;
        const paddingRight = (!propertyName || propertyName === "paddingRight") && !isNaN(+paddingRightFromStyle) ?
            +paddingRightFromStyle : axis.android.getLabelPaddingRight();
        axis.android.setLabelPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);
    }
    onLabelSizeChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setLabelSize(newValue * Utils.layout.getDisplayDensity());
        }
    }
    onAllowZoomChanged(oldValue, newValue, axis) {
        this.updatePanZoomBehavior(axis);
    }
    onAllowPanChanged(oldValue, newValue, axis) {
        this.updatePanZoomBehavior(axis);
    }
    updatePanZoomBehavior(axis) {
        if (!axis.owner) {
            return;
        }
        if (axis.owner instanceof chartCommonModule.RadCartesianChart) {
            axis.owner['updatePanZoomBehavior']();
            return;
        }
        // if owner is series we call its owner
        if (axis.owner.owner instanceof chartCommonModule.RadCartesianChart) {
            axis.owner.owner.updatePanZoomBehavior();
            return;
        }
    }
    onHiddenChanged(oldValue, newValue, axis) {
        axis.android.setVisible(newValue ? false : true);
    }
}
export class CategoricalAxisValueMapper extends CartesianAxisValueMapper {
    onMajorTickIntervalChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.android.setMajorTickInterval(java.lang.Integer.valueOf(newValue));
        }
    }
    onPlotModeChanged(oldValue, newValue, axis) {
        switch (newValue) {
            case ChartAxisPlotMode.BetweenTicks:
                axis.android.setPlotMode(com.telerik.widget.chart.engine.axes.common.AxisPlotMode.BETWEEN_TICKS);
                break;
            case ChartAxisPlotMode.OnTicks:
                axis.android.setPlotMode(com.telerik.widget.chart.engine.axes.common.AxisPlotMode.ON_TICKS);
                break;
            // case ChartAxisPlotMode.OnTicksPadded:
            //     axis.android.setPlotMode(com.telerik.widget.chart.engine.axes.common.AxisPlotMode.ON_TICKS_PADDED);
            //     break;
        }
    }
    onLastLabelVisibilityChanged(oldValue, newValue, axis) {
        switch (newValue) {
            case ChartAxisLabelVisibility.Clip: {
                axis.android.setLastLabelVisibility(com.telerik.widget.chart.engine.axes.common.AxisLastLabelVisibility.CLIP);
                break;
            }
            case ChartAxisLabelVisibility.Hidden: {
                axis.android.setLastLabelVisibility(com.telerik.widget.chart.engine.axes.common.AxisLastLabelVisibility.HIDDEN);
                break;
            }
            case ChartAxisLabelVisibility.Visible: {
                axis.android.setLastLabelVisibility(com.telerik.widget.chart.engine.axes.common.AxisLastLabelVisibility.VISIBLE);
                break;
            }
        }
    }
    onFirstLabelVisibilityChanged(oldValue, newValue, axis) {
        console.log("Error: Changing the 'firstLabelVisibility' property is not supported in Android.");
    }
}
export class ChartSeriesValueMapper {
    onShowLabelsChanged(oldValue, newValue, series) {
        if (newValue === null || newValue === undefined) {
            return;
        }
        series.android.setShowLabels(newValue);
    }
    onLegendTitleChanged(newValue, series) {
        series.android.setLegendTitle(newValue);
    }
    onLabelPaddingChanged(newValue, propertyName, series) {
        const paddingLeftFromStyle = series.label.style.paddingLeft;
        const paddingLeft = (!propertyName || propertyName === "paddingLeft") && !isNaN(+paddingLeftFromStyle) ?
            +paddingLeftFromStyle : series.android.getLabelPaddingLeft();
        const paddingTopFromStyle = series.label.style.paddingTop;
        const paddingTop = (!propertyName || propertyName === "paddingTop") && !isNaN(+paddingTopFromStyle) ?
            +paddingTopFromStyle : series.android.getLabelPaddingTop();
        const paddingBottomFromStyle = series.label.style.paddingBottom;
        const paddingBottom = (!propertyName || propertyName === "paddingBottom") && !isNaN(+paddingBottomFromStyle) ?
            +paddingBottomFromStyle : series.android.getLabelPaddingBottom();
        const paddingRightFromStyle = series.label.style.paddingRight;
        const paddingRight = (!propertyName || propertyName === "paddingRight") && !isNaN(+paddingRightFromStyle) ?
            +paddingRightFromStyle : series.android.getLabelPaddingRight();
        series.android.setLabelPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);
    }
    onItemsChanged(oldValue, newValue, series) {
        if (!series.items || !series.items.length) {
            return;
        }
        let length = series.items.length;
        let nativeSource = new java.util.ArrayList();
        for (let i = 0; i < length; i++) {
            const item = series.getItemAtIndex(i);
            if (series['categoryProperty'] && item[series['categoryProperty']] instanceof Date) {
                item[series['categoryProperty']] = item[series['categoryProperty']].getTime();
            }
            nativeSource.add(java.lang.String.valueOf(JSON.stringify(item)));
        }
        series.android.setData(nativeSource);
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        if (!series.valueProperty) {
            return;
        }
        series.android.setValueBinding(new com.telerik.widget.chart.engine.databinding.GenericDataPointBinding(new com.telerik.android.common.Function({
            apply: function (arg) {
                const item = JSON.parse(arg);
                return item[series.valueProperty];
            }
        })));
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (newValue) {
            this.applyLabelStyle(series);
        }
    }
    onSelectionModeChanged(oldValue, newValue, series) {
        if (!series.android) {
            return;
        }
        switch (newValue) {
            case ChartSeriesSelectionMode.NotSet:
                series.android.setSelectionMode(com.telerik.widget.chart.visualization.common.SeriesSelectionMode.NOT_SET);
                break;
            case ChartSeriesSelectionMode.None:
                series.android.setSelectionMode(com.telerik.widget.chart.visualization.common.SeriesSelectionMode.NONE);
                break;
            case ChartSeriesSelectionMode.Series:
                series.android.setSelectionMode(com.telerik.widget.chart.visualization.common.SeriesSelectionMode.SERIES);
                break;
            case ChartSeriesSelectionMode.DataPoint:
                series.android.setSelectionMode(com.telerik.widget.chart.visualization.common.SeriesSelectionMode.DATA_POINT_SINGLE);
                break;
            case ChartSeriesSelectionMode.DataPointMultiple:
                series.android.setSelectionMode(com.telerik.widget.chart.visualization.common.SeriesSelectionMode.DATA_POINT_MULTIPLE);
                break;
        }
    }
    onFontInternalChanged(oldValue, newValue, series) {
        this.applyFontInternal(newValue, series);
    }
    applyFontInternal(fontInternal, series) {
        if (fontInternal) {
            const androidFont = fontInternal.getAndroidTypeface();
            if (androidFont) {
                series.android.setLabelFont(androidFont);
            }
            if (!isNaN(fontInternal.fontSize)) {
                const androidSize = fontInternal.fontSize * Utils.layout.getDisplayDensity();
                series.android.setLabelSize(androidSize);
            }
        }
    }
    applyLabelStyle(series, chart) {
        if (!series || !series.labelStyle) {
            return;
        }
        if (!isNaN(+series.labelStyle.textSize)) {
            series.android.setLabelSize(series.labelStyle.textSize * Utils.layout.getDisplayDensity());
        }
        if (series.labelStyle.textColor) {
            series.android.setLabelTextColor(series.labelStyle.textColor.android);
        }
        if (series.labelStyle.fillColor) {
            series.android.setLabelFillColor(series.labelStyle.fillColor.android);
        }
        if (series.labelStyle.strokeWidth) {
            series.android.setLabelStrokeWidth(series.labelStyle.strokeWidth);
        }
        if (series.labelStyle.strokeColor) {
            series.android.setLabelStrokeColor(series.labelStyle.strokeColor.android);
        }
        if (!isNaN(+series.labelStyle.margin)) {
            series.android.setLabelMargin(series.labelStyle.margin * Utils.layout.getDisplayDensity());
        }
        if (series.labelStyle.textFormat) {
            series.android.setLabelFormat(series.labelStyle.textFormat);
        }
        if (series.label && series.label.style.fontInternal) {
            this.applyFontInternal(series.label.style.fontInternal, series);
        }
        let fontStyle = android.graphics.Typeface.NORMAL;
        switch (series.labelStyle.fontStyle) {
            case ChartFontStyle.Bold:
                fontStyle = android.graphics.Typeface.BOLD;
                break;
            case ChartFontStyle.Italic:
                fontStyle = android.graphics.Typeface.ITALIC;
                break;
            case ChartFontStyle.BoldItalic:
                fontStyle = android.graphics.Typeface.BOLD_ITALIC;
                break;
        }
        if (series.labelStyle.fontName) {
            series.android.setLabelFont(android.graphics.Typeface.create(series.labelStyle.fontName, fontStyle));
        }
        else {
            series.android.setLabelFontStyle(fontStyle);
        }
    }
}
export class CartesianSeriesValueMapper extends ChartSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        series.android.setHorizontalAxis(null);
        series.android.setHorizontalAxis(newValue.android);
        newValue.owner = series;
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        series.android.setVerticalAxis(null);
        series.android.setVerticalAxis(newValue.android);
        newValue.owner = series;
    }
    onItemsChanged(oldValue, newValue, series) {
        super.onItemsChanged(oldValue, newValue, series);
        if (series.owner) {
            series.owner['_syncZoomValues']();
            // Addresses an issue with ChartPalettes overriding applied label styles after
            // a new items collection is assigned. See ticket: 1105637
            this.applyLabelStyle(series, series.owner);
        }
    }
    onPaletteModeChanged(oldValue, newValue, series) {
        let nativePaletteMode = convertToAndroidPaletteMode(series.paletteMode);
        if (series.android && nativePaletteMode) {
            series.android.setPaletteMode(nativePaletteMode);
        }
    }
    onFillColorChanged(oldValue, newValue, series) {
        series.android.setFillColor(newValue.android);
    }
    onStrokeWidthChanged(oldValue, newValue, series) {
        let devicePixels = Utils.layout.toDevicePixels(newValue);
        series.android.setStrokeWidth(devicePixels);
    }
    onStrokeColorChanged(oldValue, newValue, series) {
        series.android.setStrokeColor(newValue.android);
    }
}
export class ScatterSeriesValueMapper extends CartesianSeriesValueMapper {
    onXPropertyChanged(oldValue, newValue, series) {
        if (!series.xProperty) {
            return;
        }
        const xPropName = series.xProperty;
        series.android.setXValueBinding(new com.telerik.widget.chart.engine.databinding.GenericDataPointBinding(new com.telerik.android.common.Function({
            apply: function (arg) {
                const item = JSON.parse(arg);
                return item[xPropName];
            }
        })));
    }
    onYPropertyChanged(oldValue, newValue, series) {
        if (!series.yProperty) {
            return;
        }
        const yPropName = series.yProperty;
        series.android.setYValueBinding(new com.telerik.widget.chart.engine.databinding.GenericDataPointBinding(new com.telerik.android.common.Function({
            apply: function (arg) {
                const item = JSON.parse(arg);
                return item[yPropName];
            }
        })));
    }
}
export class ScatterBubbleSeriesValueMapper extends ScatterSeriesValueMapper {
    onBubbleSizePropertyChanged(oldValue, newValue, series) {
        if (!series.bubbleSizeProperty) {
            return;
        }
        const propertyName = series.bubbleSizeProperty;
        const binding = new com.telerik.widget.chart.engine.databinding.GenericDataPointBinding(new com.telerik.android.common.Function({
            apply: function (arg) {
                const item = JSON.parse(arg);
                return item[propertyName];
            }
        }));
        series.android.setBubbleSizeBinding(binding);
    }
    onBubbleScaleChanged(oldValue, newValue, series) {
        if (newValue) {
            // todo: we use (scale^2) because of bug in Android scale calculation. Update this hack when it is fixed.
            series.android.setBubbleScale(Math.pow(newValue * Utils.layout.getDisplayDensity(), 2));
        }
    }
}
export class CategoricalSeriesValueMapper extends CartesianSeriesValueMapper {
    updateNative(series) {
    }
    onCategoryPropertyChanged(oldValue, newValue, series) {
        if (!series.categoryProperty) {
            return;
        }
        series.android.setCategoryBinding(new com.telerik.widget.chart.engine.databinding.GenericDataPointBinding(new com.telerik.android.common.Function({
            apply: function (arg) {
                const item = JSON.parse(arg);
                return item[series.categoryProperty];
            }
        })));
    }
    onStackModePropertyChanged(oldValue, newValue, series) {
        if (!newValue) {
            return;
        }
        switch (newValue) {
            case ChartSeriesStackMode.None:
                series.android.setCombineMode(com.telerik.widget.chart.engine.series.combination.ChartSeriesCombineMode.CLUSTER);
                break;
            case ChartSeriesStackMode.Stack:
                series.android.setCombineMode(com.telerik.widget.chart.engine.series.combination.ChartSeriesCombineMode.STACK);
                break;
            case ChartSeriesStackMode.Stack100:
                series.android.setCombineMode(com.telerik.widget.chart.engine.series.combination.ChartSeriesCombineMode.STACK_100);
                break;
        }
    }
}
export class BarSeriesValueMapper extends CategoricalSeriesValueMapper {
    onMinBarSizeChanged(oldValue, newValue, series) {
        if (series.android && !isNaN(newValue)) {
            series.android.setMinBarWidth(Utils.layout.toDevicePixels(newValue));
        }
        else {
            series.android.setMinBarWidth(0);
        }
    }
    onMaxBarSizeChanged(oldValue, newValue, series) {
        if (series.android && !isNaN(newValue)) {
            series.android.setMaxBarWidth(Utils.layout.toDevicePixels(newValue));
        }
        else {
            series.android.setMaxBarWidth(0);
        }
    }
}
export class PieSeriesValueMapper extends ChartSeriesValueMapper {
    onLabelPropertyChanged(oldValue, newValue, series) {
        if (!series.legendLabel) {
            return;
        }
        series.android.setNameBinding(new com.telerik.widget.chart.engine.databinding.GenericDataPointBinding(new com.telerik.android.common.Function({
            apply: function (arg) {
                const item = JSON.parse(arg);
                return item[series.legendLabel];
            }
        })));
    }
    onLegendTitleChanged(newValue, series) {
    }
    onExpandRadiusChanged(oldValue, newValue, series) {
        if (isNaN(+newValue) || newValue < 0.0 || newValue > 1.0) {
            console.log("WARNING: Expand radius factor must be number in range [0,1]");
            return;
        }
        series.android.setSelectedPointOffset(newValue);
    }
    onOuterRadiusFactorChanged(oldValue, newValue, series) {
        if (isNaN(+newValue) || newValue < 0.0 || newValue > 1.0) {
            console.log("WARNING: Outer radius factor must be number in range [0,1]");
            return;
        }
        series.android.setRadiusFactor(newValue);
        series.android.requestLayout();
    }
    onStartAngleChanged(oldValue, newValue, series) {
        if (!isNaN(+newValue)) {
            const sweepAngle = series.endAngle ? series.endAngle - newValue : 360;
            series.android.setAngleRange(new com.telerik.widget.chart.engine.chartAreas.AngleRange(newValue, sweepAngle));
        }
    }
    onEndAngleChanged(oldValue, newValue, series) {
        if (!isNaN(+newValue)) {
            const startAngle = series.startAngle ? series.startAngle : 0;
            const sweepAngle = newValue - startAngle;
            series.android.setAngleRange(new com.telerik.widget.chart.engine.chartAreas.AngleRange(startAngle, sweepAngle));
        }
    }
    onShowPercentageChanged(oldValue, newValue, series) {
        series.android.setDisplayPercentage(series.showPercentage);
    }
    onFillColorsChanged(oldValue, newValue, series) {
        this.applyColors(series);
    }
    onStrokeWidthChanged(oldValue, newValue, series) {
        this.applyColors(series);
    }
    onStrokeColorsChanged(oldValue, newValue, series) {
        this.applyColors(series);
    }
    applyColors(series) {
        const fillColors = series.fillColors;
        const fillColorsLength = fillColors ? fillColors.length : 0;
        const strokeColors = series.strokeColors;
        const strokeColorsLength = strokeColors ? strokeColors.length : 0;
        const length = Math.max(fillColorsLength, strokeColorsLength);
        const nativeSliceStyles = new java.util.ArrayList();
        for (let i = 0; i < length; i++) {
            const style = new com.telerik.widget.chart.visualization.pieChart.SliceStyle();
            if (i < fillColorsLength) {
                style.setFillColor(fillColors[i].android);
            }
            if (i < strokeColorsLength) {
                style.setStrokeColor(strokeColors[i].android);
            }
            if (!isNaN(+series.strokeWidth)) {
                style.setStrokeWidth(+series.strokeWidth);
            }
            nativeSliceStyles.add(style);
        }
        series.android.setSliceStyles(nativeSliceStyles);
    }
}
export class DonutSeriesValueMapper extends PieSeriesValueMapper {
    onInnerRadiusFactorChanged(oldValue, newValue, series) {
        if (!newValue) {
            return;
        }
        series.android.setInnerRadiusFactor(newValue);
    }
}
export class RangeBarSeriesValueMapper extends CategoricalSeriesValueMapper {
    onHighPropertyNameChanged(oldValue, newValue, series) { }
    onLowPropertyNameChanged(oldValue, newValue, series) { }
}
export class LineSeriesValueMapper extends CategoricalSeriesValueMapper {
    onPaletteModeChanged(oldValue, newValue, series) {
        console.log('WARNING: Property paletteMode is not applicable for series of type: ' + series.constructor.name);
    }
    onFillColorChanged(oldValue, newValue, series) {
        console.log('WARNING: Property fillColor is not applicable for series of type: ' + series.constructor.name);
    }
}
export class SplineSeriesValueMapper extends LineSeriesValueMapper {
}
export class AreaSeriesValueMapper extends LineSeriesValueMapper {
    onFillColorChanged(oldValue, newValue, series) {
        series.android.setFillColor(newValue.android);
    }
}
export class SplineAreaSeriesValueMapper extends AreaSeriesValueMapper {
}
export class OhlcSeriesValueMapper extends CategoricalSeriesValueMapper {
    onHighPropertyNameChanged(oldValue, newValue, series) { }
    onLowPropertyNameChanged(oldValue, newValue, series) { }
    onOpenPropertyNameChanged(oldValue, newValue, series) { }
    onClosePropertyNameChanged(oldValue, newValue, series) { }
    onFillColorChanged(oldValue, newValue, series) {
        console.log('WARNING: Property fillColor is not applicable for series of type: ' + series.constructor.name);
    }
    onStrokeColorsChanged(oldValue, newValue, series) {
        if (newValue && newValue.length > 0) {
            series.android.setStrokeColor(newValue[0].android);
            if (newValue.length > 1) {
                series.android.setStrokeSecondColor(newValue[1].android);
            }
        }
    }
}
export class CandlestickSeriesValueMapper extends OhlcSeriesValueMapper {
    onFillColorChanged(oldValue, newValue, series) {
        series.android.setFillColor(newValue.android);
    }
    onFillColorsChanged(oldValue, newValue, series) {
        if (newValue && newValue.length > 0) {
            series.android.setFillColor(newValue[0].android);
            if (newValue.length > 1) {
                series.android.setFillSecondColor(newValue[1].android);
            }
        }
    }
}
export class BubbleSeriesValueMapper extends CategoricalSeriesValueMapper {
    onBubbleSizePropertyChanged(oldValue, newValue, series) { }
    onBubbleScalePropertyChanged(oldValue, newValue, series) { }
}
//# sourceMappingURL=chart-initializers.android.js.map