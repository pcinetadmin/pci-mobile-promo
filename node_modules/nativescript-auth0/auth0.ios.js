import { Auth0Common, ResponseType, WebAuthException } from './auth0-common';
import { Auth0Authentication } from './ios/auth0Authentication';
import { SafariWebAuth } from './ios/safariWebAuth';
import { ResponseType as iOSResponseType } from './ios/responseType';
import { a0_url } from './ios/utils';
import { Credentials } from './common/credentials';
import { UserInfo } from './common/userInfo';
export { Credentials, UserInfo, ResponseType, WebAuthException };
export { resumeAuth } from './ios/webAuth';
export class Auth0 extends Auth0Common {
    constructor(clientId, domain) {
        super(clientId, domain);
        this.authenticationApi = new Auth0Authentication(this.clientId, a0_url(this.domain));
    }
    webAuthentication(options) {
        const auth = SafariWebAuth.init(this.clientId, a0_url(this.domain));
        if (options.audience != null) {
            auth.setAudience(options.audience);
        }
        if (options.connection != null) {
            auth.setConnection(options.connection);
        }
        if (options.nonce != null) {
            auth.setNonce(options.nonce);
        }
        if (options.responseType != null) {
            switch (options.responseType) {
                case ResponseType.CODE:
                    auth.setResponseType([iOSResponseType.code]);
                    break;
                case ResponseType.TOKEN:
                    auth.setResponseType([iOSResponseType.token]);
                    break;
                case ResponseType.ID_TOKEN:
                    auth.setResponseType([iOSResponseType.idToken]);
                    break;
            }
        }
        /**
         * Not supported by iOS at this time
         */
        /*if (options.scheme != null) {
            auth.setScheme(options.scheme);
        }*/
        if (options.scope != null) {
            auth.setScope(options.scope);
        }
        if (options.state != null) {
            auth.setState(options.state);
        }
        if (options.parameters != null) {
            auth.setParameters(options.parameters);
        }
        return new Promise((resolve, reject) => {
            try {
                auth.start((result) => {
                    if (result.failure != null) {
                        reject(new WebAuthException(result.failure.message));
                    }
                    else {
                        const credentials = result.success;
                        resolve(credentials);
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    renewCredentials(refreshToken) {
        return new Promise((resolve, reject) => {
            try {
                this.authenticationApi
                    .renew(refreshToken)
                    .start((result) => {
                    if (result.failure != null) {
                        reject(result.failure);
                    }
                    else {
                        resolve(result.success);
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    revokeRefreshToken(refreshToken) {
        return new Promise((resolve, reject) => {
            try {
                this.authenticationApi
                    .revoke(refreshToken)
                    .start((result) => {
                    if (result.failure != null) {
                        reject(result.failure);
                    }
                    else {
                        resolve();
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    getUserInfo(accessToken) {
        return new Promise((resolve, reject) => {
            try {
                this.authenticationApi
                    .userInfo(accessToken)
                    .start((result) => {
                    if (result.failure != null) {
                        reject(result.failure);
                    }
                    else {
                        resolve(result.success);
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    logoutUser(federated) {
        const auth = SafariWebAuth.init(this.clientId, a0_url(this.domain));
        return new Promise((resolve, reject) => {
            try {
                auth.clearSession(federated, (success) => {
                    if (!success) {
                        reject(new WebAuthException('Fail to Logout'));
                    }
                    else {
                        resolve(success);
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
}
//# sourceMappingURL=auth0.ios.js.map