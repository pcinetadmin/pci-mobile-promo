var Uri = android.net.Uri;
var TextUtils = android.text.TextUtils;
var Base64 = android.util.Base64;
var Log = android.util.Log;
var DecodeException = com.auth0.android.jwt.DecodeException;
var JWT = com.auth0.android.jwt.JWT;
var SecureRandom = java.security.SecureRandom;
import { CallbackHelper } from './callbackHelper';
import { AuthenticationException } from '../authentication/authenticationException';
import { Credentials } from '../../common/credentials';
import { PKCE } from './pkce';
import { AuthenticationAPIClient } from '../authentication/authenticationAPIClient';
import { authenticateUsingBrowser } from './authenticationActivity';
export class OAuthManager {
    constructor(account, callback, parameters) {
        this.account = account;
        this.callback = callback;
        this.parameters = parameters;
    }
    setCustomTabsOptions(options) {
        this.ctOptions = options;
    }
    setPKCE(pkce) {
        this.pkce = pkce;
    }
    startAuthorization(activity, redirectUri, requestCode) {
        this.addPKCEParameters(this.parameters, redirectUri);
        this.addClientParameters(this.parameters, redirectUri);
        Log.d(OAuthManager.TAG, 'Added client parameters');
        this.addValidationParameters(this.parameters);
        Log.d(OAuthManager.TAG, 'Added validation parameters');
        const uri = this.buildAuthorizeUri();
        Log.d(OAuthManager.TAG, 'Built authorize uri');
        this.requestCode = requestCode;
        authenticateUsingBrowser(activity, uri, this.ctOptions);
    }
    resumeAuthorization(data) {
        if (!data.isValid(this.requestCode)) {
            Log.w(OAuthManager.TAG, "The Authorize Result is invalid.");
            this.callback.onFailure(new AuthenticationException({
                code: "a0.invalid_response",
                description: "The received response is invalid. Try again."
            }, 0));
            return false;
        }
        const values = CallbackHelper.getValuesFromUri(data.getIntent().getData());
        if (Object.keys(values).length === 0) {
            Log.w(OAuthManager.TAG, "The response didn't contain any of these values: code, state, id_token, access_token, token_type, refresh_token");
            this.callback.onFailure(new AuthenticationException({
                code: "a0.invalid_response",
                description: "The received response is invalid. Try again."
            }, 0));
            return false;
        }
        this.logDebug("The parsed CallbackURI contains the following values: " + values);
        try {
            this.assertNoError(values[OAuthManager.KEY_ERROR], values[OAuthManager.KEY_ERROR_DESCRIPTION]);
            OAuthManager.assertValidState(this.parameters[OAuthManager.KEY_STATE], values[OAuthManager.KEY_STATE]);
            if (this.parameters[OAuthManager.KEY_RESPONSE_TYPE] != null && this.parameters[OAuthManager.KEY_RESPONSE_TYPE].includes(OAuthManager.RESPONSE_TYPE_ID_TOKEN)) {
                OAuthManager.assertValidNonce(this.parameters[OAuthManager.KEY_NONCE], values[OAuthManager.KEY_ID_TOKEN]);
            }
            Log.d(OAuthManager.TAG, "Authenticated using web flow");
            const expiresAt = values[OAuthManager.KEY_EXPIRES_IN] == null ? null : new Date(this.getCurrentTimeInMillis() + Number(values[OAuthManager.KEY_EXPIRES_IN]) * 1000);
            const urlCredentials = new Credentials(values[OAuthManager.KEY_ACCESS_TOKEN], values[OAuthManager.KEY_TOKEN_TYPE], values[OAuthManager.KEY_ID_TOKEN], values[OAuthManager.KEY_REFRESH_TOKEN], undefined, expiresAt, values[OAuthManager.KEY_SCOPE]);
            if (!this.shouldUsePKCE()) {
                this.callback.onSuccess(urlCredentials);
            }
            else {
                // Finish Code Exchange
                this.pkce.getToken(values[OAuthManager.KEY_CODE], {
                    onFailure: (...args) => {
                        this.callback.onFailure(args[0]);
                    },
                    onSuccess: (codeCredentials) => {
                        this.callback.onSuccess(OAuthManager.mergeCredentials(urlCredentials, codeCredentials));
                    }
                });
            }
        }
        catch (e) {
            if (e instanceof AuthenticationException) {
                this.callback.onFailure(e);
            }
            else {
                throw e;
            }
        }
        return true;
    }
    getCurrentTimeInMillis() {
        return this.currentTimeInMillis != null ? this.currentTimeInMillis : Date.now();
    }
    setCurrentTimeInMillis(currentTimeInMillis) {
        this.currentTimeInMillis = currentTimeInMillis;
    }
    /// Helper Methods
    assertNoError(errorValue, errorDescription) {
        if (errorValue == null) {
            return;
        }
        Log.e(OAuthManager.TAG, "Error, access denied. Check that the required Permissions are granted and that the Application has this Connection configured in Auth0 Dashboard.");
        if (OAuthManager.ERROR_VALUE_ACCESS_DENIED === errorValue) {
            throw new AuthenticationException({
                code: OAuthManager.ERROR_VALUE_ACCESS_DENIED,
                description: "Permissions were not granted. Try again."
            }, 0);
        }
        else if (OAuthManager.ERROR_VALUE_UNAUTHORIZED === errorValue) {
            throw new AuthenticationException({
                code: OAuthManager.ERROR_VALUE_UNAUTHORIZED,
                description: errorDescription
            }, 0);
        }
        else if (OAuthManager.ERROR_VALUE_LOGIN_REQUIRED === errorValue) {
            // Whitelist to allow SSO errors go through
            throw new AuthenticationException({
                code: errorValue,
                description: errorDescription
            }, 0);
        }
        else {
            throw new AuthenticationException({
                code: "a0.invalid_configuration",
                description: "The application isn't configured properly for the social connection. Please check your Auth0's application configuration"
            }, 0);
        }
    }
    static assertValidState(requestState, responseState) {
        if (requestState !== responseState) {
            Log.e(OAuthManager.TAG, `Received state doesn't match. Received ${responseState} but expected ${requestState}`);
            throw new AuthenticationException({
                code: OAuthManager.ERROR_VALUE_ACCESS_DENIED,
                description: "The received state is invalid. Try again."
            }, 0);
        }
    }
    static assertValidNonce(requestNonce, idToken) {
        let valid = false;
        try {
            const token = new JWT(idToken);
            const nonceClaim = token.getClaim(OAuthManager.KEY_NONCE);
            valid = requestNonce === nonceClaim.asString();
        }
        catch (e) {
            if (e instanceof DecodeException) {
                Log.e(OAuthManager.TAG, "An exception occurred when trying to validate the token's 'nonce' claim. " + e.getMessage(), e);
            }
            else {
                throw e;
            }
        }
        if (!valid) {
            Log.e(OAuthManager.TAG, "Received nonce doesn't match.");
            throw new AuthenticationException({
                code: OAuthManager.ERROR_VALUE_ACCESS_DENIED,
                description: "The received nonce is invalid. Try again."
            }, 0);
        }
    }
    buildAuthorizeUri() {
        const authorizeUri = Uri.parse(this.account.getAuthorizeUrl());
        const builder = authorizeUri.buildUpon();
        for (const key in this.parameters) {
            builder.appendQueryParameter(key, this.parameters[key]);
        }
        const uri = builder.build();
        this.logDebug(`Using the following AuthorizeURI: ${uri.toString()}`);
        return uri;
    }
    addPKCEParameters(parameters, redirectUri) {
        if (!this.shouldUsePKCE()) {
            return;
        }
        try {
            this.createPKCE(redirectUri);
            const codeChallenge = this.pkce.getCodeChallenge();
            parameters[OAuthManager.KEY_CODE_CHALLENGE] = codeChallenge;
            parameters[OAuthManager.KEY_CODE_CHALLENGE_METHOD] = OAuthManager.METHOD_SHA_256;
            Log.v(OAuthManager.TAG, "Using PKCE authentication flow");
        }
        catch (e) {
            if (e instanceof java.lang.IllegalStateException) {
                Log.e(OAuthManager.TAG, "Some algorithms aren't available on this device and PKCE can't be used. Defaulting to token response_type.", e);
            }
            else {
                throw e;
            }
        }
    }
    addValidationParameters(parameters) {
        const state = OAuthManager.getRandomString(parameters[OAuthManager.KEY_STATE]);
        parameters[OAuthManager.KEY_STATE] = state;
        if (parameters[OAuthManager.KEY_RESPONSE_TYPE] != null && parameters[OAuthManager.KEY_RESPONSE_TYPE].includes(OAuthManager.RESPONSE_TYPE_ID_TOKEN)) {
            const nonce = OAuthManager.getRandomString(parameters[OAuthManager.KEY_NONCE]);
            parameters[OAuthManager.KEY_NONCE] = nonce;
        }
    }
    addClientParameters(parameters, redirectUri) {
        if (this.account.getTelemetry() != null) {
            parameters[OAuthManager.KEY_TELEMETRY] = this.account.getTelemetry().getValue();
        }
        parameters[OAuthManager.KEY_CLIENT_ID] = this.account.getClientId();
        parameters[OAuthManager.KEY_REDIRECT_URI] = redirectUri;
    }
    createPKCE(redirectUri) {
        if (this.pkce == null) {
            this.pkce = new PKCE(new AuthenticationAPIClient(this.account), redirectUri);
        }
    }
    shouldUsePKCE() {
        return this.parameters[OAuthManager.KEY_RESPONSE_TYPE] != null && this.parameters[OAuthManager.KEY_RESPONSE_TYPE].includes(OAuthManager.RESPONSE_TYPE_CODE) && PKCE.isAvailable();
    }
    customTabsOptions() {
        return this.ctOptions;
    }
    static mergeCredentials(urlCredentials, codeCredentials) {
        const accessToken = TextUtils.isEmpty(codeCredentials.accessToken) ? urlCredentials.accessToken : codeCredentials.accessToken;
        const tokenType = TextUtils.isEmpty(codeCredentials.tokenType) ? urlCredentials.tokenType : codeCredentials.tokenType;
        const idToken = TextUtils.isEmpty(codeCredentials.idToken) ? urlCredentials.idToken : codeCredentials.idToken;
        const refreshToken = TextUtils.isEmpty(codeCredentials.refreshToken) ? urlCredentials.refreshToken : codeCredentials.refreshToken;
        const expiresAt = codeCredentials.expiresAt != null ? codeCredentials.expiresAt : urlCredentials.expiresAt;
        const scope = TextUtils.isEmpty(codeCredentials.scope) ? urlCredentials.scope : codeCredentials.scope;
        return new Credentials(accessToken, tokenType, idToken, refreshToken, undefined, expiresAt, scope);
    }
    static getRandomString(defaultValue) {
        return defaultValue != null ? defaultValue : OAuthManager.secureRandomString();
    }
    static secureRandomString() {
        const sr = new SecureRandom();
        const randomBytes = Array.create('byte', 32);
        sr.nextBytes(randomBytes);
        return android.util.Base64.encodeToString(randomBytes, Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);
    }
    logDebug(message) {
        if (this.account.isLoggingEnabled()) {
            Log.d(OAuthManager.TAG, message);
        }
    }
}
OAuthManager.TAG = 'OAuthManager';
OAuthManager.KEY_RESPONSE_TYPE = "response_type";
OAuthManager.KEY_STATE = "state";
OAuthManager.KEY_NONCE = "nonce";
OAuthManager.KEY_CONNECTION = "connection";
OAuthManager.RESPONSE_TYPE_ID_TOKEN = "id_token";
OAuthManager.RESPONSE_TYPE_CODE = "code";
OAuthManager.ERROR_VALUE_ACCESS_DENIED = "access_denied";
OAuthManager.ERROR_VALUE_UNAUTHORIZED = "unauthorized";
OAuthManager.ERROR_VALUE_LOGIN_REQUIRED = "login_required";
OAuthManager.METHOD_SHA_256 = "S256";
OAuthManager.KEY_CODE_CHALLENGE = "code_challenge";
OAuthManager.KEY_CODE_CHALLENGE_METHOD = "code_challenge_method";
OAuthManager.KEY_CLIENT_ID = "client_id";
OAuthManager.KEY_REDIRECT_URI = "redirect_uri";
OAuthManager.KEY_TELEMETRY = "auth0Client";
OAuthManager.KEY_ERROR = "error";
OAuthManager.KEY_ERROR_DESCRIPTION = "error_description";
OAuthManager.KEY_ID_TOKEN = "id_token";
OAuthManager.KEY_ACCESS_TOKEN = "access_token";
OAuthManager.KEY_TOKEN_TYPE = "token_type";
OAuthManager.KEY_REFRESH_TOKEN = "refresh_token";
OAuthManager.KEY_EXPIRES_IN = "expires_in";
OAuthManager.KEY_CODE = "code";
OAuthManager.KEY_SCOPE = "scope";
//# sourceMappingURL=oauthManager.js.map