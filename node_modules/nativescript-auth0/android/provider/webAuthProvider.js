var Intent = android.content.Intent;
var Uri = android.net.Uri;
var Log = android.util.Log;
import { OAuthManager } from './oauthManager';
import { ResponseType } from './responseType';
import { FlagChecker } from './flagChecker';
import { CallbackHelper } from './callbackHelper';
import { AuthenticationException } from '../authentication/authenticationException';
import { AuthorizeResult } from './authorizeResult';
/**
 * OAuth2 Web Authentication Provider.
 * It can use an external browser by sending the {@link android.content.Intent#ACTION_VIEW} intent or also the {@link WebAuthActivity}.
 * This behaviour is changed using {@link WebAuthProvider.Builder#useBrowser(boolean)}, and defaults to use browser.
 */
export class WebAuthProvider {
    /**
     * Initialize the WebAuthProvider instance with an account. Additional settings can be configured,
     * like setting the connection name or authentication parameters.
     *
     * @param account to use for authentication
     * @return a new WebAuthProvider instance to customize.
     */
    constructor(account) {
        this.account = account;
        this.values = {};
        // Default values
        this.scheme = "https";
        this.withResponseType(ResponseType.CODE);
        this.withScope(WebAuthProvider.SCOPE_TYPE_OPENID);
    }
    /**
     * Use a custom state in the requests
     *
     * @param state to use in the requests
     * @return the current builder instance
     */
    withState(state) {
        this.values[OAuthManager.KEY_STATE] = state;
        return this;
    }
    /**
     * Specify a custom nonce value to avoid replay attacks. It will be sent in the auth request that will be returned back as a claim in the id_token
     *
     * @param nonce to use in the requests
     * @return the current builder instance
     */
    withNonce(nonce) {
        this.values[OAuthManager.KEY_NONCE] = nonce;
        return this;
    }
    /**
     * Use a custom audience in the requests
     *
     * @param audience to use in the requests
     * @return the current builder instance
     */
    withAudience(audience) {
        this.values[WebAuthProvider.KEY_AUDIENCE] = audience;
        return this;
    }
    /**
     * Specify a custom Scheme to use on the Callback Uri. Default scheme is 'https'.
     *
     * @param scheme to use in the Callback Uri.
     * @return the current builder instance
     */
    withScheme(scheme) {
        const lowerCase = scheme.toLowerCase();
        if (scheme !== lowerCase) {
            Log.w(WebAuthProvider.TAG, "Please provide the scheme in lowercase and make sure it's the same configured in the intent filter. Android expects the scheme in lowercase");
        }
        this.scheme = scheme;
        return this;
    }
    /**
     * Give a scope for this request.
     *
     * @param scope to request.
     * @return the current builder instance
     */
    withScope(scope) {
        this.values[WebAuthProvider.KEY_SCOPE] = scope;
        return this;
    }
    /**
     * Give a connection scope for this request.
     *
     * @param connectionScope to request.
     * @return the current builder instance
     */
    withConnectionScope(...connectionScope) {
        const concatScope = connectionScope.map((x) => x.trim()).join(' ');
        if (concatScope.length > 0) {
            this.values[WebAuthProvider.KEY_CONNECTION_SCOPE] = concatScope;
        }
        return this;
    }
    /**
     * Choose the grant type for this request.
     *
     * @param type the ResponseType to request to the Authentication API. Multiple ResponseType's can be defined using a pipe. "CODE | TOKEN"
     * @return the current builder instance
     */
    withResponseType(type) {
        let sb = '';
        if (FlagChecker.hasFlag(type, ResponseType.CODE)) {
            sb += `${OAuthManager.RESPONSE_TYPE_CODE} `;
        }
        if (FlagChecker.hasFlag(type, ResponseType.ID_TOKEN)) {
            sb += `${OAuthManager.RESPONSE_TYPE_ID_TOKEN} `;
        }
        if (FlagChecker.hasFlag(type, ResponseType.TOKEN)) {
            sb += `${WebAuthProvider.RESPONSE_TYPE_TOKEN}`;
        }
        this.values[OAuthManager.KEY_RESPONSE_TYPE] = sb.trim();
        return this;
    }
    /**
     * Use extra parameters on the request.
     *
     * @param parameters to add
     * @return the current builder instance
     */
    withParameters(parameters) {
        for (const key in parameters) {
            const value = parameters[key];
            if (value != null) {
                this.values[key] = value.toString();
            }
        }
        return this;
    }
    /**
     * Use the given connection. By default no connection is specified, so the login page will be displayed.
     *
     * @param connectionName to use
     * @return the current builder instance
     */
    withConnection(connectionName) {
        this.values[OAuthManager.KEY_CONNECTION] = connectionName;
        return this;
    }
    /**
     * When using a Custom Tabs compatible Browser, apply this customization options.
     *
     * @param options the Custom Tabs customization options
     * @return the current builder instance
     */
    withCustomTabsOptions(options) {
        this.ctOptions = options;
        return this;
    }
    withPKCE(pkce) {
        this.pkce = pkce;
        return this;
    }
    // @VisibleForTesting
    static hasBrowserAppInstalled(packageManager) {
        const intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://auth0.com"));
        return intent.resolveActivity(packageManager) != null;
    }
    /**
     * Request user Authentication. The result will be received in the callback.
     *
     * @param activity context to run the authentication
     * @param callback to receive the parsed results
     */
    start(activity, callback) {
        WebAuthProvider.managerInstance = null;
        if (this.account.getAuthorizeUrl() == null) {
            const ex = new AuthenticationException({
                code: "a0.invalid_authorize_url",
                description: "Auth0 authorize URL not properly set. This can be related to an invalid domain."
            }, 0);
            callback.onFailure(ex);
            return;
        }
        if (!WebAuthProvider.hasBrowserAppInstalled(activity.getPackageManager())) {
            const ex = new AuthenticationException({
                code: "a0.browser_not_available",
                description: "No Browser application installed to perform web authentication."
            }, 0);
            callback.onFailure(ex);
            return;
        }
        const manager = new OAuthManager(this.account, callback, this.values);
        manager.setCustomTabsOptions(this.ctOptions);
        manager.setPKCE(this.pkce);
        WebAuthProvider.managerInstance = manager;
        const redirectUri = CallbackHelper.getCallbackUri(this.scheme, activity.getApplicationContext().getPackageName(), this.account.getDomainUrl());
        manager.startAuthorization(activity, redirectUri, 110);
    }
    // Public methods
    /**
     * Finishes the authentication flow by passing the data received in the activity's onNewIntent() callback.
     * The final authentication result will be delivered to the callback specified when calling start().
     * <p>
     * This is no longer required to be called, the authentication is handled internally as long as you've correctly setup the intent-filter.
     *
     * @param intent the data received on the onNewIntent() call
     * @return true if a result was expected and has a valid format, or false if not.
     */
    static resume(intent) {
        if (WebAuthProvider.managerInstance == null) {
            Log.w(WebAuthProvider.TAG, "There is no previous instance of this provider.");
            return false;
        }
        const data = new AuthorizeResult(intent);
        const success = WebAuthProvider.managerInstance.resumeAuthorization(data);
        if (success) {
            WebAuthProvider.managerInstance = null;
        }
        return success;
    }
    // End Public methods
    static getInstance() {
        return WebAuthProvider.managerInstance;
    }
    clearSession(federated, callback) {
        callback(true);
    }
}
WebAuthProvider.TAG = 'WebAuthProvider';
WebAuthProvider.KEY_AUDIENCE = "audience";
WebAuthProvider.KEY_SCOPE = "scope";
WebAuthProvider.KEY_CONNECTION_SCOPE = "connection_scope";
WebAuthProvider.SCOPE_TYPE_OPENID = "openid";
WebAuthProvider.RESPONSE_TYPE_TOKEN = "token";
//# sourceMappingURL=webAuthProvider.js.map