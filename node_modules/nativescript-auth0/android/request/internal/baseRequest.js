import { HttpResponseEncoding, request as makeRequest } from '@nativescript/core/http';
var IOException = java.io.IOException;
import { Auth0Exception } from '../../auth0Exception';
import { ParameterBuilder } from '../../authentication/parameterBuilder';
export class BaseRequest {
    constructor(url, adapter, errorBuilder, headers = {}, parameterBuilder = ParameterBuilder.newBuilder()) {
        this.url = url;
        this.adapter = adapter;
        this.headers = headers;
        this.builder = parameterBuilder;
        this.errorBuilder = errorBuilder;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    postOnSuccess(payload) {
        this.callback.onSuccess(payload);
    }
    postOnFailure(error) {
        this.callback.onFailure(error);
    }
    newRequestOptions(method) {
        const options = {
            url: this.url.toString(),
            method: method,
            headers: {
                'Content-Type': 'application/json'
            }
        };
        for (const entry in this.headers) {
            options.headers[entry] = this.headers[entry];
        }
        return options;
    }
    getAdapter() {
        return this.adapter;
    }
    getErrorBuilder() {
        return this.errorBuilder;
    }
    getCallback() {
        return this.callback;
    }
    buildBody() {
        const dictionary = this.builder.asDictionary();
        if (Object.keys(dictionary).length > 0) {
            return JSON.stringify(dictionary);
        }
        return null;
    }
    parseUnsuccessfulResponse(response) {
        let stringPayload = undefined;
        try {
            stringPayload = response.content.toString(HttpResponseEncoding.UTF8);
            return this.errorBuilder.from(JSON.parse(stringPayload));
        }
        catch (e) {
            if (e instanceof SyntaxError) {
                return this.errorBuilder.from(stringPayload, response.statusCode);
            }
            else if (e instanceof IOException) {
                const auth0Exception = new Auth0Exception(`Error parsing the server response ${e.toString()}`);
                return this.errorBuilder.from(`Request to ${this.url.toString()} failed`, auth0Exception);
            }
            else {
                throw e;
            }
        }
    }
    onFailure(request, e) {
        const exception = new Auth0Exception(`Failed to execute request to ${this.url.toString()} - ${e.toString()}`);
        this.postOnFailure(this.errorBuilder.from("Request failed", exception));
    }
    addHeader(name, value) {
        this.headers[name] = value;
        return this;
    }
    setBearer(jwt) {
        this.addHeader("Authorization", `Bearer ${jwt}`);
        return this;
    }
    addParameters(parameters) {
        this.builder.addAll(parameters);
        return this;
    }
    addParameter(name, value) {
        this.builder.setParameter(name, value);
        return this;
    }
    start(callback) {
        this.setCallback(callback);
        const request = this.doBuildRequest();
        makeRequest(request)
            .then((response) => {
            this.onResponse(response);
        })
            .catch((error) => {
            this.onFailure(request, error);
        });
    }
}
//# sourceMappingURL=baseRequest.js.map