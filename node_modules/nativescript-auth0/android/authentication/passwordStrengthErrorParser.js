export class PasswordStrengthErrorParser {
    constructor(descriptionMap) {
        const rules = descriptionMap[PasswordStrengthErrorParser.KEY_RULES];
        this.parseRules(rules);
    }
    getDescription() {
        return this.description;
    }
    parseRules(rules) {
        const items = [];
        for (const rule of rules) {
            const isVerified = rule[PasswordStrengthErrorParser.KEY_VERIFIED];
            if (isVerified) {
                continue;
            }
            const code = rule[PasswordStrengthErrorParser.KEY_CODE];
            switch (code) {
                case PasswordStrengthErrorParser.RULE_TYPE_LENGTH_AT_LEAST:
                    items.push(this.asLengthAtLeast(rule));
                    break;
                case PasswordStrengthErrorParser.RULE_TYPE_IDENTICAL_CHARS:
                    items.push(this.asIdenticalChars(rule));
                    break;
                case PasswordStrengthErrorParser.RULE_TYPE_CONTAINS_AT_LEAST:
                case PasswordStrengthErrorParser.RULE_TYPE_SHOULD_CONTAIN:
                    items.push(this.asContainsCharset(rule));
                    break;
            }
        }
        this.description = items.join('; ');
    }
    asLengthAtLeast(rule) {
        const length = rule[PasswordStrengthErrorParser.KEY_FORMAT];
        const message = rule[PasswordStrengthErrorParser.KEY_MESSAGE];
        return java.lang.String.format(message, [length[0]]);
    }
    asContainsCharset(rule) {
        const itemsList = rule[PasswordStrengthErrorParser.KEY_ITEMS];
        const items = [];
        for (const i of itemsList) {
            items.push(i[PasswordStrengthErrorParser.KEY_MESSAGE]);
        }
        const requiredItems = items.join(', ');
        let message = rule[PasswordStrengthErrorParser.KEY_MESSAGE];
        if (rule.containsKey(PasswordStrengthErrorParser.KEY_FORMAT)) {
            const quantity = rule[PasswordStrengthErrorParser.KEY_FORMAT];
            message = java.lang.String.format(message, [quantity[0], quantity[1]]);
        }
        return java.lang.String.format(message, [requiredItems]);
    }
    asIdenticalChars(rule) {
        const example = rule[PasswordStrengthErrorParser.KEY_FORMAT];
        const count = example[0];
        const message = rule[PasswordStrengthErrorParser.KEY_MESSAGE];
        return java.lang.String.format(message, [count, example[1]]);
    }
}
PasswordStrengthErrorParser.RULE_TYPE_LENGTH_AT_LEAST = "lengthAtLeast";
PasswordStrengthErrorParser.RULE_TYPE_CONTAINS_AT_LEAST = "containsAtLeast";
PasswordStrengthErrorParser.RULE_TYPE_SHOULD_CONTAIN = "shouldContain";
PasswordStrengthErrorParser.RULE_TYPE_IDENTICAL_CHARS = "identicalChars";
PasswordStrengthErrorParser.KEY_RULES = "rules";
PasswordStrengthErrorParser.KEY_CODE = "code";
PasswordStrengthErrorParser.KEY_VERIFIED = "verified";
PasswordStrengthErrorParser.KEY_FORMAT = "format";
PasswordStrengthErrorParser.KEY_ITEMS = "items";
PasswordStrengthErrorParser.KEY_MESSAGE = "message";
//# sourceMappingURL=passwordStrengthErrorParser.js.map