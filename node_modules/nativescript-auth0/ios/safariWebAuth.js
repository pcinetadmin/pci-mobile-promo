import { Device } from '@nativescript/core';
import { ControllerModalPresenter } from './controllerModalPresenter';
import { ResponseType } from './responseType';
import { Telemetry } from './telemetry';
import { TransactionStore } from './transactionStore';
import { WebAuth } from './webAuth';
import { a0_encodeBase64URLSafe, invokeOnRunLoop, jsArrayToNSArray, nsArrayToJSArray } from './utils';
import { WebAuthError } from './webAuthError';
import { SafariAuthenticationSession } from './safariAuthenticationSession';
import { SafariSession } from './safariSession';
import { PKCE, ImplicitGrant } from './oauth2Grant';
import { SafariAuthenticationSessionCallback } from './safariAuthenticationSessionCallback';
import { SilentSafariViewController } from './silentSafariViewController';
import { Auth0Authentication } from './auth0Authentication';
export class SafariWebAuth extends WebAuth {
    constructor(clientId, url, presenter, storage, telemetry) {
        super();
        this.parameters = {};
        this.universalLink = false;
        this.responseType = [ResponseType.code];
        this.authenticationSession = true;
        this.clientId = clientId;
        this.url = url;
        this.presenter = presenter;
        this.storage = storage;
        this.telemetry = telemetry;
    }
    static init(clientId, url, presenter = new ControllerModalPresenter(), telemetry = new Telemetry()) {
        return new SafariWebAuth(clientId, url, presenter, TransactionStore.shared, telemetry);
    }
    useUniversalLink() {
        this.universalLink = true;
        return this;
    }
    setConnection(connection) {
        this.parameters["connection"] = connection;
        return this;
    }
    setScope(scope) {
        this.parameters["scope"] = scope;
        return this;
    }
    setConnectionScope(connectionScope) {
        this.parameters["connection_scope"] = connectionScope;
        return this;
    }
    setState(state) {
        this.parameters["state"] = state;
        return this;
    }
    setParameters(parameters) {
        for (const key in parameters) {
            this.parameters[key] = parameters[key];
        }
        return this;
    }
    setResponseType(responseType) {
        this.responseType = responseType;
        return this;
    }
    setNonce(nonce) {
        this.nonce = nonce;
        return this;
    }
    usingImplicitGrant() {
        return this.setResponseType([ResponseType.token]);
    }
    setAudience(audience) {
        this.parameters["audience"] = audience;
        return this;
    }
    useLegacyAuthentication() {
        this.authenticationSession = false;
        return this;
    }
    start(callback) {
        const redirectURL = this.redirectURL;
        if (redirectURL == null || redirectURL.absoluteString.startsWith(SafariWebAuth.NoBundleIdentifier)) {
            return callback({
                failure: WebAuthError.noBundleIdentifierFound
            });
        }
        if (this.responseType.indexOf(ResponseType.idToken) > -1) {
            if (this.nonce == null) {
                return callback({
                    failure: WebAuthError.noNonceProvided
                });
            }
        }
        let handler = this.handler(redirectURL);
        let state = this.parameters["state"] || generateDefaultState();
        let authorizeURL = this.buildAuthorizeURL(redirectURL, handler.defaults, state);
        if (Number(Device.osVersion.split('.')[0]) >= 11.0 && this.authenticationSession) {
            let session = new SafariAuthenticationSession(authorizeURL, redirectURL, state, handler, callback, this.logger);
            if (this.logger != null) {
                this.logger.trace(authorizeURL, "SafariAuthenticationSession");
            }
            this.storage.store(session);
        }
        else {
            const { controller, finish } = this.newSafari(authorizeURL, callback);
            const session = new SafariSession(controller, redirectURL, state, handler, finish, this.logger);
            this.presenter.present(controller);
            if (this.logger != null) {
                this.logger.trace(authorizeURL, "Safari");
            }
            this.storage.store(session);
        }
    }
    newSafari(authorizeURL, callback) {
        let controller = new SFSafariViewController({ URL: authorizeURL });
        let finish = (result) => {
            const presenting = (controller != null) ? controller.presentingViewController : undefined;
            if (presenting == null) {
                return callback({
                    failure: WebAuthError.cannotDismissWebAuthController
                });
            }
            if (result.failure != null && result.failure === WebAuthError.userCancelled) {
                invokeOnRunLoop(() => {
                    callback(result);
                });
            }
            else {
                invokeOnRunLoop(() => {
                    presenting.dismissViewControllerAnimatedCompletion(true, () => {
                        callback(result);
                    });
                });
            }
        };
        return { controller, finish };
    }
    buildAuthorizeURL(redirectURL, defaults, state) {
        const authorize = new NSURL({ string: "/authorize", relativeToURL: this.url });
        let components = new NSURLComponents({ URL: authorize, resolvingAgainstBaseURL: true });
        let items = [];
        let entries = defaults;
        entries["client_id"] = this.clientId;
        entries["redirect_uri"] = redirectURL.absoluteString;
        entries["scope"] = "openid";
        entries["state"] = state;
        entries["response_type"] = this.responseType.map((x) => x.label).join(" ");
        if (this.responseType.indexOf(ResponseType.idToken) > -1) {
            entries["nonce"] = this.nonce;
        }
        for (const key in this.parameters) {
            entries[key] = this.parameters[key];
        }
        for (const key in entries) {
            items.push(new NSURLQueryItem({ name: key, value: entries[key] }));
        }
        components.queryItems = jsArrayToNSArray(this.telemetry.queryItemsWithTelemetry(items));
        return components.URL;
    }
    handler(redirectURL) {
        if (this.responseType.indexOf(ResponseType.code) > -1) {
            const authentication = new Auth0Authentication(this.clientId, this.url, this.telemetry);
            authentication.logger = this.logger;
            return PKCE.init(authentication, redirectURL, this.responseType, this.nonce);
        }
        else {
            return new ImplicitGrant(this.responseType, this.nonce);
        }
    }
    get redirectURL() {
        const bundleIdentifier = NSBundle.mainBundle.bundleIdentifier || SafariWebAuth.NoBundleIdentifier;
        const components = new NSURLComponents({ URL: this.url, resolvingAgainstBaseURL: true });
        if (components != null && components.URL != null) {
            components.scheme = this.universalLink ? "https" : bundleIdentifier;
            return components.URL
                .URLByAppendingPathComponent("ios")
                .URLByAppendingPathComponent(bundleIdentifier)
                .URLByAppendingPathComponent("callback");
        }
        else {
            return undefined;
        }
    }
    clearSession(federated, callback) {
        const logoutURL = federated
            ? new NSURL({ string: "/v2/logout?federated", relativeToURL: this.url })
            : new NSURL({ string: "/v2/logout", relativeToURL: this.url });
        if (Number(Device.osVersion.split('.')[0]) >= 11.0 && this.authenticationSession) {
            const returnTo = new NSURLQueryItem({ name: "returnTo", value: (this.redirectURL != null) ? this.redirectURL.absoluteString : undefined });
            const clientId = new NSURLQueryItem({ name: "client_id", value: this.clientId });
            const components = new NSURLComponents({ URL: logoutURL, resolvingAgainstBaseURL: true });
            const queryItems = (components.queryItems != null) ? nsArrayToJSArray(components.queryItems) : [];
            components.queryItems = jsArrayToNSArray([...queryItems, returnTo, clientId]);
            const clearSessionURL = components.URL;
            const redirectURL = returnTo.value;
            if (clearSessionURL == null || redirectURL == null) {
                return callback(false);
            }
            const clearSession = new SafariAuthenticationSessionCallback(clearSessionURL, redirectURL, callback);
            this.storage.store(clearSession);
        }
        else {
            let controller = SilentSafariViewController.alloc().initWithURLCallback(logoutURL, (result) => callback(result));
            if (this.logger != null) {
                this.logger.trace(logoutURL, "Safari");
            }
            this.presenter.present(controller);
        }
    }
}
SafariWebAuth.NoBundleIdentifier = 'com.auth0.this-is-no-bundle';
function generateDefaultState() {
    let data = new NSMutableData({ length: 32 });
    const result = SecRandomCopyBytes(kSecRandomDefault, data.length, data.mutableBytes);
    if (result !== 0) {
        return undefined;
    }
    return a0_encodeBase64URLSafe(data);
}
//# sourceMappingURL=safariWebAuth.js.map