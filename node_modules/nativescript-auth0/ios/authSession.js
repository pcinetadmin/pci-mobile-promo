import { AuthenticationError } from './authenticationError';
import { WebAuthError } from './webAuthError';
export class AuthSession {
    constructor(redirectURL, state = undefined, handler, finish, logger) {
        this.redirectURL = redirectURL;
        this.state = state;
        this.finish = finish;
        this.handler = handler;
        this.logger = logger;
    }
    /**
     Tries to resume (and complete) the OAuth2 session from the received URL

     - parameter url:     url received in application's AppDelegate
     - parameter options: a dictionary of launch options received from application's AppDelegate

     - returns: `true` if the url completed (successfuly or not) this session, `false` otherwise
     */
    resume(url, options = NSDictionary.alloc()) {
        if (this.logger != null) {
            this.logger.trace(url, "iOS Safari");
        }
        const hasPrefix = url.absoluteString.toLowerCase().startsWith(this.redirectURL.absoluteString.toLowerCase());
        if (hasPrefix === false) {
            return false;
        }
        const components = new NSURLComponents({ URL: url, resolvingAgainstBaseURL: true });
        if (components == null) {
            this.finish({
                failure: new AuthenticationError(url.absoluteString, 200)
            });
            return false;
        }
        let items = this.handler.values(components);
        const has = this.has(this.state, items);
        if (has === false) {
            return false;
        }
        if (items["error"] != null) {
            this.finish({
                failure: new AuthenticationError(items, 0)
            });
        }
        else {
            this.handler.credentials(items, this.finish);
        }
        return true;
    }
    cancel() {
        this.finish({
            failure: WebAuthError.userCancelled
        });
    }
    has(state, items) {
        return state === null || items["state"] === state;
    }
}
//# sourceMappingURL=authSession.js.map