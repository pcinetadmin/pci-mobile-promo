import { Authentication } from './authentication';
import { Telemetry } from './telemetry';
import { Credentials } from '../common/credentials';
import { AuthenticationError } from './authenticationError';
import { Request } from './request';
import { authenticationObject, noBody } from './handlers';
import { UserInfo } from '../common/userInfo';
import { SafariWebAuth } from './safariWebAuth';
import { ControllerModalPresenter } from './controllerModalPresenter';
import { LoggableExtension } from './loggable';
import { DatabaseUser } from '../common/databaseUser';
export class Auth0Authentication extends Authentication {
    constructor(clientId, url, telemetry = new Telemetry()) {
        super();
        this.clientId = clientId;
        this.url = url;
        this.telemetry = telemetry;
    }
    login(username, password, realm, audience, scope, parameters) {
        let resourceOwner = new NSURL({ string: "/oauth/token", relativeToURL: this.url });
        const payload = {
            "username": username,
            "password": password,
            "grant_type": "http://auth0.com/oauth/grant-type/password-realm",
            "client_id": this.clientId,
            "realm": realm
        };
        payload["audience"] = audience;
        payload["scope"] = scope;
        if (parameters != null) {
            for (const key in parameters) {
                payload[key] = parameters[key];
            }
        }
        return new Request(resourceOwner, "POST", authenticationObject(Credentials), payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    loginWithOTP(otp, mfaToken) {
        const url = new NSURL({ string: "/oauth/token", relativeToURL: this.url });
        const payload = {
            "otp": otp,
            "mfa_token": mfaToken,
            "grant_type": "http://auth0.com/oauth/grant-type/mfa-otp",
            "client_id": this.clientId
        };
        return new Request(url, "POST", authenticationObject(Credentials), payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    createUser(email, username = undefined, password, connection, userMetadata = undefined) {
        const payload = {
            "email": email,
            "password": password,
            "connection": connection,
            "client_id": this.clientId
        };
        payload["username"] = username;
        payload["user_metadata"] = userMetadata;
        const createUser = new NSURL({ string: "/dbconnections/signup", relativeToURL: this.url });
        return new Request(createUser, "POST", authenticationObject(DatabaseUser), payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    resetPassword(email, connection) {
        const payload = {
            "email": email,
            "connection": connection,
            "client_id": this.clientId
        };
        const resetPassword = new NSURL({ string: "/dbconnections/change_password", relativeToURL: this.url });
        return new Request(resetPassword, "POST", noBody, payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    userInfo(accessToken) {
        let userInfo = new NSURL({ string: "/userinfo", relativeToURL: this.url });
        return new Request(userInfo, "GET", authenticationObject(UserInfo), {}, { "Authorization": `Bearer ${accessToken}` }, this.logger, this.telemetry, AuthenticationError);
    }
    tokenExchangeWithParameters(parameters) {
        const payload = {
            "client_id": this.clientId
        };
        for (const key in parameters) {
            payload[key] = parameters[key];
        }
        let token = new NSURL({ string: "/oauth/token", relativeToURL: this.url });
        return new Request(token, "POST", authenticationObject(Credentials), payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    tokenExchangeWithCode(code, codeVerifier, redirectURI) {
        return this.tokenExchangeWithParameters({
            "code": code,
            "code_verifier": codeVerifier,
            "redirect_uri": redirectURI,
            "grant_type": "authorization_code"
        });
    }
    renew(refreshToken) {
        const payload = {
            "refresh_token": refreshToken,
            "grant_type": "refresh_token",
            "client_id": this.clientId
        };
        let oauthToken = new NSURL({ string: "/oauth/token", relativeToURL: this.url });
        return new Request(oauthToken, "POST", authenticationObject(Credentials), payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    revoke(refreshToken) {
        let payload = {
            "token": refreshToken,
            "client_id": this.clientId
        };
        let oauthToken = new NSURL({ string: "/oauth/revoke", relativeToURL: this.url });
        return new Request(oauthToken, "POST", noBody, payload, {}, this.logger, this.telemetry, AuthenticationError);
    }
    webAuth(connection) {
        const safari = SafariWebAuth.init(this.clientId, this.url, new ControllerModalPresenter(), this.telemetry);
        LoggableExtension.logging(safari, this.logger != null);
        return safari.setConnection(connection);
    }
}
//# sourceMappingURL=auth0Authentication.js.map