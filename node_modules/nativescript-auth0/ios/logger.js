import { HttpResponseEncoding } from '@nativescript/core/http';
class DefaultOutput {
    log(message) { console.log(message); }
    newLine() { console.log(''); }
}
export class DefaultLogger {
    constructor(output = new DefaultOutput()) {
        this.output = output;
    }
    trace() {
        if (arguments[0] instanceof NSURL) {
            this.traceUrl(arguments[0], arguments[1]);
        }
        else if (arguments[0].url != null) {
            this.traceRequest(arguments[0]);
        }
        {
            this.traceResponse(arguments[0]);
        }
    }
    traceRequest(request) {
        const method = request.method;
        const url = request.url;
        if (method == null || url == null) {
            return;
        }
        this.output.log(`${method} ${url} HTTP/1.1`);
        const headerFields = request.headers;
        if (headerFields != null) {
            for (const key in headerFields) {
                this.output.log(`${key}: ${headerFields[key]}`);
            }
        }
        const data = request.content;
        if (data != null) {
            this.output.newLine();
            this.output.log(String(data));
        }
        this.output.newLine();
    }
    traceResponse(response) {
        this.output.log(`HTTP/1.1 ${response.statusCode}`);
        for (const key in response.headers) {
            this.output.log(`${key}: ${response.headers[key]}`);
        }
        if (response.content.toString(HttpResponseEncoding.UTF8) != null) {
            const _string = response.content.toString(HttpResponseEncoding.UTF8);
            if (_string != null) {
                this.output.newLine();
                this.output.log(_string);
            }
        }
        this.output.newLine();
    }
    traceUrl(url, source) {
        this.output.log(`${source || 'URL'}: ${url.absoluteString}`);
    }
}
//# sourceMappingURL=logger.js.map