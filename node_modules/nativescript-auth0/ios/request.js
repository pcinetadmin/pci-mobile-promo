import { request as httpRequest } from '@nativescript/core/http';
import { Response } from './response';
/**
 Auth0 API request

 ```
 let request: Request<Credentials, Authentication.Error> = //
 request.start { result in
    //handle result
 }
 ```
 */
export class Request {
    constructor(url, method, handle, payload = {}, headers = {}, logger, telemetry, EClass) {
        this.url = url;
        this.method = method;
        this.handle = handle;
        this.payload = payload;
        this.headers = headers;
        this.logger = logger;
        this.telemetry = telemetry;
        this.EClass = EClass;
    }
    get request() {
        const request = {
            url: this.url.absoluteString,
            method: this.method,
            headers: {
                'Content-Type': 'application/json'
            },
        };
        if (Object.keys(this.payload).length > 0) {
            request.content = JSON.stringify(this.payload);
        }
        for (const key in this.headers) {
            request.headers[key] = this.headers[key];
        }
        this.telemetry.addTelemetryHeader(request);
        return request;
    }
    /**
     Starts the request to the server

     - parameter callback: called when the request finishes and yield it's result
     */
    start(callback) {
        const handler = this.handle;
        const request = this.request;
        const logger = this.logger;
        if (logger != null) {
            logger.trace(request);
        }
        httpRequest(request).then((response) => {
            if (logger != null) {
                logger.trace(response);
            }
            handler(new Response(response.content, request, response, undefined, this.EClass), callback);
        }).catch((error) => {
            handler(new Response(undefined, request, undefined, error, this.EClass), callback);
        });
    }
}
/**
 *  A concatenated request, if the first one fails it will yield it's error, otherwise it will return the last request outcome
 */
export class ConcatRequest {
    /**
     Starts the request to the server

     - parameter callback: called when the request finishes and yield it's result
     */
    start(callback) {
        const second = this.second;
        this.first.start((result) => {
            if (result.failure) {
                callback({
                    failure: result.failure
                });
            }
            else if (result.success) {
                second.start(callback);
            }
        });
    }
}
//# sourceMappingURL=request.js.map