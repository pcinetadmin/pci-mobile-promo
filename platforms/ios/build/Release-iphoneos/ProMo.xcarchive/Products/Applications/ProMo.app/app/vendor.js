(global["webpackJsonp"] = global["webpackJsonp"] || []).push([[1],[
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Trace; });
let enabled = false;
let _categories = {};
let _writers = [];
let _eventListeners = [];
let _errorHandler;
var Trace;
(function (Trace) {
    /**
     * Enables the trace module.
     */
    function enable() {
        enabled = true;
    }
    Trace.enable = enable;
    /**
     * Disables the trace module.
     */
    function disable() {
        enabled = false;
    }
    Trace.disable = disable;
    /**
     * A function that returns whether the tracer is enabled and there is a point in writing messages.
     * Check this to avoid writing complex string templates.
     * Send error messages even if tracing is disabled.
     */
    function isEnabled() {
        return enabled;
    }
    Trace.isEnabled = isEnabled;
    /**
     * Adds a TraceWriter instance to the trace module.
     * @param writer The TraceWriter instance to add.
     */
    function addWriter(writer) {
        _writers.push(writer);
    }
    Trace.addWriter = addWriter;
    /**
     * Removes a TraceWriter instance from the trace module.
     * @param writer The TraceWriter instance to remove.
     */
    function removeWriter(writer) {
        let index = _writers.indexOf(writer);
        if (index >= 0) {
            _writers.splice(index, 1);
        }
    }
    Trace.removeWriter = removeWriter;
    /**
     * Clears all the writers from the trace module.
     */
    function clearWriters() {
        if (_writers.length > 0) {
            _writers.splice(0, _writers.length);
        }
    }
    Trace.clearWriters = clearWriters;
    /**
     * Sets the categories the module will trace.
     * @param categories The comma-separated list of categories. If not specified all messages from all categories will be traced.
     */
    function setCategories(categories) {
        _categories = {};
        addCategories(categories);
    }
    Trace.setCategories = setCategories;
    /**
     * Adds categories to existing categories the module will trace.
     * @param categories The comma-separated list of categories. If not specified all messages from all categories will be traced.
     */
    function addCategories(categories) {
        let split = categories.split(',');
        for (let i = 0; i < split.length; i++) {
            _categories[split[i].trim()] = true;
        }
    }
    Trace.addCategories = addCategories;
    /**
     * Check if category is already set in trace module.
     * @param category The category to check.
     */
    function isCategorySet(category) {
        return category in _categories;
    }
    Trace.isCategorySet = isCategorySet;
    /**
     * Writes a message using the available writers.
     * @param message The message to be written.
     * @param category The category of the message.
     * @param type Optional, the type of the message - info, warning, error.
     */
    function write(message, category, type) {
        // print error no matter what
        let i;
        if (type === messageType.error) {
            for (i = 0; i < _writers.length; i++) {
                _writers[i].write(message, category, type);
            }
            return;
        }
        if (!enabled) {
            return;
        }
        if (!(category in _categories)) {
            return;
        }
        for (i = 0; i < _writers.length; i++) {
            _writers[i].write(message, category, type);
        }
    }
    Trace.write = write;
    /**
     * Notifies all the attached listeners for an event that has occurred in the sender object.
     * @param object The Object instance that raised the event.
     * @param name The name of the raised event.
     * @param data An optional parameter that passes the data associated with the event.
     */
    function notifyEvent(object, name, data) {
        if (!enabled) {
            return;
        }
        let i, listener, filters;
        for (i = 0; i < _eventListeners.length; i++) {
            listener = _eventListeners[i];
            if (listener.filter) {
                filters = listener.filter.split(',');
                filters.forEach((value) => {
                    if (value.trim() === name) {
                        listener.on(object, name, data);
                    }
                });
            }
            else {
                listener.on(object, name, data);
            }
        }
    }
    Trace.notifyEvent = notifyEvent;
    function addEventListener(listener) {
        _eventListeners.push(listener);
    }
    Trace.addEventListener = addEventListener;
    function removeEventListener(listener) {
        const index = _eventListeners.indexOf(listener);
        if (index >= 0) {
            _eventListeners.splice(index, 1);
        }
    }
    Trace.removeEventListener = removeEventListener;
    let messageType;
    (function (messageType) {
        messageType.log = 0;
        messageType.info = 1;
        messageType.warn = 2;
        messageType.error = 3;
    })(messageType = Trace.messageType || (Trace.messageType = {}));
    /**
     * all predefined categories.
     */
    let categories;
    (function (categories) {
        categories.VisualTreeEvents = 'VisualTreeEvents';
        categories.Layout = 'Layout';
        categories.Style = 'Style';
        categories.ViewHierarchy = 'ViewHierarchy';
        categories.NativeLifecycle = 'NativeLifecycle';
        categories.Debug = 'Debug';
        categories.Navigation = 'Navigation';
        categories.Test = 'Test';
        categories.Binding = 'Binding';
        categories.BindingError = 'BindingError';
        categories.Error = 'Error';
        categories.Animation = 'Animation';
        categories.Transition = 'Transition';
        categories.Livesync = 'Livesync';
        categories.ModuleNameResolver = 'ModuleNameResolver';
        categories.separator = ',';
        categories.All = [categories.VisualTreeEvents, categories.Layout, categories.Style, categories.ViewHierarchy, categories.NativeLifecycle, categories.Debug, categories.Navigation, categories.Test, categories.Binding, categories.Error, categories.Animation, categories.Transition, categories.Livesync, categories.ModuleNameResolver].join(categories.separator);
        function concat(...args) {
            let result;
            for (let i = 0; i < arguments.length; i++) {
                if (!result) {
                    result = arguments[i];
                    continue;
                }
                result = result.concat(categories.separator, arguments[i]);
            }
            return result;
        }
        categories.concat = concat;
    })(categories = Trace.categories || (Trace.categories = {}));
    class ConsoleWriter {
        write(message, category, type) {
            if (!console) {
                return;
            }
            let msgType;
            if (type === undefined) {
                msgType = messageType.log;
            }
            else {
                msgType = type;
            }
            switch (msgType) {
                case messageType.log:
                    console.log(category + ': ' + message);
                    break;
                case messageType.info:
                    console.info(category + ': ' + message);
                    break;
                case messageType.warn:
                    console.warn(category + ': ' + message);
                    break;
                case messageType.error:
                    console.error(category + ': ' + message);
                    break;
            }
        }
    }
    // register a ConsoleWriter by default
    addWriter(new ConsoleWriter());
    class DefaultErrorHandler {
        handlerError(error) {
            throw error;
        }
    }
    Trace.DefaultErrorHandler = DefaultErrorHandler;
    setErrorHandler(new DefaultErrorHandler());
    function getErrorHandler() {
        return _errorHandler;
    }
    Trace.getErrorHandler = getErrorHandler;
    function setErrorHandler(handler) {
        _errorHandler = handler;
    }
    Trace.setErrorHandler = setErrorHandler;
    /**
     * Passes an error to the registered ErrorHandler
     * @param error The error to be handled.
     */
    function error(error) {
        if (!_errorHandler) {
            return;
        }
        if (typeof error === 'string') {
            error = new Error(error);
        }
        _errorHandler.handlerError(error);
    }
    Trace.error = error;
})(Trace || (Trace = {}));
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsetValue", function() { return unsetValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_printUnregisteredProperties", function() { return _printUnregisteredProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getProperties", function() { return _getProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getStyleProperties", function() { return _getStyleProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCssVariable", function() { return isCssVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCssCalcExpression", function() { return isCssCalcExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCssVariableExpression", function() { return isCssVariableExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_evaluateCssVariableExpression", function() { return _evaluateCssVariableExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_evaluateCssCalcExpression", function() { return _evaluateCssCalcExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Property", function() { return Property; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoercibleProperty", function() { return CoercibleProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InheritedProperty", function() { return InheritedProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CssProperty", function() { return CssProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CssAnimationProperty", function() { return CssAnimationProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InheritedCssProperty", function() { return InheritedCssProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShorthandProperty", function() { return ShorthandProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initNativeView", function() { return initNativeView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPendingNativeSetters", function() { return applyPendingNativeSetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyAllNativeSetters", function() { return applyAllNativeSetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetNativeView", function() { return resetNativeView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearInheritedProperties", function() { return clearInheritedProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetCSSProperties", function() { return resetCSSProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagateInheritableProperties", function() { return propagateInheritableProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagateInheritableCssProperties", function() { return propagateInheritableCssProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeValidator", function() { return makeValidator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeParser", function() { return makeParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSetProperties", function() { return getSetProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComputedCssValues", function() { return getComputedCssValues; });
/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(283);
/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(reduce_css_calc__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);

// Types.



/**
 * Value specifing that Property should be set to its initial value.
 */
const unsetValue = new Object();
let cssPropertyNames = [];
let symbolPropertyMap = {};
let cssSymbolPropertyMap = {};
let inheritableProperties = new Array();
let inheritableCssProperties = new Array();
function print(map) {
    let symbols = Object.getOwnPropertySymbols(map);
    for (let symbol of symbols) {
        const prop = map[symbol];
        if (!prop.registered) {
            console.log(`Property ${prop.name} not Registered!!!!!`);
        }
    }
}
function _printUnregisteredProperties() {
    print(symbolPropertyMap);
    print(cssSymbolPropertyMap);
}
function _getProperties() {
    return getPropertiesFromMap(symbolPropertyMap);
}
function _getStyleProperties() {
    return getPropertiesFromMap(cssSymbolPropertyMap);
}
function isCssVariable(property) {
    return /^--[^,\s]+?$/.test(property);
}
function isCssCalcExpression(value) {
    return value.includes('calc(');
}
function isCssVariableExpression(value) {
    return value.includes('var(--');
}
function _evaluateCssVariableExpression(view, cssName, value) {
    if (typeof value !== 'string') {
        return value;
    }
    if (!isCssVariableExpression(value)) {
        // Value is not using css-variable(s)
        return value;
    }
    let output = value.trim();
    // Evaluate every (and nested) css-variables in the value.
    let lastValue;
    while (lastValue !== output) {
        lastValue = output;
        const idx = output.lastIndexOf('var(');
        if (idx === -1) {
            continue;
        }
        const endIdx = output.indexOf(')', idx);
        if (endIdx === -1) {
            continue;
        }
        const matched = output
            .substring(idx + 4, endIdx)
            .split(',')
            .map((v) => v.trim())
            .filter((v) => !!v);
        const cssVariableName = matched.shift();
        let cssVariableValue = view.style.getCssVariable(cssVariableName);
        if (cssVariableValue === null && matched.length) {
            cssVariableValue = _evaluateCssVariableExpression(view, cssName, matched.join(', ')).split(',')[0];
        }
        if (!cssVariableValue) {
            cssVariableValue = 'unset';
        }
        output = `${output.substring(0, idx)}${cssVariableValue}${output.substring(endIdx + 1)}`;
    }
    return output;
}
function _evaluateCssCalcExpression(value) {
    if (typeof value !== 'string') {
        return value;
    }
    if (isCssCalcExpression(value)) {
        // WORKAROUND: reduce-css-calc can't handle the dip-unit.
        return reduce_css_calc__WEBPACK_IMPORTED_MODULE_0__(value.replace(/([0-9]+(\.[0-9]+)?)dip\b/g, '$1'));
    }
    else {
        return value;
    }
}
function getPropertiesFromMap(map) {
    const props = [];
    Object.getOwnPropertySymbols(map).forEach((symbol) => props.push(map[symbol]));
    return props;
}
class Property {
    constructor(options) {
        this.enumerable = true;
        this.configurable = true;
        const propertyName = options.name;
        this.name = propertyName;
        const key = Symbol(propertyName + ':propertyKey');
        this.key = key;
        const getDefault = Symbol(propertyName + ':getDefault');
        this.getDefault = getDefault;
        const setNative = Symbol(propertyName + ':setNative');
        this.setNative = setNative;
        const defaultValueKey = Symbol(propertyName + ':nativeDefaultValue');
        this.defaultValueKey = defaultValueKey;
        const defaultValue = options.defaultValue;
        this.defaultValue = defaultValue;
        const eventName = propertyName + 'Change';
        const equalityComparer = options.equalityComparer;
        const affectsLayout = options.affectsLayout;
        const valueChanged = options.valueChanged;
        const valueConverter = options.valueConverter;
        const property = this;
        this.set = function (boxedValue) {
            const reset = boxedValue === unsetValue;
            let value;
            let wrapped;
            if (reset) {
                value = defaultValue;
            }
            else {
                wrapped = boxedValue && boxedValue.wrapped;
                value = wrapped ? _data_observable__WEBPACK_IMPORTED_MODULE_1__["WrappedValue"].unwrap(boxedValue) : boxedValue;
                if (valueConverter && typeof value === 'string') {
                    value = valueConverter(value);
                }
            }
            const oldValue = key in this ? this[key] : defaultValue;
            const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (wrapped || changed) {
                if (affectsLayout) {
                    this.requestLayout();
                }
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                this[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                this[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = this[getDefault] ? this[getDefault]() : defaultValue;
                            }
                            this[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({
                        object: this,
                        eventName,
                        propertyName,
                        value,
                        oldValue,
                    });
                }
                if (this.domNode) {
                    if (reset) {
                        this.domNode.attributeRemoved(propertyName);
                    }
                    else {
                        this.domNode.attributeModified(propertyName, value);
                    }
                }
            }
        };
        this.get = function () {
            return key in this ? this[key] : defaultValue;
        };
        this.nativeValueChange = function (owner, value) {
            const oldValue = key in owner ? owner[key] : defaultValue;
            const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                owner[key] = value;
                if (valueChanged) {
                    valueChanged(owner, oldValue, value);
                }
                if (owner.nativeViewProtected && !(defaultValueKey in owner)) {
                    owner[defaultValueKey] = owner[getDefault] ? owner[getDefault]() : defaultValue;
                }
                if (owner.hasListeners(eventName)) {
                    owner.notify({
                        object: owner,
                        eventName,
                        propertyName,
                        value,
                        oldValue,
                    });
                }
                if (affectsLayout) {
                    owner.requestLayout();
                }
                if (owner.domNode) {
                    owner.domNode.attributeModified(propertyName, value);
                }
            }
        };
        symbolPropertyMap[key] = this;
    }
    register(cls) {
        if (this.registered) {
            throw new Error(`Property ${this.name} already registered.`);
        }
        this.registered = true;
        Object.defineProperty(cls.prototype, this.name, this);
    }
    isSet(instance) {
        return this.key in instance;
    }
}
Property.prototype.isStyleProperty = false;
class CoercibleProperty extends Property {
    constructor(options) {
        super(options);
        const propertyName = options.name;
        const key = this.key;
        const getDefault = this.getDefault;
        const setNative = this.setNative;
        const defaultValueKey = this.defaultValueKey;
        const defaultValue = this.defaultValue;
        const coerceKey = Symbol(propertyName + ':coerceKey');
        const eventName = propertyName + 'Change';
        const affectsLayout = options.affectsLayout;
        const equalityComparer = options.equalityComparer;
        const valueChanged = options.valueChanged;
        const valueConverter = options.valueConverter;
        const coerceCallback = options.coerceValue;
        const property = this;
        this.coerce = function (target) {
            const originalValue = coerceKey in target ? target[coerceKey] : defaultValue;
            // need that to make coercing but also fire change events
            target[propertyName] = originalValue;
        };
        this.set = function (boxedValue) {
            const reset = boxedValue === unsetValue;
            let value;
            let wrapped;
            if (reset) {
                value = defaultValue;
                delete this[coerceKey];
            }
            else {
                wrapped = boxedValue && boxedValue.wrapped;
                value = wrapped ? _data_observable__WEBPACK_IMPORTED_MODULE_1__["WrappedValue"].unwrap(boxedValue) : boxedValue;
                if (valueConverter && typeof value === 'string') {
                    value = valueConverter(value);
                }
                this[coerceKey] = value;
                value = coerceCallback(this, value);
            }
            const oldValue = key in this ? this[key] : defaultValue;
            const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (wrapped || changed) {
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                this[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                this[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = this[getDefault] ? this[getDefault]() : defaultValue;
                            }
                            this[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({
                        object: this,
                        eventName,
                        propertyName,
                        value,
                        oldValue,
                    });
                }
                if (affectsLayout) {
                    this.requestLayout();
                }
                if (this.domNode) {
                    if (reset) {
                        this.domNode.attributeRemoved(propertyName);
                    }
                    else {
                        this.domNode.attributeModified(propertyName, value);
                    }
                }
            }
        };
    }
}
class InheritedProperty extends Property {
    constructor(options) {
        super(options);
        const name = options.name;
        const key = this.key;
        const defaultValue = options.defaultValue;
        const sourceKey = Symbol(name + ':valueSourceKey');
        this.sourceKey = sourceKey;
        const setBase = this.set;
        const setFunc = (valueSource) => function (value) {
            const that = this;
            let unboxedValue;
            let newValueSource;
            if (value === unsetValue) {
                // If unsetValue - we want to reset the property.
                const parent = that.parent;
                // If we have parent and it has non-default value we use as our inherited value.
                if (parent && parent[sourceKey] !== 0 /* Default */) {
                    unboxedValue = parent[name];
                    newValueSource = 1 /* Inherited */;
                }
                else {
                    unboxedValue = defaultValue;
                    newValueSource = 0 /* Default */;
                }
            }
            else {
                // else we are set through property set.
                unboxedValue = value;
                newValueSource = valueSource;
            }
            // take currentValue before calling base - base may change it.
            const currentValue = that[key];
            setBase.call(that, unboxedValue);
            const newValue = that[key];
            that[sourceKey] = newValueSource;
            if (currentValue !== newValue) {
                const reset = newValueSource === 0 /* Default */;
                that.eachChild((child) => {
                    const childValueSource = child[sourceKey] || 0 /* Default */;
                    if (reset) {
                        if (childValueSource === 1 /* Inherited */) {
                            setFunc.call(child, unsetValue);
                        }
                    }
                    else {
                        if (childValueSource <= 1 /* Inherited */) {
                            setInheritedValue.call(child, newValue);
                        }
                    }
                    return true;
                });
            }
        };
        const setInheritedValue = setFunc(1 /* Inherited */);
        this.setInheritedValue = setInheritedValue;
        this.set = setFunc(3 /* Local */);
        inheritableProperties.push(this);
    }
}
class CssProperty {
    constructor(options) {
        const propertyName = options.name;
        this.name = propertyName;
        cssPropertyNames.push(options.cssName);
        this.cssName = `css:${options.cssName}`;
        this.cssLocalName = options.cssName;
        const key = Symbol(propertyName + ':propertyKey');
        this.key = key;
        const sourceKey = Symbol(propertyName + ':valueSourceKey');
        this.sourceKey = sourceKey;
        const getDefault = Symbol(propertyName + ':getDefault');
        this.getDefault = getDefault;
        const setNative = Symbol(propertyName + ':setNative');
        this.setNative = setNative;
        const defaultValueKey = Symbol(propertyName + ':nativeDefaultValue');
        this.defaultValueKey = defaultValueKey;
        const defaultValue = options.defaultValue;
        this.defaultValue = defaultValue;
        const eventName = propertyName + 'Change';
        const affectsLayout = options.affectsLayout;
        const equalityComparer = options.equalityComparer;
        const valueChanged = options.valueChanged;
        const valueConverter = options.valueConverter;
        const property = this;
        function setLocalValue(newValue) {
            const view = this.viewRef.get();
            if (!view) {
                _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`${newValue} not set to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
                return;
            }
            const reset = newValue === unsetValue || newValue === '';
            let value;
            if (reset) {
                value = defaultValue;
                delete this[sourceKey];
            }
            else {
                this[sourceKey] = 3 /* Local */;
                value = valueConverter && typeof newValue === 'string' ? valueConverter(newValue) : newValue;
            }
            const oldValue = key in this ? this[key] : defaultValue;
            const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                view[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                view[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                            }
                            view[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({
                        object: this,
                        eventName,
                        propertyName,
                        value,
                        oldValue,
                    });
                }
                if (affectsLayout) {
                    view.requestLayout();
                }
            }
        }
        function setCssValue(newValue) {
            const view = this.viewRef.get();
            if (!view) {
                _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`${newValue} not set to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
                return;
            }
            const currentValueSource = this[sourceKey] || 0 /* Default */;
            // We have localValueSource - NOOP.
            if (currentValueSource === 3 /* Local */) {
                return;
            }
            const reset = newValue === unsetValue || newValue === '';
            let value;
            if (reset) {
                value = defaultValue;
                delete this[sourceKey];
            }
            else {
                value = valueConverter && typeof newValue === 'string' ? valueConverter(newValue) : newValue;
                this[sourceKey] = 2 /* Css */;
            }
            const oldValue = key in this ? this[key] : defaultValue;
            const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                view[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                view[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                            }
                            view[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({
                        object: this,
                        eventName,
                        propertyName,
                        value,
                        oldValue,
                    });
                }
                if (affectsLayout) {
                    view.requestLayout();
                }
            }
        }
        function get() {
            return key in this ? this[key] : defaultValue;
        }
        this.cssValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: get,
            set: setCssValue,
        };
        this.localValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: get,
            set: setLocalValue,
        };
        cssSymbolPropertyMap[key] = this;
    }
    register(cls) {
        if (this.registered) {
            throw new Error(`Property ${this.name} already registered.`);
        }
        this.registered = true;
        Object.defineProperty(cls.prototype, this.name, this.localValueDescriptor);
        Object.defineProperty(cls.prototype, this.cssName, this.cssValueDescriptor);
        if (this.cssLocalName !== this.cssName) {
            Object.defineProperty(cls.prototype, this.cssLocalName, this.localValueDescriptor);
        }
    }
    isSet(instance) {
        return this.key in instance;
    }
}
CssProperty.prototype.isStyleProperty = true;
class CssAnimationProperty {
    constructor(options) {
        const propertyName = options.name;
        this.name = propertyName;
        cssPropertyNames.push(options.cssName);
        CssAnimationProperty.properties[propertyName] = this;
        if (options.cssName && options.cssName !== propertyName) {
            CssAnimationProperty.properties[options.cssName] = this;
        }
        this._valueConverter = options.valueConverter;
        const cssLocalName = options.cssName || propertyName;
        this.cssLocalName = cssLocalName;
        const cssName = 'css:' + cssLocalName;
        this.cssName = cssName;
        const keyframeName = 'keyframe:' + propertyName;
        this.keyframe = keyframeName;
        const defaultName = 'default:' + propertyName;
        const defaultValueKey = Symbol(defaultName);
        this.defaultValueKey = defaultValueKey;
        this.defaultValue = options.defaultValue;
        const cssValue = Symbol(cssName);
        const styleValue = Symbol(`local:${propertyName}`);
        const keyframeValue = Symbol(keyframeName);
        const computedValue = Symbol('computed-value:' + propertyName);
        this.key = computedValue;
        const computedSource = Symbol('computed-source:' + propertyName);
        this.source = computedSource;
        this.getDefault = Symbol(propertyName + ':getDefault');
        const getDefault = this.getDefault;
        const setNative = (this.setNative = Symbol(propertyName + ':setNative'));
        const eventName = propertyName + 'Change';
        const property = this;
        function descriptor(symbol, propertySource, enumerable, configurable, getsComputed) {
            return {
                enumerable,
                configurable,
                get: getsComputed
                    ? function () {
                        return this[computedValue];
                    }
                    : function () {
                        return this[symbol];
                    },
                set(boxedValue) {
                    const view = this.viewRef.get();
                    if (!view) {
                        _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`${boxedValue} not set to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
                        return;
                    }
                    const oldValue = this[computedValue];
                    const oldSource = this[computedSource];
                    const wasSet = oldSource !== 0 /* Default */;
                    const reset = boxedValue === unsetValue || boxedValue === '';
                    if (reset) {
                        this[symbol] = unsetValue;
                        if (this[computedSource] === propertySource) {
                            // Fallback to lower value source.
                            if (this[styleValue] !== unsetValue) {
                                this[computedSource] = 3 /* Local */;
                                this[computedValue] = this[styleValue];
                            }
                            else if (this[cssValue] !== unsetValue) {
                                this[computedSource] = 2 /* Css */;
                                this[computedValue] = this[cssValue];
                            }
                            else {
                                delete this[computedSource];
                                delete this[computedValue];
                            }
                        }
                    }
                    else {
                        if (options.valueConverter && typeof boxedValue === 'string') {
                            boxedValue = options.valueConverter(boxedValue);
                        }
                        this[symbol] = boxedValue;
                        if (this[computedSource] <= propertySource) {
                            this[computedSource] = propertySource;
                            this[computedValue] = boxedValue;
                        }
                    }
                    const value = this[computedValue];
                    const source = this[computedSource];
                    const isSet = source !== 0 /* Default */;
                    const computedValueChanged = oldValue !== value && (!options.equalityComparer || !options.equalityComparer(oldValue, value));
                    if (computedValueChanged && options.valueChanged) {
                        options.valueChanged(this, oldValue, value);
                    }
                    if (view[setNative] && (computedValueChanged || isSet !== wasSet)) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (isSet) {
                                if (!wasSet && !(defaultValueKey in this)) {
                                    this[defaultValueKey] = view[getDefault] ? view[getDefault]() : options.defaultValue;
                                }
                                view[setNative](value);
                            }
                            else if (wasSet) {
                                if (defaultValueKey in this) {
                                    view[setNative](this[defaultValueKey]);
                                }
                                else {
                                    view[setNative](options.defaultValue);
                                }
                            }
                        }
                    }
                    if (computedValueChanged && this.hasListeners(eventName)) {
                        this.notify({
                            object: this,
                            eventName,
                            propertyName,
                            value,
                            oldValue,
                        });
                    }
                },
            };
        }
        const defaultPropertyDescriptor = descriptor(defaultValueKey, 0 /* Default */, false, false, false);
        const cssPropertyDescriptor = descriptor(cssValue, 2 /* Css */, false, false, false);
        const stylePropertyDescriptor = descriptor(styleValue, 3 /* Local */, true, true, true);
        const keyframePropertyDescriptor = descriptor(keyframeValue, 4 /* Keyframe */, false, false, false);
        symbolPropertyMap[computedValue] = this;
        cssSymbolPropertyMap[computedValue] = this;
        this.register = (cls) => {
            cls.prototype[computedValue] = options.defaultValue;
            cls.prototype[computedSource] = 0 /* Default */;
            cls.prototype[cssValue] = unsetValue;
            cls.prototype[styleValue] = unsetValue;
            cls.prototype[keyframeValue] = unsetValue;
            Object.defineProperty(cls.prototype, defaultName, defaultPropertyDescriptor);
            Object.defineProperty(cls.prototype, cssName, cssPropertyDescriptor);
            Object.defineProperty(cls.prototype, propertyName, stylePropertyDescriptor);
            if (options.cssName && options.cssName !== options.name) {
                Object.defineProperty(cls.prototype, options.cssName, stylePropertyDescriptor);
            }
            Object.defineProperty(cls.prototype, keyframeName, keyframePropertyDescriptor);
        };
    }
    _initDefaultNativeValue(target) {
        const view = target.viewRef.get();
        if (!view) {
            _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`_initDefaultNativeValue not executed to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
            return;
        }
        const defaultValueKey = this.defaultValueKey;
        if (!(defaultValueKey in target)) {
            const getDefault = this.getDefault;
            target[defaultValueKey] = view[getDefault] ? view[getDefault]() : this.defaultValue;
        }
    }
    static _getByCssName(name) {
        return this.properties[name];
    }
    static _getPropertyNames() {
        return Object.keys(CssAnimationProperty.properties);
    }
    isSet(instance) {
        return instance[this.source] !== 0 /* Default */;
    }
}
CssAnimationProperty.properties = {};
CssAnimationProperty.prototype.isStyleProperty = true;
class InheritedCssProperty extends CssProperty {
    constructor(options) {
        super(options);
        const propertyName = options.name;
        const key = this.key;
        const sourceKey = this.sourceKey;
        const getDefault = this.getDefault;
        const setNative = this.setNative;
        const defaultValueKey = this.defaultValueKey;
        const eventName = propertyName + 'Change';
        const defaultValue = options.defaultValue;
        const affectsLayout = options.affectsLayout;
        const equalityComparer = options.equalityComparer;
        const valueChanged = options.valueChanged;
        const valueConverter = options.valueConverter;
        const property = this;
        const setFunc = (valueSource) => function (boxedValue) {
            const view = this.viewRef.get();
            if (!view) {
                _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`${boxedValue} not set to view's property because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
                return;
            }
            const reset = boxedValue === unsetValue || boxedValue === '';
            const currentValueSource = this[sourceKey] || 0 /* Default */;
            if (reset) {
                // If we want to reset cssValue and we have localValue - return;
                if (valueSource === 2 /* Css */ && currentValueSource === 3 /* Local */) {
                    return;
                }
            }
            else {
                if (currentValueSource > valueSource) {
                    return;
                }
            }
            const oldValue = key in this ? this[key] : defaultValue;
            let value;
            let unsetNativeValue = false;
            if (reset) {
                // If unsetValue - we want to reset this property.
                let parent = view.parent;
                let style = parent ? parent.style : null;
                // If we have parent and it has non-default value we use as our inherited value.
                if (style && style[sourceKey] > 0 /* Default */) {
                    value = style[propertyName];
                    this[sourceKey] = 1 /* Inherited */;
                    this[key] = value;
                }
                else {
                    value = defaultValue;
                    delete this[sourceKey];
                    delete this[key];
                    unsetNativeValue = true;
                }
            }
            else {
                this[sourceKey] = valueSource;
                if (valueConverter && typeof boxedValue === 'string') {
                    value = valueConverter(boxedValue);
                }
                else {
                    value = boxedValue;
                }
                this[key] = value;
            }
            const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                if (valueChanged) {
                    valueChanged(this, oldValue, value);
                }
                if (view[setNative]) {
                    if (view._suspendNativeUpdatesCount) {
                        if (view._suspendedUpdates) {
                            view._suspendedUpdates[propertyName] = property;
                        }
                    }
                    else {
                        if (unsetNativeValue) {
                            if (defaultValueKey in this) {
                                view[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                view[setNative](defaultValue);
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                            }
                            view[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({
                        object: this,
                        eventName,
                        propertyName,
                        value,
                        oldValue,
                    });
                }
                if (affectsLayout) {
                    view.requestLayout();
                }
                view.eachChild((child) => {
                    const childStyle = child.style;
                    const childValueSource = childStyle[sourceKey] || 0 /* Default */;
                    if (reset) {
                        if (childValueSource === 1 /* Inherited */) {
                            setDefaultFunc.call(childStyle, unsetValue);
                        }
                    }
                    else {
                        if (childValueSource <= 1 /* Inherited */) {
                            setInheritedFunc.call(childStyle, value);
                        }
                    }
                    return true;
                });
            }
        };
        const setDefaultFunc = setFunc(0 /* Default */);
        const setInheritedFunc = setFunc(1 /* Inherited */);
        this.setInheritedValue = setInheritedFunc;
        this.cssValueDescriptor.set = setFunc(2 /* Css */);
        this.localValueDescriptor.set = setFunc(3 /* Local */);
        inheritableCssProperties.push(this);
    }
}
class ShorthandProperty {
    constructor(options) {
        this.name = options.name;
        const key = Symbol(this.name + ':propertyKey');
        this.key = key;
        this.cssName = `css:${options.cssName}`;
        this.cssLocalName = `${options.cssName}`;
        const converter = options.converter;
        function setLocalValue(value) {
            const view = this.viewRef.get();
            if (!view) {
                _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`setLocalValue not executed to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
                return;
            }
            view._batchUpdate(() => {
                for (let [p, v] of converter(value)) {
                    this[p.name] = v;
                }
            });
        }
        function setCssValue(value) {
            const view = this.viewRef.get();
            if (!view) {
                _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].write(`setCssValue not executed to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_2__[/* Trace */ "a"].messageType.warn);
                return;
            }
            view._batchUpdate(() => {
                for (let [p, v] of converter(value)) {
                    this[p.cssName] = v;
                }
            });
        }
        this.cssValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: options.getter,
            set: setCssValue,
        };
        this.localValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: options.getter,
            set: setLocalValue,
        };
        this.propertyBagDescriptor = {
            enumerable: false,
            configurable: true,
            set(value) {
                converter(value).forEach(([property, value]) => {
                    this[property.cssLocalName] = value;
                });
            },
        };
        cssSymbolPropertyMap[key] = this;
    }
    register(cls) {
        if (this.registered) {
            throw new Error(`Property ${this.name} already registered.`);
        }
        this.registered = true;
        Object.defineProperty(cls.prototype, this.name, this.localValueDescriptor);
        Object.defineProperty(cls.prototype, this.cssName, this.cssValueDescriptor);
        if (this.cssLocalName !== this.cssName) {
            Object.defineProperty(cls.prototype, this.cssLocalName, this.localValueDescriptor);
        }
        Object.defineProperty(cls.prototype.PropertyBag, this.cssLocalName, this.propertyBagDescriptor);
    }
}
function inheritablePropertyValuesOn(view) {
    const array = new Array();
    for (let prop of inheritableProperties) {
        const sourceKey = prop.sourceKey;
        const valueSource = view[sourceKey] || 0 /* Default */;
        if (valueSource !== 0 /* Default */) {
            // use prop.name as it will return value or default value.
            // prop.key will return undefined if property is set the same value as default one.
            array.push({ property: prop, value: view[prop.name] });
        }
    }
    return array;
}
function inheritableCssPropertyValuesOn(style) {
    const array = new Array();
    for (let prop of inheritableCssProperties) {
        const sourceKey = prop.sourceKey;
        const valueSource = style[sourceKey] || 0 /* Default */;
        if (valueSource !== 0 /* Default */) {
            // use prop.name as it will return value or default value.
            // prop.key will return undefined if property is set the same value as default one.
            array.push({ property: prop, value: style[prop.name] });
        }
    }
    return array;
}
const initNativeView = Object(_profiling__WEBPACK_IMPORTED_MODULE_3__[/* profile */ "f"])('"properties".initNativeView', function initNativeView(view) {
    if (view._suspendedUpdates) {
        applyPendingNativeSetters(view);
    }
    else {
        applyAllNativeSetters(view);
    }
    // Would it be faster to delete all members of the old object?
    view._suspendedUpdates = {};
});
function applyPendingNativeSetters(view) {
    // TODO: Check what happens if a view was suspended and its value was reset, or set back to default!
    const suspendedUpdates = view._suspendedUpdates;
    for (let propertyName in suspendedUpdates) {
        const property = suspendedUpdates[propertyName];
        const setNative = property.setNative;
        if (view[setNative]) {
            const { getDefault, isStyleProperty, defaultValueKey, defaultValue } = property;
            let value;
            if (isStyleProperty) {
                const style = view.style;
                if (property.isSet(view.style)) {
                    if (!(defaultValueKey in style)) {
                        style[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                    }
                    value = view.style[propertyName];
                }
                else {
                    value = style[defaultValueKey];
                }
            }
            else {
                if (property.isSet(view)) {
                    if (!(defaultValueKey in view)) {
                        view[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                    }
                    value = view[propertyName];
                }
                else {
                    value = view[defaultValueKey];
                }
            }
            // TODO: Only if value is different from the value before the scope was created.
            view[setNative](value);
        }
    }
}
function applyAllNativeSetters(view) {
    let symbols = Object.getOwnPropertySymbols(view);
    for (let symbol of symbols) {
        const property = symbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        const setNative = property.setNative;
        const getDefault = property.getDefault;
        if (setNative in view) {
            const defaultValueKey = property.defaultValueKey;
            if (!(defaultValueKey in view)) {
                view[defaultValueKey] = view[getDefault] ? view[getDefault]() : property.defaultValue;
            }
            const value = view[symbol];
            view[setNative](value);
        }
    }
    const style = view.style;
    symbols = Object.getOwnPropertySymbols(style);
    for (let symbol of symbols) {
        const property = cssSymbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        if (view[property.setNative]) {
            const defaultValueKey = property.defaultValueKey;
            if (!(defaultValueKey in style)) {
                style[defaultValueKey] = view[property.getDefault] ? view[property.getDefault]() : property.defaultValue;
            }
            const value = style[symbol];
            view[property.setNative](value);
        }
    }
}
function resetNativeView(view) {
    let symbols = Object.getOwnPropertySymbols(view);
    for (let symbol of symbols) {
        const property = symbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        if (view[property.setNative]) {
            if (property.defaultValueKey in view) {
                view[property.setNative](view[property.defaultValueKey]);
                delete view[property.defaultValueKey];
            }
            else {
                view[property.setNative](property.defaultValue);
            }
        }
    }
    const style = view.style;
    symbols = Object.getOwnPropertySymbols(style);
    for (let symbol of symbols) {
        const property = cssSymbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        if (view[property.setNative]) {
            if (property.defaultValueKey in style) {
                view[property.setNative](style[property.defaultValueKey]);
                delete style[property.defaultValueKey];
            }
            else {
                view[property.setNative](property.defaultValue);
            }
        }
    }
}
function clearInheritedProperties(view) {
    for (let prop of inheritableProperties) {
        const sourceKey = prop.sourceKey;
        if (view[sourceKey] === 1 /* Inherited */) {
            prop.set.call(view, unsetValue);
        }
    }
    const style = view.style;
    for (let prop of inheritableCssProperties) {
        const sourceKey = prop.sourceKey;
        if (style[sourceKey] === 1 /* Inherited */) {
            prop.setInheritedValue.call(style, unsetValue);
        }
    }
}
function resetCSSProperties(style) {
    let symbols = Object.getOwnPropertySymbols(style);
    for (let symbol of symbols) {
        let cssProperty;
        if ((cssProperty = cssSymbolPropertyMap[symbol])) {
            style[cssProperty.cssName] = unsetValue;
            if (cssProperty instanceof CssAnimationProperty) {
                style[cssProperty.keyframe] = unsetValue;
            }
        }
    }
}
function propagateInheritableProperties(view, child) {
    const inheritablePropertyValues = inheritablePropertyValuesOn(view);
    for (let pair of inheritablePropertyValues) {
        const prop = pair.property;
        const sourceKey = prop.sourceKey;
        const currentValueSource = child[sourceKey] || 0 /* Default */;
        if (currentValueSource <= 1 /* Inherited */) {
            prop.setInheritedValue.call(child, pair.value);
        }
    }
}
function propagateInheritableCssProperties(parentStyle, childStyle) {
    const inheritableCssPropertyValues = inheritableCssPropertyValuesOn(parentStyle);
    for (let pair of inheritableCssPropertyValues) {
        const prop = pair.property;
        const sourceKey = prop.sourceKey;
        const currentValueSource = childStyle[sourceKey] || 0 /* Default */;
        if (currentValueSource <= 1 /* Inherited */) {
            prop.setInheritedValue.call(childStyle, pair.value, 1 /* Inherited */);
        }
    }
}
function makeValidator(...values) {
    const set = new Set(values);
    return (value) => set.has(value);
}
function makeParser(isValid) {
    return (value) => {
        const lower = value && value.toLowerCase();
        if (isValid(lower)) {
            return lower;
        }
        else {
            throw new Error('Invalid value: ' + value);
        }
    };
}
function getSetProperties(view) {
    const result = [];
    Object.getOwnPropertyNames(view).forEach((prop) => {
        result.push([prop, view[prop]]);
    });
    let symbols = Object.getOwnPropertySymbols(view);
    for (let symbol of symbols) {
        const property = symbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        const value = view[property.key];
        result.push([property.name, value]);
    }
    return result;
}
function getComputedCssValues(view) {
    const result = [];
    const style = view.style;
    for (let prop of cssPropertyNames) {
        result.push([prop, style[prop]]);
    }
    // Add these to enable box model in chrome-devtools styles tab
    result.push(['top', 'auto']);
    result.push(['left', 'auto']);
    result.push(['bottom', 'auto']);
    result.push(['right', 'auto']);
    return result;
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "PercentLength", function() { return /* binding */ PercentLength; });
__webpack_require__.d(__webpack_exports__, "Length", function() { return /* binding */ Length; });
__webpack_require__.d(__webpack_exports__, "zeroLength", function() { return /* binding */ zeroLength; });
__webpack_require__.d(__webpack_exports__, "minWidthProperty", function() { return /* binding */ minWidthProperty; });
__webpack_require__.d(__webpack_exports__, "minHeightProperty", function() { return /* binding */ minHeightProperty; });
__webpack_require__.d(__webpack_exports__, "widthProperty", function() { return /* binding */ widthProperty; });
__webpack_require__.d(__webpack_exports__, "heightProperty", function() { return /* binding */ heightProperty; });
__webpack_require__.d(__webpack_exports__, "marginLeftProperty", function() { return /* binding */ marginLeftProperty; });
__webpack_require__.d(__webpack_exports__, "marginRightProperty", function() { return /* binding */ marginRightProperty; });
__webpack_require__.d(__webpack_exports__, "marginTopProperty", function() { return /* binding */ marginTopProperty; });
__webpack_require__.d(__webpack_exports__, "marginBottomProperty", function() { return /* binding */ marginBottomProperty; });
__webpack_require__.d(__webpack_exports__, "paddingLeftProperty", function() { return /* binding */ paddingLeftProperty; });
__webpack_require__.d(__webpack_exports__, "paddingRightProperty", function() { return /* binding */ paddingRightProperty; });
__webpack_require__.d(__webpack_exports__, "paddingTopProperty", function() { return /* binding */ paddingTopProperty; });
__webpack_require__.d(__webpack_exports__, "paddingBottomProperty", function() { return /* binding */ paddingBottomProperty; });
__webpack_require__.d(__webpack_exports__, "HorizontalAlignment", function() { return /* binding */ style_properties_HorizontalAlignment; });
__webpack_require__.d(__webpack_exports__, "horizontalAlignmentProperty", function() { return /* binding */ horizontalAlignmentProperty; });
__webpack_require__.d(__webpack_exports__, "VerticalAlignment", function() { return /* binding */ style_properties_VerticalAlignment; });
__webpack_require__.d(__webpack_exports__, "verticalAlignmentProperty", function() { return /* binding */ verticalAlignmentProperty; });
__webpack_require__.d(__webpack_exports__, "rotateProperty", function() { return /* binding */ rotateProperty; });
__webpack_require__.d(__webpack_exports__, "rotateXProperty", function() { return /* binding */ rotateXProperty; });
__webpack_require__.d(__webpack_exports__, "rotateYProperty", function() { return /* binding */ rotateYProperty; });
__webpack_require__.d(__webpack_exports__, "perspectiveProperty", function() { return /* binding */ perspectiveProperty; });
__webpack_require__.d(__webpack_exports__, "scaleXProperty", function() { return /* binding */ scaleXProperty; });
__webpack_require__.d(__webpack_exports__, "scaleYProperty", function() { return /* binding */ scaleYProperty; });
__webpack_require__.d(__webpack_exports__, "translateXProperty", function() { return /* binding */ translateXProperty; });
__webpack_require__.d(__webpack_exports__, "translateYProperty", function() { return /* binding */ translateYProperty; });
__webpack_require__.d(__webpack_exports__, "transformConverter", function() { return /* binding */ transformConverter; });
__webpack_require__.d(__webpack_exports__, "backgroundInternalProperty", function() { return /* binding */ backgroundInternalProperty; });
__webpack_require__.d(__webpack_exports__, "backgroundImageProperty", function() { return /* binding */ backgroundImageProperty; });
__webpack_require__.d(__webpack_exports__, "backgroundColorProperty", function() { return /* binding */ backgroundColorProperty; });
__webpack_require__.d(__webpack_exports__, "BackgroundRepeat", function() { return /* binding */ style_properties_BackgroundRepeat; });
__webpack_require__.d(__webpack_exports__, "backgroundRepeatProperty", function() { return /* binding */ backgroundRepeatProperty; });
__webpack_require__.d(__webpack_exports__, "backgroundSizeProperty", function() { return /* binding */ backgroundSizeProperty; });
__webpack_require__.d(__webpack_exports__, "backgroundPositionProperty", function() { return /* binding */ backgroundPositionProperty; });
__webpack_require__.d(__webpack_exports__, "borderTopColorProperty", function() { return /* binding */ borderTopColorProperty; });
__webpack_require__.d(__webpack_exports__, "borderRightColorProperty", function() { return /* binding */ borderRightColorProperty; });
__webpack_require__.d(__webpack_exports__, "borderBottomColorProperty", function() { return /* binding */ borderBottomColorProperty; });
__webpack_require__.d(__webpack_exports__, "borderLeftColorProperty", function() { return /* binding */ borderLeftColorProperty; });
__webpack_require__.d(__webpack_exports__, "borderTopWidthProperty", function() { return /* binding */ borderTopWidthProperty; });
__webpack_require__.d(__webpack_exports__, "borderRightWidthProperty", function() { return /* binding */ borderRightWidthProperty; });
__webpack_require__.d(__webpack_exports__, "borderBottomWidthProperty", function() { return /* binding */ borderBottomWidthProperty; });
__webpack_require__.d(__webpack_exports__, "borderLeftWidthProperty", function() { return /* binding */ borderLeftWidthProperty; });
__webpack_require__.d(__webpack_exports__, "borderTopLeftRadiusProperty", function() { return /* binding */ borderTopLeftRadiusProperty; });
__webpack_require__.d(__webpack_exports__, "borderTopRightRadiusProperty", function() { return /* binding */ borderTopRightRadiusProperty; });
__webpack_require__.d(__webpack_exports__, "borderBottomRightRadiusProperty", function() { return /* binding */ borderBottomRightRadiusProperty; });
__webpack_require__.d(__webpack_exports__, "borderBottomLeftRadiusProperty", function() { return /* binding */ borderBottomLeftRadiusProperty; });
__webpack_require__.d(__webpack_exports__, "clipPathProperty", function() { return /* binding */ clipPathProperty; });
__webpack_require__.d(__webpack_exports__, "zIndexProperty", function() { return /* binding */ zIndexProperty; });
__webpack_require__.d(__webpack_exports__, "opacityProperty", function() { return /* binding */ opacityProperty; });
__webpack_require__.d(__webpack_exports__, "colorProperty", function() { return /* binding */ colorProperty; });
__webpack_require__.d(__webpack_exports__, "fontInternalProperty", function() { return /* binding */ fontInternalProperty; });
__webpack_require__.d(__webpack_exports__, "fontFamilyProperty", function() { return /* binding */ fontFamilyProperty; });
__webpack_require__.d(__webpack_exports__, "fontSizeProperty", function() { return /* binding */ fontSizeProperty; });
__webpack_require__.d(__webpack_exports__, "fontStyleProperty", function() { return /* binding */ fontStyleProperty; });
__webpack_require__.d(__webpack_exports__, "fontWeightProperty", function() { return /* binding */ fontWeightProperty; });
__webpack_require__.d(__webpack_exports__, "Visibility", function() { return /* binding */ style_properties_Visibility; });
__webpack_require__.d(__webpack_exports__, "visibilityProperty", function() { return /* binding */ visibilityProperty; });
__webpack_require__.d(__webpack_exports__, "androidElevationProperty", function() { return /* binding */ androidElevationProperty; });
__webpack_require__.d(__webpack_exports__, "androidDynamicElevationOffsetProperty", function() { return /* binding */ androidDynamicElevationOffsetProperty; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var properties = __webpack_require__(1);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style/index.js
var style = __webpack_require__(7);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/color/index.js + 2 modules
var color = __webpack_require__(6);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/font.js
var styling_font = __webpack_require__(22);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/font-common.js
var font_common = __webpack_require__(33);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/background-common.js
var background_common = __webpack_require__(102);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/utils/number-utils.js
const epsilon = 1e-5;
function areClose(value1, value2) {
    return Math.abs(value1 - value2) < epsilon;
}
function greaterThanOrClose(value1, value2) {
    return value1 > value2 || areClose(value1, value2);
}
function greaterThan(value1, value2) {
    return value1 > value2 && !areClose(value1, value2);
}
function lessThan(value1, value2) {
    return value1 < value2 && !areClose(value1, value2);
}
function isZero(value) {
    return Math.abs(value) < epsilon;
}
function greaterThanZero(value) {
    return value > 0;
}
function notNegative(value) {
    return value >= 0;
}
const radiansToDegrees = (a) => a * (180 / Math.PI);
const degreesToRadians = (a) => a * (Math.PI / 180);
//# sourceMappingURL=number-utils.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/matrix/index.js

const getTransformMatrix = ({ property, value }) => TRANSFORM_MATRIXES[property](value);
const TRANSFORM_MATRIXES = {
    scale: ({ x, y }) => [x, 0, 0, 0, y, 0, 0, 0, 1],
    translate: ({ x, y }) => [1, 0, x, 0, 1, y, 0, 0, 1],
    rotate: ({ x, y, z }) => {
        // TODO: Handle rotations over X and Y axis
        const radZ = degreesToRadians(z);
        const cosZ = Math.cos(radZ);
        const sinZ = Math.sin(radZ);
        return [cosZ, -sinZ, 0, sinZ, cosZ, 0, 0, 0, 1];
    },
};
const matrixArrayToCssMatrix = (m) => [m[0], m[3], m[1], m[4], m[2], m[5]];
function multiplyAffine2d(m1, m2) {
    return [m1[0] * m2[0] + m1[1] * m2[3], m1[0] * m2[1] + m1[1] * m2[4], m1[0] * m2[2] + m1[1] * m2[5] + m1[2], m1[3] * m2[0] + m1[4] * m2[3], m1[3] * m2[1] + m1[4] * m2[4], m1[3] * m2[2] + m1[4] * m2[5] + m1[5]];
}
// TODO: Decompose rotations over X and Y axis
function decompose2DTransformMatrix(matrix) {
    verifyTransformMatrix(matrix);
    const [A, B, C, D, E, F] = [...matrix];
    const determinant = A * D - B * C;
    const translate = { x: E || 0, y: F || 0 };
    // rewrite with obj destructuring using the identity matrix
    let rotate = 0;
    let scale = { x: 1, y: 1 };
    if (A || B) {
        const R = Math.sqrt(A * A + B * B);
        rotate = B > 0 ? Math.acos(A / R) : -Math.acos(A / R);
        scale = { x: R, y: determinant / R };
    }
    else if (C || D) {
        const R = Math.sqrt(C * C + D * D);
        rotate = Math.PI / 2 - (D > 0 ? Math.acos(-C / R) : -Math.acos(C / R));
        scale = { x: determinant / R, y: R };
    }
    rotate = radiansToDegrees(rotate);
    return { translate, rotate: { x: 0, y: 0, z: rotate }, scale };
}
function verifyTransformMatrix(matrix) {
    if (matrix.length < 6) {
        throw new Error('Transform matrix should be 2x3.');
    }
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/trace/index.js
var trace = __webpack_require__(0);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/css/parser.js
var parser = __webpack_require__(54);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/linear-gradient.js
var linear_gradient = __webpack_require__(47);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/styling/style-properties.js
// Types











function equalsCommon(a, b) {
    if (a == 'auto') {
        // tslint:disable-line
        return b == 'auto'; // tslint:disable-line
    }
    if (typeof a === 'number') {
        if (b == 'auto') {
            // tslint:disable-line
            return false;
        }
        if (typeof b === 'number') {
            return a == b; // tslint:disable-line
        }
        if (!b) {
            return false;
        }
        return b.unit == 'dip' && a == b.value; // tslint:disable-line
    }
    if (b == 'auto') {
        // tslint:disable-line
        return false;
    }
    if (typeof b === 'number') {
        return a ? a.unit == 'dip' && a.value == b : false; // tslint:disable-line
    }
    if (!a || !b) {
        return false;
    }
    return a.value == b.value && a.unit == b.unit; // tslint:disable-line
}
function convertToStringCommon(length) {
    if (length == 'auto') {
        // tslint:disable-line
        return 'auto';
    }
    if (typeof length === 'number') {
        return length.toString();
    }
    let val = length.value;
    if (length.unit === '%') {
        val *= 100;
    }
    return val + length.unit;
}
function toDevicePixelsCommon(length, auto = Number.NaN, parentAvailableWidth = Number.NaN) {
    if (length == 'auto') {
        // tslint:disable-line
        return auto;
    }
    if (typeof length === 'number') {
        return utils_common["n" /* layout */].round(utils_common["n" /* layout */].toDevicePixels(length));
    }
    if (!length) {
        return auto;
    }
    switch (length.unit) {
        case 'px':
            return utils_common["n" /* layout */].round(length.value);
        case '%':
            return utils_common["n" /* layout */].round(parentAvailableWidth * length.value);
        case 'dip':
        default:
            return utils_common["n" /* layout */].round(utils_common["n" /* layout */].toDevicePixels(length.value));
    }
}
var PercentLength;
(function (PercentLength) {
    function parse(fromValue) {
        if (fromValue == 'auto') {
            // tslint:disable-line
            return 'auto';
        }
        if (typeof fromValue === 'string') {
            let stringValue = fromValue.trim();
            let percentIndex = stringValue.indexOf('%');
            if (percentIndex !== -1) {
                let value;
                // if only % or % is not last we treat it as invalid value.
                if (percentIndex !== stringValue.length - 1 || percentIndex === 0) {
                    value = Number.NaN;
                }
                else {
                    // Normalize result to values between -1 and 1
                    value = parseFloat(stringValue.substring(0, stringValue.length - 1).trim()) / 100;
                }
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error(`Invalid value: ${fromValue}`);
                }
                return { unit: '%', value };
            }
            else if (stringValue.indexOf('px') !== -1) {
                stringValue = stringValue.replace('px', '').trim();
                let value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error(`Invalid value: ${fromValue}`);
                }
                return { unit: 'px', value };
            }
            else {
                let value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error(`Invalid value: ${fromValue}`);
                }
                return value;
            }
        }
        else {
            return fromValue;
        }
    }
    PercentLength.parse = parse;
    PercentLength.equals = equalsCommon;
    PercentLength.toDevicePixels = toDevicePixelsCommon;
    PercentLength.convertToString = convertToStringCommon;
})(PercentLength || (PercentLength = {}));
var Length;
(function (Length) {
    function parse(fromValue) {
        if (fromValue == 'auto') {
            // tslint:disable-line
            return 'auto';
        }
        if (typeof fromValue === 'string') {
            let stringValue = fromValue.trim();
            if (stringValue.indexOf('px') !== -1) {
                stringValue = stringValue.replace('px', '').trim();
                let value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error(`Invalid value: ${stringValue}`);
                }
                return { unit: 'px', value };
            }
            else {
                let value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error(`Invalid value: ${stringValue}`);
                }
                return value;
            }
        }
        else {
            return fromValue;
        }
    }
    Length.parse = parse;
    Length.equals = equalsCommon;
    Length.toDevicePixels = toDevicePixelsCommon;
    Length.convertToString = convertToStringCommon;
})(Length || (Length = {}));
const zeroLength = { value: 0, unit: 'px' };
const minWidthProperty = new properties["CssProperty"]({
    name: 'minWidth',
    cssName: 'min-width',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectiveMinWidth = Length.toDevicePixels(newValue, 0);
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
    valueConverter: Length.parse,
});
minWidthProperty.register(style["a" /* Style */]);
const minHeightProperty = new properties["CssProperty"]({
    name: 'minHeight',
    cssName: 'min-height',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectiveMinHeight = Length.toDevicePixels(newValue, 0);
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
    valueConverter: Length.parse,
});
minHeightProperty.register(style["a" /* Style */]);
const widthProperty = new properties["CssAnimationProperty"]({
    name: 'width',
    cssName: 'width',
    defaultValue: 'auto',
    equalityComparer: Length.equals,
    // TODO: CSSAnimationProperty was needed for keyframe (copying other impls), but `affectsLayout` does not exist
    //       on the animation property, so fake it here. x_x
    valueChanged: (target, oldValue, newValue) => {
        if (true) {
            const view = target.viewRef.get();
            if (view) {
                view.requestLayout();
            }
        }
    },
    valueConverter: PercentLength.parse,
});
widthProperty.register(style["a" /* Style */]);
const heightProperty = new properties["CssAnimationProperty"]({
    name: 'height',
    cssName: 'height',
    defaultValue: 'auto',
    equalityComparer: Length.equals,
    // TODO: CSSAnimationProperty was needed for keyframe (copying other impls), but `affectsLayout` does not exist
    //       on the animation property, so fake it here. -_-
    valueChanged: (target, oldValue, newValue) => {
        if (true) {
            const view = target.viewRef.get();
            if (view) {
                view.requestLayout();
            }
        }
    },
    valueConverter: PercentLength.parse,
});
heightProperty.register(style["a" /* Style */]);
const marginProperty = new properties["ShorthandProperty"]({
    name: 'margin',
    cssName: 'margin',
    getter: function () {
        if (PercentLength.equals(this.marginTop, this.marginRight) && PercentLength.equals(this.marginTop, this.marginBottom) && PercentLength.equals(this.marginTop, this.marginLeft)) {
            return this.marginTop;
        }
        return `${PercentLength.convertToString(this.marginTop)} ${PercentLength.convertToString(this.marginRight)} ${PercentLength.convertToString(this.marginBottom)} ${PercentLength.convertToString(this.marginLeft)}`;
    },
    converter: convertToMargins,
});
marginProperty.register(style["a" /* Style */]);
const marginLeftProperty = new properties["CssProperty"]({
    name: 'marginLeft',
    cssName: 'margin-left',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueConverter: PercentLength.parse,
});
marginLeftProperty.register(style["a" /* Style */]);
const marginRightProperty = new properties["CssProperty"]({
    name: 'marginRight',
    cssName: 'margin-right',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueConverter: PercentLength.parse,
});
marginRightProperty.register(style["a" /* Style */]);
const marginTopProperty = new properties["CssProperty"]({
    name: 'marginTop',
    cssName: 'margin-top',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueConverter: PercentLength.parse,
});
marginTopProperty.register(style["a" /* Style */]);
const marginBottomProperty = new properties["CssProperty"]({
    name: 'marginBottom',
    cssName: 'margin-bottom',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueConverter: PercentLength.parse,
});
marginBottomProperty.register(style["a" /* Style */]);
const paddingProperty = new properties["ShorthandProperty"]({
    name: 'padding',
    cssName: 'padding',
    getter: function () {
        if (Length.equals(this.paddingTop, this.paddingRight) && Length.equals(this.paddingTop, this.paddingBottom) && Length.equals(this.paddingTop, this.paddingLeft)) {
            return this.paddingTop;
        }
        return `${Length.convertToString(this.paddingTop)} ${Length.convertToString(this.paddingRight)} ${Length.convertToString(this.paddingBottom)} ${Length.convertToString(this.paddingLeft)}`;
    },
    converter: convertToPaddings,
});
paddingProperty.register(style["a" /* Style */]);
const paddingLeftProperty = new properties["CssProperty"]({
    name: 'paddingLeft',
    cssName: 'padding-left',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectivePaddingLeft = Length.toDevicePixels(newValue, 0);
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
    valueConverter: Length.parse,
});
paddingLeftProperty.register(style["a" /* Style */]);
const paddingRightProperty = new properties["CssProperty"]({
    name: 'paddingRight',
    cssName: 'padding-right',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectivePaddingRight = Length.toDevicePixels(newValue, 0);
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
    valueConverter: Length.parse,
});
paddingRightProperty.register(style["a" /* Style */]);
const paddingTopProperty = new properties["CssProperty"]({
    name: 'paddingTop',
    cssName: 'padding-top',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectivePaddingTop = Length.toDevicePixels(newValue, 0);
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
    valueConverter: Length.parse,
});
paddingTopProperty.register(style["a" /* Style */]);
const paddingBottomProperty = new properties["CssProperty"]({
    name: 'paddingBottom',
    cssName: 'padding-bottom',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectivePaddingBottom = Length.toDevicePixels(newValue, 0);
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
    valueConverter: Length.parse,
});
paddingBottomProperty.register(style["a" /* Style */]);
var style_properties_HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment.LEFT = 'left';
    HorizontalAlignment.CENTER = 'center';
    HorizontalAlignment.RIGHT = 'right';
    HorizontalAlignment.STRETCH = 'stretch';
    HorizontalAlignment.isValid = Object(properties["makeValidator"])(HorizontalAlignment.LEFT, HorizontalAlignment.CENTER, HorizontalAlignment.RIGHT, HorizontalAlignment.STRETCH);
    HorizontalAlignment.parse = Object(properties["makeParser"])(HorizontalAlignment.isValid);
})(style_properties_HorizontalAlignment || (style_properties_HorizontalAlignment = {}));
const horizontalAlignmentProperty = new properties["CssProperty"]({
    name: 'horizontalAlignment',
    cssName: 'horizontal-align',
    defaultValue: style_properties_HorizontalAlignment.STRETCH,
    affectsLayout: true,
    valueConverter: style_properties_HorizontalAlignment.parse,
});
horizontalAlignmentProperty.register(style["a" /* Style */]);
var style_properties_VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment.TOP = 'top';
    VerticalAlignment.MIDDLE = 'middle';
    VerticalAlignment.BOTTOM = 'bottom';
    VerticalAlignment.STRETCH = 'stretch';
    VerticalAlignment.TEXTTOP = 'text-top';
    VerticalAlignment.TEXTBOTTOM = 'text-bottom';
    VerticalAlignment.SUPER = 'super';
    VerticalAlignment.SUB = 'sub';
    VerticalAlignment.BASELINE = 'baseline';
    VerticalAlignment.isValid = Object(properties["makeValidator"])(VerticalAlignment.TOP, VerticalAlignment.MIDDLE, VerticalAlignment.BOTTOM, VerticalAlignment.STRETCH, VerticalAlignment.TEXTTOP, VerticalAlignment.TEXTBOTTOM, VerticalAlignment.SUPER, VerticalAlignment.SUB, VerticalAlignment.BASELINE);
    VerticalAlignment.parse = (value) => (value.toLowerCase() === 'center' ? VerticalAlignment.MIDDLE : parseStrict(value));
    const parseStrict = Object(properties["makeParser"])(VerticalAlignment.isValid);
})(style_properties_VerticalAlignment || (style_properties_VerticalAlignment = {}));
const verticalAlignmentProperty = new properties["CssProperty"]({
    name: 'verticalAlignment',
    cssName: 'vertical-align',
    defaultValue: style_properties_VerticalAlignment.STRETCH,
    affectsLayout: true,
    valueConverter: style_properties_VerticalAlignment.parse,
});
verticalAlignmentProperty.register(style["a" /* Style */]);
function parseThickness(value) {
    if (typeof value === 'string') {
        let arr = value.split(/[ ,]+/);
        let top;
        let right;
        let bottom;
        let left;
        if (arr.length === 1) {
            top = arr[0];
            right = arr[0];
            bottom = arr[0];
            left = arr[0];
        }
        else if (arr.length === 2) {
            top = arr[0];
            bottom = arr[0];
            right = arr[1];
            left = arr[1];
        }
        else if (arr.length === 3) {
            top = arr[0];
            right = arr[1];
            left = arr[1];
            bottom = arr[2];
        }
        else if (arr.length === 4) {
            top = arr[0];
            right = arr[1];
            bottom = arr[2];
            left = arr[3];
        }
        else {
            throw new Error('Expected 1, 2, 3 or 4 parameters. Actual: ' + value);
        }
        return {
            top: top,
            right: right,
            bottom: bottom,
            left: left,
        };
    }
    else {
        return value;
    }
}
function convertToMargins(value) {
    if (typeof value === 'string' && value !== 'auto') {
        let thickness = parseThickness(value);
        return [
            [marginTopProperty, PercentLength.parse(thickness.top)],
            [marginRightProperty, PercentLength.parse(thickness.right)],
            [marginBottomProperty, PercentLength.parse(thickness.bottom)],
            [marginLeftProperty, PercentLength.parse(thickness.left)],
        ];
    }
    else {
        return [
            [marginTopProperty, value],
            [marginRightProperty, value],
            [marginBottomProperty, value],
            [marginLeftProperty, value],
        ];
    }
}
function convertToPaddings(value) {
    if (typeof value === 'string' && value !== 'auto') {
        let thickness = parseThickness(value);
        return [
            [paddingTopProperty, Length.parse(thickness.top)],
            [paddingRightProperty, Length.parse(thickness.right)],
            [paddingBottomProperty, Length.parse(thickness.bottom)],
            [paddingLeftProperty, Length.parse(thickness.left)],
        ];
    }
    else {
        return [
            [paddingTopProperty, value],
            [paddingRightProperty, value],
            [paddingBottomProperty, value],
            [paddingLeftProperty, value],
        ];
    }
}
const rotateProperty = new properties["CssAnimationProperty"]({
    name: 'rotate',
    cssName: 'rotate',
    defaultValue: 0,
    valueConverter: parseFloat,
});
rotateProperty.register(style["a" /* Style */]);
const rotateXProperty = new properties["CssAnimationProperty"]({
    name: 'rotateX',
    cssName: 'rotatex',
    defaultValue: 0,
    valueConverter: parseFloat,
});
rotateXProperty.register(style["a" /* Style */]);
const rotateYProperty = new properties["CssAnimationProperty"]({
    name: 'rotateY',
    cssName: 'rotatey',
    defaultValue: 0,
    valueConverter: parseFloat,
});
rotateYProperty.register(style["a" /* Style */]);
const perspectiveProperty = new properties["CssAnimationProperty"]({
    name: 'perspective',
    cssName: 'perspective',
    defaultValue: 1000,
    valueConverter: parseFloat,
});
perspectiveProperty.register(style["a" /* Style */]);
const scaleXProperty = new properties["CssAnimationProperty"]({
    name: 'scaleX',
    cssName: 'scaleX',
    defaultValue: 1,
    valueConverter: parseFloat,
});
scaleXProperty.register(style["a" /* Style */]);
const scaleYProperty = new properties["CssAnimationProperty"]({
    name: 'scaleY',
    cssName: 'scaleY',
    defaultValue: 1,
    valueConverter: parseFloat,
});
scaleYProperty.register(style["a" /* Style */]);
function parseDIPs(value) {
    if (value.indexOf('px') !== -1) {
        return utils_common["n" /* layout */].toDeviceIndependentPixels(parseFloat(value.replace('px', '').trim()));
    }
    else {
        return parseFloat(value.replace('dip', '').trim());
    }
}
const translateXProperty = new properties["CssAnimationProperty"]({
    name: 'translateX',
    cssName: 'translateX',
    defaultValue: 0,
    valueConverter: parseDIPs,
});
translateXProperty.register(style["a" /* Style */]);
const translateYProperty = new properties["CssAnimationProperty"]({
    name: 'translateY',
    cssName: 'translateY',
    defaultValue: 0,
    valueConverter: parseDIPs,
});
translateYProperty.register(style["a" /* Style */]);
const transformProperty = new properties["ShorthandProperty"]({
    name: 'transform',
    cssName: 'transform',
    getter: function () {
        let scaleX = this.scaleX;
        let scaleY = this.scaleY;
        let translateX = this.translateX;
        let translateY = this.translateY;
        let rotate = this.rotate;
        let rotateX = this.rotateX;
        let rotateY = this.rotateY;
        let result = '';
        if (translateX !== 0 || translateY !== 0) {
            result += `translate(${translateX}, ${translateY}) `;
        }
        if (scaleX !== 1 || scaleY !== 1) {
            result += `scale(${scaleX}, ${scaleY}) `;
        }
        if (rotateX !== 0 || rotateY !== 0 || rotate !== 0) {
            result += `rotate(${rotateX}, ${rotateY}, ${rotate}) `;
            result += `rotate (${rotate})`;
        }
        return result.trim();
    },
    converter: convertToTransform,
});
transformProperty.register(style["a" /* Style */]);
const IDENTITY_TRANSFORMATION = {
    translate: { x: 0, y: 0 },
    rotate: { x: 0, y: 0, z: 0 },
    scale: { x: 1, y: 1 },
};
const TRANSFORM_SPLITTER = new RegExp(/\s*(.+?)\((.*?)\)/g);
const TRANSFORMATIONS = Object.freeze(['rotate', 'rotateX', 'rotateY', 'rotate3d', 'translate', 'translate3d', 'translateX', 'translateY', 'scale', 'scale3d', 'scaleX', 'scaleY']);
const STYLE_TRANSFORMATION_MAP = Object.freeze({
    scale: (value) => ({ property: 'scale', value }),
    scale3d: (value) => ({ property: 'scale', value }),
    scaleX: ({ x }) => ({
        property: 'scale',
        value: { x, y: IDENTITY_TRANSFORMATION.scale.y },
    }),
    scaleY: ({ y }) => ({
        property: 'scale',
        value: { y, x: IDENTITY_TRANSFORMATION.scale.x },
    }),
    translate: (value) => ({ property: 'translate', value }),
    translate3d: (value) => ({ property: 'translate', value }),
    translateX: ({ x }) => ({
        property: 'translate',
        value: { x, y: IDENTITY_TRANSFORMATION.translate.y },
    }),
    translateY: ({ y }) => ({
        property: 'translate',
        value: { y, x: IDENTITY_TRANSFORMATION.translate.x },
    }),
    rotate3d: (value) => ({ property: 'rotate', value }),
    rotateX: (x) => ({
        property: 'rotate',
        value: {
            x,
            y: IDENTITY_TRANSFORMATION.rotate.y,
            z: IDENTITY_TRANSFORMATION.rotate.z,
        },
    }),
    rotateY: (y) => ({
        property: 'rotate',
        value: {
            x: IDENTITY_TRANSFORMATION.rotate.x,
            y,
            z: IDENTITY_TRANSFORMATION.rotate.z,
        },
    }),
    rotate: (z) => ({
        property: 'rotate',
        value: {
            x: IDENTITY_TRANSFORMATION.rotate.x,
            y: IDENTITY_TRANSFORMATION.rotate.y,
            z,
        },
    }),
});
function convertToTransform(value) {
    if (value === properties["unsetValue"]) {
        value = 'none';
    }
    const { translate, rotate, scale } = transformConverter(value);
    return [
        [translateXProperty, translate.x],
        [translateYProperty, translate.y],
        [scaleXProperty, scale.x],
        [scaleYProperty, scale.y],
        [rotateProperty, rotate.z],
        [rotateXProperty, rotate.x],
        [rotateYProperty, rotate.y],
    ];
}
function transformConverter(text) {
    const transformations = parseTransformString(text);
    if (text === 'none' || text === '' || !transformations.length) {
        return IDENTITY_TRANSFORMATION;
    }
    const usedTransforms = transformations.map((t) => t.property);
    if (!Object(utils_common["i" /* hasDuplicates */])(usedTransforms)) {
        const fullTransformations = Object.assign({}, IDENTITY_TRANSFORMATION);
        transformations.forEach((transform) => {
            fullTransformations[transform.property] = transform.value;
        });
        return fullTransformations;
    }
    const affineMatrix = transformations.map(getTransformMatrix).reduce(multiplyAffine2d);
    const cssMatrix = matrixArrayToCssMatrix(affineMatrix);
    return decompose2DTransformMatrix(cssMatrix);
}
// using general regex and manually checking the matched
// properties is faster than using more specific regex
// https://jsperf.com/cssparse
function parseTransformString(text) {
    let matches = [];
    let match;
    while ((match = TRANSFORM_SPLITTER.exec(text)) !== null) {
        const property = match[1];
        const value = convertTransformValue(property, match[2]);
        if (TRANSFORMATIONS.indexOf(property) !== -1) {
            matches.push(normalizeTransformation({ property, value }));
        }
    }
    return matches;
}
function normalizeTransformation({ property, value }) {
    return STYLE_TRANSFORMATION_MAP[property](value);
}
function convertTransformValue(property, stringValue) {
    const [x, y = x, z = y] = stringValue.split(',').map(parseFloat);
    if (property === 'rotate' || property === 'rotateX' || property === 'rotateY') {
        return stringValue.slice(-3) === 'rad' ? radiansToDegrees(x) : x;
    }
    return { x, y, z };
}
// Background properties.
const backgroundProperty = new properties["ShorthandProperty"]({
    name: 'background',
    cssName: 'background',
    getter: function () {
        return `${this.backgroundColor} ${this.backgroundImage} ${this.backgroundRepeat} ${this.backgroundPosition}`;
    },
    converter: convertToBackgrounds,
});
backgroundProperty.register(style["a" /* Style */]);
const backgroundInternalProperty = new properties["CssProperty"]({
    name: 'backgroundInternal',
    cssName: '_backgroundInternal',
    defaultValue: background_common["a" /* Background */].default,
});
backgroundInternalProperty.register(style["a" /* Style */]);
// const pattern: RegExp = /url\(('|")(.*?)\1\)/;
const backgroundImageProperty = new properties["CssProperty"]({
    name: 'backgroundImage',
    cssName: 'background-image',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withImage(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: (value1, value2) => {
        if (value1 instanceof linear_gradient["a" /* LinearGradient */] && value2 instanceof linear_gradient["a" /* LinearGradient */]) {
            return linear_gradient["a" /* LinearGradient */].equals(value1, value2);
        }
        else {
            return value1 === value2;
        }
    },
    valueConverter: (value) => {
        if (typeof value === 'string') {
            const parsed = parser["parseBackground"](value);
            if (parsed) {
                const background = parsed.value;
                value = typeof background.image === 'object' ? linear_gradient["a" /* LinearGradient */].parse(background.image) : value;
            }
        }
        return value;
    },
});
backgroundImageProperty.register(style["a" /* Style */]);
const backgroundColorProperty = new properties["CssAnimationProperty"]({
    name: 'backgroundColor',
    cssName: 'background-color',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withColor(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: color["a" /* Color */].equals,
    valueConverter: (value) => new color["a" /* Color */](value),
});
backgroundColorProperty.register(style["a" /* Style */]);
var style_properties_BackgroundRepeat;
(function (BackgroundRepeat) {
    BackgroundRepeat.REPEAT = 'repeat';
    BackgroundRepeat.REPEAT_X = 'repeat-x';
    BackgroundRepeat.REPEAT_Y = 'repeat-y';
    BackgroundRepeat.NO_REPEAT = 'no-repeat';
    BackgroundRepeat.isValid = Object(properties["makeValidator"])(BackgroundRepeat.REPEAT, BackgroundRepeat.REPEAT_X, BackgroundRepeat.REPEAT_Y, BackgroundRepeat.NO_REPEAT);
    BackgroundRepeat.parse = Object(properties["makeParser"])(BackgroundRepeat.isValid);
})(style_properties_BackgroundRepeat || (style_properties_BackgroundRepeat = {}));
const backgroundRepeatProperty = new properties["CssProperty"]({
    name: 'backgroundRepeat',
    cssName: 'background-repeat',
    valueConverter: style_properties_BackgroundRepeat.parse,
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withRepeat(newValue);
        target.backgroundInternal = background;
    },
});
backgroundRepeatProperty.register(style["a" /* Style */]);
const backgroundSizeProperty = new properties["CssProperty"]({
    name: 'backgroundSize',
    cssName: 'background-size',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withSize(newValue);
        target.backgroundInternal = background;
    },
});
backgroundSizeProperty.register(style["a" /* Style */]);
const backgroundPositionProperty = new properties["CssProperty"]({
    name: 'backgroundPosition',
    cssName: 'background-position',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withPosition(newValue);
        target.backgroundInternal = background;
    },
});
backgroundPositionProperty.register(style["a" /* Style */]);
function convertToBackgrounds(value) {
    if (typeof value === 'string') {
        const backgrounds = parser["parseBackground"](value).value;
        const backgroundColor = backgrounds.color ? new color["a" /* Color */](backgrounds.color) : properties["unsetValue"];
        let backgroundImage;
        if (typeof backgrounds.image === 'object' && backgrounds.image) {
            backgroundImage = linear_gradient["a" /* LinearGradient */].parse(backgrounds.image);
        }
        else {
            backgroundImage = backgrounds.image || properties["unsetValue"];
        }
        const backgroundRepeat = backgrounds.repeat || properties["unsetValue"];
        const backgroundPosition = backgrounds.position ? backgrounds.position.text : properties["unsetValue"];
        return [
            [backgroundColorProperty, backgroundColor],
            [backgroundImageProperty, backgroundImage],
            [backgroundRepeatProperty, backgroundRepeat],
            [backgroundPositionProperty, backgroundPosition],
        ];
    }
    else {
        return [
            [backgroundColorProperty, properties["unsetValue"]],
            [backgroundImageProperty, properties["unsetValue"]],
            [backgroundRepeatProperty, properties["unsetValue"]],
            [backgroundPositionProperty, properties["unsetValue"]],
        ];
    }
}
function parseBorderColor(value) {
    let result = {
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined,
    };
    if (value.indexOf('rgb') === 0) {
        result.top = result.right = result.bottom = result.left = new color["a" /* Color */](value);
        return result;
    }
    let arr = value.split(/[ ,]+/);
    if (arr.length === 1) {
        let arr0 = new color["a" /* Color */](arr[0]);
        result.top = arr0;
        result.right = arr0;
        result.bottom = arr0;
        result.left = arr0;
    }
    else if (arr.length === 2) {
        let arr0 = new color["a" /* Color */](arr[0]);
        let arr1 = new color["a" /* Color */](arr[1]);
        result.top = arr0;
        result.right = arr1;
        result.bottom = arr0;
        result.left = arr1;
    }
    else if (arr.length === 3) {
        let arr0 = new color["a" /* Color */](arr[0]);
        let arr1 = new color["a" /* Color */](arr[1]);
        let arr2 = new color["a" /* Color */](arr[2]);
        result.top = arr0;
        result.right = arr1;
        result.bottom = arr2;
        result.left = arr1;
    }
    else if (arr.length === 4) {
        let arr0 = new color["a" /* Color */](arr[0]);
        let arr1 = new color["a" /* Color */](arr[1]);
        let arr2 = new color["a" /* Color */](arr[2]);
        let arr3 = new color["a" /* Color */](arr[3]);
        result.top = arr0;
        result.right = arr1;
        result.bottom = arr2;
        result.left = arr3;
    }
    else {
        throw new Error(`Expected 1, 2, 3 or 4 parameters. Actual: ${value}`);
    }
    return result;
}
// Border Color properties.
const borderColorProperty = new properties["ShorthandProperty"]({
    name: 'borderColor',
    cssName: 'border-color',
    getter: function () {
        if (color["a" /* Color */].equals(this.borderTopColor, this.borderRightColor) && color["a" /* Color */].equals(this.borderTopColor, this.borderBottomColor) && color["a" /* Color */].equals(this.borderTopColor, this.borderLeftColor)) {
            return this.borderTopColor;
        }
        else {
            return `${this.borderTopColor} ${this.borderRightColor} ${this.borderBottomColor} ${this.borderLeftColor}`;
        }
    },
    converter: function (value) {
        if (typeof value === 'string') {
            let fourColors = parseBorderColor(value);
            return [
                [borderTopColorProperty, fourColors.top],
                [borderRightColorProperty, fourColors.right],
                [borderBottomColorProperty, fourColors.bottom],
                [borderLeftColorProperty, fourColors.left],
            ];
        }
        else {
            return [
                [borderTopColorProperty, value],
                [borderRightColorProperty, value],
                [borderBottomColorProperty, value],
                [borderLeftColorProperty, value],
            ];
        }
    },
});
borderColorProperty.register(style["a" /* Style */]);
const borderTopColorProperty = new properties["CssProperty"]({
    name: 'borderTopColor',
    cssName: 'border-top-color',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withBorderTopColor(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: color["a" /* Color */].equals,
    valueConverter: (value) => new color["a" /* Color */](value),
});
borderTopColorProperty.register(style["a" /* Style */]);
const borderRightColorProperty = new properties["CssProperty"]({
    name: 'borderRightColor',
    cssName: 'border-right-color',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withBorderRightColor(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: color["a" /* Color */].equals,
    valueConverter: (value) => new color["a" /* Color */](value),
});
borderRightColorProperty.register(style["a" /* Style */]);
const borderBottomColorProperty = new properties["CssProperty"]({
    name: 'borderBottomColor',
    cssName: 'border-bottom-color',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withBorderBottomColor(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: color["a" /* Color */].equals,
    valueConverter: (value) => new color["a" /* Color */](value),
});
borderBottomColorProperty.register(style["a" /* Style */]);
const borderLeftColorProperty = new properties["CssProperty"]({
    name: 'borderLeftColor',
    cssName: 'border-left-color',
    valueChanged: (target, oldValue, newValue) => {
        const background = target.backgroundInternal.withBorderLeftColor(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: color["a" /* Color */].equals,
    valueConverter: (value) => new color["a" /* Color */](value),
});
borderLeftColorProperty.register(style["a" /* Style */]);
// Border Width properties.
const borderWidthProperty = new properties["ShorthandProperty"]({
    name: 'borderWidth',
    cssName: 'border-width',
    getter: function () {
        if (Length.equals(this.borderTopWidth, this.borderRightWidth) && Length.equals(this.borderTopWidth, this.borderBottomWidth) && Length.equals(this.borderTopWidth, this.borderLeftWidth)) {
            return this.borderTopWidth;
        }
        else {
            return `${Length.convertToString(this.borderTopWidth)} ${Length.convertToString(this.borderRightWidth)} ${Length.convertToString(this.borderBottomWidth)} ${Length.convertToString(this.borderLeftWidth)}`;
        }
    },
    converter: function (value) {
        if (typeof value === 'string' && value !== 'auto') {
            let borderWidths = parseThickness(value);
            return [
                [borderTopWidthProperty, borderWidths.top],
                [borderRightWidthProperty, borderWidths.right],
                [borderBottomWidthProperty, borderWidths.bottom],
                [borderLeftWidthProperty, borderWidths.left],
            ];
        }
        else {
            return [
                [borderTopWidthProperty, value],
                [borderRightWidthProperty, value],
                [borderBottomWidthProperty, value],
                [borderLeftWidthProperty, value],
            ];
        }
    },
});
borderWidthProperty.register(style["a" /* Style */]);
const borderTopWidthProperty = new properties["CssProperty"]({
    name: 'borderTopWidth',
    cssName: 'border-top-width',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-top-width should be Non-Negative Finite number. Value: ${value}`);
        }
        const view = target.viewRef.get();
        if (view) {
            view.effectiveBorderTopWidth = value;
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
        const background = target.backgroundInternal.withBorderTopWidth(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderTopWidthProperty.register(style["a" /* Style */]);
const borderRightWidthProperty = new properties["CssProperty"]({
    name: 'borderRightWidth',
    cssName: 'border-right-width',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-right-width should be Non-Negative Finite number. Value: ${value}`);
        }
        const view = target.viewRef.get();
        if (view) {
            view.effectiveBorderRightWidth = value;
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
        const background = target.backgroundInternal.withBorderRightWidth(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderRightWidthProperty.register(style["a" /* Style */]);
const borderBottomWidthProperty = new properties["CssProperty"]({
    name: 'borderBottomWidth',
    cssName: 'border-bottom-width',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-bottom-width should be Non-Negative Finite number. Value: ${value}`);
        }
        const view = target.viewRef.get();
        if (view) {
            view.effectiveBorderBottomWidth = value;
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
        const background = target.backgroundInternal.withBorderBottomWidth(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderBottomWidthProperty.register(style["a" /* Style */]);
const borderLeftWidthProperty = new properties["CssProperty"]({
    name: 'borderLeftWidth',
    cssName: 'border-left-width',
    defaultValue: zeroLength,
    affectsLayout: true,
    equalityComparer: Length.equals,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-left-width should be Non-Negative Finite number. Value: ${value}`);
        }
        const view = target.viewRef.get();
        if (view) {
            view.effectiveBorderLeftWidth = value;
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
        const background = target.backgroundInternal.withBorderLeftWidth(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderLeftWidthProperty.register(style["a" /* Style */]);
// Border Radius properties.
const borderRadiusProperty = new properties["ShorthandProperty"]({
    name: 'borderRadius',
    cssName: 'border-radius',
    getter: function () {
        if (Length.equals(this.borderTopLeftRadius, this.borderTopRightRadius) && Length.equals(this.borderTopLeftRadius, this.borderBottomRightRadius) && Length.equals(this.borderTopLeftRadius, this.borderBottomLeftRadius)) {
            return this.borderTopLeftRadius;
        }
        return `${Length.convertToString(this.borderTopLeftRadius)} ${Length.convertToString(this.borderTopRightRadius)} ${Length.convertToString(this.borderBottomRightRadius)} ${Length.convertToString(this.borderBottomLeftRadius)}`;
    },
    converter: function (value) {
        if (typeof value === 'string') {
            let borderRadius = parseThickness(value);
            return [
                [borderTopLeftRadiusProperty, borderRadius.top],
                [borderTopRightRadiusProperty, borderRadius.right],
                [borderBottomRightRadiusProperty, borderRadius.bottom],
                [borderBottomLeftRadiusProperty, borderRadius.left],
            ];
        }
        else {
            return [
                [borderTopLeftRadiusProperty, value],
                [borderTopRightRadiusProperty, value],
                [borderBottomRightRadiusProperty, value],
                [borderBottomLeftRadiusProperty, value],
            ];
        }
    },
});
borderRadiusProperty.register(style["a" /* Style */]);
const borderTopLeftRadiusProperty = new properties["CssProperty"]({
    name: 'borderTopLeftRadius',
    cssName: 'border-top-left-radius',
    defaultValue: 0,
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-top-left-radius should be Non-Negative Finite number. Value: ${value}`);
        }
        const background = target.backgroundInternal.withBorderTopLeftRadius(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderTopLeftRadiusProperty.register(style["a" /* Style */]);
const borderTopRightRadiusProperty = new properties["CssProperty"]({
    name: 'borderTopRightRadius',
    cssName: 'border-top-right-radius',
    defaultValue: 0,
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-top-right-radius should be Non-Negative Finite number. Value: ${value}`);
        }
        const background = target.backgroundInternal.withBorderTopRightRadius(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderTopRightRadiusProperty.register(style["a" /* Style */]);
const borderBottomRightRadiusProperty = new properties["CssProperty"]({
    name: 'borderBottomRightRadius',
    cssName: 'border-bottom-right-radius',
    defaultValue: 0,
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-bottom-right-radius should be Non-Negative Finite number. Value: ${value}`);
        }
        const background = target.backgroundInternal.withBorderBottomRightRadius(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderBottomRightRadiusProperty.register(style["a" /* Style */]);
const borderBottomLeftRadiusProperty = new properties["CssProperty"]({
    name: 'borderBottomLeftRadius',
    cssName: 'border-bottom-left-radius',
    defaultValue: 0,
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        let value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error(`border-bottom-left-radius should be Non-Negative Finite number. Value: ${value}`);
        }
        const background = target.backgroundInternal.withBorderBottomLeftRadius(value);
        target.backgroundInternal = background;
    },
    valueConverter: Length.parse,
});
borderBottomLeftRadiusProperty.register(style["a" /* Style */]);
function isNonNegativeFiniteNumber(value) {
    return isFinite(value) && !isNaN(value) && value >= 0;
}
let supportedPaths = ['rect', 'circle', 'ellipse', 'polygon', 'inset'];
function isClipPathValid(value) {
    if (!value) {
        return true;
    }
    let functionName = value.substring(0, value.indexOf('(')).trim();
    return supportedPaths.indexOf(functionName) !== -1;
}
const clipPathProperty = new properties["CssProperty"]({
    name: 'clipPath',
    cssName: 'clip-path',
    valueChanged: (target, oldValue, newValue) => {
        if (!isClipPathValid(newValue)) {
            throw new Error('clip-path is not valid.');
        }
        const background = target.backgroundInternal.withClipPath(newValue);
        target.backgroundInternal = background;
    },
});
clipPathProperty.register(style["a" /* Style */]);
function isFloatValueConverter(value) {
    let newValue = parseFloat(value);
    if (isNaN(newValue)) {
        throw new Error(`Invalid value: ${newValue}`);
    }
    return newValue;
}
const zIndexProperty = new properties["CssProperty"]({
    name: 'zIndex',
    cssName: 'z-index',
    valueConverter: isFloatValueConverter,
});
zIndexProperty.register(style["a" /* Style */]);
function opacityConverter(value) {
    let newValue = parseFloat(value);
    if (!isNaN(newValue) && 0 <= newValue && newValue <= 1) {
        return newValue;
    }
    throw new Error(`Opacity should be between [0, 1]. Value: ${newValue}`);
}
const opacityProperty = new properties["CssAnimationProperty"]({
    name: 'opacity',
    cssName: 'opacity',
    defaultValue: 1,
    valueConverter: opacityConverter,
});
opacityProperty.register(style["a" /* Style */]);
const colorProperty = new properties["InheritedCssProperty"]({
    name: 'color',
    cssName: 'color',
    equalityComparer: color["a" /* Color */].equals,
    valueConverter: (v) => new color["a" /* Color */](v),
});
colorProperty.register(style["a" /* Style */]);
const fontInternalProperty = new properties["CssProperty"]({
    name: 'fontInternal',
    cssName: '_fontInternal',
});
fontInternalProperty.register(style["a" /* Style */]);
const fontFamilyProperty = new properties["InheritedCssProperty"]({
    name: 'fontFamily',
    cssName: 'font-family',
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        let currentFont = target.fontInternal || styling_font["a" /* Font */].default;
        if (currentFont.fontFamily !== newValue) {
            const newFont = currentFont.withFontFamily(newValue);
            target.fontInternal = styling_font["a" /* Font */].equals(styling_font["a" /* Font */].default, newFont) ? properties["unsetValue"] : newFont;
        }
    },
});
fontFamilyProperty.register(style["a" /* Style */]);
const fontSizeProperty = new properties["InheritedCssProperty"]({
    name: 'fontSize',
    cssName: 'font-size',
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        if (target.viewRef['handleFontSize'] === true) {
            return;
        }
        let currentFont = target.fontInternal || styling_font["a" /* Font */].default;
        if (currentFont.fontSize !== newValue) {
            const newFont = currentFont.withFontSize(newValue);
            target.fontInternal = styling_font["a" /* Font */].equals(styling_font["a" /* Font */].default, newFont) ? properties["unsetValue"] : newFont;
        }
    },
    valueConverter: (v) => parseFloat(v),
});
fontSizeProperty.register(style["a" /* Style */]);
const fontStyleProperty = new properties["InheritedCssProperty"]({
    name: 'fontStyle',
    cssName: 'font-style',
    affectsLayout: true,
    defaultValue: font_common["b" /* FontStyle */].NORMAL,
    valueConverter: font_common["b" /* FontStyle */].parse,
    valueChanged: (target, oldValue, newValue) => {
        let currentFont = target.fontInternal || styling_font["a" /* Font */].default;
        if (currentFont.fontStyle !== newValue) {
            const newFont = currentFont.withFontStyle(newValue);
            target.fontInternal = styling_font["a" /* Font */].equals(styling_font["a" /* Font */].default, newFont) ? properties["unsetValue"] : newFont;
        }
    },
});
fontStyleProperty.register(style["a" /* Style */]);
const fontWeightProperty = new properties["InheritedCssProperty"]({
    name: 'fontWeight',
    cssName: 'font-weight',
    affectsLayout: true,
    defaultValue: font_common["c" /* FontWeight */].NORMAL,
    valueConverter: font_common["c" /* FontWeight */].parse,
    valueChanged: (target, oldValue, newValue) => {
        let currentFont = target.fontInternal || styling_font["a" /* Font */].default;
        if (currentFont.fontWeight !== newValue) {
            const newFont = currentFont.withFontWeight(newValue);
            target.fontInternal = styling_font["a" /* Font */].equals(styling_font["a" /* Font */].default, newFont) ? properties["unsetValue"] : newFont;
        }
    },
});
fontWeightProperty.register(style["a" /* Style */]);
const fontProperty = new properties["ShorthandProperty"]({
    name: 'font',
    cssName: 'font',
    getter: function () {
        return `${this.fontStyle} ${this.fontWeight} ${this.fontSize} ${this.fontFamily}`;
    },
    converter: function (value) {
        if (value === properties["unsetValue"]) {
            return [
                [fontStyleProperty, properties["unsetValue"]],
                [fontWeightProperty, properties["unsetValue"]],
                [fontSizeProperty, properties["unsetValue"]],
                [fontFamilyProperty, properties["unsetValue"]],
            ];
        }
        else {
            const font = Object(font_common["e" /* parseFont */])(value);
            const fontSize = parseFloat(font.fontSize);
            return [
                [fontStyleProperty, font.fontStyle],
                [fontWeightProperty, font.fontWeight],
                [fontSizeProperty, fontSize],
                [fontFamilyProperty, font.fontFamily],
            ];
        }
    },
});
fontProperty.register(style["a" /* Style */]);
var style_properties_Visibility;
(function (Visibility) {
    Visibility.VISIBLE = 'visible';
    Visibility.HIDDEN = 'hidden';
    Visibility.COLLAPSE = 'collapse';
    Visibility.isValid = Object(properties["makeValidator"])(Visibility.VISIBLE, Visibility.HIDDEN, Visibility.COLLAPSE);
    Visibility.parse = (value) => (value.toLowerCase() === 'collapsed' ? Visibility.COLLAPSE : parseStrict(value));
    const parseStrict = Object(properties["makeParser"])(Visibility.isValid);
})(style_properties_Visibility || (style_properties_Visibility = {}));
const visibilityProperty = new properties["CssProperty"]({
    name: 'visibility',
    cssName: 'visibility',
    defaultValue: style_properties_Visibility.VISIBLE,
    affectsLayout: true,
    valueConverter: style_properties_Visibility.parse,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.isCollapsed = newValue === style_properties_Visibility.COLLAPSE;
        }
        else {
            trace["a" /* Trace */].write(`${newValue} not set to view's property because ".viewRef" is cleared`, trace["a" /* Trace */].categories.Style, trace["a" /* Trace */].messageType.warn);
        }
    },
});
visibilityProperty.register(style["a" /* Style */]);
const androidElevationProperty = new properties["CssProperty"]({
    name: 'androidElevation',
    cssName: 'android-elevation',
    valueConverter: parseFloat,
});
androidElevationProperty.register(style["a" /* Style */]);
const androidDynamicElevationOffsetProperty = new properties["CssProperty"]({
    name: 'androidDynamicElevationOffset',
    cssName: 'android-dynamic-elevation-offset',
    valueConverter: parseFloat,
});
androidDynamicElevationOffsetProperty.register(style["a" /* Style */]);
//# sourceMappingURL=style-properties.js.map; 
if (false ) {} 

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return View; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContainerView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CustomLayoutView; });
/* harmony import */ var _view_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _view_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28);
/* harmony import */ var _styling_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9);
// Requires








// helpers (these are okay re-exported here)

// This one can eventually be cleaned up but causes issues with a lot of ui-suite plugins in particular if not exported here

const PFLAG_FORCE_LAYOUT = 1;
const PFLAG_MEASURED_DIMENSION_SET = 1 << 1;
const PFLAG_LAYOUT_REQUIRED = 1 << 2;
const majorVersion = _utils__WEBPACK_IMPORTED_MODULE_2__[/* iOSNativeHelper */ "a"].MajorVersion;
class View extends _view_common__WEBPACK_IMPORTED_MODULE_0__[/* ViewCommon */ "c"] {
    constructor() {
        super(...arguments);
        this._isLaidOut = false;
        this._hasTransfrom = false;
        this._privateFlags = PFLAG_LAYOUT_REQUIRED | PFLAG_FORCE_LAYOUT;
        this._suspendCATransaction = false;
    }
    get isLayoutRequired() {
        return (this._privateFlags & PFLAG_LAYOUT_REQUIRED) === PFLAG_LAYOUT_REQUIRED;
    }
    get isLayoutRequested() {
        return (this._privateFlags & PFLAG_FORCE_LAYOUT) === PFLAG_FORCE_LAYOUT;
    }
    requestLayout() {
        super.requestLayout();
        this._privateFlags |= PFLAG_FORCE_LAYOUT;
        const nativeView = this.nativeViewProtected;
        if (nativeView && nativeView.setNeedsLayout) {
            nativeView.setNeedsLayout();
        }
        if (this.viewController && this.viewController.view !== nativeView) {
            this.viewController.view.setNeedsLayout();
        }
    }
    measure(widthMeasureSpec, heightMeasureSpec) {
        let measureSpecsChanged = this._setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec);
        let forceLayout = (this._privateFlags & PFLAG_FORCE_LAYOUT) === PFLAG_FORCE_LAYOUT;
        if (forceLayout || measureSpecsChanged) {
            // first clears the measured dimension flag
            this._privateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
            // measure ourselves, this should set the measured dimension flag back
            this.onMeasure(widthMeasureSpec, heightMeasureSpec);
            this._privateFlags |= PFLAG_LAYOUT_REQUIRED;
            // flag not set, setMeasuredDimension() was not invoked, we raise
            // an exception to warn the developer
            if ((this._privateFlags & PFLAG_MEASURED_DIMENSION_SET) !== PFLAG_MEASURED_DIMENSION_SET) {
                throw new Error('onMeasure() did not set the measured dimension by calling setMeasuredDimension() ' + this);
            }
        }
    }
    layout(left, top, right, bottom, setFrame = true) {
        const { boundsChanged, sizeChanged } = this._setCurrentLayoutBounds(left, top, right, bottom);
        if (setFrame) {
            this.layoutNativeView(left, top, right, bottom);
        }
        if (boundsChanged || (this._privateFlags & PFLAG_LAYOUT_REQUIRED) === PFLAG_LAYOUT_REQUIRED) {
            let position = { left, top, right, bottom };
            if (this.nativeViewProtected && majorVersion > 10) {
                // on iOS 11+ it is possible to have a changed layout frame due to safe area insets
                // get the frame and adjust the position, so that onLayout works correctly
                const frame = this.nativeViewProtected.frame;
                position = _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].getPositionFromFrame(frame);
            }
            this.onLayout(position.left, position.top, position.right, position.bottom);
            this._privateFlags &= ~PFLAG_LAYOUT_REQUIRED;
        }
        this.updateBackground(sizeChanged);
        this._privateFlags &= ~PFLAG_FORCE_LAYOUT;
    }
    updateBackground(sizeChanged) {
        if (sizeChanged) {
            this._onSizeChanged();
        }
        else if (this._nativeBackgroundState === 'invalid') {
            const background = this.style.backgroundInternal;
            this._redrawNativeBackground(background);
        }
    }
    setMeasuredDimension(measuredWidth, measuredHeight) {
        super.setMeasuredDimension(measuredWidth, measuredHeight);
        this._privateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const view = this.nativeViewProtected;
        const width = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].getMeasureSpecMode(widthMeasureSpec);
        const height = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].getMeasureSpecMode(heightMeasureSpec);
        let nativeWidth = 0;
        let nativeHeight = 0;
        if (view) {
            const nativeSize = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].measureNativeView(view, width, widthMode, height, heightMode);
            nativeWidth = nativeSize.width;
            nativeHeight = nativeSize.height;
        }
        const measureWidth = Math.max(nativeWidth, this.effectiveMinWidth);
        const measureHeight = Math.max(nativeHeight, this.effectiveMinHeight);
        const widthAndState = View.resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = View.resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        //
    }
    _setNativeViewFrame(nativeView, frame) {
        let oldFrame = this._cachedFrame || nativeView.frame;
        if (!CGRectEqualToRect(oldFrame, frame)) {
            if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(this + ' :_setNativeViewFrame: ' + JSON.stringify(_view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].getPositionFromFrame(frame)), _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Layout);
            }
            this._cachedFrame = frame;
            let adjustedFrame = null;
            let transform = null;
            if (this._hasTransfrom) {
                // Always set identity transform before setting frame;
                transform = nativeView.layer.transform;
                nativeView.layer.transform = CATransform3DIdentity;
                nativeView.frame = frame;
            }
            else {
                nativeView.frame = frame;
            }
            adjustedFrame = this.applySafeAreaInsets(frame);
            if (adjustedFrame) {
                nativeView.frame = adjustedFrame;
            }
            if (this._hasTransfrom) {
                // re-apply the transform after the frame is adjusted
                nativeView.layer.transform = transform;
            }
            const boundsOrigin = nativeView.bounds.origin;
            const boundsFrame = adjustedFrame || frame;
            nativeView.bounds = CGRectMake(boundsOrigin.x, boundsOrigin.y, boundsFrame.size.width, boundsFrame.size.height);
            this._raiseLayoutChangedEvent();
            this._isLaidOut = true;
        }
        else if (!this._isLaidOut) {
            // Rects could be equal on the first layout and an event should be raised.
            this._raiseLayoutChangedEvent();
            // But make sure event is raised only once if rects are equal on the first layout as
            // this method is called twice with equal rects in landscape mode (vs only once in portrait)
            this._isLaidOut = true;
        }
    }
    get isLayoutValid() {
        if (this.nativeViewProtected) {
            return this._isLayoutValid;
        }
        return false;
    }
    layoutNativeView(left, top, right, bottom) {
        if (!this.nativeViewProtected) {
            return;
        }
        const nativeView = this.nativeViewProtected;
        const frame = _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].getFrameFromPosition({
            left,
            top,
            right,
            bottom,
        });
        this._setNativeViewFrame(nativeView, frame);
    }
    _layoutParent() {
        if (this.nativeViewProtected) {
            const frame = this.nativeViewProtected.frame;
            const origin = frame.origin;
            const size = frame.size;
            const left = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(origin.x);
            const top = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(origin.y);
            const width = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(size.width);
            const height = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(size.height);
            this._setLayoutFlags(left, top, width + left, height + top);
        }
        super._layoutParent();
    }
    _setLayoutFlags(left, top, right, bottom) {
        const width = right - left;
        const height = bottom - top;
        const widthSpec = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].makeMeasureSpec(width, _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].EXACTLY);
        const heightSpec = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].makeMeasureSpec(height, _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].EXACTLY);
        this._setCurrentMeasureSpecs(widthSpec, heightSpec);
        this._privateFlags &= ~PFLAG_FORCE_LAYOUT;
        this.setMeasuredDimension(width, height);
        const { sizeChanged } = this._setCurrentLayoutBounds(left, top, right, bottom);
        this.updateBackground(sizeChanged);
        this._privateFlags &= ~PFLAG_LAYOUT_REQUIRED;
    }
    focus() {
        if (this.ios) {
            return this.ios.becomeFirstResponder();
        }
        return false;
    }
    applySafeAreaInsets(frame) {
        if (majorVersion <= 10) {
            return null;
        }
        if (!this.iosOverflowSafeArea || !this.iosOverflowSafeAreaEnabled) {
            return _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].shrinkToSafeArea(this, frame);
        }
        else if (this.nativeViewProtected && this.nativeViewProtected.window) {
            return _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].expandBeyondSafeArea(this, frame);
        }
        return null;
    }
    getSafeAreaInsets() {
        const safeAreaInsets = this.nativeViewProtected && this.nativeViewProtected.safeAreaInsets;
        let insets = { left: 0, top: 0, right: 0, bottom: 0 };
        if (safeAreaInsets) {
            insets.left = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(safeAreaInsets.left));
            insets.top = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(safeAreaInsets.top));
            insets.right = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(safeAreaInsets.right));
            insets.bottom = _utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(safeAreaInsets.bottom));
        }
        return insets;
    }
    getLocationInWindow() {
        if (!this.nativeViewProtected || !this.nativeViewProtected.window) {
            return undefined;
        }
        const pointInWindow = this.nativeViewProtected.convertPointToView(this.nativeViewProtected.bounds.origin, null);
        return {
            x: pointInWindow.x,
            y: pointInWindow.y,
        };
    }
    getLocationOnScreen() {
        if (!this.nativeViewProtected || !this.nativeViewProtected.window) {
            return undefined;
        }
        const pointInWindow = this.nativeViewProtected.convertPointToView(this.nativeViewProtected.bounds.origin, null);
        const pointOnScreen = this.nativeViewProtected.window.convertPointToWindow(pointInWindow, null);
        return {
            x: pointOnScreen.x,
            y: pointOnScreen.y,
        };
    }
    getLocationRelativeTo(otherView) {
        if (!this.nativeViewProtected || !this.nativeViewProtected.window || !otherView.nativeViewProtected || !otherView.nativeViewProtected.window || this.nativeViewProtected.window !== otherView.nativeViewProtected.window) {
            return undefined;
        }
        const myPointInWindow = this.nativeViewProtected.convertPointToView(this.nativeViewProtected.bounds.origin, null);
        const otherPointInWindow = otherView.nativeViewProtected.convertPointToView(otherView.nativeViewProtected.bounds.origin, null);
        return {
            x: myPointInWindow.x - otherPointInWindow.x,
            y: myPointInWindow.y - otherPointInWindow.y,
        };
    }
    _onSizeChanged() {
        const nativeView = this.nativeViewProtected;
        if (!nativeView) {
            return;
        }
        const background = this.style.backgroundInternal;
        const backgroundDependsOnSize = background.image || !background.hasUniformBorder() || background.hasBorderRadius();
        if (this._nativeBackgroundState === 'invalid' || (this._nativeBackgroundState === 'drawn' && backgroundDependsOnSize)) {
            this._redrawNativeBackground(background);
        }
        const clipPath = this.style.clipPath;
        if (clipPath !== '' && this[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["clipPathProperty"].setNative]) {
            this[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["clipPathProperty"].setNative](clipPath);
        }
    }
    updateNativeTransform() {
        const scaleX = this.scaleX || 1e-6;
        const scaleY = this.scaleY || 1e-6;
        const perspective = this.perspective || 300;
        let transform = new CATransform3D(CATransform3DIdentity);
        // Only set perspective if there is 3D rotation
        if (this.rotateX || this.rotateY) {
            transform.m34 = -1 / perspective;
        }
        transform = CATransform3DTranslate(transform, this.translateX, this.translateY, 0);
        transform = _utils__WEBPACK_IMPORTED_MODULE_2__[/* iOSNativeHelper */ "a"].applyRotateTransform(transform, this.rotateX, this.rotateY, this.rotate);
        transform = CATransform3DScale(transform, scaleX, scaleY, 1);
        if (!CATransform3DEqualToTransform(this.nativeViewProtected.layer.transform, transform)) {
            const updateSuspended = this._isPresentationLayerUpdateSuspeneded();
            if (!updateSuspended) {
                CATransaction.begin();
            }
            this.nativeViewProtected.layer.transform = transform;
            this._hasTransfrom = this.nativeViewProtected && !CATransform3DEqualToTransform(this.nativeViewProtected.transform3D, CATransform3DIdentity);
            if (!updateSuspended) {
                CATransaction.commit();
            }
        }
    }
    updateOriginPoint(originX, originY) {
        const newPoint = CGPointMake(originX, originY);
        this.nativeViewProtected.layer.anchorPoint = newPoint;
        if (this._cachedFrame) {
            this._setNativeViewFrame(this.nativeViewProtected, this._cachedFrame);
        }
    }
    // By default we update the view's presentation layer when setting backgroundColor and opacity properties.
    // This is done by calling CATransaction begin and commit methods.
    // This action should be disabled when updating those properties during an animation.
    _suspendPresentationLayerUpdates() {
        this._suspendCATransaction = true;
    }
    _resumePresentationLayerUpdates() {
        this._suspendCATransaction = false;
    }
    _isPresentationLayerUpdateSuspeneded() {
        return this._suspendCATransaction || this._suspendNativeUpdatesCount > 0;
    }
    _showNativeModalView(parent, options) {
        const parentWithController = _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].getParentWithViewController(parent);
        if (!parentWithController) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(`Could not find parent with viewController for ${parent} while showing modal view.`, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.ViewHierarchy, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.error);
            return;
        }
        const parentController = parentWithController.viewController;
        if (parentController.presentedViewController) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Parent is already presenting view controller. Close the current modal page before showing another one!', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.ViewHierarchy, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.error);
            return;
        }
        if (!parentController.view || !parentController.view.window) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Parent page is not part of the window hierarchy.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.ViewHierarchy, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.error);
            return;
        }
        this._setupAsRootView({});
        super._showNativeModalView(parentWithController, options);
        let controller = this.viewController;
        if (!controller) {
            const nativeView = this.ios || this.nativeViewProtected;
            controller = _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].UILayoutViewController.initWithOwner(new WeakRef(this));
            if (nativeView instanceof UIView) {
                controller.view.addSubview(nativeView);
            }
            this.viewController = controller;
        }
        if (options.fullscreen) {
            controller.modalPresentationStyle = 0 /* FullScreen */;
        }
        else {
            controller.modalPresentationStyle = 2 /* FormSheet */;
            //check whether both height and width is provided and are positive numbers
            // set it has prefered content size to the controller presenting the dialog
            if (options.ios && options.ios.width > 0 && options.ios.height > 0) {
                controller.preferredContentSize = CGSizeMake(options.ios.width, options.ios.height);
            }
            else {
                //use CSS & attribute width & height if option is not provided
                let handler = () => {
                    let w = (this.width || this.style.width);
                    let h = (this.height || this.style.height);
                    //TODO: only numeric value is supported, percentage value is not supported like Android
                    if (w > 0 && h > 0) {
                        controller.preferredContentSize = CGSizeMake(w, h);
                    }
                    this.off(View.loadedEvent, handler);
                };
                this.on(View.loadedEvent, handler);
            }
        }
        if (options.ios && options.ios.presentationStyle) {
            const presentationStyle = options.ios.presentationStyle;
            controller.modalPresentationStyle = presentationStyle;
            if (presentationStyle === 7 /* Popover */) {
                this._setupPopoverControllerDelegate(controller, parent);
            }
        }
        const cancelable = options.cancelable !== undefined ? !!options.cancelable : true;
        if (majorVersion >= 13) {
            if (cancelable) {
                // Listen for dismiss modal callback.
                this._setupAdaptiveControllerDelegate(controller);
            }
            else {
                // Prevent users from dismissing the modal.
                controller.modalInPresentation = true;
            }
        }
        this.horizontalAlignment = 'stretch';
        this.verticalAlignment = 'stretch';
        this._raiseShowingModallyEvent();
        const animated = options.animated === undefined ? true : !!options.animated;
        if (!this._modalAnimatedOptions) {
            // track the user's animated options to use upon close as well
            this._modalAnimatedOptions = [];
        }
        this._modalAnimatedOptions.push(animated);
        parentController.presentViewControllerAnimatedCompletion(controller, animated, null);
        const transitionCoordinator = parentController.transitionCoordinator;
        if (transitionCoordinator) {
            transitionCoordinator.animateAlongsideTransitionCompletion(null, () => this._raiseShownModallyEvent());
        }
        else {
            // Apparently iOS 9+ stops all transitions and animations upon application suspend and transitionCoordinator becomes null here in this case.
            // Since we are not waiting for any transition to complete, i.e. transitionCoordinator is null, we can directly raise our shownModally event.
            // Take a look at https://github.com/NativeScript/NativeScript/issues/2173 for more info and a sample project.
            this._raiseShownModallyEvent();
        }
    }
    _hideNativeModalView(parent, whenClosedCallback) {
        if (!parent || !parent.viewController) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].error('Trying to hide modal view but no parent with viewController specified.');
            return;
        }
        // modal view has already been closed by UI, probably as a popover
        if (!parent.viewController.presentedViewController) {
            whenClosedCallback();
            return;
        }
        const parentController = parent.viewController;
        const animated = this._modalAnimatedOptions ? !!this._modalAnimatedOptions.pop() : true;
        parentController.dismissViewControllerAnimatedCompletion(animated, whenClosedCallback);
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* isEnabledProperty */ "e"].getDefault]() {
        const nativeView = this.nativeViewProtected;
        return nativeView instanceof UIControl ? nativeView.enabled : true;
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* isEnabledProperty */ "e"].setNative](value) {
        const nativeView = this.nativeViewProtected;
        if (nativeView instanceof UIControl) {
            nativeView.enabled = value;
        }
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* originXProperty */ "g"].getDefault]() {
        return this.nativeViewProtected.layer.anchorPoint.x;
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* originXProperty */ "g"].setNative](value) {
        this.updateOriginPoint(value, this.originY);
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* originYProperty */ "h"].getDefault]() {
        return this.nativeViewProtected.layer.anchorPoint.y;
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* originYProperty */ "h"].setNative](value) {
        this.updateOriginPoint(this.originX, value);
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* automationTextProperty */ "d"].getDefault]() {
        return this.nativeViewProtected.accessibilityLabel;
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* automationTextProperty */ "d"].setNative](value) {
        this.nativeViewProtected.accessibilityIdentifier = value;
        this.nativeViewProtected.accessibilityLabel = value;
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* isUserInteractionEnabledProperty */ "f"].getDefault]() {
        return this.nativeViewProtected.userInteractionEnabled;
    }
    [_view_common__WEBPACK_IMPORTED_MODULE_0__[/* isUserInteractionEnabledProperty */ "f"].setNative](value) {
        this.nativeViewProtected.userInteractionEnabled = value;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["visibilityProperty"].getDefault]() {
        return this.nativeViewProtected.hidden ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].COLLAPSE : _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].VISIBLE;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["visibilityProperty"].setNative](value) {
        switch (value) {
            case _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].VISIBLE:
                this.nativeViewProtected.hidden = false;
                break;
            case _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].HIDDEN:
            case _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].COLLAPSE:
                this.nativeViewProtected.hidden = true;
                break;
            default:
                throw new Error(`Invalid visibility value: ${value}. Valid values are: "${_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].VISIBLE}", "${_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].HIDDEN}", "${_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Visibility"].COLLAPSE}".`);
        }
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["opacityProperty"].getDefault]() {
        return this.nativeViewProtected.alpha;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["opacityProperty"].setNative](value) {
        let nativeView = this.nativeViewProtected;
        let updateSuspended = this._isPresentationLayerUpdateSuspeneded();
        if (!updateSuspended) {
            CATransaction.begin();
        }
        nativeView.alpha = value;
        if (!updateSuspended) {
            CATransaction.commit();
        }
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["rotateProperty"].getDefault]() {
        return 0;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["rotateProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["rotateXProperty"].getDefault]() {
        return 0;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["rotateXProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["rotateYProperty"].getDefault]() {
        return 0;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["rotateYProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["perspectiveProperty"].getDefault]() {
        return 300;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["perspectiveProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["scaleXProperty"].getDefault]() {
        return 1;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["scaleXProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["scaleYProperty"].getDefault]() {
        return 1;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["scaleYProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["translateXProperty"].getDefault]() {
        return 0;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["translateXProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["translateYProperty"].getDefault]() {
        return 0;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["translateYProperty"].setNative](value) {
        this.updateNativeTransform();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["zIndexProperty"].getDefault]() {
        return 0;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["zIndexProperty"].setNative](value) {
        this.nativeViewProtected.layer.zPosition = value;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["backgroundInternalProperty"].getDefault]() {
        return this.nativeViewProtected.backgroundColor;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["backgroundInternalProperty"].setNative](value) {
        this._nativeBackgroundState = 'invalid';
        if (this.isLayoutValid) {
            this._redrawNativeBackground(value);
        }
    }
    _getCurrentLayoutBounds() {
        const nativeView = this.nativeViewProtected;
        if (nativeView && !this.isCollapsed) {
            const frame = nativeView.frame;
            const origin = frame.origin;
            const size = frame.size;
            return {
                left: Math.round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(origin.x)),
                top: Math.round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(origin.y)),
                right: Math.round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(origin.x + size.width)),
                bottom: Math.round(_utils__WEBPACK_IMPORTED_MODULE_3__[/* layout */ "n"].toDevicePixels(origin.y + size.height)),
            };
        }
        else {
            return { left: 0, top: 0, right: 0, bottom: 0 };
        }
    }
    _redrawNativeBackground(value) {
        let updateSuspended = this._isPresentationLayerUpdateSuspeneded();
        if (!updateSuspended) {
            CATransaction.begin();
        }
        if (value instanceof UIColor) {
            this.nativeViewProtected.backgroundColor = value;
        }
        else {
            _styling_background__WEBPACK_IMPORTED_MODULE_5__[/* ios */ "a"].createBackgroundUIColor(this, (color) => {
                this.nativeViewProtected.backgroundColor = color;
            });
            this._setNativeClipToBounds();
        }
        if (!updateSuspended) {
            CATransaction.commit();
        }
        this._nativeBackgroundState = 'drawn';
    }
    _setNativeClipToBounds() {
        const backgroundInternal = this.style.backgroundInternal;
        this.nativeViewProtected.clipsToBounds = this.nativeViewProtected instanceof UIScrollView || backgroundInternal.hasBorderWidth() || backgroundInternal.hasBorderRadius();
    }
    _setupPopoverControllerDelegate(controller, parent) {
        const popoverPresentationController = controller.popoverPresentationController;
        this._popoverPresentationDelegate = _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].UIPopoverPresentationControllerDelegateImp.initWithOwnerAndCallback(new WeakRef(this), this._closeModalCallback);
        popoverPresentationController.delegate = this._popoverPresentationDelegate;
        const view = parent.nativeViewProtected;
        // Note: sourceView and sourceRect are needed to specify the anchor location for the popover.
        // Note: sourceView should be the button triggering the modal. If it the Page the popover might appear "behind" the page content
        popoverPresentationController.sourceView = view;
        popoverPresentationController.sourceRect = CGRectMake(0, 0, view.frame.size.width, view.frame.size.height);
    }
    _setupAdaptiveControllerDelegate(controller) {
        this._adaptivePresentationDelegate = _view_helper__WEBPACK_IMPORTED_MODULE_4__[/* IOSHelper */ "a"].UIAdaptivePresentationControllerDelegateImp.initWithOwnerAndCallback(new WeakRef(this), this._closeModalCallback);
        controller.presentationController.delegate = this._adaptivePresentationDelegate;
    }
}
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_7__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number, Number, Number, Object]),
    __metadata("design:returntype", void 0)
], View.prototype, "layout", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_7__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", void 0)
], View.prototype, "onMeasure", null);
View.prototype._nativeBackgroundState = 'unset';
class ContainerView extends View {
    constructor() {
        super();
        this.iosOverflowSafeArea = true;
    }
}
class CustomLayoutView extends ContainerView {
    createNativeView() {
        return UIView.alloc().initWithFrame(UIScreen.mainScreen.bounds);
    }
    get ios() {
        return this.nativeViewProtected;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        // Don't call super because it will set MeasureDimension. This method must be overriden and calculate its measuredDimensions.
    }
    _addViewToNativeVisualTree(child, atIndex) {
        super._addViewToNativeVisualTree(child, atIndex);
        const parentNativeView = this.nativeViewProtected;
        const childNativeView = child.nativeViewProtected;
        if (parentNativeView && childNativeView) {
            if (typeof atIndex !== 'number' || atIndex >= parentNativeView.subviews.count) {
                parentNativeView.addSubview(childNativeView);
            }
            else {
                parentNativeView.insertSubviewAtIndex(childNativeView, atIndex);
            }
            return true;
        }
        return false;
    }
    _removeViewFromNativeVisualTree(child) {
        super._removeViewFromNativeVisualTree(child);
        if (child.nativeViewProtected) {
            child.nativeViewProtected.removeFromSuperview();
        }
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ layout_helper_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ mainthread_helper["a" /* dispatchToMainThread */]; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ mainthread_helper["b" /* isMainThread */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ RESOURCE_PREFIX; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ FILE_PREFIX; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ escapeRegexSymbols; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ convertString; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ getModuleName; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ isFileOrResourcePath; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ isFontIconURI; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ isDataURI; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* binding */ mergeSort; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* binding */ merge; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ hasDuplicates; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ eliminateDuplicates; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ executeOnMainThread; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* binding */ mainThreadify; });

// NAMESPACE OBJECT: ../node_modules/@nativescript/core/utils/layout-helper/index.js
var layout_helper_namespaceObject = {};
__webpack_require__.r(layout_helper_namespaceObject);
__webpack_require__.d(layout_helper_namespaceObject, "MODE_SHIFT", function() { return MODE_SHIFT; });
__webpack_require__.d(layout_helper_namespaceObject, "MODE_MASK", function() { return MODE_MASK; });
__webpack_require__.d(layout_helper_namespaceObject, "UNSPECIFIED", function() { return UNSPECIFIED; });
__webpack_require__.d(layout_helper_namespaceObject, "EXACTLY", function() { return EXACTLY; });
__webpack_require__.d(layout_helper_namespaceObject, "AT_MOST", function() { return AT_MOST; });
__webpack_require__.d(layout_helper_namespaceObject, "MEASURED_HEIGHT_STATE_SHIFT", function() { return MEASURED_HEIGHT_STATE_SHIFT; });
__webpack_require__.d(layout_helper_namespaceObject, "MEASURED_STATE_TOO_SMALL", function() { return MEASURED_STATE_TOO_SMALL; });
__webpack_require__.d(layout_helper_namespaceObject, "MEASURED_STATE_MASK", function() { return MEASURED_STATE_MASK; });
__webpack_require__.d(layout_helper_namespaceObject, "MEASURED_SIZE_MASK", function() { return MEASURED_SIZE_MASK; });
__webpack_require__.d(layout_helper_namespaceObject, "getMode", function() { return getMode; });
__webpack_require__.d(layout_helper_namespaceObject, "getMeasureSpecMode", function() { return getMeasureSpecMode; });
__webpack_require__.d(layout_helper_namespaceObject, "getMeasureSpecSize", function() { return getMeasureSpecSize; });
__webpack_require__.d(layout_helper_namespaceObject, "measureSpecToString", function() { return measureSpecToString; });
__webpack_require__.d(layout_helper_namespaceObject, "round", function() { return round; });
__webpack_require__.d(layout_helper_namespaceObject, "makeMeasureSpec", function() { return makeMeasureSpec; });
__webpack_require__.d(layout_helper_namespaceObject, "getDisplayDensity", function() { return getDisplayDensity; });
__webpack_require__.d(layout_helper_namespaceObject, "toDevicePixels", function() { return toDevicePixels; });
__webpack_require__.d(layout_helper_namespaceObject, "toDeviceIndependentPixels", function() { return toDeviceIndependentPixels; });
__webpack_require__.d(layout_helper_namespaceObject, "measureNativeView", function() { return measureNativeView; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/types.js
var types = __webpack_require__(10);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/mainthread-helper.js
var mainthread_helper = __webpack_require__(77);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/builder/module-name-sanitizer.js
var module_name_sanitizer = __webpack_require__(37);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/utils/layout-helper/layout-helper-common.js
// cache the MeasureSpec constants here, to prevent extensive marshaling calls to and from Java
// TODO: While this boosts the performance it is error-prone in case Google changes these constants
const MODE_SHIFT = 30;
const MODE_MASK = 0x3 << MODE_SHIFT;
const UNSPECIFIED = 0 << MODE_SHIFT;
const EXACTLY = 1 << MODE_SHIFT;
const AT_MOST = 2 << MODE_SHIFT;
const MEASURED_HEIGHT_STATE_SHIFT = 0x00000010; /* 16 */
const MEASURED_STATE_TOO_SMALL = 0x01000000;
const MEASURED_STATE_MASK = 0xff000000;
const MEASURED_SIZE_MASK = 0x00ffffff;
function getMode(mode) {
    switch (mode) {
        case EXACTLY:
            return 'Exact';
        case AT_MOST:
            return 'AtMost';
        default:
            return 'Unspecified';
    }
}
function getMeasureSpecMode(spec) {
    return spec & MODE_MASK;
}
function getMeasureSpecSize(spec) {
    return spec & ~MODE_MASK;
}
function measureSpecToString(measureSpec) {
    const mode = getMeasureSpecMode(measureSpec);
    const size = getMeasureSpecSize(measureSpec);
    let text = 'MeasureSpec: ';
    if (mode === UNSPECIFIED) {
        text += 'UNSPECIFIED ';
    }
    else if (mode === EXACTLY) {
        text += 'EXACTLY ';
    }
    else if (mode === AT_MOST) {
        text += 'AT_MOST ';
    }
    text += size;
    return text;
}
function round(value) {
    const res = Math.floor(value + 0.5);
    if (res !== 0) {
        return res;
    }
    else if (value === 0) {
        return 0;
    }
    else if (value > 0) {
        return 1;
    }
    return -1;
}
//# sourceMappingURL=layout-helper-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/utils/layout-helper/index.js


function makeMeasureSpec(size, mode) {
    return (Math.round(Math.max(0, size)) & ~MODE_MASK) | (mode & MODE_MASK);
}
function getDisplayDensity() {
    return UIScreen.mainScreen.scale;
}
function toDevicePixels(value) {
    return value * UIScreen.mainScreen.scale;
}
function toDeviceIndependentPixels(value) {
    return value / UIScreen.mainScreen.scale;
}
function measureNativeView(nativeView /* UIView */, width, widthMode, height, heightMode) {
    const view = nativeView;
    const nativeSize = view.sizeThatFits({
        width: widthMode === 0 /* layout.UNSPECIFIED */ ? Number.POSITIVE_INFINITY : toDeviceIndependentPixels(width),
        height: heightMode === 0 /* layout.UNSPECIFIED */ ? Number.POSITIVE_INFINITY : toDeviceIndependentPixels(height),
    });
    nativeSize.width = round(toDevicePixels(nativeSize.width));
    nativeSize.height = round(toDevicePixels(nativeSize.height));
    return nativeSize;
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/utils/utils-common.js






const RESOURCE_PREFIX = 'res://';
const FILE_PREFIX = 'file:///';
function escapeRegexSymbols(source) {
    let escapeRegex = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;
    return source.replace(escapeRegex, '\\$&');
}
function convertString(value) {
    let result;
    if (!types["k" /* isString */](value) || value.trim() === '') {
        result = value;
    }
    else {
        // Try to convert value to number.
        const valueAsNumber = +value;
        if (!isNaN(valueAsNumber)) {
            result = valueAsNumber;
        }
        else if (value && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
            result = value.toLowerCase() === 'true' ? true : false;
        }
        else {
            result = value;
        }
    }
    return result;
}
function getModuleName(path) {
    let moduleName = path.replace('./', '');
    return Object(module_name_sanitizer["a" /* sanitizeModuleName */])(moduleName);
}
function isFileOrResourcePath(path) {
    if (!types["k" /* isString */](path)) {
        return false;
    }
    return (path.indexOf('~/') === 0 || // relative to AppRoot
        path.indexOf('/') === 0 || // absolute path
        path.indexOf(RESOURCE_PREFIX) === 0); // resource
}
function isFontIconURI(uri) {
    if (!types["k" /* isString */](uri)) {
        return false;
    }
    const firstSegment = uri.trim().split('//')[0];
    return firstSegment && firstSegment.indexOf('font:') === 0;
}
function isDataURI(uri) {
    if (!types["k" /* isString */](uri)) {
        return false;
    }
    const firstSegment = uri.trim().split(',')[0];
    return firstSegment && firstSegment.indexOf('data:') === 0 && firstSegment.indexOf('base64') >= 0;
}
function mergeSort(arr, compareFunc) {
    if (arr.length < 2) {
        return arr;
    }
    const middle = arr.length / 2;
    const left = arr.slice(0, middle);
    const right = arr.slice(middle, arr.length);
    return merge(mergeSort(left, compareFunc), mergeSort(right, compareFunc), compareFunc);
}
function merge(left, right, compareFunc) {
    let result = [];
    while (left.length && right.length) {
        if (compareFunc(left[0], right[0]) <= 0) {
            result.push(left.shift());
        }
        else {
            result.push(right.shift());
        }
    }
    while (left.length) {
        result.push(left.shift());
    }
    while (right.length) {
        result.push(right.shift());
    }
    return result;
}
function hasDuplicates(arr) {
    return arr.length !== eliminateDuplicates(arr).length;
}
function eliminateDuplicates(arr) {
    return Array.from(new Set(arr));
}
function executeOnMainThread(func) {
    if (Object(mainthread_helper["b" /* isMainThread */])()) {
        return func();
    }
    else {
        Object(mainthread_helper["a" /* dispatchToMainThread */])(func);
    }
}
function mainThreadify(func) {
    return function () {
        const argsToPass = arguments;
        executeOnMainThread(() => func.apply(this, argsToPass));
    };
}
//# sourceMappingURL=utils-common.js.map; 
if (false ) {} 

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrappedValue", function() { return WrappedValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromObject", function() { return fromObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromObjectRecursive", function() { return fromObjectRecursive; });
let _wrappedIndex = 0;
class WrappedValue {
    constructor(wrapped) {
        this.wrapped = wrapped;
    }
    static unwrap(value) {
        return value instanceof WrappedValue ? value.wrapped : value;
    }
    static wrap(value) {
        const w = _wrappedValues[_wrappedIndex++ % 5];
        w.wrapped = value;
        return w;
    }
}
const _wrappedValues = [new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null)];
const _globalEventHandlers = {};
class Observable {
    constructor() {
        this._observers = {};
    }
    get(name) {
        return this[name];
    }
    set(name, value) {
        // TODO: Parameter validation
        const oldValue = this[name];
        if (this[name] === value) {
            return;
        }
        const newValue = WrappedValue.unwrap(value);
        this[name] = newValue;
        this.notifyPropertyChange(name, newValue, oldValue);
    }
    setProperty(name, value) {
        const oldValue = this[name];
        if (this[name] === value) {
            return;
        }
        this[name] = value;
        this.notifyPropertyChange(name, value, oldValue);
        const specificPropertyChangeEventName = name + 'Change';
        if (this.hasListeners(specificPropertyChangeEventName)) {
            const eventData = this._createPropertyChangeData(name, value, oldValue);
            eventData.eventName = specificPropertyChangeEventName;
            this.notify(eventData);
        }
    }
    on(eventNames, callback, thisArg) {
        this.addEventListener(eventNames, callback, thisArg);
    }
    once(event, callback, thisArg) {
        if (typeof event !== 'string') {
            throw new TypeError('Event must be string.');
        }
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be function.');
        }
        const list = this._getEventList(event, true);
        list.push({ callback, thisArg, once: true });
    }
    off(eventNames, callback, thisArg) {
        this.removeEventListener(eventNames, callback, thisArg);
    }
    addEventListener(eventNames, callback, thisArg) {
        if (typeof eventNames !== 'string') {
            throw new TypeError('Events name(s) must be string.');
        }
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be function.');
        }
        const events = eventNames.split(',');
        for (let i = 0, l = events.length; i < l; i++) {
            const event = events[i].trim();
            const list = this._getEventList(event, true);
            // TODO: Performance optimization - if we do not have the thisArg specified, do not wrap the callback in additional object (ObserveEntry)
            list.push({
                callback: callback,
                thisArg: thisArg,
            });
        }
    }
    removeEventListener(eventNames, callback, thisArg) {
        if (typeof eventNames !== 'string') {
            throw new TypeError('Events name(s) must be string.');
        }
        if (callback && typeof callback !== 'function') {
            throw new TypeError('callback must be function.');
        }
        const events = eventNames.split(',');
        for (let i = 0, l = events.length; i < l; i++) {
            const event = events[i].trim();
            if (callback) {
                const list = this._getEventList(event, false);
                if (list) {
                    const index = Observable._indexOfListener(list, callback, thisArg);
                    if (index >= 0) {
                        list.splice(index, 1);
                    }
                    if (list.length === 0) {
                        delete this._observers[event];
                    }
                }
            }
            else {
                this._observers[event] = undefined;
                delete this._observers[event];
            }
        }
    }
    static on(eventName, callback, thisArg) {
        this.addEventListener(eventName, callback, thisArg);
    }
    static once(eventName, callback, thisArg) {
        if (typeof eventName !== 'string') {
            throw new TypeError('Event must be string.');
        }
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be function.');
        }
        const eventClass = this.name === 'Observable' ? '*' : this.name;
        if (!_globalEventHandlers[eventClass]) {
            _globalEventHandlers[eventClass] = {};
        }
        if (!Array.isArray(_globalEventHandlers[eventClass][eventName])) {
            _globalEventHandlers[eventClass][eventName] = [];
        }
        _globalEventHandlers[eventClass][eventName].push({ callback, thisArg, once: true });
    }
    static off(eventName, callback, thisArg) {
        this.removeEventListener(eventName, callback, thisArg);
    }
    static removeEventListener(eventName, callback, thisArg) {
        if (typeof eventName !== 'string') {
            throw new TypeError('Event must be string.');
        }
        if (callback && typeof callback !== 'function') {
            throw new TypeError('callback must be function.');
        }
        const eventClass = this.name === 'Observable' ? '*' : this.name;
        // Short Circuit if no handlers exist..
        if (!_globalEventHandlers[eventClass] || !Array.isArray(_globalEventHandlers[eventClass][eventName])) {
            return;
        }
        const events = _globalEventHandlers[eventClass][eventName];
        if (thisArg) {
            for (let i = 0; i < events.length; i++) {
                if (events[i].callback === callback && events[i].thisArg === thisArg) {
                    events.splice(i, 1);
                    i--;
                }
            }
        }
        else if (callback) {
            for (let i = 0; i < events.length; i++) {
                if (events[i].callback === callback) {
                    events.splice(i, 1);
                    i--;
                }
            }
        }
        else {
            // Clear all events of this type
            delete _globalEventHandlers[eventClass][eventName];
        }
        if (events.length === 0) {
            // Clear all events of this type
            delete _globalEventHandlers[eventClass][eventName];
        }
        // Clear the primary class grouping if no events are left
        const keys = Object.keys(_globalEventHandlers[eventClass]);
        if (keys.length === 0) {
            delete _globalEventHandlers[eventClass];
        }
    }
    static addEventListener(eventName, callback, thisArg) {
        if (typeof eventName !== 'string') {
            throw new TypeError('Event must be string.');
        }
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be function.');
        }
        const eventClass = this.name === 'Observable' ? '*' : this.name;
        if (!_globalEventHandlers[eventClass]) {
            _globalEventHandlers[eventClass] = {};
        }
        if (!Array.isArray(_globalEventHandlers[eventClass][eventName])) {
            _globalEventHandlers[eventClass][eventName] = [];
        }
        _globalEventHandlers[eventClass][eventName].push({ callback, thisArg });
    }
    _globalNotify(eventClass, eventType, data) {
        // Check for the Global handlers for JUST this class
        if (_globalEventHandlers[eventClass]) {
            const event = data.eventName + eventType;
            const events = _globalEventHandlers[eventClass][event];
            if (events) {
                Observable._handleEvent(events, data);
            }
        }
        // Check for he Global handlers for ALL classes
        if (_globalEventHandlers['*']) {
            const event = data.eventName + eventType;
            const events = _globalEventHandlers['*'][event];
            if (events) {
                Observable._handleEvent(events, data);
            }
        }
    }
    notify(data) {
        const eventClass = this.constructor.name;
        this._globalNotify(eventClass, 'First', data);
        const observers = this._observers[data.eventName];
        if (observers) {
            Observable._handleEvent(observers, data);
        }
        this._globalNotify(eventClass, '', data);
    }
    static _handleEvent(observers, data) {
        if (!observers) {
            return;
        }
        for (let i = observers.length - 1; i >= 0; i--) {
            const entry = observers[i];
            if (entry.once) {
                observers.splice(i, 1);
            }
            if (entry.thisArg) {
                entry.callback.apply(entry.thisArg, [data]);
            }
            else {
                entry.callback(data);
            }
        }
    }
    notifyPropertyChange(name, value, oldValue) {
        this.notify(this._createPropertyChangeData(name, value, oldValue));
    }
    hasListeners(eventName) {
        return eventName in this._observers;
    }
    _createPropertyChangeData(propertyName, value, oldValue) {
        return {
            eventName: Observable.propertyChangeEvent,
            object: this,
            propertyName,
            value,
            oldValue,
        };
    }
    _emit(eventNames) {
        const events = eventNames.split(',');
        for (let i = 0, l = events.length; i < l; i++) {
            const event = events[i].trim();
            this.notify({ eventName: event, object: this });
        }
    }
    _getEventList(eventName, createIfNeeded) {
        if (!eventName) {
            throw new TypeError('EventName must be valid string.');
        }
        let list = this._observers[eventName];
        if (!list && createIfNeeded) {
            list = [];
            this._observers[eventName] = list;
        }
        return list;
    }
    static _indexOfListener(list, callback, thisArg) {
        for (let i = 0; i < list.length; i++) {
            const entry = list[i];
            if (thisArg) {
                if (entry.callback === callback && entry.thisArg === thisArg) {
                    return i;
                }
            }
            else {
                if (entry.callback === callback) {
                    return i;
                }
            }
        }
        return -1;
    }
}
Observable.propertyChangeEvent = 'propertyChange';
class ObservableFromObject extends Observable {
    constructor() {
        super(...arguments);
        this._map = {};
    }
    get(name) {
        return this._map[name];
    }
    set(name, value) {
        const currentValue = this._map[name];
        if (currentValue === value) {
            return;
        }
        const newValue = WrappedValue.unwrap(value);
        this._map[name] = newValue;
        this.notifyPropertyChange(name, newValue, currentValue);
    }
}
function defineNewProperty(target, propertyName) {
    Object.defineProperty(target, propertyName, {
        get: function () {
            return target._map[propertyName];
        },
        set: function (value) {
            target.set(propertyName, value);
        },
        enumerable: true,
        configurable: true,
    });
}
function addPropertiesFromObject(observable, source, recursive = false) {
    Object.keys(source).forEach((prop) => {
        let value = source[prop];
        if (recursive && !Array.isArray(value) && value && typeof value === 'object' && !(value instanceof Observable)) {
            value = fromObjectRecursive(value);
        }
        defineNewProperty(observable, prop);
        observable.set(prop, value);
    });
}
function fromObject(source) {
    const observable = new ObservableFromObject();
    addPropertiesFromObject(observable, source, false);
    return observable;
}
function fromObjectRecursive(source) {
    const observable = new ObservableFromObject();
    addPropertiesFromObject(observable, source, true);
    return observable;
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ color_Color; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/types.js
var types = __webpack_require__(10);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/color/known-colors.js
const _allColors = {};
function registerColor(name, value) {
    _allColors[name.toLowerCase()] = value;
    return value;
}
function isKnownName(name) {
    if (!name) {
        return undefined;
    }
    return name.toLowerCase() in _allColors;
}
function getKnownColor(name) {
    if (!name) {
        return undefined;
    }
    return _allColors[name.toLowerCase()];
}
const Transparent = registerColor('Transparent', '#00000000');
const AliceBlue = registerColor('AliceBlue', '#F0F8FF');
const AntiqueWhite = registerColor('AntiqueWhite', '#FAEBD7');
const Aqua = registerColor('Aqua', '#00FFFF');
const Aquamarine = registerColor('Aquamarine', '#7FFFD4');
const Azure = registerColor('Azure', '#F0FFFF');
const Beige = registerColor('Beige', '#F5F5DC');
const Bisque = registerColor('Bisque', '#FFE4C4');
const Black = registerColor('Black', '#000000');
const BlanchedAlmond = registerColor('BlanchedAlmond', '#FFEBCD');
const Blue = registerColor('Blue', '#0000FF');
const BlueViolet = registerColor('BlueViolet', '#8A2BE2');
const Brown = registerColor('Brown', '#A52A2A');
const BurlyWood = registerColor('BurlyWood', '#DEB887');
const CadetBlue = registerColor('CadetBlue', '#5F9EA0');
const Chartreuse = registerColor('Chartreuse', '#7FFF00');
const Chocolate = registerColor('Chocolate', '#D2691E');
const Coral = registerColor('Coral', '#FF7F50');
const CornflowerBlue = registerColor('CornflowerBlue', '#6495ED');
const Cornsilk = registerColor('Cornsilk', '#FFF8DC');
const Crimson = registerColor('Crimson', '#DC143C');
const Cyan = registerColor('Cyan', '#00FFFF');
const DarkBlue = registerColor('DarkBlue', '#00008B');
const DarkCyan = registerColor('DarkCyan', '#008B8B');
const DarkGoldenRod = registerColor('DarkGoldenRod', '#B8860B');
const DarkGray = registerColor('DarkGray', '#A9A9A9');
const DarkGreen = registerColor('DarkGreen', '#006400');
const DarkKhaki = registerColor('DarkKhaki', '#BDB76B');
const DarkMagenta = registerColor('DarkMagenta', '#8B008B');
const DarkOliveGreen = registerColor('DarkOliveGreen', '#556B2F');
const DarkOrange = registerColor('DarkOrange', '#FF8C00');
const DarkOrchid = registerColor('DarkOrchid', '#9932CC');
const DarkRed = registerColor('DarkRed', '#8B0000');
const DarkSalmon = registerColor('DarkSalmon', '#E9967A');
const DarkSeaGreen = registerColor('DarkSeaGreen', '#8FBC8F');
const DarkSlateBlue = registerColor('DarkSlateBlue', '#483D8B');
const DarkSlateGray = registerColor('DarkSlateGray', '#2F4F4F');
const DarkTurquoise = registerColor('DarkTurquoise', '#00CED1');
const DarkViolet = registerColor('DarkViolet', '#9400D3');
const DeepPink = registerColor('DeepPink', '#FF1493');
const DeepSkyBlue = registerColor('DeepSkyBlue', '#00BFFF');
const DimGray = registerColor('DimGray', '#696969');
const DodgerBlue = registerColor('DodgerBlue', '#1E90FF');
const FireBrick = registerColor('FireBrick', '#B22222');
const FloralWhite = registerColor('FloralWhite', '#FFFAF0');
const ForestGreen = registerColor('ForestGreen', '#228B22');
const Fuchsia = registerColor('Fuchsia', '#FF00FF');
const Gainsboro = registerColor('Gainsboro', '#DCDCDC');
const GhostWhite = registerColor('GhostWhite', '#F8F8FF');
const Gold = registerColor('Gold', '#FFD700');
const GoldenRod = registerColor('GoldenRod', '#DAA520');
const Gray = registerColor('Gray', '#808080');
const Green = registerColor('Green', '#008000');
const GreenYellow = registerColor('GreenYellow', '#ADFF2F');
const HoneyDew = registerColor('HoneyDew', '#F0FFF0');
const HotPink = registerColor('HotPink', '#FF69B4');
const IndianRed = registerColor('IndianRed', '#CD5C5C');
const Indigo = registerColor('Indigo', '#4B0082');
const Ivory = registerColor('Ivory', '#FFFFF0');
const Khaki = registerColor('Khaki', '#F0E68C');
const Lavender = registerColor('Lavender', '#E6E6FA');
const LavenderBlush = registerColor('LavenderBlush', '#FFF0F5');
const LawnGreen = registerColor('LawnGreen', '#7CFC00');
const LemonChiffon = registerColor('LemonChiffon', '#FFFACD');
const LightBlue = registerColor('LightBlue', '#ADD8E6');
const LightCoral = registerColor('LightCoral', '#F08080');
const LightCyan = registerColor('LightCyan', '#E0FFFF');
const LightGoldenRodYellow = registerColor('LightGoldenRodYellow', '#FAFAD2');
const LightGray = registerColor('LightGray', '#D3D3D3');
const LightGreen = registerColor('LightGreen', '#90EE90');
const LightPink = registerColor('LightPink', '#FFB6C1');
const LightSalmon = registerColor('LightSalmon', '#FFA07A');
const LightSeaGreen = registerColor('LightSeaGreen', '#20B2AA');
const LightSkyBlue = registerColor('LightSkyBlue', '#87CEFA');
const LightSlateGray = registerColor('LightSlateGray', '#778899');
const LightSteelBlue = registerColor('LightSteelBlue', '#B0C4DE');
const LightYellow = registerColor('LightYellow', '#FFFFE0');
const Lime = registerColor('Lime', '#00FF00');
const LimeGreen = registerColor('LimeGreen', '#32CD32');
const Linen = registerColor('Linen', '#FAF0E6');
const Magenta = registerColor('Magenta', '#FF00FF');
const Maroon = registerColor('Maroon', '#800000');
const MediumAquaMarine = registerColor('MediumAquaMarine', '#66CDAA');
const MediumBlue = registerColor('MediumBlue', '#0000CD');
const MediumOrchid = registerColor('MediumOrchid', '#BA55D3');
const MediumPurple = registerColor('MediumPurple', '#9370DB');
const MediumSeaGreen = registerColor('MediumSeaGreen', '#3CB371');
const MediumSlateBlue = registerColor('MediumSlateBlue', '#7B68EE');
const MediumSpringGreen = registerColor('MediumSpringGreen', '#00FA9A');
const MediumTurquoise = registerColor('MediumTurquoise', '#48D1CC');
const MediumVioletRed = registerColor('MediumVioletRed', '#C71585');
const MidnightBlue = registerColor('MidnightBlue', '#191970');
const MintCream = registerColor('MintCream', '#F5FFFA');
const MistyRose = registerColor('MistyRose', '#FFE4E1');
const Moccasin = registerColor('Moccasin', '#FFE4B5');
const NavajoWhite = registerColor('NavajoWhite', '#FFDEAD');
const Navy = registerColor('Navy', '#000080');
const OldLace = registerColor('OldLace', '#FDF5E6');
const Olive = registerColor('Olive', '#808000');
const OliveDrab = registerColor('OliveDrab', '#6B8E23');
const Orange = registerColor('Orange', '#FFA500');
const OrangeRed = registerColor('OrangeRed', '#FF4500');
const Orchid = registerColor('Orchid', '#DA70D6');
const PaleGoldenRod = registerColor('PaleGoldenRod', '#EEE8AA');
const PaleGreen = registerColor('PaleGreen', '#98FB98');
const PaleTurquoise = registerColor('PaleTurquoise', '#AFEEEE');
const PaleVioletRed = registerColor('PaleVioletRed', '#DB7093');
const PapayaWhip = registerColor('PapayaWhip', '#FFEFD5');
const PeachPuff = registerColor('PeachPuff', '#FFDAB9');
const Peru = registerColor('Peru', '#CD853F');
const Pink = registerColor('Pink', '#FFC0CB');
const Plum = registerColor('Plum', '#DDA0DD');
const PowderBlue = registerColor('PowderBlue', '#B0E0E6');
const Purple = registerColor('Purple', '#800080');
const RebeccaPurple = registerColor('RebeccaPurple', '#663399');
const Red = registerColor('Red', '#FF0000');
const RosyBrown = registerColor('RosyBrown', '#BC8F8F');
const RoyalBlue = registerColor('RoyalBlue', '#4169E1');
const SaddleBrown = registerColor('SaddleBrown', '#8B4513');
const Salmon = registerColor('Salmon', '#FA8072');
const SandyBrown = registerColor('SandyBrown', '#F4A460');
const SeaGreen = registerColor('SeaGreen', '#2E8B57');
const SeaShell = registerColor('SeaShell', '#FFF5EE');
const Sienna = registerColor('Sienna', '#A0522D');
const Silver = registerColor('Silver', '#C0C0C0');
const SkyBlue = registerColor('SkyBlue', '#87CEEB');
const SlateBlue = registerColor('SlateBlue', '#6A5ACD');
const SlateGray = registerColor('SlateGray', '#708090');
const Snow = registerColor('Snow', '#FFFAFA');
const SpringGreen = registerColor('SpringGreen', '#00FF7F');
const SteelBlue = registerColor('SteelBlue', '#4682B4');
const Tan = registerColor('Tan', '#D2B48C');
const Teal = registerColor('Teal', '#008080');
const Thistle = registerColor('Thistle', '#D8BFD8');
const Tomato = registerColor('Tomato', '#FF6347');
const Turquoise = registerColor('Turquoise', '#40E0D0');
const Violet = registerColor('Violet', '#EE82EE');
const Wheat = registerColor('Wheat', '#F5DEB3');
const White = registerColor('White', '#FFFFFF');
const WhiteSmoke = registerColor('WhiteSmoke', '#F5F5F5');
const Yellow = registerColor('Yellow', '#FFFF00');
const YellowGreen = registerColor('YellowGreen', '#9ACD32');
//# sourceMappingURL=known-colors.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/css/parser.js
var parser = __webpack_require__(54);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/color/color-common.js



const SHARP = '#';
const HEX_REGEX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i;
class color_common_Color {
    constructor() {
        if (arguments.length === 1) {
            const arg = arguments[0];
            if (types["k" /* isString */](arg)) {
                if (isRgbOrRgba(arg)) {
                    this._argb = argbFromRgbOrRgba(arg);
                }
                else if (isHslOrHsla(arg)) {
                    this._argb = argbFromHslOrHsla(arg);
                }
                else if (isKnownName(arg)) {
                    // The parameter is a known color name
                    const hex = getKnownColor(arg);
                    this._name = arg;
                    this._argb = this._argbFromString(hex);
                }
                else if (HEX_REGEX.test(arg)) {
                    // The parameter is a "#AARRGGBB" formatted string
                    const hex = this._normalizeHex(arg);
                    this._argb = this._argbFromString(hex);
                }
                else {
                    throw new Error('Invalid color: ' + arg);
                }
            }
            else if (types["i" /* isNumber */](arg)) {
                // The parameter is a 32-bit unsigned integer where each 8 bits specify a color component
                // In case a 32-bit signed int (Android, Java has no unsigned types) was provided - convert to unsigned by applyint >>> 0
                this._argb = arg >>> 0;
            }
            else {
                throw new Error('Expected 1 or 4 constructor parameters.');
            }
        }
        else if (arguments.length === 4) {
            this._argb = (arguments[0] & 0xff) * 0x01000000 + (arguments[1] & 0xff) * 0x00010000 + (arguments[2] & 0xff) * 0x00000100 + (arguments[3] & 0xff) * 0x00000001;
        }
        else {
            throw new Error('Expected 1 or 4 constructor parameters.');
        }
    }
    get a() {
        return (this._argb / 0x01000000) & 0xff;
    }
    get r() {
        return (this._argb / 0x00010000) & 0xff;
    }
    get g() {
        return (this._argb / 0x00000100) & 0xff;
    }
    get b() {
        return (this._argb / 0x00000001) & 0xff;
    }
    get argb() {
        return this._argb;
    }
    get hex() {
        if (this.a === 0xff) {
            return ('#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b)).toUpperCase();
        }
        else {
            return ('#' + this._componentToHex(this.a) + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b)).toUpperCase();
        }
    }
    get name() {
        return this._name;
    }
    get ios() {
        return undefined;
    }
    get android() {
        return undefined;
    }
    _argbFromString(hex) {
        if (hex.charAt(0) === '#') {
            hex = hex.substr(1);
        }
        if (hex.length === 3) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        else if (hex.length === 4) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
        }
        let intVal = parseInt(hex, 16);
        if (hex.length === 6) {
            // add the alpha component since the provided string is RRGGBB
            intVal = (intVal & 0x00ffffff) + 0xff000000;
        }
        return intVal;
    }
    equals(value) {
        return value && this.argb === value.argb;
    }
    static equals(value1, value2) {
        // both values are falsy
        if (!value1 && !value2) {
            return true;
        }
        // only one is falsy
        if (!value1 || !value2) {
            return false;
        }
        return value1.equals(value2);
    }
    static isValid(value) {
        if (types["h" /* isNullOrUndefined */](value) || value instanceof color_common_Color) {
            return true;
        }
        if (!types["k" /* isString */](value)) {
            return false;
        }
        if (isKnownName(value)) {
            return true;
        }
        return HEX_REGEX.test(value) || isRgbOrRgba(value) || isHslOrHsla(value);
    }
    _componentToHex(component) {
        let hex = component.toString(16);
        if (hex.length === 1) {
            hex = '0' + hex;
        }
        return hex;
    }
    _normalizeHex(hexStr) {
        if (hexStr.charAt(0) === SHARP && hexStr.length === 4) {
            // Duplicate each char after the #, so "#123" becomes "#112233"
            hexStr = hexStr.charAt(0) + hexStr.charAt(1) + hexStr.charAt(1) + hexStr.charAt(2) + hexStr.charAt(2) + hexStr.charAt(3) + hexStr.charAt(3);
        }
        return hexStr;
    }
    toString() {
        return this.hex;
    }
    static fromIosColor(value) {
        return undefined;
    }
}
function isRgbOrRgba(value) {
    const toLower = value.toLowerCase();
    return (toLower.indexOf('rgb(') === 0 || toLower.indexOf('rgba(') === 0) && toLower.indexOf(')') === toLower.length - 1;
}
function isHslOrHsla(value) {
    const toLower = value.toLowerCase();
    return (toLower.indexOf('hsl(') === 0 || toLower.indexOf('hsla(') === 0) && toLower.indexOf(')') === toLower.length - 1;
}
function parseColorWithAlpha(value) {
    const toLower = value.toLowerCase();
    const parts = toLower
        .replace(/(rgb|hsl)a?\(/, '')
        .replace(')', '')
        .trim()
        .split(',');
    let f = 255;
    let s = 255;
    let t = 255;
    let a = 255;
    if (parts[0]) {
        f = parseInt(parts[0].trim());
    }
    if (parts[1]) {
        s = parseInt(parts[1].trim());
    }
    if (parts[2]) {
        t = parseInt(parts[2].trim());
    }
    if (parts[3]) {
        a = Math.round(parseFloat(parts[3].trim()) * 255);
    }
    return { f, s, t, a };
}
function argbFromRgbOrRgba(value) {
    const { f: r, s: g, t: b, a } = parseColorWithAlpha(value);
    return (a & 0xff) * 0x01000000 + (r & 0xff) * 0x00010000 + (g & 0xff) * 0x00000100 + (b & 0xff);
}
function argbFromHslOrHsla(value) {
    const { f: h, s: s, t: l, a } = parseColorWithAlpha(value);
    const { r, g, b } = Object(parser["convertHSLToRGBColor"])(h, s, l);
    return (a & 0xff) * 0x01000000 + (r & 0xff) * 0x00010000 + (g & 0xff) * 0x00000100 + (b & 0xff);
}
//# sourceMappingURL=color-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/color/index.js

class color_Color extends color_common_Color {
    get ios() {
        if (!this._ios) {
            // iOS Color is using floating-point values in the [0, 1] range, so divide the components by 255
            this._ios = UIColor.alloc().initWithRedGreenBlueAlpha(this.r / 255, this.g / 255, this.b / 255, this.a / 255);
        }
        return this._ios;
    }
    static fromIosColor(value) {
        const rgba = CGColorGetComponents(value.CGColor);
        return new color_Color(Math.round(rgba[3] * 255), Math.round(rgba[0] * 255), Math.round(rgba[1] * 255), Math.round(rgba[2] * 255));
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Style; });
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);


class Style extends _data_observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] {
    constructor(ownerView) {
        super();
        this.unscopedCssVariables = new Map();
        this.scopedCssVariables = new Map();
        // HACK: Could not find better way for cross platform WeakRef type checking.
        if (ownerView.constructor.toString().indexOf('[native code]') !== -1) {
            this.viewRef = ownerView;
        }
        else {
            this.viewRef = new WeakRef(ownerView);
        }
    }
    setScopedCssVariable(varName, value) {
        this.scopedCssVariables.set(varName, value);
    }
    setUnscopedCssVariable(varName, value) {
        this.unscopedCssVariables.set(varName, value);
    }
    getCssVariable(varName) {
        const view = this.view;
        if (!view) {
            return null;
        }
        if (this.unscopedCssVariables.has(varName)) {
            return this.unscopedCssVariables.get(varName);
        }
        if (this.scopedCssVariables.has(varName)) {
            return this.scopedCssVariables.get(varName);
        }
        if (!view.parent || !view.parent.style) {
            return null;
        }
        return view.parent.style.getCssVariable(varName);
    }
    resetScopedCssVariables() {
        this.scopedCssVariables.clear();
    }
    resetUnscopedCssVariables() {
        this.unscopedCssVariables.clear();
    }
    toString() {
        const view = this.viewRef.get();
        if (!view) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(`toString() of Style cannot execute correctly because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
            return '';
        }
        return `${view}.style`;
    }
    get view() {
        if (this.viewRef) {
            return this.viewRef.get();
        }
        return undefined;
    }
}
Style.prototype.PropertyBag = class {
};
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alert", function() { return alert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "confirm", function() { return confirm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prompt", function() { return prompt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "login", function() { return login; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "action", function() { return action; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dialogs", function() { return Dialogs; });
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _dialogs_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _application__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DialogStrings", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inputType", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "capitalizationType", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentPage", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getButtonColors", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLabelColor", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTextFieldColor", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDialogOptions", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseLoginOptions", function() { return _dialogs_common__WEBPACK_IMPORTED_MODULE_1__["i"]; });

/**
 * iOS specific dialogs functions implementation.
 */





function addButtonsToAlertController(alertController, options, callback) {
    if (!options) {
        return;
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.cancelButtonText)) {
        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.cancelButtonText, 0 /* Default */, () => {
            raiseCallback(callback, false);
        }));
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.neutralButtonText)) {
        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.neutralButtonText, 0 /* Default */, () => {
            raiseCallback(callback, undefined);
        }));
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.okButtonText)) {
        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.okButtonText, 0 /* Default */, () => {
            raiseCallback(callback, true);
        }));
    }
}
function raiseCallback(callback, result) {
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isFunction */ "g"])(callback)) {
        callback(result);
    }
}
function showUIAlertController(alertController) {
    let viewController = _application__WEBPACK_IMPORTED_MODULE_3__["ios"].rootController;
    while (viewController && viewController.presentedViewController) {
        viewController = viewController.presentedViewController;
    }
    if (!viewController) {
        _trace__WEBPACK_IMPORTED_MODULE_0__[/* Trace */ "a"].write(`No root controller found to open dialog.`, _trace__WEBPACK_IMPORTED_MODULE_0__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_0__[/* Trace */ "a"].messageType.warn);
        return;
    }
    if (alertController.popoverPresentationController) {
        alertController.popoverPresentationController.sourceView = viewController.view;
        alertController.popoverPresentationController.sourceRect = CGRectMake(viewController.view.bounds.size.width / 2.0, viewController.view.bounds.size.height / 2.0, 1.0, 1.0);
        alertController.popoverPresentationController.permittedArrowDirections = 0;
    }
    let color = Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* getButtonColors */ "c"])().color;
    if (color) {
        alertController.view.tintColor = color.ios;
    }
    let lblColor = Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* getLabelColor */ "e"])();
    if (lblColor) {
        if (alertController.title) {
            let title = NSAttributedString.alloc().initWithStringAttributes(alertController.title, { [NSForegroundColorAttributeName]: lblColor.ios });
            alertController.setValueForKey(title, 'attributedTitle');
        }
        if (alertController.message) {
            let message = NSAttributedString.alloc().initWithStringAttributes(alertController.message, { [NSForegroundColorAttributeName]: lblColor.ios });
            alertController.setValueForKey(message, 'attributedMessage');
        }
    }
    viewController.presentModalViewControllerAnimated(alertController, true);
}
function alert(arg) {
    return new Promise((resolve, reject) => {
        try {
            let options = !Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* isDialogOptions */ "h"])(arg) ? { title: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].ALERT, okButtonText: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].OK, message: arg + '' } : arg;
            let alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1 /* Alert */);
            addButtonsToAlertController(alertController, options, () => {
                resolve();
            });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
function confirm(arg) {
    return new Promise((resolve, reject) => {
        try {
            let options = !Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* isDialogOptions */ "h"])(arg)
                ? {
                    title: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].CONFIRM,
                    okButtonText: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].OK,
                    cancelButtonText: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].CANCEL,
                    message: arg + '',
                }
                : arg;
            let alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1 /* Alert */);
            addButtonsToAlertController(alertController, options, (r) => {
                resolve(r);
            });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
function prompt(arg) {
    let options;
    let defaultOptions = {
        title: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].PROMPT,
        okButtonText: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].OK,
        cancelButtonText: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].CANCEL,
        inputType: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* inputType */ "g"].text,
    };
    if (arguments.length === 1) {
        if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arg)) {
            options = defaultOptions;
            options.message = arg;
        }
        else {
            options = arg;
        }
    }
    else if (arguments.length === 2) {
        if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[0]) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[1])) {
            options = defaultOptions;
            options.message = arguments[0];
            options.defaultText = arguments[1];
        }
    }
    return new Promise((resolve, reject) => {
        try {
            let textField;
            let alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1 /* Alert */);
            alertController.addTextFieldWithConfigurationHandler((arg) => {
                arg.text = Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.defaultText) ? options.defaultText : '';
                arg.secureTextEntry = options && options.inputType === _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* inputType */ "g"].password;
                if (options && options.inputType === _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* inputType */ "g"].email) {
                    arg.keyboardType = 7 /* EmailAddress */;
                }
                else if (options && options.inputType === _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* inputType */ "g"].number) {
                    arg.keyboardType = 4 /* NumberPad */;
                }
                else if (options && options.inputType === _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* inputType */ "g"].decimal) {
                    arg.keyboardType = 8 /* DecimalPad */;
                }
                else if (options && options.inputType === _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* inputType */ "g"].phone) {
                    arg.keyboardType = 5 /* PhonePad */;
                }
                let color = Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* getTextFieldColor */ "f"])();
                if (color) {
                    arg.textColor = arg.tintColor = color.ios;
                }
            });
            textField = alertController.textFields.firstObject;
            if (options) {
                switch (options.capitalizationType) {
                    case _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* capitalizationType */ "b"].all: {
                        textField.autocapitalizationType = 3 /* AllCharacters */;
                        break;
                    }
                    case _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* capitalizationType */ "b"].sentences: {
                        textField.autocapitalizationType = 2 /* Sentences */;
                        break;
                    }
                    case _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* capitalizationType */ "b"].words: {
                        textField.autocapitalizationType = 1 /* Words */;
                        break;
                    }
                    default: {
                        textField.autocapitalizationType = 0 /* None */;
                    }
                }
            }
            addButtonsToAlertController(alertController, options, (r) => {
                resolve({ result: r, text: textField.text });
            });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
function login(...args) {
    let options = Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* parseLoginOptions */ "i"])(args);
    return new Promise((resolve, reject) => {
        try {
            let userNameTextField;
            let passwordTextField;
            let alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1 /* Alert */);
            let textFieldColor = Object(_dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* getTextFieldColor */ "f"])();
            alertController.addTextFieldWithConfigurationHandler((arg) => {
                arg.placeholder = 'Login';
                arg.placeholder = options.userNameHint ? options.userNameHint : '';
                arg.text = Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.userName) ? options.userName : '';
                if (textFieldColor) {
                    arg.textColor = arg.tintColor = textFieldColor.ios;
                }
            });
            alertController.addTextFieldWithConfigurationHandler((arg) => {
                arg.placeholder = 'Password';
                arg.secureTextEntry = true;
                arg.placeholder = options.passwordHint ? options.passwordHint : '';
                arg.text = Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.password) ? options.password : '';
                if (textFieldColor) {
                    arg.textColor = arg.tintColor = textFieldColor.ios;
                }
            });
            userNameTextField = alertController.textFields.firstObject;
            passwordTextField = alertController.textFields.lastObject;
            addButtonsToAlertController(alertController, options, (r) => {
                resolve({
                    result: r,
                    userName: userNameTextField.text,
                    password: passwordTextField.text,
                });
            });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
function action() {
    let options;
    let defaultOptions = { title: null, cancelButtonText: _dialogs_common__WEBPACK_IMPORTED_MODULE_1__[/* DialogStrings */ "a"].CANCEL };
    if (arguments.length === 1) {
        if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[0])) {
            options = defaultOptions;
            options.message = arguments[0];
        }
        else {
            options = arguments[0];
        }
    }
    else if (arguments.length === 2) {
        if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[0]) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[1])) {
            options = defaultOptions;
            options.message = arguments[0];
            options.cancelButtonText = arguments[1];
        }
    }
    else if (arguments.length === 3) {
        if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[0]) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(arguments[1]) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isDefined */ "f"])(arguments[2])) {
            options = defaultOptions;
            options.message = arguments[0];
            options.cancelButtonText = arguments[1];
            options.actions = arguments[2];
        }
    }
    return new Promise((resolve, reject) => {
        try {
            let i;
            let action;
            let alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 0 /* ActionSheet */);
            if (options.actions) {
                for (i = 0; i < options.actions.length; i++) {
                    action = options.actions[i];
                    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(action)) {
                        const thisActionIsDestructive = options.destructiveActionsIndexes && options.destructiveActionsIndexes.indexOf(i) !== -1;
                        const dialogType = thisActionIsDestructive ? 2 /* Destructive */ : 0 /* Default */;
                        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(action, dialogType, (arg) => {
                            resolve(arg.title);
                        }));
                    }
                }
            }
            if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(options.cancelButtonText)) {
                alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.cancelButtonText, 1 /* Cancel */, (arg) => {
                    resolve(arg.title);
                }));
            }
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
/**
 * Singular rollup for convenience of all dialog methods
 */
const Dialogs = {
    alert,
    confirm,
    prompt,
    login,
    action,
};
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return uptime; });
/* unused harmony export log */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return start; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return stop; });
/* unused harmony export timer */
/* unused harmony export print */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isRunning; });
/* unused harmony export Level */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return enable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return disable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return profile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return dumpProfiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return resetProfiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return startCPUProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return stopCPUProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return level; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return trace; });
function uptime() {
    return global.android ? org.nativescript.Process.getUpTime() : global.__tns_uptime();
}
function log(message) {
    if (global.__nslog) {
        global.__nslog('CONSOLE LOG: ' + message);
    }
    console.log(message);
}
// Use object instead of map as it is a bit faster
const timers = {};
const anyGlobal = global;
const profileNames = [];
const time = global.__time || Date.now;
function start(name) {
    let info = timers[name];
    if (info) {
        info.currentStart = time();
        info.runCount++;
    }
    else {
        info = {
            totalTime: 0,
            count: 0,
            currentStart: time(),
            runCount: 1,
        };
        timers[name] = info;
        profileNames.push(name);
    }
}
function stop(name) {
    const info = timers[name];
    if (!info) {
        throw new Error(`No timer started: ${name}`);
    }
    if (info.runCount) {
        info.runCount--;
        if (info.runCount) {
            info.count++;
        }
        else {
            info.lastTime = time() - info.currentStart;
            info.totalTime += info.lastTime;
            info.count++;
            info.currentStart = 0;
        }
    }
    else {
        throw new Error(`Timer ${name} paused more times than started.`);
    }
    return info;
}
function timer(name) {
    return timers[name];
}
function print(name) {
    const info = timers[name];
    if (!info) {
        throw new Error(`No timer started: ${name}`);
    }
    console.log(`---- [${name}] STOP total: ${info.totalTime} count:${info.count}`);
    return info;
}
function isRunning(name) {
    const info = timers[name];
    return !!(info && info.runCount);
}
function countersProfileFunctionFactory(fn, name, type = 1 /* Instance */) {
    profileNames.push(name);
    return function () {
        start(name);
        try {
            return fn.apply(this, arguments);
        }
        finally {
            stop(name);
        }
    };
}
function timelineProfileFunctionFactory(fn, name, type = 1 /* Instance */) {
    return type === 1 /* Instance */
        ? function () {
            const start = time();
            try {
                return fn.apply(this, arguments);
            }
            finally {
                const end = time();
                console.log(`Timeline: Modules: ${name} ${this}  (${start}ms. - ${end}ms.)`);
            }
        }
        : function () {
            const start = time();
            try {
                return fn.apply(this, arguments);
            }
            finally {
                const end = time();
                console.log(`Timeline: Modules: ${name}  (${start}ms. - ${end}ms.)`);
            }
        };
}
var Level;
(function (Level) {
    Level[Level["none"] = 0] = "none";
    Level[Level["lifecycle"] = 1] = "lifecycle";
    Level[Level["timeline"] = 2] = "timeline";
})(Level || (Level = {}));
let tracingLevel = Level.none;
let profileFunctionFactory;
function enable(mode = 'counters') {
    profileFunctionFactory =
        mode &&
            {
                counters: countersProfileFunctionFactory,
                timeline: timelineProfileFunctionFactory,
            }[mode];
    tracingLevel =
        {
            lifecycle: Level.lifecycle,
            timeline: Level.timeline,
        }[mode] || Level.none;
}
try {
    const appConfig = __webpack_require__(90);
    if (appConfig && appConfig.profiling) {
        enable(appConfig.profiling);
    }
}
catch (e1) {
    try {
        console.log('Profiling startup failed to figure out defaults from package.json, error: ' + e1);
    }
    catch (e2) {
        // We can get here if an exception is thrown in the mksnapshot as there is no console there.
    }
}
function disable() {
    profileFunctionFactory = undefined;
}
function profileFunction(fn, customName) {
    return profileFunctionFactory(fn, customName || fn.name);
}
const profileMethodUnnamed = (target, key, descriptor) => {
    // save a reference to the original method this way we keep the values currently in the
    // descriptor and don't overwrite what another decorator might have done to the descriptor.
    if (descriptor === undefined) {
        descriptor = Object.getOwnPropertyDescriptor(target, key);
    }
    const originalMethod = descriptor.value;
    let className = '';
    if (target && target.constructor && target.constructor.name) {
        className = target.constructor.name + '.';
    }
    let name = className + key;
    //editing the descriptor/value parameter
    descriptor.value = profileFunctionFactory(originalMethod, name, 1 /* Instance */);
    // return edited descriptor as opposed to overwriting the descriptor
    return descriptor;
};
const profileStaticMethodUnnamed = (ctor, key, descriptor) => {
    // save a reference to the original method this way we keep the values currently in the
    // descriptor and don't overwrite what another decorator might have done to the descriptor.
    if (descriptor === undefined) {
        descriptor = Object.getOwnPropertyDescriptor(ctor, key);
    }
    const originalMethod = descriptor.value;
    let className = '';
    if (ctor && ctor.name) {
        className = ctor.name + '.';
    }
    let name = className + key;
    //editing the descriptor/value parameter
    descriptor.value = profileFunctionFactory(originalMethod, name, 0 /* Static */);
    // return edited descriptor as opposed to overwriting the descriptor
    return descriptor;
};
function profileMethodNamed(name) {
    return (target, key, descriptor) => {
        // save a reference to the original method this way we keep the values currently in the
        // descriptor and don't overwrite what another decorator might have done to the descriptor.
        if (descriptor === undefined) {
            descriptor = Object.getOwnPropertyDescriptor(target, key);
        }
        const originalMethod = descriptor.value;
        //editing the descriptor/value parameter
        descriptor.value = profileFunctionFactory(originalMethod, name);
        // return edited descriptor as opposed to overwriting the descriptor
        return descriptor;
    };
}
const voidMethodDecorator = () => {
    // no op
};
function profile(nameFnOrTarget, fnOrKey, descriptor, attrs) {
    if (typeof nameFnOrTarget === 'object' && (typeof fnOrKey === 'string' || typeof fnOrKey === 'symbol')) {
        if (!profileFunctionFactory) {
            return;
        }
        return profileMethodUnnamed(nameFnOrTarget, fnOrKey, descriptor);
    }
    else if (typeof nameFnOrTarget === 'function' && (typeof fnOrKey === 'string' || typeof fnOrKey === 'symbol')) {
        if (!profileFunctionFactory) {
            return;
        }
        return profileStaticMethodUnnamed(nameFnOrTarget, fnOrKey, descriptor);
    }
    else if (typeof nameFnOrTarget === 'string' && typeof fnOrKey === 'function') {
        if (!profileFunctionFactory) {
            return fnOrKey;
        }
        return profileFunction(fnOrKey, nameFnOrTarget);
    }
    else if (typeof nameFnOrTarget === 'function') {
        if (!profileFunctionFactory) {
            return nameFnOrTarget;
        }
        return profileFunction(nameFnOrTarget);
    }
    else if (typeof nameFnOrTarget === 'string') {
        if (!profileFunctionFactory) {
            return voidMethodDecorator;
        }
        return profileMethodNamed(nameFnOrTarget);
    }
    else {
        if (!profileFunctionFactory) {
            return voidMethodDecorator;
        }
        return profileMethodUnnamed;
    }
}
function dumpProfiles() {
    profileNames.forEach(function (name) {
        const info = timers[name];
        if (info) {
            console.log('---- [' + name + '] STOP total: ' + info.totalTime + ' count:' + info.count);
        }
        else {
            console.log('---- [' + name + '] Never called');
        }
    });
}
function resetProfiles() {
    profileNames.forEach(function (name) {
        const info = timers[name];
        if (info) {
            if (info.runCount) {
                console.log('---- timer with name [' + name + "] is currently running and won't be reset");
            }
            else {
                timers[name] = undefined;
            }
        }
    });
}
function startCPUProfile(name) {
    if (anyGlobal.android) {
        __startCPUProfiler(name);
    }
}
function stopCPUProfile(name) {
    if (anyGlobal.android) {
        __stopCPUProfiler(name);
    }
}
function level() {
    return tracingLevel;
}
function trace(message, start, end) {
    log(`Timeline: Modules: ${message}  (${start}ms. - ${end}ms.)`);
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isDefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isNullOrUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return verifyCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getClassInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getBaseClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClassInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return toUIString; });
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
function isNumber(value) {
    return typeof value === 'number' || value instanceof Number;
}
function isBoolean(value) {
    return typeof value === 'boolean' || value instanceof Boolean;
}
function isFunction(value) {
    if (!value) {
        return false;
    }
    return typeof value === 'function';
}
function isObject(value) {
    if (!value) {
        return false;
    }
    return typeof value === 'object';
}
function isUndefined(value) {
    return typeof value === 'undefined';
}
function isDefined(value) {
    return typeof value !== 'undefined';
}
function isNullOrUndefined(value) {
    return typeof value === 'undefined' || value === null;
}
function verifyCallback(value) {
    if (value && !isFunction(value)) {
        throw new TypeError('Callback must be a valid function.');
    }
}
const classInfosMap = new Map();
// ES3-5 type classes are "function blah()", new ES6+ classes can be "class blah"
const funcNameRegex = /(?:function|class)\s+(\w+).*/;
function getClass(object) {
    return getClassInfo(object).name;
}
function getClassInfo(object) {
    const constructor = object.constructor;
    let result = classInfosMap.get(constructor);
    if (!result) {
        result = new ClassInfo(constructor);
        classInfosMap.set(constructor, result);
    }
    return result;
}
function getBaseClasses(object) {
    const result = [];
    let info = getClassInfo(object);
    while (info) {
        result.push(info.name);
        info = info.baseClassInfo;
    }
    return result;
}
class ClassInfo {
    constructor(typeConstructor) {
        this._typeConstructor = typeConstructor;
    }
    get name() {
        if (!this._name) {
            if (this._typeConstructor.name) {
                this._name = this._typeConstructor.name;
            }
            else {
                const results = funcNameRegex.exec(this._typeConstructor.toString());
                this._name = results && results.length > 1 ? results[1] : '';
            }
        }
        return this._name;
    }
    get baseClassInfo() {
        if (isUndefined(this._baseClassInfo)) {
            this._baseClassInfo = ClassInfo._getBase(this);
            // While extending some classes for platform specific versions results in duplicate class types in hierarchy.
            if (this._baseClassInfo && this._baseClassInfo.name === this.name) {
                this._baseClassInfo = ClassInfo._getBase(this._baseClassInfo);
            }
        }
        return this._baseClassInfo;
    }
    static _getBase(info) {
        let result = null;
        const constructorProto = info._typeConstructor.prototype;
        if (constructorProto.__proto__) {
            result = getClassInfo(constructorProto.__proto__);
        }
        return result;
    }
}
function toUIString(obj) {
    return isNullOrUndefined(obj) ? '' : obj + '';
}
//# sourceMappingURL=types.js.map; 
if (false ) {} 

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;
; 
if (false ) {} 

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "NavigationType", function() { return /* reexport */ frame_interfaces["a" /* NavigationType */]; });
__webpack_require__.d(__webpack_exports__, "FrameBase", function() { return /* reexport */ frame_common_FrameBase; });
__webpack_require__.d(__webpack_exports__, "getFrameById", function() { return /* reexport */ getFrameById; });
__webpack_require__.d(__webpack_exports__, "topmost", function() { return /* reexport */ frame_common_topmost; });
__webpack_require__.d(__webpack_exports__, "goBack", function() { return /* reexport */ goBack; });
__webpack_require__.d(__webpack_exports__, "_stack", function() { return /* reexport */ _stack; });
__webpack_require__.d(__webpack_exports__, "defaultPage", function() { return /* reexport */ defaultPage; });
__webpack_require__.d(__webpack_exports__, "actionBarVisibilityProperty", function() { return /* reexport */ actionBarVisibilityProperty; });
__webpack_require__.d(__webpack_exports__, "Frame", function() { return /* binding */ frame_Frame; });
__webpack_require__.d(__webpack_exports__, "_getNativeCurve", function() { return /* binding */ _getNativeCurve; });
__webpack_require__.d(__webpack_exports__, "setActivityCallbacks", function() { return /* binding */ setActivityCallbacks; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/frame/frame-interfaces.js
var frame_interfaces = __webpack_require__(40);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/index.js
var view = __webpack_require__(3);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-common.js
var view_common = __webpack_require__(31);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var properties = __webpack_require__(1);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/trace/index.js
var trace = __webpack_require__(0);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/frame/frame-stack.js
let frameStack = [];
function topmost() {
    if (frameStack.length > 0) {
        return frameStack[frameStack.length - 1];
    }
    return undefined;
}
function _pushInFrameStack(frame) {
    if (frame._isInFrameStack && frameStack[frameStack.length - 1] === frame) {
        return;
    }
    if (frame._isInFrameStack) {
        const indexOfFrame = frameStack.indexOf(frame);
        frameStack.splice(indexOfFrame, 1);
    }
    frameStack.push(frame);
    frame._isInFrameStack = true;
}
function _popFromFrameStack(frame) {
    if (!frame._isInFrameStack) {
        return;
    }
    const top = topmost();
    if (top !== frame) {
        throw new Error('Cannot pop a Frame which is not at the top of the navigation stack.');
    }
    frameStack.pop();
    frame._isInFrameStack = false;
}
function _removeFromFrameStack(frame) {
    if (!frame._isInFrameStack) {
        return;
    }
    const index = frameStack.indexOf(frame);
    frameStack.splice(index, 1);
    frame._isInFrameStack = false;
}
//# sourceMappingURL=frame-stack.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view-base/index.js
var view_base = __webpack_require__(15);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/builder/index.js
var builder = __webpack_require__(42);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/builder/module-name-sanitizer.js
var module_name_sanitizer = __webpack_require__(37);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/profiling/index.js
var profiling = __webpack_require__(9);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/frame/frame-common.js
var FrameBase_1;











function buildEntryFromArgs(arg) {
    let entry;
    if (typeof arg === 'string') {
        entry = {
            moduleName: arg,
        };
    }
    else if (typeof arg === 'function') {
        entry = {
            create: arg,
        };
    }
    else {
        entry = arg;
    }
    return entry;
}
let frame_common_FrameBase = FrameBase_1 = class FrameBase extends view["b" /* CustomLayoutView */] {
    constructor() {
        super(...arguments);
        this._backStack = new Array();
        this._navigationQueue = new Array();
        this._animationInProgress = false;
        this._isInFrameStack = false;
    }
    static getFrameById(id) {
        return frameStack.find((frame) => frame.id && frame.id === id);
    }
    static topmost() {
        return topmost();
    }
    static goBack() {
        const top = FrameBase_1.topmost();
        if (top && top.canGoBack()) {
            top.goBack();
            return true;
        }
        else if (top) {
            let parentFrameCanGoBack = false;
            let parentFrame = Object(view_base["getAncestor"])(top, 'Frame');
            while (parentFrame && !parentFrameCanGoBack) {
                if (parentFrame && parentFrame.canGoBack()) {
                    parentFrameCanGoBack = true;
                }
                else {
                    parentFrame = Object(view_base["getAncestor"])(parentFrame, 'Frame');
                }
            }
            if (parentFrame && parentFrameCanGoBack) {
                parentFrame.goBack();
                return true;
            }
        }
        if (frameStack.length > 1) {
            top._popFromFrameStack();
        }
        return false;
    }
    /**
     * @private
     */
    static reloadPage() {
        // Implemented in plat-specific file - only for android.
    }
    /**
     * @private
     */
    static _stack() {
        return frameStack;
    }
    // TODO: Currently our navigation will not be synchronized in case users directly call native navigation methods like Activity.startActivity.
    _addChildFromBuilder(name, value) {
        throw new Error(`Frame should not have a view. Use 'defaultPage' property instead.`);
    }
    onLoaded() {
        super.onLoaded();
        this._processNextNavigationEntry();
    }
    canGoBack() {
        let backstack = this._backStack.length;
        let previousForwardNotInBackstack = false;
        this._navigationQueue.forEach((item) => {
            const entry = item.entry;
            const isBackNavigation = item.navigationType === frame_interfaces["a" /* NavigationType */].back;
            if (isBackNavigation) {
                previousForwardNotInBackstack = false;
                if (!entry) {
                    backstack--;
                }
                else {
                    const backstackIndex = this._backStack.indexOf(entry);
                    if (backstackIndex !== -1) {
                        backstack = backstackIndex;
                    }
                    else {
                        // NOTE: We don't search for entries in navigationQueue because there is no way for
                        // developer to get reference to BackstackEntry unless transition is completed.
                        // At that point the entry is put in the backstack array.
                        // If we start to return Backstack entry from navigate method then
                        // here we should check also navigationQueue as well.
                        backstack--;
                    }
                }
            }
            else if (entry.entry.clearHistory) {
                previousForwardNotInBackstack = false;
                backstack = 0;
            }
            else {
                backstack++;
                if (previousForwardNotInBackstack) {
                    backstack--;
                }
                previousForwardNotInBackstack = entry.entry.backstackVisible === false;
            }
        });
        // this is our first navigation which is not completed yet.
        if (this._navigationQueue.length > 0 && !this._currentEntry) {
            backstack--;
        }
        return backstack > 0;
    }
    /**
     * Navigates to the previous entry (if any) in the back stack.
     * @param to The backstack entry to navigate back to.
     */
    goBack(backstackEntry) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`GO BACK`, trace["a" /* Trace */].categories.Navigation);
        }
        if (!this.canGoBack()) {
            return;
        }
        if (backstackEntry) {
            const index = this._backStack.indexOf(backstackEntry);
            if (index < 0) {
                return;
            }
        }
        const navigationContext = {
            entry: backstackEntry,
            isBackNavigation: true,
            navigationType: frame_interfaces["a" /* NavigationType */].back,
        };
        this._navigationQueue.push(navigationContext);
        this._processNextNavigationEntry();
    }
    _removeEntry(removed) {
        const page = removed.resolvedPage;
        const frame = page.frame;
        page._frame = null;
        if (frame) {
            frame._removeView(page);
        }
        else {
            page._tearDownUI(true);
        }
        removed.resolvedPage = null;
    }
    navigate(param) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`NAVIGATE`, trace["a" /* Trace */].categories.Navigation);
        }
        this._pushInFrameStack();
        const entry = buildEntryFromArgs(param);
        const page = builder["a" /* Builder */].createViewFromEntry(entry);
        const backstackEntry = {
            entry: entry,
            resolvedPage: page,
            navDepth: undefined,
            fragmentTag: undefined,
        };
        const navigationContext = {
            entry: backstackEntry,
            isBackNavigation: false,
            navigationType: frame_interfaces["a" /* NavigationType */].forward,
        };
        this._navigationQueue.push(navigationContext);
        this._processNextNavigationEntry();
    }
    isCurrent(entry) {
        return this._currentEntry === entry;
    }
    setCurrent(entry, navigationType) {
        const newPage = entry.resolvedPage;
        // In case we navigated forward to a page that was in the backstack
        // with clearHistory: true
        if (!newPage.frame) {
            this._addView(newPage);
            newPage._frame = this;
        }
        this._currentEntry = entry;
        const isBack = navigationType === frame_interfaces["a" /* NavigationType */].back;
        if (isBack) {
            this._pushInFrameStack();
        }
        newPage.onNavigatedTo(isBack);
        // Reset executing context after NavigatedTo is raised;
        // we do not want to execute two navigations in parallel in case
        // additional navigation is triggered from the NavigatedTo handler.
        this._executingContext = null;
    }
    _updateBackstack(entry, navigationType) {
        const isBack = navigationType === frame_interfaces["a" /* NavigationType */].back;
        const isReplace = navigationType === frame_interfaces["a" /* NavigationType */].replace;
        this.raiseCurrentPageNavigatedEvents(isBack);
        const current = this._currentEntry;
        // Do nothing for Hot Module Replacement
        if (isBack) {
            const index = this._backStack.indexOf(entry);
            this._backStack.splice(index + 1).forEach((e) => this._removeEntry(e));
            this._backStack.pop();
        }
        else if (!isReplace) {
            if (entry.entry.clearHistory) {
                this._backStack.forEach((e) => this._removeEntry(e));
                this._backStack.length = 0;
            }
            else if (FrameBase_1._isEntryBackstackVisible(current)) {
                this._backStack.push(current);
            }
        }
        if (current && this._backStack.indexOf(current) < 0) {
            this._removeEntry(current);
        }
    }
    isNestedWithin(parentFrameCandidate) {
        let frameAncestor = this;
        while (frameAncestor) {
            frameAncestor = Object(view_base["getAncestor"])(frameAncestor, FrameBase_1);
            if (frameAncestor === parentFrameCandidate) {
                return true;
            }
        }
        return false;
    }
    raiseCurrentPageNavigatedEvents(isBack) {
        const page = this.currentPage;
        if (page) {
            if (page.isLoaded) {
                // Forward navigation does not remove page from frame so we raise unloaded manually.
                page.callUnloaded();
            }
            page.onNavigatedFrom(isBack);
        }
    }
    _processNavigationQueue(page) {
        if (this._navigationQueue.length === 0) {
            // This could happen when showing recreated page after activity has been destroyed.
            return;
        }
        const entry = this._navigationQueue[0].entry;
        const currentNavigationPage = entry.resolvedPage;
        if (page !== currentNavigationPage) {
            // If the page is not the one that requested navigation - skip it.
            return;
        }
        // remove completed operation.
        this._navigationQueue.shift();
        this._processNextNavigationEntry();
        this._updateActionBar();
    }
    _findEntryForTag(fragmentTag) {
        let entry;
        if (this._currentEntry && this._currentEntry.fragmentTag === fragmentTag) {
            entry = this._currentEntry;
        }
        else {
            entry = this._backStack.find((value) => value.fragmentTag === fragmentTag);
            // on API 26 fragments are recreated lazily after activity is destroyed.
            if (!entry) {
                const navigationItem = this._navigationQueue.find((value) => value.entry.fragmentTag === fragmentTag);
                entry = navigationItem ? navigationItem.entry : undefined;
            }
        }
        return entry;
    }
    navigationQueueIsEmpty() {
        return this._navigationQueue.length === 0;
    }
    static _isEntryBackstackVisible(entry) {
        if (!entry) {
            return false;
        }
        const backstackVisibleValue = entry.entry.backstackVisible;
        const backstackHidden = backstackVisibleValue !== undefined && !backstackVisibleValue;
        return !backstackHidden;
    }
    _updateActionBar(page, disableNavBarAnimation) {
        //Trace.write("calling _updateActionBar on Frame", Trace.categories.Navigation);
    }
    _processNextNavigationEntry() {
        if (!this.isLoaded || this._executingContext) {
            return;
        }
        if (this._navigationQueue.length > 0) {
            const navigationContext = this._navigationQueue[0];
            const isBackNavigation = navigationContext.navigationType === frame_interfaces["a" /* NavigationType */].back;
            if (isBackNavigation) {
                this.performGoBack(navigationContext);
            }
            else {
                this.performNavigation(navigationContext);
            }
        }
    }
    performNavigation(navigationContext) {
        this._executingContext = navigationContext;
        const backstackEntry = navigationContext.entry;
        const isBackNavigation = navigationContext.navigationType === frame_interfaces["a" /* NavigationType */].back;
        this._onNavigatingTo(backstackEntry, isBackNavigation);
        this._navigateCore(backstackEntry);
    }
    performGoBack(navigationContext) {
        let backstackEntry = navigationContext.entry;
        const backstack = this._backStack;
        if (!backstackEntry) {
            backstackEntry = backstack[backstack.length - 1];
            navigationContext.entry = backstackEntry;
        }
        this._executingContext = navigationContext;
        this._onNavigatingTo(backstackEntry, true);
        this._goBackCore(backstackEntry);
    }
    _goBackCore(backstackEntry) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`GO BACK CORE(${this._backstackEntryTrace(backstackEntry)}); currentPage: ${this.currentPage}`, trace["a" /* Trace */].categories.Navigation);
        }
    }
    _navigateCore(backstackEntry) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`NAVIGATE CORE(${this._backstackEntryTrace(backstackEntry)}); currentPage: ${this.currentPage}`, trace["a" /* Trace */].categories.Navigation);
        }
    }
    _onNavigatingTo(backstackEntry, isBack) {
        if (this.currentPage) {
            this.currentPage.onNavigatingFrom(isBack);
        }
        backstackEntry.resolvedPage.onNavigatingTo(backstackEntry.entry.context, isBack, backstackEntry.entry.bindingContext);
    }
    get animated() {
        return this._animated;
    }
    set animated(value) {
        this._animated = value;
    }
    get transition() {
        return this._transition;
    }
    set transition(value) {
        this._transition = value;
    }
    get backStack() {
        return this._backStack.slice();
    }
    get currentPage() {
        if (this._currentEntry) {
            return this._currentEntry.resolvedPage;
        }
        return null;
    }
    get currentEntry() {
        if (this._currentEntry) {
            return this._currentEntry.entry;
        }
        return null;
    }
    _pushInFrameStackRecursive() {
        this._pushInFrameStack();
        // make sure nested frames order is kept intact i.e. the nested one should always be on top;
        // see https://github.com/NativeScript/nativescript-angular/issues/1596 for more information
        const framesToPush = [];
        for (const frame of frameStack) {
            if (frame.isNestedWithin(this)) {
                framesToPush.push(frame);
            }
        }
        for (const frame of framesToPush) {
            frame._pushInFrameStack();
        }
    }
    _pushInFrameStack() {
        _pushInFrameStack(this);
    }
    _popFromFrameStack() {
        _popFromFrameStack(this);
    }
    _removeFromFrameStack() {
        _removeFromFrameStack(this);
    }
    _dialogClosed() {
        // No super call as we do not support nested frames to clean up
        this._removeFromFrameStack();
    }
    _onRootViewReset() {
        super._onRootViewReset();
        this._removeFromFrameStack();
    }
    get _childrenCount() {
        if (this.currentPage) {
            return 1;
        }
        return 0;
    }
    eachChildView(callback) {
        const page = this.currentPage;
        if (page) {
            callback(page);
        }
    }
    _getIsAnimatedNavigation(entry) {
        if (entry && entry.animated !== undefined) {
            return entry.animated;
        }
        if (this.animated !== undefined) {
            return this.animated;
        }
        return FrameBase_1.defaultAnimatedNavigation;
    }
    _getNavigationTransition(entry) {
        if (entry) {
            if ( true && entry.transitioniOS !== undefined) {
                return entry.transitioniOS;
            }
            if (false) {}
            if (entry.transition !== undefined) {
                return entry.transition;
            }
        }
        if (this.transition !== undefined) {
            return this.transition;
        }
        return FrameBase_1.defaultTransition;
    }
    get navigationBarHeight() {
        return 0;
    }
    _getNavBarVisible(page) {
        throw new Error();
    }
    // We don't need to put Page as visual child. Don't call super.
    _addViewToNativeVisualTree(child) {
        return true;
    }
    // We don't need to put Page as visual child. Don't call super.
    _removeViewFromNativeVisualTree(child) {
        child._isAddedToNativeVisualTree = false;
    }
    _printFrameBackStack() {
        const length = this.backStack.length;
        let i = length - 1;
        console.log(`Frame Back Stack: `);
        while (i >= 0) {
            let backstackEntry = this.backStack[i--];
            console.log(`\t${backstackEntry.resolvedPage}`);
        }
    }
    _backstackEntryTrace(b) {
        let result = `${b.resolvedPage}`;
        const backstackVisible = FrameBase_1._isEntryBackstackVisible(b);
        if (!backstackVisible) {
            result += ` | INVISIBLE`;
        }
        if (b.entry.clearHistory) {
            result += ` | CLEAR HISTORY`;
        }
        const animated = this._getIsAnimatedNavigation(b.entry);
        if (!animated) {
            result += ` | NOT ANIMATED`;
        }
        const t = this._getNavigationTransition(b.entry);
        if (t) {
            result += ` | Transition[${JSON.stringify(t)}]`;
        }
        return result;
    }
    _onLivesync(context) {
        if (super._onLivesync(context)) {
            return true;
        }
        // Fallback
        if (!context) {
            return this.legacyLivesync();
        }
        return false;
    }
    _handleLivesync(context) {
        if (super._handleLivesync(context)) {
            return true;
        }
        // Handle markup/script changes in currentPage
        if (this.currentPage && Object(view_common["i" /* viewMatchesModuleContext */])(this.currentPage, context, ['markup', 'script'])) {
            trace["a" /* Trace */].write(`Change Handled: Replacing page ${context.path}`, trace["a" /* Trace */].categories.Livesync);
            this.replacePage(context.path);
            return true;
        }
        return false;
    }
    legacyLivesync() {
        // Reset activity/window content when:
        // + Changes are not handled on View
        // + There is no ModuleContext
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`${this}._onLivesync()`, trace["a" /* Trace */].categories.Livesync);
        }
        if (!this._currentEntry || !this._currentEntry.entry) {
            return false;
        }
        const currentEntry = this._currentEntry.entry;
        const newEntry = {
            animated: false,
            clearHistory: true,
            context: currentEntry.context,
            create: currentEntry.create,
            moduleName: currentEntry.moduleName,
            backstackVisible: currentEntry.backstackVisible,
        };
        // If create returns the same page instance we can't recreate it.
        // Instead of navigation set activity content.
        // This could happen if current page was set in XML as a Page instance.
        if (newEntry.create) {
            const page = newEntry.create();
            if (page === this.currentPage) {
                return false;
            }
        }
        this.navigate(newEntry);
        return true;
    }
    replacePage(pagePath) {
        const currentBackstackEntry = this._currentEntry;
        const contextModuleName = Object(module_name_sanitizer["a" /* sanitizeModuleName */])(pagePath);
        const newPage = builder["a" /* Builder */].createViewFromEntry({ moduleName: contextModuleName });
        const newBackstackEntry = {
            entry: currentBackstackEntry.entry,
            resolvedPage: newPage,
            navDepth: currentBackstackEntry.navDepth,
            fragmentTag: currentBackstackEntry.fragmentTag,
            frameId: currentBackstackEntry.frameId,
        };
        const navigationContext = {
            entry: newBackstackEntry,
            isBackNavigation: false,
            navigationType: frame_interfaces["a" /* NavigationType */].replace,
        };
        this._navigationQueue.push(navigationContext);
        this._processNextNavigationEntry();
    }
};
frame_common_FrameBase.androidOptionSelectedEvent = 'optionSelected';
frame_common_FrameBase.defaultAnimatedNavigation = true;
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], frame_common_FrameBase.prototype, "onLoaded", null);
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], frame_common_FrameBase.prototype, "performNavigation", null);
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], frame_common_FrameBase.prototype, "performGoBack", null);
frame_common_FrameBase = FrameBase_1 = __decorate([
    Object(view_common["a" /* CSSType */])('Frame')
], frame_common_FrameBase);

function getFrameById(id) {
    console.log('getFrameById() is deprecated. Use Frame.getFrameById() instead.');
    return frame_common_FrameBase.getFrameById(id);
}
function frame_common_topmost() {
    console.log('topmost() is deprecated. Use Frame.topmost() instead.');
    return frame_common_FrameBase.topmost();
}
function goBack() {
    console.log('goBack() is deprecated. Use Frame.goBack() instead.');
    return frame_common_FrameBase.goBack();
}
function _stack() {
    console.log('_stack() is deprecated. Use Frame._stack() instead.');
    return frame_common_FrameBase._stack();
}
const defaultPage = new properties["Property"]({
    name: 'defaultPage',
    valueChanged: (frame, oldValue, newValue) => {
        frame.navigate({ moduleName: newValue });
    },
});
defaultPage.register(frame_common_FrameBase);
const actionBarVisibilityProperty = new properties["Property"]({ name: 'actionBarVisibility', defaultValue: 'auto', affectsLayout: true });
actionBarVisibilityProperty.register(frame_common_FrameBase);
//# sourceMappingURL=frame-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/transition/index.js
var ui_transition = __webpack_require__(70);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/platform/index.js
var platform = __webpack_require__(13);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/transition/slide-transition.js


let leftEdge = CGAffineTransformMakeTranslation(-platform["Screen"].mainScreen.widthDIPs, 0);
let rightEdge = CGAffineTransformMakeTranslation(platform["Screen"].mainScreen.widthDIPs, 0);
let topEdge = CGAffineTransformMakeTranslation(0, -platform["Screen"].mainScreen.heightDIPs);
let bottomEdge = CGAffineTransformMakeTranslation(0, platform["Screen"].mainScreen.heightDIPs);
class slide_transition_SlideTransition extends ui_transition["a" /* Transition */] {
    constructor(direction, duration, curve) {
        super(duration, curve);
        this._direction = direction;
    }
    animateIOSTransition(containerView, fromView, toView, operation, completion) {
        let originalToViewTransform = toView.transform;
        let originalFromViewTransform = fromView.transform;
        let fromViewEndTransform;
        let toViewBeginTransform;
        let push = operation === 1 /* Push */;
        switch (this._direction) {
            case 'left':
                toViewBeginTransform = push ? rightEdge : leftEdge;
                fromViewEndTransform = push ? leftEdge : rightEdge;
                break;
            case 'right':
                toViewBeginTransform = push ? leftEdge : rightEdge;
                fromViewEndTransform = push ? rightEdge : leftEdge;
                break;
            case 'top':
                toViewBeginTransform = push ? bottomEdge : topEdge;
                fromViewEndTransform = push ? topEdge : bottomEdge;
                break;
            case 'bottom':
                toViewBeginTransform = push ? topEdge : bottomEdge;
                fromViewEndTransform = push ? bottomEdge : topEdge;
                break;
        }
        toView.transform = toViewBeginTransform;
        fromView.transform = CGAffineTransformIdentity;
        switch (operation) {
            case 1 /* Push */:
                containerView.insertSubviewAboveSubview(toView, fromView);
                break;
            case 2 /* Pop */:
                containerView.insertSubviewBelowSubview(toView, fromView);
                break;
        }
        let duration = this.getDuration();
        let curve = this.getCurve();
        UIView.animateWithDurationAnimationsCompletion(duration, () => {
            UIView.setAnimationCurve(curve);
            toView.transform = CGAffineTransformIdentity;
            fromView.transform = fromViewEndTransform;
        }, (finished) => {
            toView.transform = originalToViewTransform;
            fromView.transform = originalFromViewTransform;
            completion(finished);
        });
    }
}
//# sourceMappingURL=slide-transition.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/transition/fade-transition.js

class fade_transition_FadeTransition extends ui_transition["a" /* Transition */] {
    animateIOSTransition(containerView, fromView, toView, operation, completion) {
        let originalToViewAlpha = toView.alpha;
        let originalFromViewAlpha = fromView.alpha;
        toView.alpha = 0.0;
        fromView.alpha = 1.0;
        switch (operation) {
            case 1 /* Push */:
                containerView.insertSubviewAboveSubview(toView, fromView);
                break;
            case 2 /* Pop */:
                containerView.insertSubviewBelowSubview(toView, fromView);
                break;
        }
        let duration = this.getDuration();
        let curve = this.getCurve();
        UIView.animateWithDurationAnimationsCompletion(duration, () => {
            UIView.setAnimationCurve(curve);
            toView.alpha = 1.0;
            fromView.alpha = 0.0;
        }, (finished) => {
            toView.alpha = originalToViewAlpha;
            fromView.alpha = originalFromViewAlpha;
            completion(finished);
        });
    }
}
//# sourceMappingURL=fade-transition.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/frame/fragment.transitions.js



var UIViewControllerAnimatedTransitioningMethods;
(function (UIViewControllerAnimatedTransitioningMethods) {
    const methodSignature = NSMethodSignature.signatureWithObjCTypes('v@:c');
    const invocation = NSInvocation.invocationWithMethodSignature(methodSignature);
    invocation.selector = 'completeTransition:';
    function completeTransition(didComplete) {
        const didCompleteReference = new interop.Reference(interop.types.bool, didComplete);
        invocation.setArgumentAtIndex(didCompleteReference, 2);
        invocation.invokeWithTarget(this);
    }
    UIViewControllerAnimatedTransitioningMethods.completeTransition = completeTransition;
})(UIViewControllerAnimatedTransitioningMethods || (UIViewControllerAnimatedTransitioningMethods = {}));
var fragment_transitions_AnimatedTransitioning = /** @class */ (function (_super) {
    __extends(AnimatedTransitioning, _super);
    function AnimatedTransitioning() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimatedTransitioning.init = function (transition, operation, fromVC, toVC) {
        var impl = AnimatedTransitioning.new();
        impl._transition = transition;
        impl._operation = operation;
        impl._fromVC = fromVC;
        impl._toVC = toVC;
        return impl;
    };
    AnimatedTransitioning.prototype.animateTransition = function (transitionContext) {
        var containerView = transitionContext.valueForKey('containerView');
        var completion = UIViewControllerAnimatedTransitioningMethods.completeTransition.bind(transitionContext);
        switch (this._operation) {
            case UINavigationControllerOperation.Push:
                this._transitionType = 'push';
                break;
            case UINavigationControllerOperation.Pop:
                this._transitionType = 'pop';
                break;
            case UINavigationControllerOperation.None:
                this._transitionType = 'none';
                break;
        }
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("START " + this._transition + " " + this._transitionType, trace["a" /* Trace */].categories.Transition);
        }
        this._transition.animateIOSTransition(containerView, this._fromVC.view, this._toVC.view, this._operation, completion);
    };
    AnimatedTransitioning.prototype.transitionDuration = function (transitionContext) {
        return this._transition.getDuration();
    };
    AnimatedTransitioning.prototype.animationEnded = function (transitionCompleted) {
        if (transitionCompleted) {
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write("END " + this._transition + " " + this._transitionType, trace["a" /* Trace */].categories.Transition);
            }
        }
        else {
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write("CANCEL " + this._transition + " " + this._transitionType, trace["a" /* Trace */].categories.Transition);
            }
        }
    };
    AnimatedTransitioning.ObjCProtocols = [UIViewControllerAnimatedTransitioning];
    return AnimatedTransitioning;
}(NSObject));
function _createIOSAnimatedTransitioning(navigationTransition, nativeCurve, operation, fromVC, toVC) {
    const instance = navigationTransition.instance;
    let transition;
    if (instance) {
        // Instance transition should take precedence even if the given name match existing transition.
        transition = instance;
    }
    else if (navigationTransition.name) {
        const name = navigationTransition.name.toLowerCase();
        if (name.indexOf('slide') === 0) {
            const direction = name.substr('slide'.length) || 'left'; //Extract the direction from the string
            transition = new slide_transition_SlideTransition(direction, navigationTransition.duration, nativeCurve);
        }
        else if (name === 'fade') {
            transition = new fade_transition_FadeTransition(navigationTransition.duration, nativeCurve);
        }
    }
    return transition ? fragment_transitions_AnimatedTransitioning.init(transition, operation, fromVC, toVC) : undefined;
}
//# sourceMappingURL=fragment.transitions.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-helper/index.js
var view_helper = __webpack_require__(28);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/native-helper.js
var native_helper = __webpack_require__(38);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/frame/index.js


// Requires






const majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
const ENTRY = '_entry';
const DELEGATE = '_delegate';
const NAV_DEPTH = '_navDepth';
const TRANSITION = '_transition';
const NON_ANIMATED_TRANSITION = 'non-animated';
const HMR_REPLACE_TRANSITION = 'fade';
let navDepth = -1;
class frame_Frame extends frame_common_FrameBase {
    constructor() {
        super();
        this._animatedDelegate = frame_UINavigationControllerAnimatedDelegate.new();
        this._ios = new iOSFrame(this);
        this.viewController = this._ios.controller;
    }
    createNativeView() {
        return this.viewController.view;
    }
    disposeNativeView() {
        this._removeFromFrameStack();
        this.viewController = null;
        this._ios.controller = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    setCurrent(entry, navigationType) {
        const current = this._currentEntry;
        const currentEntryChanged = current !== entry;
        if (currentEntryChanged) {
            this._updateBackstack(entry, navigationType);
            super.setCurrent(entry, navigationType);
        }
    }
    // !!! THIS PROFILE DECORATOR CREATES A CIRCULAR DEPENDENCY
    // !!! BECAUSE THE PARAMETER TYPE IS EVALUATED WITH TYPEOF
    _navigateCore(backstackEntry) {
        super._navigateCore(backstackEntry);
        let viewController = backstackEntry.resolvedPage.ios;
        if (!viewController) {
            throw new Error('Required page does not have a viewController created.');
        }
        let clearHistory = backstackEntry.entry.clearHistory;
        if (clearHistory) {
            navDepth = -1;
        }
        const isReplace = this._executingContext && this._executingContext.navigationType === frame_interfaces["a" /* NavigationType */].replace;
        if (!isReplace) {
            navDepth++;
        }
        let navigationTransition;
        let animated = this.currentPage ? this._getIsAnimatedNavigation(backstackEntry.entry) : false;
        if (isReplace) {
            animated = true;
            navigationTransition = {
                name: HMR_REPLACE_TRANSITION,
                duration: 100,
            };
            viewController[TRANSITION] = navigationTransition;
        }
        else if (animated) {
            navigationTransition = this._getNavigationTransition(backstackEntry.entry);
            if (navigationTransition) {
                viewController[TRANSITION] = navigationTransition;
            }
        }
        else {
            //https://github.com/NativeScript/NativeScript/issues/1787
            viewController[TRANSITION] = { name: NON_ANIMATED_TRANSITION };
        }
        let nativeTransition = _getNativeTransition(navigationTransition, true);
        if (!nativeTransition && navigationTransition) {
            this._ios.controller.delegate = this._animatedDelegate;
            viewController[DELEGATE] = this._animatedDelegate;
        }
        else {
            viewController[DELEGATE] = null;
            this._ios.controller.delegate = null;
        }
        backstackEntry[NAV_DEPTH] = navDepth;
        viewController[ENTRY] = backstackEntry;
        if (!animated && majorVersion > 10) {
            // Reset back button title before pushing view controller to prevent
            // displaying default 'back' title (when NavigaitonButton custom title is set).
            let barButtonItem = UIBarButtonItem.alloc().initWithTitleStyleTargetAction('', 0 /* Plain */, null, null);
            viewController.navigationItem.backBarButtonItem = barButtonItem;
        }
        // First navigation.
        if (!this._currentEntry) {
            // Update action-bar with disabled animations before the initial navigation.
            this._updateActionBar(backstackEntry.resolvedPage, true);
            this._ios.controller.pushViewControllerAnimated(viewController, animated);
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write(`${this}.pushViewControllerAnimated(${viewController}, ${animated}); depth = ${navDepth}`, trace["a" /* Trace */].categories.Navigation);
            }
            return;
        }
        // We should clear the entire history.
        if (clearHistory) {
            viewController.navigationItem.hidesBackButton = true;
            const newControllers = NSMutableArray.alloc().initWithCapacity(1);
            newControllers.addObject(viewController);
            // Mark all previous ViewControllers as cleared
            const oldControllers = this._ios.controller.viewControllers;
            for (let i = 0; i < oldControllers.count; i++) {
                oldControllers.objectAtIndex(i).isBackstackCleared = true;
            }
            this._ios.controller.setViewControllersAnimated(newControllers, animated);
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write(`${this}.setViewControllersAnimated([${viewController}], ${animated}); depth = ${navDepth}`, trace["a" /* Trace */].categories.Navigation);
            }
            return;
        }
        // We should hide the current entry from the back stack.
        // This is the case for HMR when NavigationType.replace.
        if (!frame_Frame._isEntryBackstackVisible(this._currentEntry) || isReplace) {
            let newControllers = NSMutableArray.alloc().initWithArray(this._ios.controller.viewControllers);
            if (newControllers.count === 0) {
                throw new Error('Wrong controllers count.');
            }
            // the code below fixes a phantom animation that appears on the Back button in this case
            // TODO: investigate why the animation happens at first place before working around it
            viewController.navigationItem.hidesBackButton = this.backStack.length === 0;
            // swap the top entry with the new one
            const skippedNavController = newControllers.lastObject;
            skippedNavController.isBackstackSkipped = true;
            newControllers.removeLastObject();
            newControllers.addObject(viewController);
            // replace the controllers instead of pushing directly
            this._ios.controller.setViewControllersAnimated(newControllers, animated);
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write(`${this}.setViewControllersAnimated([originalControllers - lastController + ${viewController}], ${animated}); depth = ${navDepth}`, trace["a" /* Trace */].categories.Navigation);
            }
            return;
        }
        // General case.
        this._ios.controller.pushViewControllerAnimated(viewController, animated);
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`${this}.pushViewControllerAnimated(${viewController}, ${animated}); depth = ${navDepth}`, trace["a" /* Trace */].categories.Navigation);
        }
    }
    _goBackCore(backstackEntry) {
        super._goBackCore(backstackEntry);
        navDepth = backstackEntry[NAV_DEPTH];
        let controller = backstackEntry.resolvedPage.ios;
        let animated = this._currentEntry ? this._getIsAnimatedNavigation(this._currentEntry.entry) : false;
        this._updateActionBar(backstackEntry.resolvedPage);
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`${this}.popToViewControllerAnimated(${controller}, ${animated}); depth = ${navDepth}`, trace["a" /* Trace */].categories.Navigation);
        }
        this._ios.controller.popToViewControllerAnimated(controller, animated);
    }
    _updateActionBar(page, disableNavBarAnimation = false) {
        super._updateActionBar(page);
        if (page && this.currentPage && this.currentPage.modal === page) {
            return;
        }
        page = page || this.currentPage;
        let newValue = this._getNavBarVisible(page);
        let disableNavBarAnimationCache = this._ios._disableNavBarAnimation;
        if (disableNavBarAnimation) {
            this._ios._disableNavBarAnimation = true;
        }
        // when showing/hiding navigationbar, the page needs a relayout to avoid overlapping or hidden layouts
        const needsPageLayout = this._ios.showNavigationBar !== newValue;
        this._ios.showNavigationBar = newValue;
        if (disableNavBarAnimation) {
            this._ios._disableNavBarAnimation = disableNavBarAnimationCache;
        }
        if (this._ios.controller.navigationBar) {
            this._ios.controller.navigationBar.userInteractionEnabled = this.navigationQueueIsEmpty();
        }
        if (needsPageLayout && page) {
            page.requestLayout();
        }
    }
    _getNavBarVisible(page) {
        switch (this.actionBarVisibility) {
            case 'always':
                return true;
            case 'never':
                return false;
            case 'auto':
                switch (this._ios.navBarVisibility) {
                    case 'always':
                        return true;
                    case 'never':
                        return false;
                    case 'auto':
                        let newValue;
                        if (page && page.actionBarHidden !== undefined) {
                            newValue = !page.actionBarHidden;
                        }
                        else {
                            newValue = this.ios.controller.viewControllers.count > 1 || (page && page.actionBar && !page.actionBar._isEmpty());
                        }
                        newValue = !!newValue;
                        return newValue;
                }
        }
    }
    static get defaultAnimatedNavigation() {
        return frame_common_FrameBase.defaultAnimatedNavigation;
    }
    static set defaultAnimatedNavigation(value) {
        frame_common_FrameBase.defaultAnimatedNavigation = value;
    }
    static get defaultTransition() {
        return frame_common_FrameBase.defaultTransition;
    }
    static set defaultTransition(value) {
        frame_common_FrameBase.defaultTransition = value;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const widthAndState = view["c" /* View */].resolveSizeAndState(width, width, widthMode, 0);
        const heightAndState = view["c" /* View */].resolveSizeAndState(height, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    layoutNativeView(left, top, right, bottom) {
        //
    }
    _setNativeViewFrame(nativeView, frame) {
        //
    }
    _onNavigatingTo(backstackEntry, isBack) {
        //
    }
}
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], frame_Frame.prototype, "_navigateCore", null);
let transitionDelegates = new Array();
var frame_TransitionDelegate = /** @class */ (function (_super) {
    __extends(TransitionDelegate, _super);
    function TransitionDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TransitionDelegate.initWithOwnerId = function (id) {
        var delegate = TransitionDelegate.new();
        delegate._id = id;
        transitionDelegates.push(delegate);
        return delegate;
    };
    TransitionDelegate.prototype.animationWillStart = function (animationID, context) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("START " + this._id, trace["a" /* Trace */].categories.Transition);
        }
    };
    TransitionDelegate.prototype.animationDidStop = function (animationID, finished, context) {
        if (finished) {
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write("END " + this._id, trace["a" /* Trace */].categories.Transition);
            }
        }
        else {
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write("CANCEL " + this._id, trace["a" /* Trace */].categories.Transition);
            }
        }
        var index = transitionDelegates.indexOf(this);
        if (index > -1) {
            transitionDelegates.splice(index, 1);
        }
    };
    TransitionDelegate.ObjCExposedMethods = {
        animationWillStart: {
            returns: interop.types.void,
            params: [NSString, NSObject],
        },
        animationDidStop: {
            returns: interop.types.void,
            params: [NSString, NSNumber, NSObject],
        },
    };
    return TransitionDelegate;
}(NSObject));
const _defaultTransitionDuration = 0.35;
var frame_UINavigationControllerAnimatedDelegate = /** @class */ (function (_super) {
    __extends(UINavigationControllerAnimatedDelegate, _super);
    function UINavigationControllerAnimatedDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UINavigationControllerAnimatedDelegate.prototype.navigationControllerAnimationControllerForOperationFromViewControllerToViewController = function (navigationController, operation, fromVC, toVC) {
        var viewController;
        switch (operation) {
            case UINavigationControllerOperation.Push:
                viewController = toVC;
                break;
            case UINavigationControllerOperation.Pop:
                viewController = fromVC;
                break;
        }
        if (!viewController) {
            return null;
        }
        var navigationTransition = viewController[TRANSITION];
        if (!navigationTransition) {
            return null;
        }
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("UINavigationControllerImpl.navigationControllerAnimationControllerForOperationFromViewControllerToViewController(" + operation + ", " + fromVC + ", " + toVC + "), transition: " + JSON.stringify(navigationTransition), trace["a" /* Trace */].categories.NativeLifecycle);
        }
        var curve = _getNativeCurve(navigationTransition);
        var animationController = _createIOSAnimatedTransitioning(navigationTransition, curve, operation, fromVC, toVC);
        return animationController;
    };
    UINavigationControllerAnimatedDelegate.ObjCProtocols = [UINavigationControllerDelegate];
    return UINavigationControllerAnimatedDelegate;
}(NSObject));
var frame_UINavigationControllerImpl = /** @class */ (function (_super) {
    __extends(UINavigationControllerImpl, _super);
    function UINavigationControllerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UINavigationControllerImpl.initWithOwner = function (owner) {
        var controller = UINavigationControllerImpl.new();
        controller._owner = owner;
        return controller;
    };
    Object.defineProperty(UINavigationControllerImpl.prototype, "owner", {
        get: function () {
            return this._owner.get();
        },
        enumerable: true,
        configurable: true
    });
    UINavigationControllerImpl.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this._owner.get();
        if (owner && !owner.isLoaded && !owner.parent) {
            owner.callLoaded();
        }
    };
    UINavigationControllerImpl.prototype.viewDidDisappear = function (animated) {
        _super.prototype.viewDidDisappear.call(this, animated);
        var owner = this._owner.get();
        if (owner && owner.isLoaded && !owner.parent && !this.presentedViewController) {
            owner.callUnloaded();
            owner._tearDownUI(true);
        }
    };
    UINavigationControllerImpl.prototype.animateWithDuration = function (navigationTransition, nativeTransition, transitionType, baseCallback) {
        var _this = this;
        var duration = navigationTransition.duration ? navigationTransition.duration / 1000 : _defaultTransitionDuration;
        var curve = _getNativeCurve(navigationTransition);
        var transitionTraced = trace["a" /* Trace */].isCategorySet(trace["a" /* Trace */].categories.Transition);
        var transitionDelegate;
        if (transitionTraced) {
            var id = _getTransitionId(nativeTransition, transitionType);
            transitionDelegate = frame_TransitionDelegate.initWithOwnerId(id);
        }
        UIView.animateWithDurationAnimations(duration, function () {
            if (transitionTraced) {
                UIView.setAnimationDelegate(transitionDelegate);
            }
            UIView.setAnimationWillStartSelector('animationWillStart');
            UIView.setAnimationDidStopSelector('animationDidStop');
            UIView.setAnimationCurve(curve);
            baseCallback();
            UIView.setAnimationTransitionForViewCache(nativeTransition, _this.view, true);
        });
    };
    UINavigationControllerImpl.prototype.pushViewControllerAnimated = function (viewController, animated) {
        var _this = this;
        var navigationTransition = viewController[TRANSITION];
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("UINavigationControllerImpl.pushViewControllerAnimated(" + viewController + ", " + animated + "); transition: " + JSON.stringify(navigationTransition), trace["a" /* Trace */].categories.NativeLifecycle);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, true);
        if (!animated || !navigationTransition || !nativeTransition) {
            _super.prototype.pushViewControllerAnimated.call(this, viewController, animated);
            return;
        }
        this.animateWithDuration(navigationTransition, nativeTransition, 'push', function () {
            _super.prototype.pushViewControllerAnimated.call(_this, viewController, false);
        });
    };
    UINavigationControllerImpl.prototype.setViewControllersAnimated = function (viewControllers, animated) {
        var _this = this;
        var viewController = viewControllers.lastObject;
        var navigationTransition = viewController[TRANSITION];
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("UINavigationControllerImpl.setViewControllersAnimated(" + viewControllers + ", " + animated + "); transition: " + JSON.stringify(navigationTransition), trace["a" /* Trace */].categories.NativeLifecycle);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, true);
        if (!animated || !navigationTransition || !nativeTransition) {
            _super.prototype.setViewControllersAnimated.call(this, viewControllers, animated);
            return;
        }
        this.animateWithDuration(navigationTransition, nativeTransition, 'set', function () {
            _super.prototype.setViewControllersAnimated.call(_this, viewControllers, false);
        });
    };
    UINavigationControllerImpl.prototype.popViewControllerAnimated = function (animated) {
        var _this = this;
        var lastViewController = this.viewControllers.lastObject;
        var navigationTransition = lastViewController[TRANSITION];
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("UINavigationControllerImpl.popViewControllerAnimated(" + animated + "); transition: " + JSON.stringify(navigationTransition), trace["a" /* Trace */].categories.NativeLifecycle);
        }
        if (navigationTransition && navigationTransition.name === NON_ANIMATED_TRANSITION) {
            //https://github.com/NativeScript/NativeScript/issues/1787
            return _super.prototype.popViewControllerAnimated.call(this, false);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, false);
        if (!animated || !navigationTransition || !nativeTransition) {
            return _super.prototype.popViewControllerAnimated.call(this, animated);
        }
        this.animateWithDuration(navigationTransition, nativeTransition, 'pop', function () {
            _super.prototype.popViewControllerAnimated.call(_this, false);
        });
        return null;
    };
    UINavigationControllerImpl.prototype.popToViewControllerAnimated = function (viewController, animated) {
        var _this = this;
        var lastViewController = this.viewControllers.lastObject;
        var navigationTransition = lastViewController[TRANSITION];
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write("UINavigationControllerImpl.popToViewControllerAnimated(" + viewController + ", " + animated + "); transition: " + JSON.stringify(navigationTransition), trace["a" /* Trace */].categories.NativeLifecycle);
        }
        if (navigationTransition && navigationTransition.name === NON_ANIMATED_TRANSITION) {
            //https://github.com/NativeScript/NativeScript/issues/1787
            return _super.prototype.popToViewControllerAnimated.call(this, viewController, false);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, false);
        if (!animated || !navigationTransition || !nativeTransition) {
            return _super.prototype.popToViewControllerAnimated.call(this, viewController, animated);
        }
        this.animateWithDuration(navigationTransition, nativeTransition, 'popTo', function () {
            _super.prototype.popToViewControllerAnimated.call(_this, viewController, false);
        });
        return null;
    };
    // Mind implementation for other controllers
    UINavigationControllerImpl.prototype.traitCollectionDidChange = function (previousTraitCollection) {
        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
        if (majorVersion >= 13) {
            var owner = this._owner.get();
            if (owner && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection(previousTraitCollection)) {
                owner.notify({
                    eventName: view_helper["a" /* IOSHelper */].traitCollectionColorAppearanceChangedEvent,
                    object: owner,
                });
            }
        }
    };
    __decorate([
        profiling["f" /* profile */]
    ], UINavigationControllerImpl.prototype, "viewWillAppear", null);
    __decorate([
        profiling["f" /* profile */]
    ], UINavigationControllerImpl.prototype, "viewDidDisappear", null);
    __decorate([
        profiling["f" /* profile */]
    ], UINavigationControllerImpl.prototype, "pushViewControllerAnimated", null);
    __decorate([
        profiling["f" /* profile */]
    ], UINavigationControllerImpl.prototype, "setViewControllersAnimated", null);
    return UINavigationControllerImpl;
}(UINavigationController));
function _getTransitionId(nativeTransition, transitionType) {
    let name;
    switch (nativeTransition) {
        case 4 /* CurlDown */:
            name = 'CurlDown';
            break;
        case 3 /* CurlUp */:
            name = 'CurlUp';
            break;
        case 1 /* FlipFromLeft */:
            name = 'FlipFromLeft';
            break;
        case 2 /* FlipFromRight */:
            name = 'FlipFromRight';
            break;
        case 0 /* None */:
            name = 'None';
            break;
    }
    return `${name} ${transitionType}`;
}
function _getNativeTransition(navigationTransition, push) {
    if (navigationTransition && navigationTransition.name) {
        switch (navigationTransition.name.toLowerCase()) {
            case 'flip':
            case 'flipright':
                return push ? 2 /* FlipFromRight */ : 1 /* FlipFromLeft */;
            case 'flipleft':
                return push ? 1 /* FlipFromLeft */ : 2 /* FlipFromRight */;
            case 'curl':
            case 'curlup':
                return push ? 3 /* CurlUp */ : 4 /* CurlDown */;
            case 'curldown':
                return push ? 4 /* CurlDown */ : 3 /* CurlUp */;
        }
    }
    return null;
}
function _getNativeCurve(transition) {
    if (transition.curve) {
        switch (transition.curve) {
            case 'easeIn':
                if (trace["a" /* Trace */].isEnabled()) {
                    trace["a" /* Trace */].write('Transition curve resolved to UIViewAnimationCurve.EaseIn.', trace["a" /* Trace */].categories.Transition);
                }
                return 1 /* EaseIn */;
            case 'easeOut':
                if (trace["a" /* Trace */].isEnabled()) {
                    trace["a" /* Trace */].write('Transition curve resolved to UIViewAnimationCurve.EaseOut.', trace["a" /* Trace */].categories.Transition);
                }
                return 2 /* EaseOut */;
            case 'easeInOut':
                if (trace["a" /* Trace */].isEnabled()) {
                    trace["a" /* Trace */].write('Transition curve resolved to UIViewAnimationCurve.EaseInOut.', trace["a" /* Trace */].categories.Transition);
                }
                return 0 /* EaseInOut */;
            case 'linear':
                if (trace["a" /* Trace */].isEnabled()) {
                    trace["a" /* Trace */].write('Transition curve resolved to UIViewAnimationCurve.Linear.', trace["a" /* Trace */].categories.Transition);
                }
                return 3 /* Linear */;
            default:
                if (trace["a" /* Trace */].isEnabled()) {
                    trace["a" /* Trace */].write('Transition curve resolved to original: ' + transition.curve, trace["a" /* Trace */].categories.Transition);
                }
                return transition.curve;
        }
    }
    return 0 /* EaseInOut */;
}
/* tslint:disable */
class iOSFrame {
    constructor(frame) {
        this._navBarVisibility = 'auto';
        this._controller = frame_UINavigationControllerImpl.initWithOwner(new WeakRef(frame));
    }
    get controller() {
        return this._controller;
    }
    set controller(value) {
        this._controller = value;
    }
    get showNavigationBar() {
        return this._showNavigationBar;
    }
    set showNavigationBar(value) {
        this._showNavigationBar = value;
        this._controller.setNavigationBarHiddenAnimated(!value, !this._disableNavBarAnimation);
    }
    get navBarVisibility() {
        return this._navBarVisibility;
    }
    set navBarVisibility(value) {
        this._navBarVisibility = value;
    }
}
function setActivityCallbacks(activity) { }
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platformNames", function() { return platformNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Device", function() { return Device; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Screen", function() { return Screen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAndroid", function() { return isAndroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIOS", function() { return isIOS; });
/* tslint:disable:class-name */
const platformNames = {
    android: 'Android',
    ios: 'iOS',
};
class DeviceRef {
    get manufacturer() {
        return 'Apple';
    }
    get os() {
        return platformNames.ios;
    }
    get osVersion() {
        if (!this._osVersion) {
            this._osVersion = UIDevice.currentDevice.systemVersion;
        }
        return this._osVersion;
    }
    get model() {
        if (!this._model) {
            this._model = UIDevice.currentDevice.model;
        }
        return this._model;
    }
    get sdkVersion() {
        if (!this._sdkVersion) {
            this._sdkVersion = UIDevice.currentDevice.systemVersion;
        }
        return this._sdkVersion;
    }
    get deviceType() {
        if (!this._deviceType) {
            if (UIDevice.currentDevice.userInterfaceIdiom === 0 /* Phone */) {
                this._deviceType = 'Phone';
            }
            else {
                this._deviceType = 'Tablet';
            }
        }
        return this._deviceType;
    }
    get uuid() {
        const userDefaults = NSUserDefaults.standardUserDefaults;
        const uuid_key = 'TNSUUID';
        let app_uuid = userDefaults.stringForKey(uuid_key);
        if (!app_uuid) {
            app_uuid = NSUUID.UUID().UUIDString;
            userDefaults.setObjectForKey(app_uuid, uuid_key);
            userDefaults.synchronize();
        }
        return app_uuid;
    }
    get language() {
        if (!this._language) {
            const languages = NSLocale.preferredLanguages;
            this._language = languages[0];
        }
        return this._language;
    }
    get region() {
        if (!this._region) {
            this._region = NSLocale.currentLocale.objectForKey(NSLocaleCountryCode);
        }
        return this._region;
    }
}
class MainScreen {
    get screen() {
        if (!this._screen) {
            this._screen = UIScreen.mainScreen;
        }
        return this._screen;
    }
    get widthPixels() {
        return this.widthDIPs * this.scale;
    }
    get heightPixels() {
        return this.heightDIPs * this.scale;
    }
    get scale() {
        return this.screen.scale;
    }
    get widthDIPs() {
        return this.screen.bounds.size.width;
    }
    get heightDIPs() {
        return this.screen.bounds.size.height;
    }
}
const Device = new DeviceRef();
class Screen {
}
Screen.mainScreen = new MainScreen();
const isAndroid = false;
const isIOS = true;
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChangeType", function() { return ChangeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObservableArray", function() { return ObservableArray; });
/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);


class ChangeType {
}
ChangeType.Add = 'add';
ChangeType.Delete = 'delete';
ChangeType.Update = 'update';
ChangeType.Splice = 'splice';
ChangeType.Change = 'change';
const CHANGE = 'change';
/**
 * Advanced array like class used when you want to be notified when a change occurs.
 */
class ObservableArray extends _observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] {
    /**
     * Create ObservableArray<T> from source Array<T>.
     */
    constructor(args) {
        super();
        if (arguments.length === 1 && Array.isArray(arguments[0])) {
            this._array = arguments[0].slice();
        }
        else {
            this._array = Array.apply(null, arguments);
        }
        this._addArgs = {
            eventName: CHANGE,
            object: this,
            action: ChangeType.Add,
            index: null,
            removed: new Array(),
            addedCount: 1,
        };
        this._deleteArgs = {
            eventName: CHANGE,
            object: this,
            action: ChangeType.Delete,
            index: null,
            removed: null,
            addedCount: 0,
        };
    }
    /**
     * Returns item at specified index.
     */
    getItem(index) {
        return this._array[index];
    }
    /**
     * Sets item at specified index.
     */
    setItem(index, value) {
        let oldValue = this._array[index];
        this._array[index] = value;
        this.notify({
            eventName: CHANGE,
            object: this,
            action: ChangeType.Update,
            index: index,
            removed: [oldValue],
            addedCount: 1,
        });
    }
    /**
     * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.
     */
    get length() {
        return this._array.length;
    }
    set length(value) {
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isNumber */ "i"](value) && this._array && this._array.length !== value) {
            let added = [];
            for (let i = this._array.length; i < value; ++i) {
                added.push(undefined);
            }
            this.splice(value, this._array.length - value, ...added);
        }
    }
    /**
     * Returns a string representation of an array.
     */
    toString() {
        return this._array.toString();
    }
    toLocaleString() {
        return this._array.toLocaleString();
    }
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(_args) {
        this._addArgs.index = this._array.length;
        const result = this._array.concat.apply(this._array, arguments);
        return result;
    }
    /**
     * Adds all the elements of an array separated by the specified separator string.
     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
     */
    join(separator) {
        return this._array.join(separator);
    }
    /**
     * Removes the last element from an array and returns it.
     */
    pop() {
        this._deleteArgs.index = this._array.length - 1;
        const result = this._array.pop();
        this._deleteArgs.removed = [result];
        this.notify(this._deleteArgs);
        this._notifyLengthChange();
        return result;
    }
    /**
     * Appends new elements to an array, and returns the new length of the array.
     * @param item New element of the Array.
     */
    push(...args) {
        this._addArgs.index = this._array.length;
        if (arguments.length === 1 && Array.isArray(arguments[0])) {
            const source = arguments[0];
            for (let i = 0, l = source.length; i < l; i++) {
                this._array.push(source[i]);
            }
        }
        else {
            this._array.push.apply(this._array, arguments);
        }
        this._addArgs.addedCount = this._array.length - this._addArgs.index;
        this.notify(this._addArgs);
        this._notifyLengthChange();
        return this._array.length;
    }
    _notifyLengthChange() {
        const lengthChangedData = this._createPropertyChangeData('length', this._array.length);
        this.notify(lengthChangedData);
    }
    /**
     * Reverses the elements in an Array.
     */
    reverse() {
        return this._array.reverse();
    }
    /**
     * Removes the first element from an array and returns it.
     */
    shift() {
        const result = this._array.shift();
        this._deleteArgs.index = 0;
        this._deleteArgs.removed = [result];
        this.notify(this._deleteArgs);
        this._notifyLengthChange();
        return result;
    }
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array.
     */
    slice(start, end) {
        return this._array.slice(start, end);
    }
    /**
     * Sorts an array.
     * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.
     */
    sort(compareFn) {
        return this._array.sort(compareFn);
    }
    /**
     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
     * @param start The zero-based location in the array from which to start removing elements.
     * @param deleteCount The number of elements to remove.
     * @param items Elements to insert into the array in place of the deleted elements.
     */
    splice(start, deleteCount, ...items) {
        const length = this._array.length;
        const result = this._array.splice.apply(this._array, arguments);
        this.notify({
            eventName: CHANGE,
            object: this,
            action: ChangeType.Splice,
            // The logic here is a bit weird; so lets explain why it is written this way
            // First of all, if you ADD any items to the array, we want the index to point to
            //   the first value of the index, so this fixes it when you put a value to high in
            // If you remove items from the array, then the index needs to point to the INDEX
            //   where you removed the item.
            // If you add and remove items, the index will point to the remove location as that
            //   is the index you passed in.
            index: Math.max(Math.min(start, length - (result.length > 0 ? 1 : 0)), 0),
            removed: result,
            addedCount: this._array.length + result.length - length,
        });
        if (this._array.length !== length) {
            this._notifyLengthChange();
        }
        return result;
    }
    /**
     * Inserts new elements at the start of an array.
     * @param items  Elements to insert at the start of the Array.
     */
    unshift(...args) {
        const length = this._array.length;
        const result = this._array.unshift.apply(this._array, arguments);
        this._addArgs.index = 0;
        this._addArgs.addedCount = result - length;
        this.notify(this._addArgs);
        this._notifyLengthChange();
        return result;
    }
    /**
     * Returns the index of the first occurrence of a value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    indexOf(searchElement, fromIndex) {
        const index = fromIndex ? fromIndex : 0;
        for (let i = index, l = this._array.length; i < l; i++) {
            if (this._array[i] === searchElement) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Returns the index of the last occurrence of a specified value in an array.
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
     */
    lastIndexOf(searchElement, fromIndex) {
        const index = fromIndex ? fromIndex : this._array.length - 1;
        for (let i = index; i >= 0; i--) {
            if (this._array[i] === searchElement) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Determines whether all the members of an array satisfy the specified test.
     * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    every(callbackfn, thisArg) {
        return this._array.every(callbackfn, thisArg);
    }
    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    some(callbackfn, thisArg) {
        return this._array.some(callbackfn, thisArg);
    }
    /**
     * Performs the specified action for each element in an array.
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    forEach(callbackfn, thisArg) {
        this._array.forEach(callbackfn, thisArg);
    }
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map(callbackfn, thisArg) {
        return this._array.map(callbackfn, thisArg);
    }
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(callbackfn, thisArg) {
        return this._array.filter(callbackfn, thisArg);
    }
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn, initialValue) {
        return initialValue !== undefined ? this._array.reduce(callbackfn, initialValue) : this._array.reduce(callbackfn);
    }
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn, initialValue) {
        return initialValue !== undefined ? this._array.reduceRight(callbackfn, initialValue) : this._array.reduceRight(callbackfn);
    }
}
/**
 * String value used when hooking to change event.
 */
ObservableArray.changeEvent = CHANGE;
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAncestor", function() { return getAncestor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getViewById", function() { return getViewById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachDescendant", function() { return eachDescendant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewBase", function() { return ViewBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindingContextProperty", function() { return bindingContextProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classNameProperty", function() { return classNameProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idProperty", function() { return idProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "booleanConverter", function() { return booleanConverter; });
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _css_system_classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _utils_debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/* harmony import */ var _bindable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);
/* harmony import */ var _styling_style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);
/* harmony import */ var _styling_style_scope__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(50);
// Types.








// TODO: Remove this import!



let domNodeModule;
function ensuredomNodeModule() {
    if (!domNodeModule) {
        domNodeModule = __webpack_require__(78);
    }
}
let styleScopeModule;
function ensureStyleScopeModule() {
    if (!styleScopeModule) {
        styleScopeModule = __webpack_require__(50);
    }
}
let defaultBindingSource = {};
function getAncestor(view, criterion) {
    let matcher = null;
    if (typeof criterion === 'string') {
        matcher = (view) => view.typeName === criterion;
    }
    else {
        matcher = (view) => view instanceof criterion;
    }
    for (let parent = view.parent; parent != null; parent = parent.parent) {
        if (matcher(parent)) {
            return parent;
        }
    }
    return null;
}
function getViewById(view, id) {
    if (!view) {
        return undefined;
    }
    if (view.id === id) {
        return view;
    }
    let retVal;
    const descendantsCallback = function (child) {
        if (child.id === id) {
            retVal = child;
            // break the iteration by returning false
            return false;
        }
        return true;
    };
    eachDescendant(view, descendantsCallback);
    return retVal;
}
function eachDescendant(view, callback) {
    if (!callback || !view) {
        return;
    }
    let continueIteration;
    let localCallback = function (child) {
        continueIteration = callback(child);
        if (continueIteration) {
            child.eachChild(localCallback);
        }
        return continueIteration;
    };
    view.eachChild(localCallback);
}
let viewIdCounter = 1;
// const contextMap = new WeakMap<Object, Map<string, WeakRef<Object>[]>>();
// function getNativeView(context: Object, typeName: string): Object {
//     let typeMap = contextMap.get(context);
//     if (!typeMap) {
//         typeMap = new Map<string, WeakRef<Object>[]>();
//         contextMap.set(context, typeMap);
//         return undefined;
//     }
//     const array = typeMap.get(typeName);
//     if (array) {
//         let nativeView;
//         while (array.length > 0) {
//             const weakRef = array.pop();
//             nativeView = weakRef.get();
//             if (nativeView) {
//                 return nativeView;
//             }
//         }
//     }
//     return undefined;
// }
// function putNativeView(context: Object, view: ViewBase): void {
//     const typeMap = contextMap.get(context);
//     const typeName = view.typeName;
//     let list = typeMap.get(typeName);
//     if (!list) {
//         list = [];
//         typeMap.set(typeName, list);
//     }
//     list.push(new WeakRef(view.nativeViewProtected));
// }
var Flags;
(function (Flags) {
    Flags["superOnLoadedCalled"] = "Loaded";
    Flags["superOnUnloadedCalled"] = "Unloaded";
})(Flags || (Flags = {}));
var SuspendType;
(function (SuspendType) {
    SuspendType[SuspendType["Incremental"] = 0] = "Incremental";
    SuspendType[SuspendType["Loaded"] = 1048576] = "Loaded";
    SuspendType[SuspendType["NativeView"] = 2097152] = "NativeView";
    SuspendType[SuspendType["UISetup"] = 4194304] = "UISetup";
    SuspendType[SuspendType["IncrementalCountMask"] = -7340033] = "IncrementalCountMask";
})(SuspendType || (SuspendType = {}));
(function (SuspendType) {
    function toString(type) {
        return (type ? 'suspended' : 'resumed') + '(' + 'Incremental: ' + (type & SuspendType.IncrementalCountMask) + ', ' + 'Loaded: ' + !(type & SuspendType.Loaded) + ', ' + 'NativeView: ' + !(type & SuspendType.NativeView) + ', ' + 'UISetup: ' + !(type & SuspendType.UISetup) + ')';
    }
    SuspendType.toString = toString;
})(SuspendType || (SuspendType = {}));
class ViewBase extends _data_observable__WEBPACK_IMPORTED_MODULE_5__["Observable"] {
    constructor() {
        super();
        this._onLoadedCalled = false;
        this._onUnloadedCalled = false;
        this._cssState = new _styling_style_scope__WEBPACK_IMPORTED_MODULE_9__["CssState"](new WeakRef(this));
        this.pseudoClassAliases = {
            highlighted: ['active', 'pressed'],
        };
        this.cssClasses = new Set();
        this.cssPseudoClasses = new Set();
        this._domId = viewIdCounter++;
        this._style = new _styling_style__WEBPACK_IMPORTED_MODULE_6__[/* Style */ "a"](new WeakRef(this));
        this.notify({ eventName: ViewBase.createdEvent, type: this.constructor.name, object: this });
    }
    // Used in Angular.
    get parentNode() {
        return this._templateParent || this.parent;
    }
    set parentNode(node) {
        this._templateParent = node;
    }
    get nativeView() {
        // this._disableNativeViewRecycling = true;
        return this.nativeViewProtected;
    }
    set nativeView(value) {
        this.setNativeView(value);
    }
    // TODO: Use Type.prototype.typeName instead.
    get typeName() {
        return Object(_utils_types__WEBPACK_IMPORTED_MODULE_7__[/* getClass */ "c"])(this);
    }
    get style() {
        return this._style;
    }
    set style(inlineStyle /* | string */) {
        if (typeof inlineStyle === 'string') {
            this.setInlineStyle(inlineStyle);
        }
        else {
            throw new Error('View.style property is read-only.');
        }
    }
    get android() {
        // this._disableNativeViewRecycling = true;
        return this._androidView;
    }
    get ios() {
        // this._disableNativeViewRecycling = true;
        return this._iosView;
    }
    get isLoaded() {
        return this._isLoaded;
    }
    get class() {
        return this.className;
    }
    set class(v) {
        this.className = v;
    }
    getViewById(id) {
        return getViewById(this, id);
    }
    get page() {
        if (this.parent) {
            return this.parent.page;
        }
        return null;
    }
    ensureDomNode() {
        if (!this.domNode) {
            ensuredomNodeModule();
            this.domNode = new domNodeModule.DOMNode(this);
        }
    }
    // Overridden so we don't raise `propertyChange`
    // The property will raise its own event.
    set(name, value) {
        this[name] = _data_observable__WEBPACK_IMPORTED_MODULE_5__["WrappedValue"].unwrap(value);
    }
    onLoaded() {
        this.setFlag(Flags.superOnLoadedCalled, true);
        if (this._isLoaded) {
            return;
        }
        this._isLoaded = true;
        this._cssState.onLoaded();
        this._resumeNativeUpdates(SuspendType.Loaded);
        this.eachChild((child) => {
            this.loadView(child);
            return true;
        });
        this._emit('loaded');
    }
    onUnloaded() {
        this.setFlag(Flags.superOnUnloadedCalled, true);
        if (!this._isLoaded) {
            return;
        }
        this._suspendNativeUpdates(SuspendType.Loaded);
        this.eachChild((child) => {
            this.unloadView(child);
            return true;
        });
        this._isLoaded = false;
        this._cssState.onUnloaded();
        this._emit('unloaded');
    }
    _layoutParent() {
        if (this.parent) {
            this.parent._layoutParent();
        }
    }
    _suspendNativeUpdates(type) {
        if (type) {
            this._suspendNativeUpdatesCount = this._suspendNativeUpdatesCount | type;
        }
        else {
            this._suspendNativeUpdatesCount++;
        }
    }
    _resumeNativeUpdates(type) {
        if (type) {
            this._suspendNativeUpdatesCount = this._suspendNativeUpdatesCount & ~type;
        }
        else {
            if ((this._suspendNativeUpdatesCount & SuspendType.IncrementalCountMask) === 0) {
                throw new Error(`Invalid call to ${this}._resumeNativeUpdates`);
            }
            this._suspendNativeUpdatesCount--;
        }
        if (!this._suspendNativeUpdatesCount) {
            this.onResumeNativeUpdates();
        }
    }
    _batchUpdate(callback) {
        try {
            this._suspendNativeUpdates(SuspendType.Incremental);
            return callback();
        }
        finally {
            this._resumeNativeUpdates(SuspendType.Incremental);
        }
    }
    setFlag(flag, value) {
        switch (flag) {
            case Flags.superOnLoadedCalled:
                this._onLoadedCalled = value;
                break;
            case Flags.superOnUnloadedCalled:
                this._onUnloadedCalled = value;
                break;
        }
    }
    isFlagSet(flag) {
        switch (flag) {
            case Flags.superOnLoadedCalled:
                return this._onLoadedCalled;
            case Flags.superOnUnloadedCalled:
                return this._onUnloadedCalled;
        }
    }
    callFunctionWithSuper(flag, func) {
        this.setFlag(flag, false);
        func();
        if (!this.isFlagSet(flag)) {
            throw new Error(`super.${flag} not called in ${this}`);
        }
    }
    callLoaded() {
        this.callFunctionWithSuper(Flags.superOnLoadedCalled, () => this.onLoaded());
    }
    callUnloaded() {
        this.callFunctionWithSuper(Flags.superOnUnloadedCalled, () => this.onUnloaded());
    }
    notifyPseudoClassChanged(pseudoClass) {
        this.notify({ eventName: ':' + pseudoClass, object: this });
    }
    getAllAliasedStates(name) {
        const allStates = [];
        allStates.push(name);
        if (name in this.pseudoClassAliases) {
            for (let i = 0; i < this.pseudoClassAliases[name].length; i++) {
                allStates.push(this.pseudoClassAliases[name][i]);
            }
        }
        return allStates;
    }
    addPseudoClass(name) {
        let allStates = this.getAllAliasedStates(name);
        for (let i = 0; i < allStates.length; i++) {
            if (!this.cssPseudoClasses.has(allStates[i])) {
                this.cssPseudoClasses.add(allStates[i]);
                this.notifyPseudoClassChanged(allStates[i]);
            }
        }
    }
    deletePseudoClass(name) {
        let allStates = this.getAllAliasedStates(name);
        for (let i = 0; i < allStates.length; i++) {
            if (this.cssPseudoClasses.has(allStates[i])) {
                this.cssPseudoClasses.delete(allStates[i]);
                this.notifyPseudoClassChanged(allStates[i]);
            }
        }
    }
    bindingContextChanged(data) {
        this.bindings.get('bindingContext').bind(data.value);
    }
    bind(options, source = defaultBindingSource) {
        const targetProperty = options.targetProperty;
        this.unbind(targetProperty);
        if (!this.bindings) {
            this.bindings = new Map();
        }
        const binding = new _bindable__WEBPACK_IMPORTED_MODULE_3__[/* Binding */ "a"](this, options);
        this.bindings.set(targetProperty, binding);
        let bindingSource = source;
        if (bindingSource === defaultBindingSource) {
            bindingSource = this.bindingContext;
            binding.sourceIsBindingContext = true;
            if (targetProperty === 'bindingContext') {
                this.bindingContextBoundToParentBindingContextChanged = true;
                const parent = this.parent;
                if (parent) {
                    parent.on('bindingContextChange', this.bindingContextChanged, this);
                }
                else {
                    this.shouldAddHandlerToParentBindingContextChanged = true;
                }
            }
        }
        binding.bind(bindingSource);
    }
    unbind(property) {
        const bindings = this.bindings;
        if (!bindings) {
            return;
        }
        const binding = bindings.get(property);
        if (binding) {
            binding.unbind();
            bindings.delete(property);
            if (binding.sourceIsBindingContext) {
                if (property === 'bindingContext') {
                    this.shouldAddHandlerToParentBindingContextChanged = false;
                    this.bindingContextBoundToParentBindingContextChanged = false;
                    const parent = this.parent;
                    if (parent) {
                        parent.off('bindingContextChange', this.bindingContextChanged, this);
                    }
                }
            }
        }
    }
    performLayout(currentRun = 0) {
        // if there's an animation in progress we need to delay the layout
        // we've added a guard of 5000 milliseconds execution
        // to make sure that the layout will happen even if the animation haven't finished in 5 seconds
        if (this._shouldDelayLayout() && currentRun < 100) {
            setTimeout(() => this.performLayout(currentRun), currentRun);
            currentRun++;
        }
        else {
            this.parent.requestLayout();
        }
    }
    requestLayout() {
        // Default implementation for non View instances (like TabViewItem).
        const parent = this.parent;
        if (parent) {
            this.performLayout();
        }
    }
    eachChild(callback) {
        //
    }
    _addView(view, atIndex) {
        if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`${this}._addView(${view}, ${atIndex})`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.ViewHierarchy);
        }
        if (!view) {
            throw new Error('Expecting a valid View instance.');
        }
        if (!(view instanceof ViewBase)) {
            throw new Error(view + ' is not a valid View instance.');
        }
        if (view.parent) {
            throw new Error('View already has a parent. View: ' + view + ' Parent: ' + view.parent);
        }
        view.parent = this;
        this._addViewCore(view, atIndex);
        view._parentChanged(null);
        if (this.domNode) {
            this.domNode.onChildAdded(view);
        }
    }
    _addViewCore(view, atIndex) {
        Object(_properties__WEBPACK_IMPORTED_MODULE_0__["propagateInheritableProperties"])(this, view);
        view._inheritStyleScope(this._styleScope);
        Object(_properties__WEBPACK_IMPORTED_MODULE_0__["propagateInheritableCssProperties"])(this.style, view.style);
        if (this._context) {
            view._setupUI(this._context, atIndex);
        }
        if (this._isLoaded) {
            this.loadView(view);
        }
    }
    loadView(view) {
        if (view && !view.isLoaded) {
            view.callLoaded();
        }
    }
    _shouldDelayLayout() {
        return false;
    }
    unloadView(view) {
        if (view && view.isLoaded) {
            view.callUnloaded();
        }
    }
    /**
     * Core logic for removing a child view from this instance. Used by the framework to handle lifecycle events more centralized. Do not use outside the UI Stack implementation.
     */
    _removeView(view) {
        if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`${this}._removeView(${view})`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.ViewHierarchy);
        }
        if (view.parent !== this) {
            throw new Error('View not added to this instance. View: ' + view + ' CurrentParent: ' + view.parent + ' ExpectedParent: ' + this);
        }
        if (this.domNode) {
            this.domNode.onChildRemoved(view);
        }
        this._removeViewCore(view);
        view.parent = undefined;
        view._parentChanged(this);
    }
    /**
     * Method is intended to be overridden by inheritors and used as "protected"
     */
    _removeViewCore(view) {
        this.unloadView(view);
        if (view._context) {
            view._tearDownUI();
        }
    }
    createNativeView() {
        return undefined;
    }
    disposeNativeView() {
        //
    }
    initNativeView() {
        //
    }
    resetNativeView() {
        //
    }
    resetNativeViewInternal() {
        // const nativeView = this.nativeViewProtected;
        // if (nativeView && global.isAndroid) {
        //     const recycle = this.recycleNativeView;
        //     if (recycle === "always" || (recycle === "auto" && !this._disableNativeViewRecycling)) {
        //         resetNativeView(this);
        //         if (this._isPaddingRelative) {
        //             nativeView.setPaddingRelative(this._defaultPaddingLeft, this._defaultPaddingTop, this._defaultPaddingRight, this._defaultPaddingBottom);
        //         } else {
        //             nativeView.setPadding(this._defaultPaddingLeft, this._defaultPaddingTop, this._defaultPaddingRight, this._defaultPaddingBottom);
        //         }
        //         this.resetNativeView();
        //     }
        // }
        // if (this._cssState) {
        //     this._cancelAllAnimations();
        // }
    }
    _setupAsRootView(context) {
        this._setupUI(context);
    }
    _setupUI(context, atIndex, parentIsLoaded) {
        if (this._context === context) {
            return;
        }
        else if (this._context) {
            this._tearDownUI(true);
        }
        this._context = context;
        // This will account for nativeView that is created in createNativeView, recycled
        // or for backward compatability - set before _setupUI in iOS contructor.
        let nativeView = this.nativeViewProtected;
        // if (global.isAndroid) {
        //     const recycle = this.recycleNativeView;
        //     if (recycle === "always" || (recycle === "auto" && !this._disableNativeViewRecycling)) {
        //         nativeView = <android.view.View>getNativeView(context, this.typeName);
        //     }
        // }
        if (!nativeView) {
            nativeView = this.createNativeView();
        }
        if (false) {}
        else {
            this._iosView = nativeView;
        }
        this.setNativeView(nativeView);
        if (this.parent) {
            const nativeIndex = this.parent._childIndexToNativeChildIndex(atIndex);
            this._isAddedToNativeVisualTree = this.parent._addViewToNativeVisualTree(this, nativeIndex);
        }
        this._resumeNativeUpdates(SuspendType.UISetup);
        this.eachChild((child) => {
            child._setupUI(context);
            return true;
        });
    }
    setNativeView(value) {
        if (this.__nativeView === value) {
            return;
        }
        if (this.__nativeView) {
            this._suspendNativeUpdates(SuspendType.NativeView);
            // We may do a `this.resetNativeView()` here?
        }
        this.__nativeView = this.nativeViewProtected = value;
        if (this.__nativeView) {
            this._suspendedUpdates = undefined;
            this.initNativeView();
            this._resumeNativeUpdates(SuspendType.NativeView);
        }
    }
    _tearDownUI(force) {
        // No context means we are already teared down.
        if (!this._context) {
            return;
        }
        this.resetNativeViewInternal();
        this.eachChild((child) => {
            child._tearDownUI(force);
            return true;
        });
        if (this.parent) {
            this.parent._removeViewFromNativeVisualTree(this);
        }
        // const nativeView = this.nativeViewProtected;
        // if (nativeView && global.isAndroid) {
        //     const recycle = this.recycleNativeView;
        //     let shouldRecycle = false;
        //     if (recycle === "always") {
        //         shouldRecycle = true;
        //     } else if (recycle === "auto" && !this._disableNativeViewRecycling) {
        //         const propertiesSet = Object.getOwnPropertySymbols(this).length + Object.getOwnPropertySymbols(this.style).length / 2;
        //         shouldRecycle = propertiesSet <= this.recyclePropertyCounter;
        //     }
        //     // const nativeParent = global.isAndroid ? (<android.view.View>nativeView).getParent() : (<UIView>nativeView).superview;
        //     const nativeParent = (<android.view.View>nativeView).getParent();
        //     const animation = (<android.view.View>nativeView).getAnimation();
        //     if (shouldRecycle && !nativeParent && !animation) {
        //         putNativeView(this._context, this);
        //     }
        // }
        this.disposeNativeView();
        this._suspendNativeUpdates(SuspendType.UISetup);
        if (false) {}
        // this._iosView = null;
        this._context = null;
        if (this.domNode) {
            this.domNode.dispose();
            this.domNode = undefined;
        }
    }
    _childIndexToNativeChildIndex(index) {
        return index;
    }
    /**
     * Method is intended to be overridden by inheritors and used as "protected".
     */
    _addViewToNativeVisualTree(view, atIndex) {
        if (view._isAddedToNativeVisualTree) {
            throw new Error('Child already added to the native visual tree.');
        }
        return true;
    }
    /**
     * Method is intended to be overridden by inheritors and used as "protected"
     */
    _removeViewFromNativeVisualTree(view) {
        view._isAddedToNativeVisualTree = false;
    }
    _goToVisualState(state) {
        if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(this + ' going to state: ' + state, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Style);
        }
        if (state === this._visualState) {
            return;
        }
        this.deletePseudoClass(this._visualState);
        this._visualState = state;
        this.addPseudoClass(state);
    }
    /**
     * @deprecated
     *
     * This used to be the way to set attribute values in early {N} versions.
     * Now attributes are expected to be set as plain properties on the view instances.
     */
    _applyXmlAttribute(attribute, value) {
        console.log('ViewBase._applyXmlAttribute(...) is deprecated; set attributes as plain properties instead');
        if (attribute === 'style' || attribute === 'rows' || attribute === 'columns' || attribute === 'fontAttributes') {
            this[attribute] = value;
            return true;
        }
        return false;
    }
    setInlineStyle(style) {
        if (typeof style !== 'string') {
            throw new Error('Parameter should be valid CSS string!');
        }
        ensureStyleScopeModule();
        styleScopeModule.applyInlineStyle(this, style, undefined);
    }
    _parentChanged(oldParent) {
        const newParent = this.parent;
        //Overridden
        if (oldParent) {
            Object(_properties__WEBPACK_IMPORTED_MODULE_0__["clearInheritedProperties"])(this);
            if (this.bindingContextBoundToParentBindingContextChanged) {
                oldParent.off('bindingContextChange', this.bindingContextChanged, this);
            }
        }
        else if (this.shouldAddHandlerToParentBindingContextChanged) {
            newParent.on('bindingContextChange', this.bindingContextChanged, this);
            this.bindings.get('bindingContext').bind(newParent.bindingContext);
        }
    }
    onResumeNativeUpdates() {
        // Apply native setters...
        Object(_properties__WEBPACK_IMPORTED_MODULE_0__["initNativeView"])(this, undefined, undefined);
    }
    toString() {
        let str = this.typeName;
        if (this.id) {
            str += `<${this.id}>`;
        }
        else {
            str += `(${this._domId})`;
        }
        let source = _utils_debug__WEBPACK_IMPORTED_MODULE_2__["Source"].get(this);
        if (source) {
            str += `@${source};`;
        }
        return str;
    }
    _onCssStateChange() {
        this._cssState.onChange();
        eachDescendant(this, (child) => {
            child._cssState.onChange();
            return true;
        });
    }
    _inheritStyleScope(styleScope) {
        // If we are styleScope don't inherit parent stylescope.
        // TODO: Consider adding parent scope and merge selectors.
        if (this._isStyleScopeHost) {
            return;
        }
        if (this._styleScope !== styleScope) {
            this._styleScope = styleScope;
            this._onCssStateChange();
            this.eachChild((child) => {
                child._inheritStyleScope(styleScope);
                return true;
            });
        }
    }
    showModal(...args) {
        const parent = this.parent;
        return parent && parent.showModal(...args);
    }
    closeModal(...args) {
        const parent = this.parent;
        if (parent) {
            parent.closeModal(...args);
        }
    }
    _dialogClosed() {
        eachDescendant(this, (child) => {
            child._dialogClosed();
            return true;
        });
    }
    _onRootViewReset() {
        eachDescendant(this, (child) => {
            child._onRootViewReset();
            return true;
        });
    }
}
ViewBase.loadedEvent = 'loaded';
ViewBase.unloadedEvent = 'unloaded';
ViewBase.createdEvent = 'created';
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "onLoaded", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "onUnloaded", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "addPseudoClass", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "deletePseudoClass", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "requestLayout", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [ViewBase, Number]),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "_addView", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Number, Boolean]),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "_setupUI", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], ViewBase.prototype, "_tearDownUI", null);
ViewBase.prototype.isCollapsed = false;
ViewBase.prototype._oldLeft = 0;
ViewBase.prototype._oldTop = 0;
ViewBase.prototype._oldRight = 0;
ViewBase.prototype._oldBottom = 0;
ViewBase.prototype.effectiveMinWidth = 0;
ViewBase.prototype.effectiveMinHeight = 0;
ViewBase.prototype.effectiveWidth = 0;
ViewBase.prototype.effectiveHeight = 0;
ViewBase.prototype.effectiveMarginTop = 0;
ViewBase.prototype.effectiveMarginRight = 0;
ViewBase.prototype.effectiveMarginBottom = 0;
ViewBase.prototype.effectiveMarginLeft = 0;
ViewBase.prototype.effectivePaddingTop = 0;
ViewBase.prototype.effectivePaddingRight = 0;
ViewBase.prototype.effectivePaddingBottom = 0;
ViewBase.prototype.effectivePaddingLeft = 0;
ViewBase.prototype.effectiveBorderTopWidth = 0;
ViewBase.prototype.effectiveBorderRightWidth = 0;
ViewBase.prototype.effectiveBorderBottomWidth = 0;
ViewBase.prototype.effectiveBorderLeftWidth = 0;
ViewBase.prototype._defaultPaddingTop = 0;
ViewBase.prototype._defaultPaddingRight = 0;
ViewBase.prototype._defaultPaddingBottom = 0;
ViewBase.prototype._defaultPaddingLeft = 0;
ViewBase.prototype._isViewBase = true;
ViewBase.prototype.recycleNativeView = 'never';
ViewBase.prototype._suspendNativeUpdatesCount = SuspendType.Loaded | SuspendType.NativeView | SuspendType.UISetup;
const bindingContextProperty = new _properties__WEBPACK_IMPORTED_MODULE_0__["InheritedProperty"]({
    name: 'bindingContext',
});
bindingContextProperty.register(ViewBase);
const classNameProperty = new _properties__WEBPACK_IMPORTED_MODULE_0__["Property"]({
    name: 'className',
    valueChanged(view, oldValue, newValue) {
        const cssClasses = view.cssClasses;
        const rootViewsCssClasses = _css_system_classes__WEBPACK_IMPORTED_MODULE_1__[/* CSSUtils */ "a"].getSystemCssClasses();
        const shouldAddModalRootViewCssClasses = cssClasses.has(_css_system_classes__WEBPACK_IMPORTED_MODULE_1__[/* CSSUtils */ "a"].MODAL_ROOT_VIEW_CSS_CLASS);
        const shouldAddRootViewCssClasses = cssClasses.has(_css_system_classes__WEBPACK_IMPORTED_MODULE_1__[/* CSSUtils */ "a"].ROOT_VIEW_CSS_CLASS);
        cssClasses.clear();
        if (shouldAddModalRootViewCssClasses) {
            cssClasses.add(_css_system_classes__WEBPACK_IMPORTED_MODULE_1__[/* CSSUtils */ "a"].MODAL_ROOT_VIEW_CSS_CLASS);
        }
        else if (shouldAddRootViewCssClasses) {
            cssClasses.add(_css_system_classes__WEBPACK_IMPORTED_MODULE_1__[/* CSSUtils */ "a"].ROOT_VIEW_CSS_CLASS);
        }
        rootViewsCssClasses.forEach((c) => cssClasses.add(c));
        if (typeof newValue === 'string' && newValue !== '') {
            newValue.split(' ').forEach((c) => cssClasses.add(c));
        }
        view._onCssStateChange();
    },
});
classNameProperty.register(ViewBase);
const idProperty = new _properties__WEBPACK_IMPORTED_MODULE_0__["Property"]({
    name: 'id',
    valueChanged: (view, oldValue, newValue) => view._onCssStateChange(),
});
idProperty.register(ViewBase);
function booleanConverter(v) {
    const lowercase = (v + '').toLowerCase();
    if (lowercase === 'true') {
        return true;
    }
    else if (lowercase === 'false') {
        return false;
    }
    throw new Error(`Invalid boolean: ${v}`);
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var TokenStream = __webpack_require__(81);
var adoptBuffer = __webpack_require__(112);

var constants = __webpack_require__(82);
var TYPE = constants.TYPE;

var charCodeDefinitions = __webpack_require__(110);
var isNewline = charCodeDefinitions.isNewline;
var isName = charCodeDefinitions.isName;
var isValidEscape = charCodeDefinitions.isValidEscape;
var isNumberStart = charCodeDefinitions.isNumberStart;
var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
var charCodeCategory = charCodeDefinitions.charCodeCategory;
var isBOM = charCodeDefinitions.isBOM;

var utils = __webpack_require__(76);
var cmpStr = utils.cmpStr;
var getNewlineLength = utils.getNewlineLength;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var consumeEscaped = utils.consumeEscaped;
var consumeName = utils.consumeName;
var consumeNumber = utils.consumeNumber;
var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

function tokenize(source, stream) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    // § 4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = consumeNumber(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>’s unit to the returned value.
            // Return the <dimension-token>.
            type = TYPE.Dimension;
            offset = consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = TYPE.Percentage;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = TYPE.Number;
    }

    // § 4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = consumeName(source, offset);

        // If string’s value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = TYPE.Function;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = TYPE.Function;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = TYPE.Ident;
    }

    // § 4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = TYPE.String;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <string-token>.
                    return;

                // newline
                case charCodeCategory.WhiteSpace:
                    if (isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += getNewlineLength(source, offset, code);
                        type = TYPE.BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    var nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>’s value.
                        offset = consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>’s value.
            }
        }
    }

    // § 4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = TYPE.Url;

        // Consume as much whitespace as possible.
        offset = findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <url-token>.
                    return;

                // whitespace
                case charCodeCategory.WhiteSpace:
                    // Consume as much whitespace as possible.
                    offset = findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case charCodeCategory.NonPrintable:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>’s value.
                    if (isValidEscape(code, getCharCode(offset + 1))) {
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>’s value.
            }
        }
    }

    if (!stream) {
        stream = new TokenStream();
    }

    // ensure source is a string
    source = String(source || '');

    var sourceLength = source.length;
    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
    var balance = adoptBuffer(stream.balance, sourceLength + 1);
    var tokenCount = 0;
    var start = isBOM(getCharCode(0));
    var offset = start;
    var balanceCloseType = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    // § 4.3.1. Consume a token
    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;

        balance[tokenCount] = sourceLength;

        switch (charCodeCategory(code)) {
            // whitespace
            case charCodeCategory.WhiteSpace:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = TYPE.WhiteSpace;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = TYPE.Hash;

                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>’s value to the returned string.
                    offset = consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = TYPE.LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = TYPE.RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = TYPE.Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = TYPE.CDC;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = TYPE.Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = TYPE.Comment;
                    offset = source.indexOf('*/', offset + 2) + 2;
                    if (offset === 1) {
                        offset = source.length;
                    }
                } else {
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = TYPE.Colon;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = TYPE.Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = TYPE.CDO;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = TYPE.AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = TYPE.LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = TYPE.RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = TYPE.LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = TYPE.RightCurlyBracket;
                offset++;
                break;

            // digit
            case charCodeCategory.Digit:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case charCodeCategory.NameStart:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

            // EOF
            case charCodeCategory.Eof:
                // Return an <EOF-token>.
                break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = TYPE.Delim;
                offset++;
        }

        switch (type) {
            case balanceCloseType:
                balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                    if (balance[balancePrev] === sourceLength) {
                        balance[balancePrev] = tokenCount;
                    }
                }
                break;

            case TYPE.LeftParenthesis:
            case TYPE.Function:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightParenthesis;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE.LeftSquareBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightSquareBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightCurlyBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
    }

    // finalize buffers
    offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    // update stream
    stream.source = source;
    stream.firstCharOffset = start;
    stream.offsetAndType = offsetAndType;
    stream.tokenCount = tokenCount;
    stream.balance = balance;
    stream.reset();
    stream.next();

    return stream;
}

// extend tokenizer with constants
Object.keys(constants).forEach(function(key) {
    tokenize[key] = constants[key];
});

// extend tokenizer with static methods from utils
Object.keys(charCodeDefinitions).forEach(function(key) {
    tokenize[key] = charCodeDefinitions[key];
});
Object.keys(utils).forEach(function(key) {
    tokenize[key] = utils[key];
});

module.exports = tokenize;
; 
if (false ) {} 

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GestureTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GestureStateTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SwipeDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return TouchAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return toString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return GesturesObserverBase; });
var GestureTypes;
(function (GestureTypes) {
    GestureTypes[GestureTypes["tap"] = 1] = "tap";
    GestureTypes[GestureTypes["doubleTap"] = 2] = "doubleTap";
    GestureTypes[GestureTypes["pinch"] = 4] = "pinch";
    GestureTypes[GestureTypes["pan"] = 8] = "pan";
    GestureTypes[GestureTypes["swipe"] = 16] = "swipe";
    GestureTypes[GestureTypes["rotation"] = 32] = "rotation";
    GestureTypes[GestureTypes["longPress"] = 64] = "longPress";
    GestureTypes[GestureTypes["touch"] = 128] = "touch";
})(GestureTypes || (GestureTypes = {}));
var GestureStateTypes;
(function (GestureStateTypes) {
    GestureStateTypes[GestureStateTypes["cancelled"] = 0] = "cancelled";
    GestureStateTypes[GestureStateTypes["began"] = 1] = "began";
    GestureStateTypes[GestureStateTypes["changed"] = 2] = "changed";
    GestureStateTypes[GestureStateTypes["ended"] = 3] = "ended";
})(GestureStateTypes || (GestureStateTypes = {}));
var SwipeDirection;
(function (SwipeDirection) {
    SwipeDirection[SwipeDirection["right"] = 1] = "right";
    SwipeDirection[SwipeDirection["left"] = 2] = "left";
    SwipeDirection[SwipeDirection["up"] = 4] = "up";
    SwipeDirection[SwipeDirection["down"] = 8] = "down";
})(SwipeDirection || (SwipeDirection = {}));
var TouchAction;
(function (TouchAction) {
    TouchAction.down = 'down';
    TouchAction.up = 'up';
    TouchAction.move = 'move';
    TouchAction.cancel = 'cancel';
})(TouchAction || (TouchAction = {}));
function toString(type, separator) {
    let types = new Array();
    if (type & GestureTypes.tap) {
        types.push('tap');
    }
    if (type & GestureTypes.doubleTap) {
        types.push('doubleTap');
    }
    if (type & GestureTypes.pinch) {
        types.push('pinch');
    }
    if (type & GestureTypes.pan) {
        types.push('pan');
    }
    if (type & GestureTypes.swipe) {
        types.push('swipe');
    }
    if (type & GestureTypes.rotation) {
        types.push('rotation');
    }
    if (type & GestureTypes.longPress) {
        types.push('longPress');
    }
    if (type & GestureTypes.touch) {
        types.push('touch');
    }
    return types.join(separator);
}
// NOTE: toString could return the text of multiple GestureTypes.
// Souldn't fromString do split on separator and return multiple GestureTypes?
function fromString(type) {
    let t = type.trim().toLowerCase();
    if (t === 'tap') {
        return GestureTypes.tap;
    }
    else if (t === 'doubletap') {
        return GestureTypes.doubleTap;
    }
    else if (t === 'pinch') {
        return GestureTypes.pinch;
    }
    else if (t === 'pan') {
        return GestureTypes.pan;
    }
    else if (t === 'swipe') {
        return GestureTypes.swipe;
    }
    else if (t === 'rotation') {
        return GestureTypes.rotation;
    }
    else if (t === 'longpress') {
        return GestureTypes.longPress;
    }
    else if (t === 'touch') {
        return GestureTypes.touch;
    }
    return undefined;
}
class GesturesObserverBase {
    constructor(target, callback, context) {
        this._target = target;
        this._callback = callback;
        this._context = context;
    }
    get callback() {
        return this._callback;
    }
    get target() {
        return this._target;
    }
    get context() {
        return this._context;
    }
    disconnect() {
        // remove gesture observer from map
        if (this.target) {
            let list = this.target.getGestureObservers(this.type);
            if (list && list.length > 0) {
                for (let i = 0; i < list.length; i++) {
                    if (list[i].callback === this.callback) {
                        break;
                    }
                }
                list.length = 0;
                this.target._gestureObservers[this.type] = undefined;
                delete this.target._gestureObservers[this.type];
            }
        }
        this._target = null;
        this._callback = null;
        this._context = null;
    }
}
//# sourceMappingURL=gestures-common.js.map; 
if (false ) {} 

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpResponseEncoding", function() { return HttpResponseEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getString", function() { return getString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getJSON", function() { return getJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImage", function() { return getImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFile", function() { return getFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinary", function() { return getBinary; });
/* harmony import */ var _http_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "request", function() { return _http_request__WEBPACK_IMPORTED_MODULE_0__["request"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addHeader", function() { return _http_request__WEBPACK_IMPORTED_MODULE_0__["addHeader"]; });



var HttpResponseEncoding;
(function (HttpResponseEncoding) {
    HttpResponseEncoding[HttpResponseEncoding["UTF8"] = 0] = "UTF8";
    HttpResponseEncoding[HttpResponseEncoding["GBK"] = 1] = "GBK";
})(HttpResponseEncoding || (HttpResponseEncoding = {}));
function getString(arg) {
    return new Promise((resolve, reject) => {
        _http_request__WEBPACK_IMPORTED_MODULE_0__["request"](typeof arg === 'string' ? { url: arg, method: 'GET' } : arg).then((r) => {
            try {
                const str = r.content.toString();
                resolve(str);
            }
            catch (e) {
                reject(e);
            }
        }, (e) => reject(e));
    });
}
function getJSON(arg) {
    return new Promise((resolve, reject) => {
        _http_request__WEBPACK_IMPORTED_MODULE_0__["request"](typeof arg === 'string' ? { url: arg, method: 'GET' } : arg).then((r) => {
            try {
                const json = r.content.toJSON();
                resolve(json);
            }
            catch (e) {
                reject(e);
            }
        }, (e) => reject(e));
    });
}
function getImage(arg) {
    return new Promise((resolve, reject) => {
        _http_request__WEBPACK_IMPORTED_MODULE_0__["request"](typeof arg === 'string' ? { url: arg, method: 'GET' } : arg).then((r) => {
            try {
                resolve(r.content.toImage());
            }
            catch (err) {
                reject(err);
            }
        }, (err) => {
            reject(err);
        });
    });
}
function getFile(arg, destinationFilePath) {
    return new Promise((resolve, reject) => {
        _http_request__WEBPACK_IMPORTED_MODULE_0__["request"](typeof arg === 'string' ? { url: arg, method: 'GET' } : arg).then((r) => {
            try {
                const file = r.content.toFile(destinationFilePath);
                resolve(file);
            }
            catch (e) {
                reject(e);
            }
        }, (e) => reject(e));
    });
}
function getBinary(arg) {
    return new Promise((resolve, reject) => {
        _http_request__WEBPACK_IMPORTED_MODULE_0__["request"](typeof arg === 'string' ? { url: arg, method: 'GET' } : arg).then((r) => {
            try {
                const arrayBuffer = r.content.toArrayBuffer();
                resolve(arrayBuffer);
            }
            catch (e) {
                reject(e);
            }
        }, (e) => reject(e));
    });
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return openFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return releaseNativeObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return openUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return isRealDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ad; });
/* harmony import */ var _native_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "m", function() { return _native_helper__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _utils_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "f", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "g", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "h", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "i", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "j", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "l", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "n", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["j"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "o", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "p", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "q", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["m"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "s", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["n"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "t", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["o"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "u", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v", function() { return _utils_common__WEBPACK_IMPORTED_MODULE_2__["q"]; });

/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(41);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _debug__WEBPACK_IMPORTED_MODULE_3__["Source"]; });






function openFile(filePath) {
    try {
        const appPath = _native_helper__WEBPACK_IMPORTED_MODULE_0__[/* iOSNativeHelper */ "a"].getCurrentAppPath();
        let path = _native_helper__WEBPACK_IMPORTED_MODULE_0__[/* iOSNativeHelper */ "a"].isRealDevice() ? filePath.replace('~', appPath) : filePath;
        const controller = UIDocumentInteractionController.interactionControllerWithURL(NSURL.fileURLWithPath(path));
        controller.delegate = _native_helper__WEBPACK_IMPORTED_MODULE_0__[/* iOSNativeHelper */ "a"].createUIDocumentInteractionControllerDelegate();
        return controller.presentPreviewAnimated(true);
    }
    catch (e) {
        _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Error in openFile', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.error);
    }
    return false;
}
function GC() {
    __collect();
}
function releaseNativeObject(object) {
    __releaseNativeCounterpart(object);
}
function openUrl(location) {
    try {
        const url = NSURL.URLWithString(location.trim());
        if (UIApplication.sharedApplication.canOpenURL(url)) {
            return UIApplication.sharedApplication.openURL(url);
        }
    }
    catch (e) {
        // We Don't do anything with an error.  We just output it
        _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Error in OpenURL', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.error);
    }
    return false;
}
function isRealDevice() {
    return _native_helper__WEBPACK_IMPORTED_MODULE_0__[/* iOSNativeHelper */ "a"].isRealDevice();
}
const ad = 0;
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Properties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CubicBezierAnimationCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnimationBase; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
// Requires.




var Properties;
(function (Properties) {
    Properties.opacity = 'opacity';
    Properties.backgroundColor = 'backgroundColor';
    Properties.translate = 'translate';
    Properties.rotate = 'rotate';
    Properties.scale = 'scale';
    Properties.height = 'height';
    Properties.width = 'width';
})(Properties || (Properties = {}));
class CubicBezierAnimationCurve {
    constructor(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
}
class AnimationBase {
    constructor(animationDefinitions, playSequentially) {
        if (!animationDefinitions || animationDefinitions.length === 0) {
            throw new Error('No animation definitions specified');
        }
        if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Analyzing ' + animationDefinitions.length + ' animation definitions...', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
        }
        this._propertyAnimations = new Array();
        for (let i = 0, length = animationDefinitions.length; i < length; i++) {
            if (animationDefinitions[i].curve) {
                animationDefinitions[i].curve = this._resolveAnimationCurve(animationDefinitions[i].curve);
            }
            this._propertyAnimations = this._propertyAnimations.concat(AnimationBase._createPropertyAnimations(animationDefinitions[i]));
        }
        if (this._propertyAnimations.length === 0) {
            throw new Error('Nothing to animate.');
        }
        if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Created ' + this._propertyAnimations.length + ' individual property animations.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
        }
        this._playSequentially = playSequentially;
    }
    _rejectAlreadyPlaying() {
        const reason = 'Animation is already playing.';
        _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(reason, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
        return new Promise((resolve, reject) => {
            reject(reason);
        });
    }
    play() {
        // We have to actually create a "Promise" due to a bug in the v8 engine and decedent promises
        // We just cast it to a animationPromise so that all the rest of the code works fine
        const animationFinishedPromise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        this.fixupAnimationPromise(animationFinishedPromise);
        this._isPlaying = true;
        return animationFinishedPromise;
    }
    fixupAnimationPromise(promise) {
        // Since we are using function() below because of arguments, TS won't automatically do a _this for those functions.
        const _this = this;
        promise.cancel = () => {
            _this.cancel();
        };
        const _then = promise.then;
        promise.then = function () {
            const r = _then.apply(promise, arguments);
            _this.fixupAnimationPromise(r);
            return r;
        };
        const _catch = promise.catch;
        promise.catch = function () {
            const r = _catch.apply(promise, arguments);
            _this.fixupAnimationPromise(r);
            return r;
        };
    }
    cancel() {
        // Implemented in platform specific files
    }
    get isPlaying() {
        return this._isPlaying;
    }
    _resolveAnimationFinishedPromise() {
        this._isPlaying = false;
        this._resolve();
    }
    _rejectAnimationFinishedPromise() {
        this._isPlaying = false;
        this._reject(new Error('Animation cancelled.'));
    }
    static _createPropertyAnimations(animationDefinition) {
        if (!animationDefinition.target) {
            throw new Error('No animation target specified.');
        }
        for (let item in animationDefinition) {
            const value = animationDefinition[item];
            if (value === undefined) {
                continue;
            }
            if ((item === Properties.opacity || item === 'duration' || item === 'delay' || item === 'iterations') && typeof value !== 'number') {
                throw new Error(`Property ${item} must be valid number. Value: ${value}`);
            }
            else if ((item === Properties.scale || item === Properties.translate) && (typeof value.x !== 'number' || typeof value.y !== 'number')) {
                throw new Error(`Property ${item} must be valid Pair. Value: ${value}`);
            }
            else if (item === Properties.backgroundColor && !_color__WEBPACK_IMPORTED_MODULE_0__[/* Color */ "a"].isValid(animationDefinition.backgroundColor)) {
                throw new Error(`Property ${item} must be valid color. Value: ${value}`);
            }
            else if (item === Properties.width || item === Properties.height) {
                // Coerce input into a PercentLength object in case it's a string.
                animationDefinition[item] = _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["PercentLength"].parse(value);
            }
            else if (item === Properties.rotate) {
                const rotate = value;
                if (typeof rotate !== 'number' && !(typeof rotate.x === 'number' && typeof rotate.y === 'number' && typeof rotate.z === 'number')) {
                    throw new Error(`Property ${rotate} must be valid number or Point3D. Value: ${value}`);
                }
            }
        }
        const propertyAnimations = new Array();
        // opacity
        if (animationDefinition.opacity !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.opacity,
                value: animationDefinition.opacity,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        // backgroundColor
        if (animationDefinition.backgroundColor !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.backgroundColor,
                value: typeof animationDefinition.backgroundColor === 'string' ? new _color__WEBPACK_IMPORTED_MODULE_0__[/* Color */ "a"](animationDefinition.backgroundColor) : animationDefinition.backgroundColor,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        // translate
        if (animationDefinition.translate !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.translate,
                value: animationDefinition.translate,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        // scale
        if (animationDefinition.scale !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.scale,
                value: animationDefinition.scale,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        // rotate
        if (animationDefinition.rotate !== undefined) {
            // Make sure the value of the rotation property is always Point3D
            let rotationValue;
            if (typeof animationDefinition.rotate === 'number') {
                rotationValue = { x: 0, y: 0, z: animationDefinition.rotate };
            }
            else {
                rotationValue = animationDefinition.rotate;
            }
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.rotate,
                value: rotationValue,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        // height
        if (animationDefinition.height !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.height,
                value: animationDefinition.height,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        // width
        if (animationDefinition.width !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.width,
                value: animationDefinition.width,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve,
            });
        }
        if (propertyAnimations.length === 0) {
            throw new Error('No known animation properties specified');
        }
        return propertyAnimations;
    }
    static _getAnimationInfo(animation) {
        return JSON.stringify({
            target: animation.target.id,
            property: animation.property,
            value: animation.value,
            duration: animation.duration,
            delay: animation.delay,
            iterations: animation.iterations,
            curve: animation.curve,
        });
    }
}
//# sourceMappingURL=animation-common.js.map; 
if (false ) {} 

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "getFileAccess", function() { return /* binding */ getFileAccess; });
__webpack_require__.d(__webpack_exports__, "FileSystemEntity", function() { return /* binding */ FileSystemEntity; });
__webpack_require__.d(__webpack_exports__, "File", function() { return /* binding */ File; });
__webpack_require__.d(__webpack_exports__, "Folder", function() { return /* binding */ Folder; });
__webpack_require__.d(__webpack_exports__, "knownFolders", function() { return /* binding */ knownFolders; });
__webpack_require__.d(__webpack_exports__, "path", function() { return /* binding */ file_system_path; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/text/index.js + 1 modules
var core_text = __webpack_require__(61);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/native-helper.js
var native_helper = __webpack_require__(38);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/file-system/file-system-access.js


// TODO: Implement all the APIs receiving callback using async blocks
// TODO: Check whether we need try/catch blocks for the iOS implementation
class file_system_access_FileSystemAccess {
    constructor() {
        this.readText = this.readTextSync.bind(this);
        this.read = this.readSync.bind(this);
        this.writeText = this.writeTextSync.bind(this);
        this.write = this.writeSync.bind(this);
    }
    getLastModified(path) {
        const fileManager = NSFileManager.defaultManager;
        const attributes = fileManager.attributesOfItemAtPathError(path);
        if (attributes) {
            return attributes.objectForKey('NSFileModificationDate');
        }
        else {
            return new Date();
        }
    }
    getFileSize(path) {
        const fileManager = NSFileManager.defaultManager;
        const attributes = fileManager.attributesOfItemAtPathError(path);
        if (attributes) {
            return attributes.objectForKey('NSFileSize');
        }
        else {
            return 0;
        }
    }
    getParent(path, onError) {
        try {
            const fileManager = NSFileManager.defaultManager;
            const nsString = NSString.stringWithString(path);
            const parentPath = nsString.stringByDeletingLastPathComponent;
            const name = fileManager.displayNameAtPath(parentPath);
            return {
                path: parentPath.toString(),
                name: name,
            };
        }
        catch (exception) {
            if (onError) {
                onError(exception);
            }
            return undefined;
        }
    }
    getFile(path, onError) {
        try {
            const fileManager = NSFileManager.defaultManager;
            const exists = fileManager.fileExistsAtPath(path);
            if (!exists) {
                const parentPath = this.getParent(path, onError).path;
                if (!fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(parentPath, true, null) || !fileManager.createFileAtPathContentsAttributes(path, null, null)) {
                    if (onError) {
                        onError(new Error("Failed to create file at path '" + path + "'"));
                    }
                    return undefined;
                }
            }
            const fileName = fileManager.displayNameAtPath(path);
            return {
                path: path,
                name: fileName,
                extension: this.getFileExtension(path),
            };
        }
        catch (exception) {
            if (onError) {
                onError(exception);
            }
            return undefined;
        }
    }
    getFolder(path, onError) {
        try {
            const fileManager = NSFileManager.defaultManager;
            const exists = this.folderExists(path);
            if (!exists) {
                try {
                    fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(path, true, null);
                }
                catch (ex) {
                    if (onError) {
                        onError(new Error("Failed to create folder at path '" + path + "': " + ex));
                    }
                    return undefined;
                }
            }
            const dirName = fileManager.displayNameAtPath(path);
            return {
                path: path,
                name: dirName,
            };
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to create folder at path '" + path + "'"));
            }
            return undefined;
        }
    }
    getExistingFolder(path, onError) {
        try {
            const fileManager = NSFileManager.defaultManager;
            const exists = this.folderExists(path);
            if (exists) {
                const dirName = fileManager.displayNameAtPath(path);
                return {
                    path: path,
                    name: dirName,
                };
            }
            return undefined;
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to get folder at path '" + path + "'"));
            }
            return undefined;
        }
    }
    eachEntity(path, onEntity, onError) {
        if (!onEntity) {
            return;
        }
        this.enumEntities(path, onEntity, onError);
    }
    getEntities(path, onError) {
        const fileInfos = new Array();
        const onEntity = function (entity) {
            fileInfos.push(entity);
            return true;
        };
        let errorOccurred;
        const localError = function (error) {
            if (onError) {
                onError(error);
            }
            errorOccurred = true;
        };
        this.enumEntities(path, onEntity, localError);
        if (!errorOccurred) {
            return fileInfos;
        }
        return null;
    }
    fileExists(path) {
        const result = this.exists(path);
        return result.exists;
    }
    folderExists(path) {
        const result = this.exists(path);
        return result.exists && result.isDirectory;
    }
    exists(path) {
        const fileManager = NSFileManager.defaultManager;
        const isDirectory = new interop.Reference(interop.types.bool, false);
        const exists = fileManager.fileExistsAtPathIsDirectory(path, isDirectory);
        return { exists: exists, isDirectory: isDirectory.value };
    }
    concatPath(left, right) {
        return NSString.pathWithComponents([left, right]).toString();
    }
    deleteFile(path, onError) {
        this.deleteEntity(path, onError);
    }
    deleteFolder(path, onError) {
        this.deleteEntity(path, onError);
    }
    emptyFolder(path, onError) {
        const fileManager = NSFileManager.defaultManager;
        const entities = this.getEntities(path, onError);
        if (!entities) {
            return;
        }
        for (let i = 0; i < entities.length; i++) {
            try {
                fileManager.removeItemAtPathError(entities[i].path);
            }
            catch (ex) {
                if (onError) {
                    onError(new Error("Failed to empty folder '" + path + "': " + ex));
                }
                return;
            }
        }
    }
    rename(path, newPath, onError) {
        const fileManager = NSFileManager.defaultManager;
        try {
            fileManager.moveItemAtPathToPathError(path, newPath);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to rename '" + path + "' to '" + newPath + "': " + ex));
            }
        }
    }
    getLogicalRootPath() {
        const mainBundlePath = NSBundle.mainBundle.bundlePath;
        const resolvedPath = NSString.stringWithString(mainBundlePath).stringByResolvingSymlinksInPath;
        return resolvedPath;
    }
    getDocumentsFolderPath() {
        return this.getKnownPath(9 /* DocumentDirectory */);
    }
    getTempFolderPath() {
        return this.getKnownPath(13 /* CachesDirectory */);
    }
    getCurrentAppPath() {
        return native_helper["a" /* iOSNativeHelper */].getCurrentAppPath();
    }
    readTextAsync(path, encoding) {
        const actualEncoding = encoding || core_text["encoding"].UTF_8;
        return new Promise((resolve, reject) => {
            try {
                NSString.stringWithContentsOfFileEncodingCompletion(path, actualEncoding, (result, error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(result.toString());
                    }
                });
            }
            catch (ex) {
                reject(new Error("Failed to read file at path '" + path + "': " + ex));
            }
        });
    }
    readTextSync(path, onError, encoding) {
        const actualEncoding = encoding || core_text["encoding"].UTF_8;
        try {
            const nsString = NSString.stringWithContentsOfFileEncodingError(path, actualEncoding);
            return nsString.toString();
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to read file at path '" + path + "': " + ex));
            }
        }
    }
    readAsync(path) {
        return new Promise((resolve, reject) => {
            try {
                NSData.dataWithContentsOfFileCompletion(path, resolve);
            }
            catch (ex) {
                reject(new Error("Failed to read file at path '" + path + "': " + ex));
            }
        });
    }
    readSync(path, onError) {
        try {
            return NSData.dataWithContentsOfFile(path);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to read file at path '" + path + "': " + ex));
            }
        }
    }
    writeTextAsync(path, content, encoding) {
        const nsString = NSString.stringWithString(content);
        const actualEncoding = encoding || core_text["encoding"].UTF_8;
        return new Promise((resolve, reject) => {
            try {
                nsString.writeToFileAtomicallyEncodingCompletion(path, true, actualEncoding, (error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            }
            catch (ex) {
                reject(new Error("Failed to write file at path '" + path + "': " + ex));
            }
        });
    }
    writeTextSync(path, content, onError, encoding) {
        const nsString = NSString.stringWithString(content);
        const actualEncoding = encoding || core_text["encoding"].UTF_8;
        // TODO: verify the useAuxiliaryFile parameter should be false
        try {
            nsString.writeToFileAtomicallyEncodingError(path, false, actualEncoding);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to write to file '" + path + "': " + ex));
            }
        }
    }
    writeAsync(path, content) {
        return new Promise((resolve, reject) => {
            try {
                content.writeToFileAtomicallyCompletion(path, true, () => {
                    resolve();
                });
            }
            catch (ex) {
                reject(new Error("Failed to write file at path '" + path + "': " + ex));
            }
        });
    }
    writeSync(path, content, onError) {
        try {
            content.writeToFileAtomically(path, true);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to write to file '" + path + "': " + ex));
            }
        }
    }
    getKnownPath(folderType) {
        const fileManager = NSFileManager.defaultManager;
        const paths = fileManager.URLsForDirectoryInDomains(folderType, 1 /* UserDomainMask */);
        const url = paths.objectAtIndex(0);
        return url.path;
    }
    // TODO: This method is the same as in the iOS implementation.
    // Make it in a separate file / module so it can be reused from both implementations.
    getFileExtension(path) {
        // TODO [For Panata]: The definitions currently specify "any" as a return value of this method
        //const nsString = Foundation.NSString.stringWithString(path);
        //const extension = nsString.pathExtension();
        //if (extension && extension.length > 0) {
        //    extension = extension.concat(".", extension);
        //}
        //return extension;
        const dotIndex = path.lastIndexOf('.');
        if (dotIndex && dotIndex >= 0 && dotIndex < path.length) {
            return path.substring(dotIndex);
        }
        return '';
    }
    deleteEntity(path, onError) {
        const fileManager = NSFileManager.defaultManager;
        try {
            fileManager.removeItemAtPathError(path);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to delete file at path '" + path + "': " + ex));
            }
        }
    }
    enumEntities(path, callback, onError) {
        try {
            const fileManager = NSFileManager.defaultManager;
            let files;
            try {
                files = fileManager.contentsOfDirectoryAtPathError(path);
            }
            catch (ex) {
                if (onError) {
                    onError(new Error("Failed to enum files for folder '" + path + "': " + ex));
                }
                return;
            }
            for (let i = 0; i < files.count; i++) {
                const file = files.objectAtIndex(i);
                const info = {
                    path: this.concatPath(path, file),
                    name: file,
                    extension: '',
                };
                if (!this.folderExists(this.joinPath(path, file))) {
                    info.extension = this.getFileExtension(info.path);
                }
                const retVal = callback(info);
                if (retVal === false) {
                    // the callback returned false meaning we should stop the iteration
                    break;
                }
            }
        }
        catch (ex) {
            if (onError) {
                onError(ex);
            }
        }
    }
    getPathSeparator() {
        return '/';
    }
    normalizePath(path) {
        const nsString = NSString.stringWithString(path);
        const normalized = nsString.stringByStandardizingPath;
        return normalized;
    }
    joinPath(left, right) {
        const nsString = NSString.stringWithString(left);
        return nsString.stringByAppendingPathComponent(right);
    }
    joinPaths(paths) {
        return native_helper["a" /* iOSNativeHelper */].joinPaths(...paths);
    }
}
//# sourceMappingURL=file-system-access.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/file-system/index.js

// The FileSystemAccess implementation, used through all the APIs.
let fileAccess;
/**
 * Returns FileSystemAccess, a shared singleton utility class to provide methods to access and work with the file system. This is used under the hood of all the file system apis in @nativescript/core and provided as a lower level convenience if needed.
 * @returns FileSystemAccess
 */
function getFileAccess() {
    if (!fileAccess) {
        fileAccess = new file_system_access_FileSystemAccess();
    }
    return fileAccess;
}
function createFile(info) {
    const file = new File();
    file._path = info.path;
    file._name = info.name;
    file._extension = info.extension;
    return file;
}
function createFolder(info) {
    const documents = knownFolders.documents();
    if (info.path === documents.path) {
        return documents;
    }
    const temp = knownFolders.temp();
    if (info.path === temp.path) {
        return temp;
    }
    const folder = new Folder();
    folder._path = info.path;
    folder._name = info.name;
    return folder;
}
class FileSystemEntity {
    get parent() {
        const onError = function (error) {
            throw error;
        };
        const folderInfo = getFileAccess().getParent(this.path, onError);
        if (!folderInfo) {
            return undefined;
        }
        return createFolder(folderInfo);
    }
    remove() {
        return new Promise((resolve, reject) => {
            let hasError = false;
            const localError = function (error) {
                hasError = true;
                reject(error);
            };
            this.removeSync(localError);
            if (!hasError) {
                resolve();
            }
        });
    }
    removeSync(onError) {
        if (this._isKnown) {
            if (onError) {
                onError({ message: 'Cannot delete known folder.' });
            }
            return;
        }
        const fileAccess = getFileAccess();
        if (this instanceof File) {
            fileAccess.deleteFile(this.path, onError);
        }
        else if (this instanceof Folder) {
            fileAccess.deleteFolder(this.path, onError);
        }
    }
    rename(newName) {
        return new Promise((resolve, reject) => {
            let hasError = false;
            const localError = function (error) {
                hasError = true;
                reject(error);
            };
            this.renameSync(newName, localError);
            if (!hasError) {
                resolve();
            }
        });
    }
    renameSync(newName, onError) {
        if (this._isKnown) {
            if (onError) {
                onError(new Error('Cannot rename known folder.'));
            }
            return;
        }
        const parentFolder = this.parent;
        if (!parentFolder) {
            if (onError) {
                onError(new Error('No parent folder.'));
            }
            return;
        }
        const fileAccess = getFileAccess();
        const path = parentFolder.path;
        const newPath = fileAccess.joinPath(path, newName);
        const localError = function (error) {
            if (onError) {
                onError(error);
            }
            return null;
        };
        fileAccess.rename(this.path, newPath, localError);
        this._path = newPath;
        this._name = newName;
        if (this instanceof File) {
            this._extension = fileAccess.getFileExtension(newPath);
        }
    }
    get name() {
        return this._name;
    }
    get path() {
        return this._path;
    }
    get lastModified() {
        let value = this._lastModified;
        if (!this._lastModified) {
            value = this._lastModified = getFileAccess().getLastModified(this.path);
        }
        return value;
    }
}
class File extends FileSystemEntity {
    static fromPath(path) {
        const onError = function (error) {
            throw error;
        };
        const fileInfo = getFileAccess().getFile(path, onError);
        if (!fileInfo) {
            return undefined;
        }
        return createFile(fileInfo);
    }
    static exists(path) {
        return getFileAccess().fileExists(path);
    }
    get extension() {
        return this._extension;
    }
    get isLocked() {
        // !! is a boolean conversion/cast, handling undefined as well
        return !!this._locked;
    }
    get size() {
        return getFileAccess().getFileSize(this.path);
    }
    read() {
        return new Promise((resolve, reject) => {
            try {
                this.checkAccess();
            }
            catch (ex) {
                reject(ex);
                return;
            }
            this._locked = true;
            getFileAccess()
                .readAsync(this.path)
                .then((result) => {
                resolve(result);
                this._locked = false;
            }, (error) => {
                reject(error);
                this._locked = false;
            });
        });
    }
    readSync(onError) {
        this.checkAccess();
        this._locked = true;
        const that = this;
        const localError = (error) => {
            that._locked = false;
            if (onError) {
                onError(error);
            }
        };
        const content = getFileAccess().readSync(this.path, localError);
        this._locked = false;
        return content;
    }
    write(content) {
        return new Promise((resolve, reject) => {
            try {
                this.checkAccess();
            }
            catch (ex) {
                reject(ex);
                return;
            }
            this._locked = true;
            getFileAccess()
                .writeAsync(this.path, content)
                .then(() => {
                resolve();
                this._locked = false;
            }, (error) => {
                reject(error);
                this._locked = false;
            });
        });
    }
    writeSync(content, onError) {
        this.checkAccess();
        try {
            this._locked = true;
            const that = this;
            const localError = function (error) {
                that._locked = false;
                if (onError) {
                    onError(error);
                }
            };
            getFileAccess().writeSync(this.path, content, localError);
        }
        finally {
            this._locked = false;
        }
    }
    readText(encoding) {
        return new Promise((resolve, reject) => {
            try {
                this.checkAccess();
            }
            catch (ex) {
                reject(ex);
                return;
            }
            this._locked = true;
            getFileAccess()
                .readTextAsync(this.path, encoding)
                .then((result) => {
                resolve(result);
                this._locked = false;
            }, (error) => {
                reject(error);
                this._locked = false;
            });
        });
    }
    readTextSync(onError, encoding) {
        this.checkAccess();
        this._locked = true;
        const that = this;
        const localError = (error) => {
            that._locked = false;
            if (onError) {
                onError(error);
            }
        };
        const content = getFileAccess().readTextSync(this.path, localError, encoding);
        this._locked = false;
        return content;
    }
    writeText(content, encoding) {
        return new Promise((resolve, reject) => {
            try {
                this.checkAccess();
            }
            catch (ex) {
                reject(ex);
                return;
            }
            this._locked = true;
            getFileAccess()
                .writeTextAsync(this.path, content, encoding)
                .then(() => {
                resolve();
                this._locked = false;
            }, (error) => {
                reject(error);
                this._locked = false;
            });
        });
    }
    writeTextSync(content, onError, encoding) {
        this.checkAccess();
        try {
            this._locked = true;
            const that = this;
            const localError = function (error) {
                that._locked = false;
                if (onError) {
                    onError(error);
                }
            };
            getFileAccess().writeTextSync(this.path, content, localError, encoding);
        }
        finally {
            this._locked = false;
        }
    }
    checkAccess() {
        if (this.isLocked) {
            throw new Error('Cannot access a locked file.');
        }
    }
}
class Folder extends FileSystemEntity {
    static fromPath(path) {
        const onError = function (error) {
            throw error;
        };
        const folderInfo = getFileAccess().getFolder(path, onError);
        if (!folderInfo) {
            return undefined;
        }
        return createFolder(folderInfo);
    }
    static exists(path) {
        return getFileAccess().folderExists(path);
    }
    contains(name) {
        const fileAccess = getFileAccess();
        const path = fileAccess.joinPath(this.path, name);
        if (fileAccess.fileExists(path)) {
            return true;
        }
        return fileAccess.folderExists(path);
    }
    clear() {
        return new Promise((resolve, reject) => {
            let hasError = false;
            const onError = function (error) {
                hasError = true;
                reject(error);
            };
            this.clearSync(onError);
            if (!hasError) {
                resolve();
            }
        });
    }
    clearSync(onError) {
        getFileAccess().emptyFolder(this.path, onError);
    }
    get isKnown() {
        return this._isKnown;
    }
    getFile(name) {
        const fileAccess = getFileAccess();
        const path = fileAccess.joinPath(this.path, name);
        const onError = function (error) {
            throw error;
        };
        const fileInfo = fileAccess.getFile(path, onError);
        if (!fileInfo) {
            return undefined;
        }
        return createFile(fileInfo);
    }
    getFolder(name) {
        const fileAccess = getFileAccess();
        const path = fileAccess.joinPath(this.path, name);
        const onError = function (error) {
            throw error;
        };
        const folderInfo = fileAccess.getFolder(path, onError);
        if (!folderInfo) {
            return undefined;
        }
        return createFolder(folderInfo);
    }
    getEntities() {
        return new Promise((resolve, reject) => {
            let hasError = false;
            const localError = function (error) {
                hasError = true;
                reject(error);
            };
            const entities = this.getEntitiesSync(localError);
            if (!hasError) {
                resolve(entities);
            }
        });
    }
    getEntitiesSync(onError) {
        const fileInfos = getFileAccess().getEntities(this.path, onError);
        if (!fileInfos) {
            return null;
        }
        const entities = new Array();
        for (let i = 0; i < fileInfos.length; i++) {
            if (fileInfos[i].extension) {
                entities.push(createFile(fileInfos[i]));
            }
            else {
                entities.push(createFolder(fileInfos[i]));
            }
        }
        return entities;
    }
    eachEntity(onEntity) {
        if (!onEntity) {
            return;
        }
        const onSuccess = function (fileInfo) {
            let entity;
            if (fileInfo.extension) {
                entity = createFile(fileInfo);
            }
            else {
                entity = createFolder(fileInfo);
            }
            return onEntity(entity);
        };
        const onError = function (error) {
            throw error;
        };
        getFileAccess().eachEntity(this.path, onSuccess, onError);
    }
}
var knownFolders;
(function (knownFolders) {
    let _documents;
    let _temp;
    let _app;
    function documents() {
        if (!_documents) {
            const path = getFileAccess().getDocumentsFolderPath();
            _documents = new Folder();
            _documents._path = path;
            _documents._isKnown = true;
        }
        return _documents;
    }
    knownFolders.documents = documents;
    function temp() {
        if (!_temp) {
            const path = getFileAccess().getTempFolderPath();
            _temp = new Folder();
            _temp._path = path;
            _temp._isKnown = true;
        }
        return _temp;
    }
    knownFolders.temp = temp;
    function currentApp() {
        if (!_app) {
            const path = getFileAccess().getCurrentAppPath();
            _app = new Folder();
            _app._path = path;
            _app._isKnown = true;
        }
        return _app;
    }
    knownFolders.currentApp = currentApp;
    let ios;
    (function (ios) {
        function _checkPlatform(knownFolderName) {
            if (false) {}
        }
        let _library;
        function library() {
            _checkPlatform('library');
            if (!_library) {
                let existingFolderInfo = getExistingFolderInfo(5 /* LibraryDirectory */);
                if (existingFolderInfo) {
                    _library = existingFolderInfo.folder;
                    _library._path = existingFolderInfo.path;
                    _library._isKnown = true;
                }
            }
            return _library;
        }
        ios.library = library;
        let _developer;
        function developer() {
            _checkPlatform('developer');
            if (!_developer) {
                let existingFolderInfo = getExistingFolderInfo(6 /* DeveloperDirectory */);
                if (existingFolderInfo) {
                    _developer = existingFolderInfo.folder;
                    _developer._path = existingFolderInfo.path;
                    _developer._isKnown = true;
                }
            }
            return _developer;
        }
        ios.developer = developer;
        let _desktop;
        function desktop() {
            _checkPlatform('desktop');
            if (!_desktop) {
                let existingFolderInfo = getExistingFolderInfo(12 /* DesktopDirectory */);
                if (existingFolderInfo) {
                    _desktop = existingFolderInfo.folder;
                    _desktop._path = existingFolderInfo.path;
                    _desktop._isKnown = true;
                }
            }
            return _desktop;
        }
        ios.desktop = desktop;
        let _downloads;
        function downloads() {
            _checkPlatform('downloads');
            if (!_downloads) {
                let existingFolderInfo = getExistingFolderInfo(15 /* DownloadsDirectory */);
                if (existingFolderInfo) {
                    _downloads = existingFolderInfo.folder;
                    _downloads._path = existingFolderInfo.path;
                    _downloads._isKnown = true;
                }
            }
            return _downloads;
        }
        ios.downloads = downloads;
        let _movies;
        function movies() {
            _checkPlatform('movies');
            if (!_movies) {
                let existingFolderInfo = getExistingFolderInfo(17 /* MoviesDirectory */);
                if (existingFolderInfo) {
                    _movies = existingFolderInfo.folder;
                    _movies._path = existingFolderInfo.path;
                    _movies._isKnown = true;
                }
            }
            return _movies;
        }
        ios.movies = movies;
        let _music;
        function music() {
            _checkPlatform('music');
            if (!_music) {
                let existingFolderInfo = getExistingFolderInfo(18 /* MusicDirectory */);
                if (existingFolderInfo) {
                    _music = existingFolderInfo.folder;
                    _music._path = existingFolderInfo.path;
                    _music._isKnown = true;
                }
            }
            return _music;
        }
        ios.music = music;
        let _pictures;
        function pictures() {
            _checkPlatform('pictures');
            if (!_pictures) {
                let existingFolderInfo = getExistingFolderInfo(19 /* PicturesDirectory */);
                if (existingFolderInfo) {
                    _pictures = existingFolderInfo.folder;
                    _pictures._path = existingFolderInfo.path;
                    _pictures._isKnown = true;
                }
            }
            return _pictures;
        }
        ios.pictures = pictures;
        let _sharedPublic;
        function sharedPublic() {
            _checkPlatform('sharedPublic');
            if (!_sharedPublic) {
                let existingFolderInfo = getExistingFolderInfo(21 /* SharedPublicDirectory */);
                if (existingFolderInfo) {
                    _sharedPublic = existingFolderInfo.folder;
                    _sharedPublic._path = existingFolderInfo.path;
                    _sharedPublic._isKnown = true;
                }
            }
            return _sharedPublic;
        }
        ios.sharedPublic = sharedPublic;
        function getExistingFolderInfo(pathDirectory /* NSSearchPathDirectory */) {
            const fileAccess = getFileAccess();
            const folderPath = fileAccess.getKnownPath(pathDirectory);
            const folderInfo = fileAccess.getExistingFolder(folderPath);
            if (folderInfo) {
                return {
                    folder: createFolder(folderInfo),
                    path: folderPath,
                };
            }
            return undefined;
        }
    })(ios = knownFolders.ios || (knownFolders.ios = {}));
})(knownFolders || (knownFolders = {}));
var file_system_path;
(function (path_1) {
    function normalize(path) {
        return getFileAccess().normalizePath(path);
    }
    path_1.normalize = normalize;
    function join(...paths) {
        const fileAccess = getFileAccess();
        return fileAccess.joinPaths(paths);
    }
    path_1.join = join;
    path_1.separator = getFileAccess().getPathSeparator();
})(file_system_path || (file_system_path = {}));
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Font; });
/* unused harmony export ios */
/* harmony import */ var _font_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _file_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);





const EMULATE_OBLIQUE = true;
const OBLIQUE_TRANSFORM = CGAffineTransformMake(1, 0, 0.2, 1, 0, 0);
const DEFAULT_SERIF = 'Times New Roman';
const DEFAULT_MONOSPACE = 'Courier New';
const SUPPORT_FONT_WEIGHTS = parseFloat(_platform__WEBPACK_IMPORTED_MODULE_2__["Device"].osVersion) >= 10.0;
class Font extends _font_common__WEBPACK_IMPORTED_MODULE_0__[/* Font */ "a"] {
    constructor(family, size, style, weight) {
        super(family, size, style, weight);
    }
    withFontFamily(family) {
        return new Font(family, this.fontSize, this.fontStyle, this.fontWeight);
    }
    withFontStyle(style) {
        return new Font(this.fontFamily, this.fontSize, style, this.fontWeight);
    }
    withFontWeight(weight) {
        return new Font(this.fontFamily, this.fontSize, this.fontStyle, weight);
    }
    withFontSize(size) {
        return new Font(this.fontFamily, size, this.fontStyle, this.fontWeight);
    }
    getUIFont(defaultFont) {
        if (!this._uiFont) {
            this._uiFont = createUIFont(this, defaultFont);
        }
        return this._uiFont;
    }
    getAndroidTypeface() {
        return undefined;
    }
}
Font.default = new Font(undefined, undefined, _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontStyle */ "b"].NORMAL, _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].NORMAL);
function getFontFamilyRespectingGenericFonts(fontFamily) {
    if (!fontFamily) {
        return fontFamily;
    }
    switch (fontFamily.toLowerCase()) {
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* genericFontFamilies */ "d"].serif:
            return DEFAULT_SERIF;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* genericFontFamilies */ "d"].monospace:
            return DEFAULT_MONOSPACE;
        default:
            return fontFamily;
    }
}
function shouldUseSystemFont(fontFamily) {
    return !fontFamily || fontFamily === _font_common__WEBPACK_IMPORTED_MODULE_0__[/* genericFontFamilies */ "d"].sansSerif || fontFamily === _font_common__WEBPACK_IMPORTED_MODULE_0__[/* genericFontFamilies */ "d"].system;
}
function getNativeFontWeight(fontWeight) {
    switch (fontWeight) {
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].THIN:
            return UIFontWeightUltraLight;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].EXTRA_LIGHT:
            return UIFontWeightThin;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].LIGHT:
            return UIFontWeightLight;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].NORMAL:
        case '400':
        case undefined:
        case null:
            return UIFontWeightRegular;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].MEDIUM:
            return UIFontWeightMedium;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].SEMI_BOLD:
            return UIFontWeightSemibold;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].BOLD:
        case '700':
            return UIFontWeightBold;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].EXTRA_BOLD:
            return UIFontWeightHeavy;
        case _font_common__WEBPACK_IMPORTED_MODULE_0__[/* FontWeight */ "c"].BLACK:
            return UIFontWeightBlack;
        default:
            throw new Error(`Invalid font weight: "${fontWeight}"`);
    }
}
function getSystemFont(size, nativeWeight, italic, symbolicTraits) {
    let result = UIFont.systemFontOfSizeWeight(size, nativeWeight);
    if (italic) {
        let descriptor = result.fontDescriptor.fontDescriptorWithSymbolicTraits(symbolicTraits);
        result = UIFont.fontWithDescriptorSize(descriptor, size);
    }
    return result;
}
function createUIFont(font, defaultFont) {
    let result;
    const size = font.fontSize || defaultFont.pointSize;
    const nativeWeight = getNativeFontWeight(font.fontWeight);
    const fontFamilies = Object(_font_common__WEBPACK_IMPORTED_MODULE_0__[/* parseFontFamily */ "f"])(font.fontFamily);
    let symbolicTraits = 0;
    if (font.isBold) {
        symbolicTraits |= 2 /* TraitBold */;
    }
    if (font.isItalic) {
        symbolicTraits |= 1 /* TraitItalic */;
    }
    let fontDescriptorTraits = {
        [UIFontSymbolicTrait]: symbolicTraits,
    };
    // IOS versions below 10 will not return the correct font when UIFontWeightTrait is set
    // In this case - rely on UIFontSymbolicTrait only
    if (SUPPORT_FONT_WEIGHTS) {
        fontDescriptorTraits[UIFontWeightTrait] = nativeWeight;
    }
    for (let i = 0; i < fontFamilies.length; i++) {
        const fontFamily = getFontFamilyRespectingGenericFonts(fontFamilies[i]);
        if (shouldUseSystemFont(fontFamily)) {
            result = getSystemFont(size, nativeWeight, font.isItalic, symbolicTraits);
            break;
        }
        else {
            const fontAttributes = {
                [UIFontDescriptorFamilyAttribute]: fontFamily,
                [UIFontDescriptorTraitsAttribute]: fontDescriptorTraits,
            };
            let descriptor = UIFontDescriptor.fontDescriptorWithFontAttributes(fontAttributes);
            result = UIFont.fontWithDescriptorSize(descriptor, size);
            let actualItalic = result.fontDescriptor.symbolicTraits & 1 /* TraitItalic */;
            if (font.isItalic && !actualItalic && EMULATE_OBLIQUE) {
                // The font we got is not actually italic so emulate that with a matrix
                descriptor = descriptor.fontDescriptorWithMatrix(OBLIQUE_TRANSFORM);
                result = UIFont.fontWithDescriptorSize(descriptor, size);
            }
            // Check if the resolved font has the correct font-family
            // If not - fallback to the next font-family
            if (result.familyName === fontFamily) {
                break;
            }
            else {
                result = null;
            }
        }
    }
    // Couldn't resolve font - fallback to the system font
    if (!result) {
        result = getSystemFont(size, nativeWeight, font.isItalic, symbolicTraits);
    }
    return result;
}
var ios;
(function (ios) {
    function registerFont(fontFile) {
        let filePath = _file_system__WEBPACK_IMPORTED_MODULE_3__["path"].join(_file_system__WEBPACK_IMPORTED_MODULE_3__["knownFolders"].currentApp().path, 'fonts', fontFile);
        if (!_file_system__WEBPACK_IMPORTED_MODULE_3__["File"].exists(filePath)) {
            filePath = _file_system__WEBPACK_IMPORTED_MODULE_3__["path"].join(_file_system__WEBPACK_IMPORTED_MODULE_3__["knownFolders"].currentApp().path, fontFile);
        }
        const fontData = NSFileManager.defaultManager.contentsAtPath(filePath);
        if (!fontData) {
            throw new Error('Could not load font from: ' + fontFile);
        }
        const provider = CGDataProviderCreateWithCFData(fontData);
        const font = CGFontCreateWithDataProvider(provider);
        if (!font) {
            throw new Error('Could not load font from: ' + fontFile);
        }
        const error = new interop.Reference();
        if (!CTFontManagerRegisterGraphicsFont(font, error)) {
            if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Error occur while registering font: ' + CFErrorCopyDescription(error.value), _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.error);
            }
        }
    }
    ios.registerFont = registerFont;
})(ios || (ios = {}));
function registerFontsInFolder(fontsFolderPath) {
    const fontsFolder = _file_system__WEBPACK_IMPORTED_MODULE_3__["Folder"].fromPath(fontsFolderPath);
    fontsFolder.eachEntity((fileEntity) => {
        if (_file_system__WEBPACK_IMPORTED_MODULE_3__["Folder"].exists(_file_system__WEBPACK_IMPORTED_MODULE_3__["path"].join(fontsFolderPath, fileEntity.name))) {
            return true;
        }
        if (fileEntity instanceof _file_system__WEBPACK_IMPORTED_MODULE_3__["File"] && (fileEntity.extension === '.ttf' || fileEntity.extension === '.otf')) {
            ios.registerFont(fileEntity.name);
        }
        return true;
    });
}
function registerCustomFonts() {
    const appDir = _file_system__WEBPACK_IMPORTED_MODULE_3__["knownFolders"].currentApp().path;
    const fontsDir = _file_system__WEBPACK_IMPORTED_MODULE_3__["path"].join(appDir, 'fonts');
    if (_file_system__WEBPACK_IMPORTED_MODULE_3__["Folder"].exists(fontsDir)) {
        registerFontsInFolder(fontsDir);
    }
}
registerCustomFonts();
//# sourceMappingURL=font.ios.js.map; 
if (false ) {} 

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "RadChartBase", function() { return /* reexport */ ui_chart_common_RadChartBase; });
__webpack_require__.d(__webpack_exports__, "setupCssScope", function() { return /* reexport */ setupCssScope; });
__webpack_require__.d(__webpack_exports__, "seriesName", function() { return /* reexport */ seriesName; });
__webpack_require__.d(__webpack_exports__, "ChartSeriesStackMode", function() { return /* reexport */ ChartSeriesStackMode; });
__webpack_require__.d(__webpack_exports__, "ChartFontStyle", function() { return /* reexport */ ChartFontStyle; });
__webpack_require__.d(__webpack_exports__, "ChartSeriesSelectionMode", function() { return /* reexport */ ChartSeriesSelectionMode; });
__webpack_require__.d(__webpack_exports__, "ChartSelectionMode", function() { return /* reexport */ ChartSelectionMode; });
__webpack_require__.d(__webpack_exports__, "ChartTrackballSnapMode", function() { return /* reexport */ ChartTrackballSnapMode; });
__webpack_require__.d(__webpack_exports__, "ChartLegendPosition", function() { return /* reexport */ ChartLegendPosition; });
__webpack_require__.d(__webpack_exports__, "ChartLegendOffsetOrigin", function() { return /* reexport */ ChartLegendOffsetOrigin; });
__webpack_require__.d(__webpack_exports__, "ChartPaletteSeriesState", function() { return /* reexport */ ChartPaletteSeriesState; });
__webpack_require__.d(__webpack_exports__, "ChartSeriesPaletteMode", function() { return /* reexport */ ChartSeriesPaletteMode; });
__webpack_require__.d(__webpack_exports__, "ChartAxisLabelFitMode", function() { return /* reexport */ ChartAxisLabelFitMode; });
__webpack_require__.d(__webpack_exports__, "ChartAxisLabelLayoutMode", function() { return /* reexport */ ChartAxisLabelLayoutMode; });
__webpack_require__.d(__webpack_exports__, "ChartAxisHorizontalLocation", function() { return /* reexport */ ChartAxisHorizontalLocation; });
__webpack_require__.d(__webpack_exports__, "ChartAxisVerticalLocation", function() { return /* reexport */ ChartAxisVerticalLocation; });
__webpack_require__.d(__webpack_exports__, "ChartAxisPlotMode", function() { return /* reexport */ ChartAxisPlotMode; });
__webpack_require__.d(__webpack_exports__, "ChartAxisLabelVisibility", function() { return /* reexport */ ChartAxisLabelVisibility; });
__webpack_require__.d(__webpack_exports__, "ChartAxisDateTimeComponent", function() { return /* reexport */ ChartAxisDateTimeComponent; });
__webpack_require__.d(__webpack_exports__, "ChartAnnotationZPosition", function() { return /* reexport */ ChartAnnotationZPosition; });
__webpack_require__.d(__webpack_exports__, "toPascalCase", function() { return /* reexport */ toPascalCase; });
__webpack_require__.d(__webpack_exports__, "ChartEventData", function() { return /* reexport */ ChartEventData; });
__webpack_require__.d(__webpack_exports__, "TrackballSelection", function() { return /* reexport */ TrackballSelection; });
__webpack_require__.d(__webpack_exports__, "TrackballCustomContentData", function() { return /* reexport */ TrackballCustomContentData; });
__webpack_require__.d(__webpack_exports__, "RadLegendView", function() { return /* reexport */ chart_legend_view_RadLegendView; });
__webpack_require__.d(__webpack_exports__, "LinearAxis", function() { return /* reexport */ chart_axis_LinearAxis; });
__webpack_require__.d(__webpack_exports__, "CategoricalAxis", function() { return /* reexport */ chart_axis_CategoricalAxis; });
__webpack_require__.d(__webpack_exports__, "DateTimeContinuousAxis", function() { return /* reexport */ chart_axis_DateTimeContinuousAxis; });
__webpack_require__.d(__webpack_exports__, "DateTimeCategoricalAxis", function() { return /* reexport */ chart_axis_DateTimeCategoricalAxis; });
__webpack_require__.d(__webpack_exports__, "LogarithmicAxis", function() { return /* reexport */ chart_axis_LogarithmicAxis; });
__webpack_require__.d(__webpack_exports__, "PointLabelStyle", function() { return /* reexport */ chart_label_style_common_PointLabelStyle; });
__webpack_require__.d(__webpack_exports__, "PieSeries", function() { return /* reexport */ chart_series_PieSeries; });
__webpack_require__.d(__webpack_exports__, "DonutSeries", function() { return /* reexport */ chart_series_DonutSeries; });
__webpack_require__.d(__webpack_exports__, "BarSeries", function() { return /* reexport */ chart_series_BarSeries; });
__webpack_require__.d(__webpack_exports__, "RangeBarSeries", function() { return /* reexport */ chart_series_RangeBarSeries; });
__webpack_require__.d(__webpack_exports__, "LineSeries", function() { return /* reexport */ chart_series_LineSeries; });
__webpack_require__.d(__webpack_exports__, "SplineSeries", function() { return /* reexport */ chart_series_SplineSeries; });
__webpack_require__.d(__webpack_exports__, "AreaSeries", function() { return /* reexport */ chart_series_AreaSeries; });
__webpack_require__.d(__webpack_exports__, "SplineAreaSeries", function() { return /* reexport */ chart_series_SplineAreaSeries; });
__webpack_require__.d(__webpack_exports__, "BubbleSeries", function() { return /* reexport */ chart_series_BubbleSeries; });
__webpack_require__.d(__webpack_exports__, "ScatterSeries", function() { return /* reexport */ chart_series_ScatterSeries; });
__webpack_require__.d(__webpack_exports__, "ScatterBubbleSeries", function() { return /* reexport */ chart_series_ScatterBubbleSeries; });
__webpack_require__.d(__webpack_exports__, "OhlcSeries", function() { return /* reexport */ chart_series_OhlcSeries; });
__webpack_require__.d(__webpack_exports__, "CandlestickSeries", function() { return /* reexport */ chart_series_CandlestickSeries; });
__webpack_require__.d(__webpack_exports__, "Palette", function() { return /* reexport */ chart_palette_common_Palette; });
__webpack_require__.d(__webpack_exports__, "PaletteEntry", function() { return /* reexport */ chart_palette_common_PaletteEntry; });
__webpack_require__.d(__webpack_exports__, "ChartGridLineAnnotation", function() { return /* reexport */ chart_annotation_ChartGridLineAnnotation; });
__webpack_require__.d(__webpack_exports__, "ChartPlotBandAnnotation", function() { return /* reexport */ chart_annotation_ChartPlotBandAnnotation; });
__webpack_require__.d(__webpack_exports__, "stringColorsConverter", function() { return /* reexport */ stringColorsConverter; });
__webpack_require__.d(__webpack_exports__, "RadCartesianChartGrid", function() { return /* reexport */ chart_cartesian_chart_grid_RadCartesianChartGrid; });
__webpack_require__.d(__webpack_exports__, "Trackball", function() { return /* reexport */ chart_track_ball_Trackball; });
__webpack_require__.d(__webpack_exports__, "RadPieChart", function() { return /* binding */ ui_chart_RadPieChart; });
__webpack_require__.d(__webpack_exports__, "RadCartesianChart", function() { return /* binding */ ui_chart_RadCartesianChart; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/builder/index.js
var builder = __webpack_require__(42);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/index.js
var view = __webpack_require__(3);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable-array/index.js
var observable_array = __webpack_require__(14);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable/index.js
var observable = __webpack_require__(5);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/weak-event-listener/index.js
var weak_event_listener = __webpack_require__(43);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var properties = __webpack_require__(1);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view-base/index.js
var view_base = __webpack_require__(15);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-common.js
var view_common = __webpack_require__(31);

// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/misc/chart-public-enum.js
const seriesName = "seriesName";
/*
* Lists the possible stack modes for chart series.
*/
var ChartSeriesStackMode;
(function (ChartSeriesStackMode) {
    /**
     * Series are not stacked
     * */
    ChartSeriesStackMode["None"] = "None";
    /**
     *  Stack series
     */
    ChartSeriesStackMode["Stack"] = "Stack";
    /**
     * Stack series up to 100%.
     * */
    ChartSeriesStackMode["Stack100"] = "Stack100";
})(ChartSeriesStackMode || (ChartSeriesStackMode = {}));
/**
 * Font styles
 */
var ChartFontStyle;
(function (ChartFontStyle) {
    /**
     * Regular font style
     */
    ChartFontStyle["Normal"] = "Normal";
    /**
     * Bold font style
     */
    ChartFontStyle["Bold"] = "Bold";
    /**
     * Italic font style
     */
    ChartFontStyle["Italic"] = "Italic";
    /**
     * Combine Bold and Italic styles
     */
    ChartFontStyle["BoldItalic"] = "BoldItalic";
})(ChartFontStyle || (ChartFontStyle = {}));
/**
 * Defines available options for {@link ChartSeries}'s {@link selectionMode} property
 */
var ChartSeriesSelectionMode;
(function (ChartSeriesSelectionMode) {
    /**
     * Series selection disabled.
     */
    ChartSeriesSelectionMode["None"] = "Normal";
    /**
     * Series selection not set. The selection mode set to chart will be used.
     */
    ChartSeriesSelectionMode["NotSet"] = "NotSet";
    /**
     * Select the whole series.
     */
    ChartSeriesSelectionMode["Series"] = "Series";
    /**
     * Select a single data point.
     */
    ChartSeriesSelectionMode["DataPoint"] = "DataPoint";
    /**
     * Select multiple points.
     */
    ChartSeriesSelectionMode["DataPointMultiple"] = "DataPointMultiple";
})(ChartSeriesSelectionMode || (ChartSeriesSelectionMode = {}));
/**
 * Defines available options for {@link RadChartBase}'s seriesSelectionMode and pointSelectionMode properties
 */
var ChartSelectionMode;
(function (ChartSelectionMode) {
    /**
     *  Only a single item (series or point) can be selected at a time.
     */
    ChartSelectionMode["Single"] = "Single";
    /**
     * Multiple series/points can be selected.
     */
    ChartSelectionMode["Multiple"] = "Multiple";
    /**
     * Selection disabled.
     */
    ChartSelectionMode["None"] = "None";
})(ChartSelectionMode || (ChartSelectionMode = {}));
var ChartTrackballSnapMode;
(function (ChartTrackballSnapMode) {
    /**
    * Only the closest point is selected.
    */
    ChartTrackballSnapMode["ClosestPoint"] = "ClosestPoint";
    /**
    * All points with the same category as the closest point are selected.
    */
    ChartTrackballSnapMode["AllClosestPoints"] = "AllClosestPoints";
})(ChartTrackballSnapMode || (ChartTrackballSnapMode = {}));
/*
* Defines the different places where the legend can be positioned.
*/
var ChartLegendPosition;
(function (ChartLegendPosition) {
    /**
     * The legend is positioned at the left side of the chart.
     */
    ChartLegendPosition["Left"] = "Left";
    /**
     * The legend is positioned at the right side of the chart.
     */
    ChartLegendPosition["Right"] = "Right";
    /**
     * The legend is positioned at the top side of the chart.
     */
    ChartLegendPosition["Top"] = "Top";
    /**
     * The legend is positioned at the bottom side of the chart.
     */
    ChartLegendPosition["Bottom"] = "Bottom";
    /**
     * The legend is floating. The default offset origin for this mode is TopLeft with offset values (0,0).
     */
    ChartLegendPosition["Floating"] = "Floating";
})(ChartLegendPosition || (ChartLegendPosition = {}));
/*
* Defines the possible values of the offsetOrigin property of {@link RadLegendView}.
* The offsetOrigin has effect only when the legend's position property's value is Floating.
*/
var ChartLegendOffsetOrigin;
(function (ChartLegendOffsetOrigin) {
    /**
     * The offset is relative to the top left corner.
     */
    ChartLegendOffsetOrigin["TopLeft"] = "TopLeft";
    /**
     * The offset is relative to the top right corner.
     */
    ChartLegendOffsetOrigin["TopRight"] = "TopRight";
    /**
     * The offset is relative to the bottom left corner.
     */
    ChartLegendOffsetOrigin["BottomLeft"] = "BottomLeft";
    /**
     * The offset is relative to the bottom right corner.
     */
    ChartLegendOffsetOrigin["BottomRight"] = "BottomRight";
})(ChartLegendOffsetOrigin || (ChartLegendOffsetOrigin = {}));
/*
* Lists the possible values for the seriesState property of {@link Palette}.
*/
var ChartPaletteSeriesState;
(function (ChartPaletteSeriesState) {
    /**
     * The palette will be used when the series are not in selected state
     */
    ChartPaletteSeriesState["Normal"] = "Normal";
    /**
     * The palette will be used when the series are in selected state
     */
    ChartPaletteSeriesState["Selected"] = "Selected";
})(ChartPaletteSeriesState || (ChartPaletteSeriesState = {}));
/*
* Lists the possible values for the paletteMode property of {@link CartesianSeries}.
*/
var ChartSeriesPaletteMode;
(function (ChartSeriesPaletteMode) {
    /**
     * The palette item that will be used will be selected depending on the index of the current series.
     */
    ChartSeriesPaletteMode["Series"] = "Series";
    /**
     * The palette item that will be used will be selected depending on the index of the current item.
     */
    ChartSeriesPaletteMode["Item"] = "Item";
})(ChartSeriesPaletteMode || (ChartSeriesPaletteMode = {}));
/*
* Lists the possible values for the labelFitMode property of {@link CartesianAxis}.
*/
var ChartAxisLabelFitMode;
(function (ChartAxisLabelFitMode) {
    /**
     * The default single line mode
     */
    ChartAxisLabelFitMode["None"] = "None";
    /**
     * Axis labels are on multiple lines.
     */
    ChartAxisLabelFitMode["Multiline"] = "Multiline";
    /**
     * Axis labels are rotated. Use labelRotationAngle to set the corresponding rotation angle.
     */
    ChartAxisLabelFitMode["Rotate"] = "Rotate";
})(ChartAxisLabelFitMode || (ChartAxisLabelFitMode = {}));
/*
 * Lists the possible values for the labelLayoutMode property of {@link CartesianAxis}.
 */
var ChartAxisLabelLayoutMode;
(function (ChartAxisLabelLayoutMode) {
    /*
     * The labels will be outside for the chart. Otherwise said, for horizontal axis the label will be on bottom and for vertical on right side of axis.
     */
    ChartAxisLabelLayoutMode["Outer"] = "Outer";
    /*
     * The labels will be inside of the chart. Otherwise said, for horizontal axis the label will be on top and for vertical on left side of axis.
     */
    ChartAxisLabelLayoutMode["Inner"] = "Inner";
})(ChartAxisLabelLayoutMode || (ChartAxisLabelLayoutMode = {}));
/**
* Lists the possible values for the horizontalLocation property of vertical axes of type {@link CartesianAxis}.
*/
var ChartAxisHorizontalLocation;
(function (ChartAxisHorizontalLocation) {
    /**
    * The axis is positioned at the left side of the plotting area.
    */
    ChartAxisHorizontalLocation["Left"] = "Left";
    /**
    * The axis is positioned at the right side of the plotting area.
    */
    ChartAxisHorizontalLocation["Right"] = "Right";
})(ChartAxisHorizontalLocation || (ChartAxisHorizontalLocation = {}));
/**
* Lists the possible values for the verticalLocation property of horizontal axes of type {@link CartesianAxis}.
*/
var ChartAxisVerticalLocation;
(function (ChartAxisVerticalLocation) {
    /**
    * The axis is positioned at the top of the plotting area.
    */
    ChartAxisVerticalLocation["Top"] = "Top";
    /**
    * The axis is positioned at the bottom of the plotting area.
    */
    ChartAxisVerticalLocation["Bottom"] = "Bottom";
})(ChartAxisVerticalLocation || (ChartAxisVerticalLocation = {}));
/**
* Lists the possible values of the plotMode property of {@link CategoricalAxis} and {@link DateTimeContinuousAxis}.
*/
var ChartAxisPlotMode;
(function (ChartAxisPlotMode) {
    /**
    * Data points are plotted between the ticks.
    */
    ChartAxisPlotMode["BetweenTicks"] = "BetweenTicks";
    /**
    * Data points are plotted on the ticks.
    */
    ChartAxisPlotMode["OnTicks"] = "OnTicks";
})(ChartAxisPlotMode || (ChartAxisPlotMode = {}));
/**
* Lists the possible visibility options for the firstLabelVisibility and lastLabelVisibility properties of {@link CategoricalAxis}.
*/
var ChartAxisLabelVisibility;
(function (ChartAxisLabelVisibility) {
    /**
    * The axis label is shown.
    */
    ChartAxisLabelVisibility["Visible"] = "Visible";
    /**
    * The axis label is not shown.
    */
    ChartAxisLabelVisibility["Hidden"] = "Hidden";
    /**
    * The axis label is clipped.
    * NOTE: Works only on Android.
    */
    ChartAxisLabelVisibility["Clip"] = "Clip";
})(ChartAxisLabelVisibility || (ChartAxisLabelVisibility = {}));
/**
* Lists the possible ways to extract a category from a Date object.
* The proper type should be set as a value of the dateTimeComponent property of {@link DateTimeCategoricalAxis} or
* the majorStepUnit property of {@link DateTimeContinuousAxis}.
*/
var ChartAxisDateTimeComponent;
(function (ChartAxisDateTimeComponent) {
    /**
    * The 'seconds' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Second"] = "Second";
    /**
    * The 'minutes' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Minute"] = "Minute";
    /**
    * The 'hours' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Hour"] = "Hour";
    /**
    * The 'days' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Day"] = "Day";
    /**
    * The 'weeks' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Week"] = "Week";
    /**
    * The 'months' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Month"] = "Month";
    /**
    * The 'years' value of the Date object will be considered.
    */
    ChartAxisDateTimeComponent["Year"] = "Year";
})(ChartAxisDateTimeComponent || (ChartAxisDateTimeComponent = {}));
/**
* Lists the possible values of the zPosition property of {@link CartesianChartAnnotation}.
*/
var ChartAnnotationZPosition;
(function (ChartAnnotationZPosition) {
    /**
    * The annotation is rendered below the series (default).
    */
    ChartAnnotationZPosition["BelowSeries"] = "BelowSeries";
    /**
    * The annotation is rendered above the series.
    */
    ChartAnnotationZPosition["AboveSeries"] = "AboveSeries";
})(ChartAnnotationZPosition || (ChartAnnotationZPosition = {}));
function toPascalCase(value) {
    if (!value) {
        return value;
    }
    const words = value.split('-');
    const upperCaseWords = words.map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    return upperCaseWords.join('');
}
//# sourceMappingURL=chart-public-enum.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/font.js
var styling_font = __webpack_require__(22);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/color/index.js + 2 modules
var core_color = __webpack_require__(6);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/index.js + 2 modules
var core = __webpack_require__(29);

// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/views/chart-axis.common.js




/**
* Represents an axis in a Cartesian chart. This class is a base class for all
* axes that can be used within a RadCartesianChart instance.
*/
class chart_axis_common_CartesianAxis extends view["c" /* View */] {
    onLineColorPropertyChanged(oldValue, newValue) {
        this.onLineColorChanged(oldValue, newValue);
    }
    /*
    * Called when the lineColor property changes.
    * @param data an object containing information about the change event.
    */
    onLineColorChanged(oldValue, newValue) {
        this.initializer.onLineColorChanged(oldValue, newValue, this);
    }
    onLineThicknessPropertyChanged(oldValue, newValue) {
        this.onLineThicknessChanged(oldValue, newValue);
    }
    /*
    * Called when the lineThickness property changes.
    * @param data an object containing information about the change event.
    */
    onLineThicknessChanged(oldValue, newValue) {
        this.initializer.onLineThicknessChanged(oldValue, newValue, this);
    }
    onLineHiddenPropertyChanged(oldValue, newValue) {
        this.onLineHiddenChanged(oldValue, newValue);
    }
    /*
    * Called when the lineHidden property changes.
    * @param data an object containing information about the change event.
    */
    onLineHiddenChanged(oldValue, newValue) {
        this.initializer.onLineHiddenChanged(oldValue, newValue, this);
    }
    onLabelTextColorPropertyChanged(oldValue, newValue) {
        this.onLabelTextColorChanged(oldValue, newValue);
    }
    /*
    * Called when the labelTextColor property changes.
    * @param data an object containing information about the change event.
    */
    onLabelTextColorChanged(oldValue, newValue) {
        this.initializer.onLabelTextColorChanged(oldValue, newValue, this);
    }
    onLabelBackgroundColorPropertyChanged(oldValue, newValue) {
        this.onLabelBackgroundColorChanged(oldValue, newValue);
    }
    /*
    * Called when the labelBackgroundColor property changes.
    * @param data an object containing information about the change event.
    */
    onLabelBackgroundColorChanged(oldValue, newValue) {
        this.initializer.onLabelBackgroundColorChanged(oldValue, newValue, this);
    }
    onLabelBorderColorPropertyChanged(oldValue, newValue) {
        this.onLabelBorderColorChanged(oldValue, newValue);
    }
    /*
    * Called when the labelBorderColor property changes.
    * @param data an object containing information about the change event.
    */
    onLabelBorderColorChanged(oldValue, newValue) {
        this.initializer.onLabelBorderColorChanged(oldValue, newValue, this);
    }
    onLabelBorderWidthPropertyChanged(oldValue, newValue) {
        this.onLabelBorderWidthChanged(oldValue, newValue);
    }
    /*
    * Called when the labelBorderWidth property changes.
    * @param data an object containing information about the change event.
    */
    onLabelBorderWidthChanged(oldValue, newValue) {
        this.initializer.onLabelBorderWidthChanged(oldValue, newValue, this);
    }
    onLabelSizePropertyChanged(oldValue, newValue) {
        this.onLabelSizeChanged(oldValue, newValue);
    }
    /**
    * Called when the labelSize property changes.
    * @param data an object containing information about the change event.
    */
    onLabelSizeChanged(oldValue, newValue) {
        this.initializer.onLabelSizeChanged(oldValue, newValue, this);
    }
    onLabelFormatPropertyChanged(oldValue, newValue) {
        this.onLabelFormatChanged(oldValue, newValue);
    }
    /**
    * Called when the labelFormat property changes.
    * @param data an object containing information about the change event.
    */
    onLabelFormatChanged(oldValue, newValue) {
        this.initializer.onLabelFormatChanged(oldValue, newValue, this);
    }
    onLabelMarginPropertyChanged(oldValue, newValue) {
        this.onLabelMarginChanged(oldValue, newValue);
    }
    /**
    * Called when the labelMargin property changes.
    * @param data an object containing information about the change event.
    */
    onLabelMarginChanged(oldValue, newValue) {
        this.initializer.onLabelMarginChanged(oldValue, newValue, this);
    }
    onLabelRotationAnglePropertyChanged(oldValue, newValue) {
        this.onLabelRotationAngleChanged(oldValue, newValue);
    }
    /**
    * Called when the labelRotationAngle property changes.
    * @param data an object containing information about the change event.
    */
    onLabelRotationAngleChanged(oldValue, newValue) {
        this.initializer.onLabelRotationAngleChanged(oldValue, newValue, this);
    }
    onLabelFitModePropertyChanged(oldValue, newValue) {
        this.onLabelFitModeChanged(oldValue, newValue);
    }
    /**
    * Called when the labelFitMode property changes.
    * @param data an object containing information about the change event.
    */
    onLabelFitModeChanged(oldValue, newValue) {
        this.initializer.onLabelFitModeChanged(oldValue, newValue, this);
    }
    onLabelLayoutModePropertyChanged(oldValue, newValue) {
        this.onLabelLayoutModeChanged(oldValue, newValue);
    }
    /**
    * Called when the labelLayoutMode property changes.
    * @param data an object containing information about the change event.
    */
    onLabelLayoutModeChanged(oldValue, newValue) {
        this.initializer.onLabelLayoutModeChanged(oldValue, newValue, this);
    }
    onTicksThicknessPropertyChanged(oldValue, newValue) {
        this.onTicksThicknessChanged(oldValue, newValue);
    }
    /*
    * Called when the ticksThickness property changes.
    */
    onTicksThicknessChanged(oldValue, newValue) {
        this.initializer.onTicksThicknessChanged(oldValue, newValue, this);
    }
    onTicksLengthPropertyChanged(oldValue, newValue) {
        this.onTicksLengthChanged(oldValue, newValue);
    }
    /*
    * Called when the ticksLength property changes.
    */
    onTicksLengthChanged(oldValue, newValue) {
        this.initializer.onTicksLengthChanged(oldValue, newValue, this);
    }
    onTicksOffsetPropertyChanged(oldValue, newValue) {
        this.onTicksOffsetChanged(oldValue, newValue);
    }
    /*
    * Called when the ticksOffset property changes.
    */
    onTicksOffsetChanged(oldValue, newValue) {
        this.initializer.onTicksOffsetChanged(oldValue, newValue, this);
    }
    onTicksHiddenPropertyChanged(oldValue, newValue) {
        this.onTicksHiddenChanged(oldValue, newValue);
    }
    /*
    * Called when the ticksHidden property changes.
    */
    onTicksHiddenChanged(oldValue, newValue) {
        this.initializer.onTicksHiddenChanged(oldValue, newValue, this);
    }
    onTicksColorPropertyChanged(oldValue, newValue) {
        this.onTicksColorChanged(oldValue, newValue);
    }
    /*
    * Called when the ticksColor property changes.
    */
    onTicksColorChanged(oldValue, newValue) {
        this.initializer.onTicksColorChanged(oldValue, newValue, this);
    }
    onHorizontalLocationPropertyChanged(oldValue, newValue) {
        this.onHorizontalLocationChanged(oldValue, newValue);
    }
    /**
    * Called when the horizontalLocation property changes.
    * @param data an object containing information about the change event.
    */
    onHorizontalLocationChanged(oldValue, newValue) {
        this.initializer.onHorizontalLocationChanged(oldValue, newValue, this);
    }
    onVerticalLocationPropertyChanged(oldValue, newValue) {
        this.onVerticalLocationChanged(oldValue, newValue);
    }
    /**
    * Called when the verticalLocation property changes.
    */
    onVerticalLocationChanged(oldValue, newValue) {
        this.initializer.onVerticalLocationChanged(oldValue, newValue, this);
    }
    onAllowPanPropertyChanged(oldValue, newValue) {
        this.onAllowPanChanged(oldValue, newValue);
    }
    /**
    * Called when the allowPan property changes.
    */
    onAllowPanChanged(oldValue, newValue) {
        this.initializer.onAllowPanChanged(oldValue, newValue, this);
    }
    onAllowZoomPropertyChanged(oldValue, newValue) {
        this.onAllowZoomChanged(oldValue, newValue);
    }
    /**
    * Called when the allowZoom property changes.
    */
    onAllowZoomChanged(oldValue, newValue) {
        this.initializer.onAllowZoomChanged(oldValue, newValue, this);
    }
    onHiddenPropertyChanged(oldValue, newValue) {
        this.onHiddenChanged(oldValue, newValue);
    }
    /**
    * Called when the hidden property changes.
    */
    onHiddenChanged(oldValue, newValue) {
        this.initializer.onHiddenChanged(oldValue, newValue, this);
    }
    eachChild(callback) {
        if (this._label) {
            callback(this._label);
        }
    }
    get label() {
        return this._label;
    }
    onLoaded() {
        if (!this._label) {
            const label = new chart_axis_common_ChartAxisLabel();
            this._label = label;
            setupCssScope(this.owner, this._label);
            this._addView(this._label);
        }
        super.onLoaded();
        this._labelPropertyChangeHandler = this._labelPropertyChangeHandler || ((args) => {
            this.applyLabelPropertyFromStyle(args.propertyName);
        });
        this.attachLabelChangeListeners();
        this.applyLabelPropertyFromStyle();
    }
    onUnloaded() {
        super.onUnloaded();
        this.detachLabelChangeListeners();
    }
    updateLabelColorFromStyle() {
        const labelTextColor = this._label.style.color;
        if (labelTextColor !== undefined) {
            this.labelTextColor = labelTextColor;
        }
    }
    updateLabelFontFromStyle() {
        const fontInternal = this._label.style.fontInternal;
        if (fontInternal && fontInternal !== styling_font["a" /* Font */].default) {
            this.initializer.onFontInternalChanged(null, fontInternal, this);
        }
    }
    updateLabelMarginFromStyle() {
        const labelMargin = this._label.style.marginLeft;
        if (labelMargin !== undefined && !isNaN(+labelMargin)) {
            this.labelMargin = +labelMargin;
        }
    }
    updateLabelFitModeFromStyle() {
        const labelFitMode = this._label.fitMode;
        if (labelFitMode !== undefined) {
            this.labelFitMode = labelFitMode;
        }
    }
    updateLabelLayoutModeFromStyle() {
        const labelLayoutMode = this._label.layoutMode;
        if (labelLayoutMode !== undefined) {
            this.labelLayoutMode = labelLayoutMode;
        }
    }
    updateLabelRotationAngleFromStyle() {
        const labelRotationAngle = this._label.rotationAngle;
        if (labelRotationAngle !== undefined && !isNaN(+labelRotationAngle)) {
            this.labelRotationAngle = labelRotationAngle;
        }
    }
    updateLabelFormatFromStyle() {
        const labelFormat = this._label.format;
        if (labelFormat !== undefined) {
            this.labelFormat = labelFormat;
        }
    }
    updateLabelPaddingFromStyle(propertyName) {
        this.initializer.onLabelPaddingChanged(null, propertyName, this);
    }
    updateLabelBackgroundColorFromStyle() {
        const labelBackgroundColor = this._label.style.backgroundColor;
        if (labelBackgroundColor !== undefined) {
            this.labelBackgroundColor = labelBackgroundColor;
        }
    }
    updateLabelBorderWidthFromStyle() {
        const labelBorderWidth = +this._label.style.borderLeftWidth;
        if (labelBorderWidth !== undefined && !isNaN(+labelBorderWidth)) {
            this.labelBorderWidth = labelBorderWidth;
        }
    }
    updateLabelBorderColorFromStyle() {
        const labelBorderColor = this._label.style.borderLeftColor;
        if (labelBorderColor !== undefined) {
            if (labelBorderColor instanceof core_color["a" /* Color */]) {
                this.labelBorderColor = labelBorderColor;
            }
            else {
                this.labelBorderColor = new core_color["a" /* Color */](labelBorderColor);
            }
        }
    }
    applyLabelPropertyFromStyle(propertyName) {
        if (!propertyName || propertyName === "color") {
            this.updateLabelColorFromStyle();
        }
        if (!propertyName || propertyName === "fontInternal") {
            this.updateLabelFontFromStyle();
        }
        if (!propertyName || propertyName === "fitMode") {
            this.updateLabelFitModeFromStyle();
        }
        if (!propertyName || propertyName === "layoutMode") {
            this.updateLabelLayoutModeFromStyle();
        }
        if (!propertyName || propertyName === "rotationAngle") {
            this.updateLabelRotationAngleFromStyle();
        }
        if (!propertyName || propertyName === "format") {
            this.updateLabelFormatFromStyle();
        }
        if (!propertyName || propertyName.startsWith("padding")) {
            this.updateLabelPaddingFromStyle(propertyName);
        }
        if (!propertyName || propertyName === "backgroundColor") {
            this.updateLabelBackgroundColorFromStyle();
        }
        if (!propertyName || propertyName === "borderLeftWidth") {
            this.updateLabelBorderWidthFromStyle();
        }
        if (!propertyName || propertyName === "borderLeftColor") {
            this.updateLabelBorderColorFromStyle();
        }
        if (!propertyName || propertyName === "marginLeft") {
            this.updateLabelMarginFromStyle();
        }
    }
    attachLabelChangeListeners() {
        this._label.style.on("colorChange", this._labelPropertyChangeHandler);
        this._label.style.on("fontInternalChange", this._labelPropertyChangeHandler);
        this._label.style.on("paddingLeftChange", this._labelPropertyChangeHandler);
        this._label.style.on("paddingTopChange", this._labelPropertyChangeHandler);
        this._label.style.on("paddingRightChange", this._labelPropertyChangeHandler);
        this._label.style.on("paddingBottomChange", this._labelPropertyChangeHandler);
        this._label.style.on("backgroundColorChange", this._labelPropertyChangeHandler);
        this._label.style.on("borderLeftWidthChange", this._labelPropertyChangeHandler);
        this._label.style.on("borderLeftColorChange", this._labelPropertyChangeHandler);
        this._label.style.on("marginLeftChange", this._labelPropertyChangeHandler);
        this._label.on("fitModeChange", this._labelPropertyChangeHandler);
        this._label.on("layoutModeChange", this._labelPropertyChangeHandler);
        this._label.on("rotationAngleChange", this._labelPropertyChangeHandler);
        this._label.on("formatChange", this._labelPropertyChangeHandler);
    }
    detachLabelChangeListeners() {
        this._label.style.off("colorChange", this._labelPropertyChangeHandler);
        this._label.style.off("paddingLeftChange", this._labelPropertyChangeHandler);
        this._label.style.off("paddingTopChange", this._labelPropertyChangeHandler);
        this._label.style.off("paddingRightChange", this._labelPropertyChangeHandler);
        this._label.style.off("paddingBottomChange", this._labelPropertyChangeHandler);
        this._label.style.off("backgroundColorChange", this._labelPropertyChangeHandler);
        this._label.style.off("borderLeftWidthChange", this._labelPropertyChangeHandler);
        this._label.style.off("borderLeftColorChange", this._labelPropertyChangeHandler);
        this._label.style.off("marginLeftChange", this._labelPropertyChangeHandler);
        this._label.off("fitModeChange", this._labelPropertyChangeHandler);
        this._label.off("layoutModeChange", this._labelPropertyChangeHandler);
        this._label.off("rotationAngleChange", this._labelPropertyChangeHandler);
        this._label.off("formatChange", this._labelPropertyChangeHandler);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_CartesianAxisValueMapper();
        }
        return this._initializer;
    }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
    }
    update() {
        if (!this.owner) {
            return;
        }
        if (this.ios) {
            this.owner.updateChart();
        }
    }
}
/*
* Identifies the lineColor dependency property.
*/
chart_axis_common_CartesianAxis.idProperty = new properties["Property"]({
    name: "id",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
    },
});
/*
* Identifies the lineColor dependency property.
*/
chart_axis_common_CartesianAxis.lineColorProperty = new properties["Property"]({
    name: "lineColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLineColorPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the lineThickness dependency property.
*/
chart_axis_common_CartesianAxis.lineThicknessProperty = new properties["Property"]({
    name: "lineThickness",
    defaultValue: undefined,
    valueConverter: (v) => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLineThicknessPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the lineHidden dependency property.
*/
chart_axis_common_CartesianAxis.lineHiddenProperty = new properties["Property"]({
    name: "lineHidden",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onLineHiddenPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the labelTextColor dependency property.
*/
chart_axis_common_CartesianAxis.labelTextColorProperty = new properties["Property"]({
    name: "labelTextColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelTextColorPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the labelFillColor dependency property.
*/
chart_axis_common_CartesianAxis.labelBackgroundColorProperty = new properties["Property"]({
    name: "labelBackgroundColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelBackgroundColorPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the labelBorderColor dependency property.
*/
chart_axis_common_CartesianAxis.labelBorderColorProperty = new properties["Property"]({
    name: "labelBorderColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelBorderColorPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the labelBorderWidth dependency property.
*/
chart_axis_common_CartesianAxis.labelBorderWidthProperty = new properties["Property"]({
    name: "labelBorderWidth",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelBorderWidthPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the labelSize dependency property.
*/
chart_axis_common_CartesianAxis.labelSizeProperty = new properties["Property"]({
    name: "labelSize",
    defaultValue: undefined,
    valueConverter: parseInt,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelSizePropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies labelFormat dependency property.
*/
chart_axis_common_CartesianAxis.labelFormatProperty = new properties["Property"]({
    name: "labelFormat",
    defaultValue: undefined,
    valueConverter: (v) => trimQuotes(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelFormatPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the labelMargin dependency property.
*/
chart_axis_common_CartesianAxis.labelMarginProperty = new properties["Property"]({
    name: "labelMargin",
    defaultValue: undefined,
    valueConverter: parseInt,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelMarginPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the labelRotationAngle dependency property.
*/
chart_axis_common_CartesianAxis.labelRotationAngleProperty = new properties["Property"]({
    name: "labelRotationAngle",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelRotationAnglePropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the labelFitMode dependency property.
*/
chart_axis_common_CartesianAxis.labelFitModeProperty = new properties["Property"]({
    name: "labelFitMode",
    defaultValue: undefined,
    valueConverter: (value) => ChartAxisLabelFitMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelFitModePropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the labelLayoutMode dependency property.
*/
chart_axis_common_CartesianAxis.labelLayoutModeProperty = new properties["Property"]({
    name: "labelLayoutMode",
    defaultValue: undefined,
    valueConverter: (value) => ChartAxisLabelLayoutMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelLayoutModePropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the ticksThickness dependency property.
*/
chart_axis_common_CartesianAxis.ticksThicknessProperty = new properties["Property"]({
    name: "ticksThickness",
    defaultValue: undefined,
    valueConverter: (v) => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksThicknessPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the ticksLength dependency property.
*/
chart_axis_common_CartesianAxis.ticksLengthProperty = new properties["Property"]({
    name: "ticksLength",
    defaultValue: undefined,
    valueConverter: (v) => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksLengthPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the ticksOffset dependency property.
*/
chart_axis_common_CartesianAxis.ticksOffsetProperty = new properties["Property"]({
    name: "ticksOffset",
    defaultValue: undefined,
    valueConverter: (v) => parseInt(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksOffsetPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the ticksHidden dependency property.
*/
chart_axis_common_CartesianAxis.ticksHiddenProperty = new properties["Property"]({
    name: "ticksHidden",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksHiddenPropertyChanged(oldValue, newValue);
    },
});
/*
* Identifies the ticksColor dependency property.
*/
chart_axis_common_CartesianAxis.ticksColorProperty = new properties["Property"]({
    name: "ticksColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTicksColorPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the horizontalLocation dependency property.
*/
chart_axis_common_CartesianAxis.horizontalLocationProperty = new properties["Property"]({
    name: "horizontalLocation",
    defaultValue: ChartAxisHorizontalLocation.Left,
    valueConverter: (value) => ChartAxisHorizontalLocation[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onHorizontalLocationPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the verticalLocation dependency property.
*/
chart_axis_common_CartesianAxis.verticalLocationProperty = new properties["Property"]({
    name: "verticalLocation",
    defaultValue: ChartAxisVerticalLocation.Bottom,
    valueConverter: (value) => ChartAxisVerticalLocation[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onVerticalLocationPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the allowPan dependency property.
*/
chart_axis_common_CartesianAxis.allowPanProperty = new properties["Property"]({
    name: "allowPan",
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onAllowPanPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the allowZoom dependency property.
*/
chart_axis_common_CartesianAxis.allowZoomProperty = new properties["Property"]({
    name: "allowZoom",
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onAllowZoomPropertyChanged(oldValue, newValue);
    },
});
/**
* Identifies the hidden dependency property.
*/
chart_axis_common_CartesianAxis.hiddenProperty = new properties["Property"]({
    name: "hidden",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onHiddenPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_CartesianAxis.idProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.lineColorProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.lineThicknessProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.lineHiddenProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelTextColorProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelBackgroundColorProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelBorderWidthProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelBorderColorProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelSizeProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelFormatProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelMarginProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelRotationAngleProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelFitModeProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.labelLayoutModeProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.ticksThicknessProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.ticksLengthProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.ticksOffsetProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.ticksHiddenProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.ticksColorProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.horizontalLocationProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.verticalLocationProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.allowPanProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.allowZoomProperty.register(chart_axis_common_CartesianAxis);
chart_axis_common_CartesianAxis.hiddenProperty.register(chart_axis_common_CartesianAxis);
let chart_axis_common_CategoricalAxis = class CategoricalAxis extends chart_axis_common_CartesianAxis {
    onMajorTickIntervalPropertyChanged(oldValue, newValue) {
        this.onMajorTickIntervalChanged(oldValue, newValue);
    }
    onPlotModePropertyChanged(oldValue, newValue) {
        this.onPlotModeChanged(oldValue, newValue);
    }
    onLastLabelVisibilityPropertyChanged(oldValue, newValue) {
        this.onLastLabelVisibilityChanged(oldValue, newValue);
    }
    onFirstLabelVisibilityPropertyChanged(oldValue, newValue) {
        this.onFirstLabelVisibilityChanged(oldValue, newValue);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_CategoricalAxisValueMapper();
        }
        return this._initializer;
    }
    onMajorTickIntervalChanged(oldValue, newValue) {
        this.initializer.onMajorTickIntervalChanged(oldValue, newValue, this);
    }
    onPlotModeChanged(oldValue, newValue) {
        this.initializer.onPlotModeChanged(oldValue, newValue, this);
    }
    onLastLabelVisibilityChanged(oldValue, newValue) {
        this.initializer.onLastLabelVisibilityChanged(oldValue, newValue, this);
    }
    onFirstLabelVisibilityChanged(oldValue, newValue) {
        this.initializer.onFirstLabelVisibilityChanged(oldValue, newValue, this);
    }
};
chart_axis_common_CategoricalAxis.majorTickIntervalProperty = new properties["Property"]({
    name: "majorTickInterval",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onMajorTickIntervalPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_CategoricalAxis.plotModeProperty = new properties["Property"]({
    name: "plotMode",
    defaultValue: undefined,
    valueConverter: (value) => ChartAxisPlotMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPlotModePropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_CategoricalAxis.lastLabelVisibilityProperty = new properties["Property"]({
    name: "lastLabelVisibility",
    defaultValue: ChartAxisLabelVisibility.Visible,
    valueConverter: (value) => ChartAxisLabelVisibility[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onLastLabelVisibilityPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_CategoricalAxis.firstLabelVisibilityProperty = new properties["Property"]({
    name: "firstLabelVisibility",
    defaultValue: ChartAxisLabelVisibility.Visible,
    valueConverter: (value) => ChartAxisLabelVisibility[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onFirstLabelVisibilityPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_CategoricalAxis = __decorate([
    Object(view_common["a" /* CSSType */])("CategoricalAxis")
], chart_axis_common_CategoricalAxis);

chart_axis_common_CategoricalAxis.majorTickIntervalProperty.register(chart_axis_common_CategoricalAxis);
chart_axis_common_CategoricalAxis.plotModeProperty.register(chart_axis_common_CategoricalAxis);
chart_axis_common_CategoricalAxis.lastLabelVisibilityProperty.register(chart_axis_common_CategoricalAxis);
chart_axis_common_CategoricalAxis.firstLabelVisibilityProperty.register(chart_axis_common_CategoricalAxis);
let chart_axis_common_LinearAxis = class LinearAxis extends chart_axis_common_CartesianAxis {
    onMinimumPropertyChanged(oldValue, newValue) {
        this.onMinimumChanged(oldValue, newValue);
    }
    onMinimumChanged(oldValue, newValue) {
    }
    onMaximumPropertyChanged(oldValue, newValue) {
        this.onMaximumChanged(oldValue, newValue);
    }
    onMaximumChanged(oldValue, newValue) {
    }
    onMajorStepPropertyChanged(oldValue, newValue) {
        this.onMajorStepChanged(oldValue, newValue);
    }
    onMajorStepChanged(oldValue, newValue) {
    }
};
chart_axis_common_LinearAxis.majorStepProperty = new properties["Property"]({
    name: "majorStep",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMajorStepPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_LinearAxis.minimumProperty = new properties["Property"]({
    name: "minimum",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMinimumPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_LinearAxis.maximumProperty = new properties["Property"]({
    name: "maximum",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMaximumPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_LinearAxis = __decorate([
    Object(view_common["a" /* CSSType */])("LinearAxis")
], chart_axis_common_LinearAxis);

chart_axis_common_LinearAxis.majorStepProperty.register(chart_axis_common_LinearAxis);
chart_axis_common_LinearAxis.minimumProperty.register(chart_axis_common_LinearAxis);
chart_axis_common_LinearAxis.maximumProperty.register(chart_axis_common_LinearAxis);
let chart_axis_common_DateTimeContinuousAxis = class DateTimeContinuousAxis extends chart_axis_common_LinearAxis {
    onPlotModePropertyChanged(oldValue, newValue) {
        this.onPlotModeChanged(oldValue, newValue);
    }
    onDateFormatPropertyChanged(oldValue, newValue) {
        this.onDateFormatChanged(oldValue, newValue);
    }
    onSourceDateFormatPropertyChanged(oldValue, newValue) {
        this.onSourceDateFormatChanged(oldValue, newValue);
    }
    onPlotModeChanged(oldValue, newValue) {
    }
    onDateFormatChanged(oldValue, newValue) {
    }
    onSourceDateFormatChanged(oldValue, newValue) {
    }
    onMajorStepUnitPropertyChanged(oldValue, newValue) {
        this.onMajorStepUnitChanged(oldValue, newValue);
    }
    onMajorStepUnitChanged(oldValue, newValue) {
    }
};
chart_axis_common_DateTimeContinuousAxis.plotModeProperty = new properties["Property"]({
    name: "plotMode",
    defaultValue: undefined,
    valueConverter: (value) => ChartAxisPlotMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPlotModePropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_DateTimeContinuousAxis.dateFormatProperty = new properties["Property"]({
    name: "dateFormat",
    defaultValue: undefined,
    valueConverter: (v) => trimQuotes(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onDateFormatPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_DateTimeContinuousAxis.sourceDateFormatProperty = new properties["Property"]({
    name: "sourceDateFormat",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onSourceDateFormatPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_DateTimeContinuousAxis.majorStepUnitProperty = new properties["Property"]({
    name: "majorStepUnit",
    defaultValue: undefined,
    valueConverter: (value) => ChartAxisDateTimeComponent[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onMajorStepUnitPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_DateTimeContinuousAxis = __decorate([
    Object(view_common["a" /* CSSType */])("DateTimeContinuousAxis")
], chart_axis_common_DateTimeContinuousAxis);

chart_axis_common_DateTimeContinuousAxis.plotModeProperty.register(chart_axis_common_DateTimeContinuousAxis);
chart_axis_common_DateTimeContinuousAxis.dateFormatProperty.register(chart_axis_common_DateTimeContinuousAxis);
chart_axis_common_DateTimeContinuousAxis.sourceDateFormatProperty.register(chart_axis_common_DateTimeContinuousAxis);
chart_axis_common_DateTimeContinuousAxis.majorStepUnitProperty.register(chart_axis_common_DateTimeContinuousAxis);
let chart_axis_common_DateTimeCategoricalAxis = class DateTimeCategoricalAxis extends chart_axis_common_CategoricalAxis {
    onDateTimeComponentPropertyChanged(oldValue, newValue) {
        this.onDateTimeComponentChanged(oldValue, newValue);
    }
    onDateFormatPropertyChanged(oldValue, newValue) {
        this.onDateFormatChanged(oldValue, newValue);
    }
    onDateTimeComponentChanged(oldValue, newValue) {
    }
    onDateFormatChanged(oldValue, newValue) {
    }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
};
chart_axis_common_DateTimeCategoricalAxis.dateTimeComponentProperty = new properties["Property"]({
    name: "dateTimeComponent",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onDateTimeComponentPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_DateTimeCategoricalAxis.dateFormatProperty = new properties["Property"]({
    name: "dateFormat",
    defaultValue: undefined,
    valueConverter: (v) => trimQuotes(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onDateFormatPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_DateTimeCategoricalAxis = __decorate([
    Object(view_common["a" /* CSSType */])("DateTimeCategoricalAxis")
], chart_axis_common_DateTimeCategoricalAxis);

chart_axis_common_DateTimeCategoricalAxis.dateTimeComponentProperty.register(chart_axis_common_DateTimeCategoricalAxis);
chart_axis_common_DateTimeCategoricalAxis.dateFormatProperty.register(chart_axis_common_DateTimeCategoricalAxis);
let chart_axis_common_LogarithmicAxis = class LogarithmicAxis extends chart_axis_common_LinearAxis {
    onExponentStepPropertyChanged(oldValue, newValue) {
        this.onExponentStepChanged(oldValue, newValue);
    }
    onLogarithmBasePropertyChanged(oldValue, newValue) {
        this.onLogarithmBaseChanged(oldValue, newValue);
    }
    onExponentStepChanged(oldValue, newValue) {
    }
    onLogarithmBaseChanged(oldValue, newValue) {
    }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
};
chart_axis_common_LogarithmicAxis.exponentStepProperty = new properties["Property"]({
    name: "exponentStep",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onExponentStepPropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_LogarithmicAxis.logarithmBaseProperty = new properties["Property"]({
    name: "logarithmBase",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onLogarithmBasePropertyChanged(oldValue, newValue);
    },
});
chart_axis_common_LogarithmicAxis = __decorate([
    Object(view_common["a" /* CSSType */])("LogarithmicAxis")
], chart_axis_common_LogarithmicAxis);

chart_axis_common_LogarithmicAxis.exponentStepProperty.register(chart_axis_common_LogarithmicAxis);
chart_axis_common_LogarithmicAxis.logarithmBaseProperty.register(chart_axis_common_LogarithmicAxis);
let chart_axis_common_ChartAxisLabel = class ChartAxisLabel extends view["c" /* View */] {
};
chart_axis_common_ChartAxisLabel.fitModeProperty = new properties["Property"]({
    name: "fitMode",
    valueConverter: (value) => ChartAxisLabelFitMode[toPascalCase(value)]
});
chart_axis_common_ChartAxisLabel.layoutModeProperty = new properties["Property"]({
    name: "layoutMode",
    valueConverter: (value) => ChartAxisLabelLayoutMode[toPascalCase(value)]
});
chart_axis_common_ChartAxisLabel.rotationAngleProperty = new properties["Property"]({
    name: "rotationAngle"
});
chart_axis_common_ChartAxisLabel.formatProperty = new properties["Property"]({
    name: "format",
    valueConverter: (v) => trimQuotes(v)
});
chart_axis_common_ChartAxisLabel = __decorate([
    Object(view_common["a" /* CSSType */])("ChartAxisLabel")
], chart_axis_common_ChartAxisLabel);

chart_axis_common_ChartAxisLabel.fitModeProperty.register(chart_axis_common_ChartAxisLabel);
chart_axis_common_ChartAxisLabel.layoutModeProperty.register(chart_axis_common_ChartAxisLabel);
chart_axis_common_ChartAxisLabel.rotationAngleProperty.register(chart_axis_common_ChartAxisLabel);
chart_axis_common_ChartAxisLabel.formatProperty.register(chart_axis_common_ChartAxisLabel);
function trimQuotes(value) {
    if (!value) {
        return value;
    }
    if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
        return value.substr(1, value.length - 2);
    }
    return value;
}
//# sourceMappingURL=chart-axis.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-label-style.common.js

class chart_label_style_common_PointLabelStyle extends view_base["ViewBase"] {
}
chart_label_style_common_PointLabelStyle.strokeWidthProperty = new properties["Property"]({
    name: "strokeWidth",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.strokeColorProperty = new properties["Property"]({
    name: "strokeColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.fillColorProperty = new properties["Property"]({
    name: "fillColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.textColorProperty = new properties["Property"]({
    name: "textColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.textSizeProperty = new properties["Property"]({
    name: "textSize",
    defaultValue: 10,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.marginProperty = new properties["Property"]({
    name: "margin",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.textFormatProperty = new properties["Property"]({
    name: "textFormat",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
    },
});
chart_label_style_common_PointLabelStyle.fontNameProperty = new properties["Property"]({
    name: "fontName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.fontStyleProperty = new properties["Property"]({
    name: "fontStyle",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => { },
});
chart_label_style_common_PointLabelStyle.strokeWidthProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.strokeColorProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.fillColorProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.textColorProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.textSizeProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.marginProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.textFormatProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.fontNameProperty.register(chart_label_style_common_PointLabelStyle);
chart_label_style_common_PointLabelStyle.fontStyleProperty.register(chart_label_style_common_PointLabelStyle);
//# sourceMappingURL=chart-label-style.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/views/chart-series.common.js






class chart_series_common_ChartSeries extends view["c" /* View */] {
    constructor() {
        super();
    }
    initNativeView() {
    }
    eachChild(callback) {
        if (this._label) {
            callback(this._label);
        }
    }
    onLoaded() {
        if (!this._label) {
            const label = new chart_series_common_ChartSeriesLabel();
            this._label = label;
            setupCssScope(this.owner, this._label);
            this._addView(this._label);
        }
        if (!this.labelStyle) {
            this.labelStyle = new chart_label_style_common_PointLabelStyle();
        }
        super.onLoaded();
        this._labelPropertyChangeHandler = this._labelPropertyChangeHandler || ((args) => {
            this.applyLabelPropertyFromStyle(args.propertyName);
        });
        this.attachLabelChangeListeners();
        this.applyLabelPropertyFromStyle();
    }
    get label() {
        return this._label;
    }
    updateLabelColorFromStyle() {
        const labelTextColor = this._label.style.color;
        if (labelTextColor !== undefined) {
            this.labelStyle.textColor = labelTextColor;
        }
    }
    updateLabelFontFromStyle() {
        const fontInternal = this._label.style.fontInternal;
        if (fontInternal && fontInternal !== styling_font["a" /* Font */].default) {
            this.initializer.onFontInternalChanged(null, fontInternal, this);
        }
    }
    updateLabelMarginFromStyle() {
        const labelMargin = this._label.style.marginLeft;
        if (labelMargin !== undefined && !isNaN(+labelMargin)) {
            this.labelStyle.margin = +labelMargin;
        }
    }
    updateLabelFillColorFromStyle() {
        const labelFillColor = this._label.style.backgroundColor;
        if (labelFillColor !== undefined) {
            this.labelStyle.fillColor = labelFillColor;
        }
    }
    updateLabelStrokeWidthFromStyle() {
        const labelStrokeWidth = this._label.style.borderLeftWidth;
        if (labelStrokeWidth !== undefined && !isNaN(+labelStrokeWidth)) {
            this.labelStyle.strokeWidth = +labelStrokeWidth;
        }
    }
    updateLabelStrokeColorFromStyle() {
        const labelStrokeColor = this._label.style.borderLeftColor;
        if (labelStrokeColor !== undefined) {
            this.labelStyle.strokeColor = labelStrokeColor;
        }
    }
    updateLabelFormatFromStyle() {
        const labelFormat = this._label.format;
        if (labelFormat !== undefined) {
            this.labelStyle.textFormat = labelFormat;
        }
    }
    updateLabelPaddingFromStyle(propertyName) {
        this.initializer.onLabelPaddingChanged(null, propertyName, this);
    }
    applyLabelPropertyFromStyle(propertyName) {
        if (!propertyName || propertyName === "color") {
            this.updateLabelColorFromStyle();
        }
        if (!propertyName || propertyName === "fontInternal") {
            this.updateLabelFontFromStyle();
        }
        if (!propertyName || propertyName === "backgroundColor") {
            this.updateLabelFillColorFromStyle();
        }
        if (!propertyName || propertyName === "borderLeftWidth") {
            this.updateLabelStrokeWidthFromStyle();
        }
        if (!propertyName || propertyName === "borderLeftColor") {
            this.updateLabelStrokeColorFromStyle();
        }
        if (!propertyName || propertyName === "marginLeft") {
            this.updateLabelMarginFromStyle();
        }
        if (!propertyName || propertyName === "format") {
            this.updateLabelFormatFromStyle();
        }
        if (!propertyName || propertyName.startsWith("padding")) {
            this.updateLabelPaddingFromStyle(propertyName);
        }
        this.initializer.onLabelStyleChanged(null, this.labelStyle, this);
    }
    attachLabelChangeListeners() {
        this.label.style.on("colorChange", this._labelPropertyChangeHandler);
        this.label.style.on("fontInternalChange", this._labelPropertyChangeHandler);
        this.label.style.on("paddingLeftChange", this._labelPropertyChangeHandler);
        this.label.style.on("paddingTopChange", this._labelPropertyChangeHandler);
        this.label.style.on("paddingRightChange", this._labelPropertyChangeHandler);
        this.label.style.on("paddingBottomChange", this._labelPropertyChangeHandler);
        this.label.style.on("backgroundColorChange", this._labelPropertyChangeHandler);
        this.label.style.on("borderLeftWidthChange", this._labelPropertyChangeHandler);
        this.label.style.on("borderLeftColorChange", this._labelPropertyChangeHandler);
        this.label.style.on("marginLeftChange", this._labelPropertyChangeHandler);
        this.label.on("formatChange", this._labelPropertyChangeHandler);
    }
    detachLabelChangeListeners() {
        this.label.style.off("colorChange", this._labelPropertyChangeHandler);
        this.label.style.off("fontInternalChange", this._labelPropertyChangeHandler);
        this.label.style.off("paddingLeftChange", this._labelPropertyChangeHandler);
        this.label.style.off("paddingTopChange", this._labelPropertyChangeHandler);
        this.label.style.off("paddingRightChange", this._labelPropertyChangeHandler);
        this.label.style.off("paddingBottomChange", this._labelPropertyChangeHandler);
        this.label.style.off("backgroundColorChange", this._labelPropertyChangeHandler);
        this.label.style.off("borderLeftWidthChange", this._labelPropertyChangeHandler);
        this.label.style.off("borderLeftColorChange", this._labelPropertyChangeHandler);
        this.label.style.off("marginLeftChange", this._labelPropertyChangeHandler);
        this.label.off("formatChange", this._labelPropertyChangeHandler);
    }
    onUnloaded() {
        super.onUnloaded();
        this.detachLabelChangeListeners();
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_ChartSeriesValueMapper();
        }
        return this._initializer;
    }
    get owner() {
        return null;
    }
    set owner(value) {
    }
    updateOwnerChart() {
        if (this.owner) {
            this.owner.updateChart();
        }
    }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
    set ios(value) {
    }
    onLegendTitlePropertyChanged(oldValue, newValue) {
        this.onLegendTitleChanged(oldValue, newValue);
    }
    onItemsPropertyChanged(oldValue, newValue) {
        this.onItemsChanged(oldValue, newValue);
    }
    onValuePropertyPropertyChanged(oldValue, newValue) {
        this.onValuePropertyChanged(oldValue, newValue);
    }
    onShowLabelsPropertyChanged(oldValue, newValue) {
        this.onShowLabelsChanged(oldValue, newValue);
    }
    onLabelStylePropertyChanged(oldValue, newValue) {
        this.onLabelStyleChanged(oldValue, newValue);
    }
    onSelectionModePropertyChanged(oldValue, newValue) {
        this.onSelectionModeChanged(oldValue, newValue);
    }
    onSelectionModeChanged(oldValue, newValue) {
        this.initializer.onSelectionModeChanged(oldValue, newValue, this);
    }
    onLabelStyleChanged(oldValue, newValue) {
        this.initializer.onLabelStyleChanged(oldValue, newValue, this);
    }
    onShowLabelsChanged(oldValue, newValue) {
        this.initializer.onShowLabelsChanged(oldValue, newValue, this);
    }
    onLegendTitleChanged(oldValue, newValue) {
    }
    onItemsChanged(oldValue, newValue) {
        this.initializer.onItemsChanged(oldValue, newValue, this);
        if (oldValue instanceof observable["Observable"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, this.ItemsCollectionChangedInternal, this);
        }
        if (newValue instanceof observable["Observable"]) {
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, this.ItemsCollectionChangedInternal, this);
        }
    }
    ItemsCollectionChangedInternal(data) {
        this.initializer.onItemsChanged(null, null, this);
    }
    getItemAtIndex(index) {
        if (this.items.getItem) {
            return this.items.getItem(index);
        }
        return this.items[index];
    }
    onValuePropertyChanged(oldValue, newValue) {
        this.initializer.onValuePropertyChanged(oldValue, newValue, this);
    }
}
chart_series_common_ChartSeries.selectionModeProperty = new properties["Property"]({
    name: "selectionMode",
    defaultValue: ChartSeriesSelectionMode.NotSet,
    valueConverter: (value) => ChartSeriesSelectionMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onSelectionModePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ChartSeries.labelStyleProperty = new properties["Property"]({
    name: "labelStyle",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLabelStylePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ChartSeries.showLabelsProperty = new properties["Property"]({
    name: "showLabels",
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onShowLabelsPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ChartSeries.legendTitleProperty = new properties["Property"]({
    name: "legendTitle",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLegendTitlePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ChartSeries.valuePropertyProperty = new properties["Property"]({
    name: "valueProperty",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onValuePropertyPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ChartSeries.itemsProperty = new properties["Property"]({
    name: "items",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onItemsPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ChartSeries.selectionModeProperty.register(chart_series_common_ChartSeries);
chart_series_common_ChartSeries.labelStyleProperty.register(chart_series_common_ChartSeries);
chart_series_common_ChartSeries.showLabelsProperty.register(chart_series_common_ChartSeries);
chart_series_common_ChartSeries.legendTitleProperty.register(chart_series_common_ChartSeries);
chart_series_common_ChartSeries.valuePropertyProperty.register(chart_series_common_ChartSeries);
chart_series_common_ChartSeries.itemsProperty.register(chart_series_common_ChartSeries);
class chart_series_common_CartesianSeries extends chart_series_common_ChartSeries {
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
        if (this.horizontalAxis) {
            this.horizontalAxis.owner = value;
        }
        if (this.verticalAxis) {
            this.verticalAxis.owner = value;
        }
    }
    eachChild(callback) {
        super.eachChild(callback);
        if (this.horizontalAxis) {
            callback(this.horizontalAxis);
        }
        if (this.verticalAxis) {
            callback(this.verticalAxis);
        }
    }
    onFillColorPropertyChanged(oldValue, newValue) {
        this.onFillColorChanged(oldValue, newValue);
    }
    onStrokeWidthPropertyChanged(oldValue, newValue) {
        this.onStrokeWidthChanged(oldValue, newValue);
    }
    onStrokeColorPropertyChanged(oldValue, newValue) {
        this.onStrokeColorChanged(oldValue, newValue);
    }
    onFillColorChanged(oldValue, newValue) {
        this.initializer.onFillColorChanged(oldValue, newValue, this);
    }
    onStrokeWidthChanged(oldValue, newValue) {
        this.initializer.onStrokeWidthChanged(oldValue, newValue, this);
    }
    onStrokeColorChanged(oldValue, newValue) {
        this.initializer.onStrokeColorChanged(oldValue, newValue, this);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_CartesianSeriesValueMapper();
        }
        return this._initializer;
    }
    onHorizontalAxisPropertyChanged(oldValue, newValue) {
        if (oldValue) {
            this._removeView(oldValue);
        }
        if (newValue) {
            this._addView(newValue);
            if (this.owner) {
                newValue.owner = this.owner;
            }
        }
        this.onHorizontalAxisChanged(oldValue, newValue);
    }
    onVerticalAxisPropertyChanged(oldValue, newValue) {
        if (oldValue) {
            this._removeView(oldValue);
        }
        if (newValue) {
            this._addView(newValue);
            if (this.owner) {
                newValue.owner = this.owner;
            }
        }
        this.onVerticalAxisChanged(oldValue, newValue);
    }
    onHorizontalAxisChanged(oldValue, newValue) {
        this.updateAxisBindingContext(oldValue, newValue);
        this.initializer.onHorizontalAxisChanged(oldValue, newValue, this);
    }
    onVerticalAxisChanged(oldValue, newValue) {
        this.updateAxisBindingContext(oldValue, newValue);
        this.initializer.onVerticalAxisChanged(oldValue, newValue, this);
    }
    onPaletteModeChanged(oldValue, newValue) {
        this.initializer.onPaletteModeChanged(oldValue, newValue, this);
    }
    updateAxisBindingContext(oldValue, newValue) {
        if (newValue) {
            newValue.bindingContext = this.bindingContext;
        }
        else {
            if (oldValue) {
                oldValue.bindingContext = null;
            }
        }
    }
}
chart_series_common_CartesianSeries.horizontalAxisProperty = new properties["Property"]({
    name: "horizontalAxis",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onHorizontalAxisPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CartesianSeries.verticalAxisProperty = new properties["Property"]({
    name: "verticalAxis",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onVerticalAxisPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CartesianSeries.paletteModeProperty = new properties["Property"]({
    name: 'paletteMode',
    defaultValue: undefined,
    valueConverter: (value) => ChartSeriesPaletteMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPaletteModeChanged(oldValue, newValue);
    }
});
chart_series_common_CartesianSeries.fillColorProperty = new properties["Property"]({
    name: "fillColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onFillColorPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CartesianSeries.strokeWidthProperty = new properties["Property"]({
    name: "strokeWidth",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeWidthPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CartesianSeries.strokeColorProperty = new properties["Property"]({
    name: "strokeColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeColorPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CartesianSeries.horizontalAxisProperty.register(chart_series_common_CartesianSeries);
chart_series_common_CartesianSeries.verticalAxisProperty.register(chart_series_common_CartesianSeries);
chart_series_common_CartesianSeries.paletteModeProperty.register(chart_series_common_CartesianSeries);
chart_series_common_CartesianSeries.fillColorProperty.register(chart_series_common_CartesianSeries);
chart_series_common_CartesianSeries.strokeWidthProperty.register(chart_series_common_CartesianSeries);
chart_series_common_CartesianSeries.strokeColorProperty.register(chart_series_common_CartesianSeries);
class chart_series_common_CategoricalSeries extends chart_series_common_CartesianSeries {
    onStackModePropertyChanged(oldValue, newValue) {
        this.onStackModeChanged(oldValue, newValue);
    }
    onCategoryPropertyChanged(oldValue, newValue) {
        this.onCategoryChanged(oldValue, newValue);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_CategoricalSeriesValueMapper();
        }
        return this._initializer;
    }
    onStackModeChanged(oldValue, newValue) {
        this.initializer.onStackModePropertyChanged(oldValue, newValue, this);
    }
    onCategoryChanged(oldValue, newValue) {
        this.initializer.onCategoryPropertyChanged(oldValue, newValue, this);
    }
}
chart_series_common_CategoricalSeries.categoryPropertyProperty = new properties["Property"]({
    name: "categoryProperty",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onCategoryPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CategoricalSeries.stackModeProperty = new properties["Property"]({
    name: "stackMode",
    defaultValue: ChartSeriesStackMode.None,
    valueConverter: (value) => ChartSeriesStackMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onStackModePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_CategoricalSeries.categoryPropertyProperty.register(chart_series_common_CategoricalSeries);
chart_series_common_CategoricalSeries.stackModeProperty.register(chart_series_common_CategoricalSeries);
let chart_series_common_BarSeries = class BarSeries extends chart_series_common_CategoricalSeries {
    onMinBarSizeChanged(oldValue, newValue) {
        this.initializer.onMinBarSizeChanged(oldValue, newValue, this);
    }
    onMaxBarSizeChanged(oldValue, newValue) {
        this.initializer.onMaxBarSizeChanged(oldValue, newValue, this);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_BarSeriesValueMapper();
        }
        return this._initializer;
    }
};
chart_series_common_BarSeries.minBarSizeProperty = new properties["Property"]({
    name: 'minBarSize',
    defaultValue: 0,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onMinBarSizeChanged(oldValue, newValue);
    }
});
chart_series_common_BarSeries.maxBarSizeProperty = new properties["Property"]({
    name: 'maxBarSize',
    defaultValue: 0,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onMaxBarSizeChanged(oldValue, newValue);
    }
});
chart_series_common_BarSeries = __decorate([
    Object(view_common["a" /* CSSType */])("BarSeries")
], chart_series_common_BarSeries);

chart_series_common_BarSeries.minBarSizeProperty.register(chart_series_common_BarSeries);
chart_series_common_BarSeries.maxBarSizeProperty.register(chart_series_common_BarSeries);
let chart_series_common_RangeBarSeries = class RangeBarSeries extends chart_series_common_CategoricalSeries {
    onHighPropertyNamePropertyChanged(oldValue, newValue) {
        this.onHighPropertyNameChanged(oldValue, newValue);
    }
    onLowPropertyNamePropertyChanged(oldValue, newValue) {
        this.onLowPropertyNameChanged(oldValue, newValue);
    }
    onLowPropertyNameChanged(oldValue, newValue) {
    }
    onHighPropertyNameChanged(oldValue, newValue) {
    }
};
chart_series_common_RangeBarSeries.highPropertyNameProperty = new properties["Property"]({
    name: "highPropertyName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onHighPropertyNamePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_RangeBarSeries.lowPropertyNameProperty = new properties["Property"]({
    name: "lowPropertyName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLowPropertyNamePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_RangeBarSeries = __decorate([
    Object(view_common["a" /* CSSType */])("RangeBarSeries")
], chart_series_common_RangeBarSeries);

chart_series_common_RangeBarSeries.highPropertyNameProperty.register(chart_series_common_RangeBarSeries);
chart_series_common_RangeBarSeries.lowPropertyNameProperty.register(chart_series_common_RangeBarSeries);
let chart_series_common_OhlcSeries = class OhlcSeries extends chart_series_common_CategoricalSeries {
    onOpenPropertyNamePropertyChanged(oldValue, newValue) {
        this.onOpenPropertyNameChanged(oldValue, newValue);
    }
    onClosePropertyNamePropertyChanged(oldValue, newValue) {
        this.onClosePropertyNameChanged(oldValue, newValue);
    }
    onHighPropertyNamePropertyChanged(oldValue, newValue) {
        this.onHighPropertyNameChanged(oldValue, newValue);
    }
    onLowPropertyNamePropertyChanged(oldValue, newValue) {
        this.onLowPropertyNameChanged(oldValue, newValue);
    }
    onStrokeColorsPropertyChanged(oldValue, newValue) {
        this.onStrokeColorsChanged(oldValue, newValue);
    }
    onLowPropertyNameChanged(oldValue, newValue) {
    }
    onHighPropertyNameChanged(oldValue, newValue) {
    }
    onClosePropertyNameChanged(oldValue, newValue) {
    }
    onOpenPropertyNameChanged(oldValue, newValue) {
    }
    onStrokeColorsChanged(oldValue, newValue) {
        this.initializer.onStrokeColorsChanged(oldValue, newValue, this);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new OhlcSeriesValueMapper();
        }
        return this._initializer;
    }
};
chart_series_common_OhlcSeries.openPropertyNameProperty = new properties["Property"]({
    name: "openPropertyName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onOpenPropertyNamePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_OhlcSeries.closePropertyNameProperty = new properties["Property"]({
    name: "closePropertyName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onClosePropertyNamePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_OhlcSeries.highPropertyNameProperty = new properties["Property"]({
    name: "highPropertyName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onHighPropertyNamePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_OhlcSeries.lowPropertyNameProperty = new properties["Property"]({
    name: "lowPropertyName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLowPropertyNamePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_OhlcSeries.strokeColorsProperty = new properties["Property"]({
    name: "strokeColors",
    defaultValue: undefined,
    valueConverter: v => v.split(",").map(v1 => new core_color["a" /* Color */](v1)),
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeColorsPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_OhlcSeries = __decorate([
    Object(view_common["a" /* CSSType */])("OhlcSeries")
], chart_series_common_OhlcSeries);

chart_series_common_OhlcSeries.openPropertyNameProperty.register(chart_series_common_OhlcSeries);
chart_series_common_OhlcSeries.closePropertyNameProperty.register(chart_series_common_OhlcSeries);
chart_series_common_OhlcSeries.highPropertyNameProperty.register(chart_series_common_OhlcSeries);
chart_series_common_OhlcSeries.lowPropertyNameProperty.register(chart_series_common_OhlcSeries);
chart_series_common_OhlcSeries.strokeColorsProperty.register(chart_series_common_OhlcSeries);
let chart_series_common_CandlestickSeries = class CandlestickSeries extends chart_series_common_OhlcSeries {
};
chart_series_common_CandlestickSeries = __decorate([
    Object(view_common["a" /* CSSType */])("CandlestickSeries")
], chart_series_common_CandlestickSeries);

let chart_series_common_BubbleSeries = class BubbleSeries extends chart_series_common_CategoricalSeries {
    onBubbleScalePropertyChanged(oldValue, newValue) {
        this.onBubbleScaleChanged(oldValue, newValue);
    }
    onBubbleScaleChanged(oldValue, newValue) {
    }
    onBubbleSizePropertyPropertyChanged(oldValue, newValue) {
        this.onBubbleSizePropertyChanged(oldValue, newValue);
    }
    onBubbleSizePropertyChanged(oldValue, newValue) {
    }
};
chart_series_common_BubbleSeries.bubbleScaleProperty = new properties["Property"]({
    name: "bubbleScale",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onBubbleScalePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_BubbleSeries.bubbleSizePropertyProperty = new properties["Property"]({
    name: "bubbleSizeProperty",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onBubbleSizePropertyPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_BubbleSeries = __decorate([
    Object(view_common["a" /* CSSType */])("BubbleSeries")
], chart_series_common_BubbleSeries);

chart_series_common_BubbleSeries.bubbleScaleProperty.register(chart_series_common_BubbleSeries);
chart_series_common_BubbleSeries.bubbleSizePropertyProperty.register(chart_series_common_BubbleSeries);
let chart_series_common_PieSeries = class PieSeries extends chart_series_common_ChartSeries {
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new PieSeriesValueMapper();
        }
        return this._initializer;
    }
    get android() {
        return undefined;
    }
    get ios() {
        return undefined;
    }
    set ios(value) {
    }
    onFillColorsPropertyChanged(oldValue, newValue) {
        this.onFillColorsChanged(oldValue, newValue);
    }
    onStrokeWidthPropertyChanged(oldValue, newValue) {
        this.onStrokeWidthChanged(oldValue, newValue);
    }
    onStrokeColorsPropertyChanged(oldValue, newValue) {
        this.onStrokeColorsChanged(oldValue, newValue);
    }
    onFillColorsChanged(oldValue, newValue) {
        this.initializer.onFillColorsChanged(oldValue, newValue, this);
    }
    onStrokeWidthChanged(oldValue, newValue) {
        this.initializer.onStrokeWidthChanged(oldValue, newValue, this);
    }
    onStrokeColorsChanged(oldValue, newValue) {
        this.initializer.onStrokeColorsChanged(oldValue, newValue, this);
    }
    onLegendLabelPropertyChanged(oldValue, newValue) {
        this.onLegendLabelChanged(oldValue, newValue);
    }
    onExpandRadiusPropertyChanged(oldValue, newValue) {
        this.onExpandRadiusChanged(oldValue, newValue);
    }
    onOuterRadiusFactorPropertyChanged(oldValue, newValue) {
        this.onOuterRadiusFactorChanged(oldValue, newValue);
    }
    onStartAnglePropertyChanged(oldValue, newValue) {
        this.onStartAngleChanged(oldValue, newValue);
    }
    onEndAnglePropertyChanged(oldValue, newValue) {
        this.onEndAngleChanged(oldValue, newValue);
    }
    onShowPercentagePropertyChanged(oldValue, newValue) {
        this.onShowPercentageChanged(oldValue, newValue);
    }
    onLegendLabelChanged(oldValue, newValue) {
        this.initializer.onLabelPropertyChanged(oldValue, newValue, this);
    }
    onExpandRadiusChanged(oldValue, newValue) {
        this.initializer.onExpandRadiusChanged(oldValue, newValue, this);
    }
    onOuterRadiusFactorChanged(oldValue, newValue) {
        this.initializer.onOuterRadiusFactorChanged(oldValue, newValue, this);
    }
    onStartAngleChanged(oldValue, newValue) {
        this.initializer.onStartAngleChanged(oldValue, newValue, this);
    }
    onEndAngleChanged(oldValue, newValue) {
        this.initializer.onEndAngleChanged(oldValue, newValue, this);
    }
    onShowPercentageChanged(oldValue, newValue) {
        this.initializer.onShowPercentageChanged(oldValue, newValue, this);
    }
};
chart_series_common_PieSeries.legendLabelProperty = new properties["Property"]({
    name: "legendLabel",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLegendLabelPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.expandRadiusProperty = new properties["Property"]({
    name: "expandRadius",
    defaultValue: undefined,
    valueConverter: (v) => parseFloat(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onExpandRadiusPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.outerRadiusFactorProperty = new properties["Property"]({
    name: "outerRadiusFactor",
    defaultValue: undefined,
    valueConverter: (v) => parseFloat(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onOuterRadiusFactorPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.startAngleProperty = new properties["Property"]({
    name: "startAngle",
    defaultValue: undefined,
    valueConverter: (v) => parseFloat(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onStartAnglePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.endAngleProperty = new properties["Property"]({
    name: "endAngle",
    defaultValue: undefined,
    valueConverter: (v) => parseFloat(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onEndAnglePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.showPercentageProperty = new properties["Property"]({
    name: "showPercentage",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onShowPercentagePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.fillColorsProperty = new properties["Property"]({
    name: "fillColors",
    defaultValue: undefined,
    valueConverter: v => v.split(",").map(v1 => new core_color["a" /* Color */](v1)),
    valueChanged: (target, oldValue, newValue) => {
        target.onFillColorsPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.strokeWidthProperty = new properties["Property"]({
    name: "strokeWidth",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeWidthPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries.strokeColorsProperty = new properties["Property"]({
    name: "strokeColors",
    defaultValue: undefined,
    valueConverter: v => v.split(",").map(v1 => new core_color["a" /* Color */](v1)),
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeColorsPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_PieSeries = __decorate([
    Object(view_common["a" /* CSSType */])("PieSeries")
], chart_series_common_PieSeries);

chart_series_common_PieSeries.legendLabelProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.expandRadiusProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.outerRadiusFactorProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.startAngleProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.endAngleProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.showPercentageProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.fillColorsProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.strokeWidthProperty.register(chart_series_common_PieSeries);
chart_series_common_PieSeries.strokeColorsProperty.register(chart_series_common_PieSeries);
let chart_series_common_DonutSeries = class DonutSeries extends chart_series_common_PieSeries {
    onInnerRadiusFactorPropertyChanged(oldValue, newValue) {
        this.onInnerRadiusFactorChanged(oldValue, newValue);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new DonutSeriesValueMapper();
        }
        return this._initializer;
    }
    onInnerRadiusFactorChanged(oldValue, newValue) {
        this.initializer.onInnerRadiusFactorChanged(oldValue, newValue, this);
    }
};
chart_series_common_DonutSeries.innerRadiusFactorProperty = new properties["Property"]({
    name: "innerRadiusFactor",
    defaultValue: undefined,
    valueConverter: (v) => parseFloat(v),
    valueChanged: (target, oldValue, newValue) => {
        target.onInnerRadiusFactorPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_DonutSeries = __decorate([
    Object(view_common["a" /* CSSType */])("DonutSeries")
], chart_series_common_DonutSeries);

chart_series_common_DonutSeries.innerRadiusFactorProperty.register(chart_series_common_DonutSeries);
let chart_series_common_ScatterSeries = class ScatterSeries extends chart_series_common_CartesianSeries {
    onXPropertyPropertyChanged(oldValue, newValue) {
        this.onXPropertyChanged(oldValue, newValue);
    }
    onYPropertyPropertyChanged(oldValue, newValue) {
        this.onYPropertyChanged(oldValue, newValue);
    }
    onXPropertyChanged(oldValue, newValue) {
        this.initializer.onXPropertyChanged(oldValue, newValue, this);
    }
    onYPropertyChanged(oldValue, newValue) {
        this.initializer.onYPropertyChanged(oldValue, newValue, this);
    }
    onValuePropertyChanged(oldValue, newValue) {
        console.log("WARNING: ValueProperty is not used for Scatter this. Use XProperty & YProperty instead.");
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new ScatterSeriesValueMapper();
        }
        return this._initializer;
    }
};
chart_series_common_ScatterSeries.xPropertyProperty = new properties["Property"]({
    name: "xProperty",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onXPropertyPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ScatterSeries.yPropertyProperty = new properties["Property"]({
    name: "yProperty",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onYPropertyPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ScatterSeries = __decorate([
    Object(view_common["a" /* CSSType */])("ScatterSeries")
], chart_series_common_ScatterSeries);

chart_series_common_ScatterSeries.xPropertyProperty.register(chart_series_common_ScatterSeries);
chart_series_common_ScatterSeries.yPropertyProperty.register(chart_series_common_ScatterSeries);
let chart_series_common_ScatterBubbleSeries = class ScatterBubbleSeries extends chart_series_common_ScatterSeries {
    onBubbleScalePropertyChanged(oldValue, newValue) {
        this.onBubbleScaleChanged(oldValue, newValue);
    }
    onBubbleScaleChanged(oldValue, newValue) {
        this.initializer.onBubbleScaleChanged(oldValue, newValue, this);
    }
    onBubbleSizePropertyPropertyChanged(oldValue, newValue) {
        this.onBubbleSizePropertyChanged(oldValue, newValue);
    }
    onBubbleSizePropertyChanged(oldValue, newValue) {
        this.initializer.onBubbleSizePropertyChanged(oldValue, newValue, this);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new ScatterBubbleSeriesValueMapper();
        }
        return this._initializer;
    }
};
chart_series_common_ScatterBubbleSeries.bubbleScaleProperty = new properties["Property"]({
    name: "bubbleScale",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onBubbleScalePropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ScatterBubbleSeries.bubbleSizePropertyProperty = new properties["Property"]({
    name: "bubbleSizeProperty",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onBubbleSizePropertyPropertyChanged(oldValue, newValue);
    },
});
chart_series_common_ScatterBubbleSeries = __decorate([
    Object(view_common["a" /* CSSType */])("ScatterBubbleSeries")
], chart_series_common_ScatterBubbleSeries);

chart_series_common_ScatterBubbleSeries.bubbleScaleProperty.register(chart_series_common_ScatterBubbleSeries);
chart_series_common_ScatterBubbleSeries.bubbleSizePropertyProperty.register(chart_series_common_ScatterBubbleSeries);
let chart_series_common_ChartSeriesLabel = class ChartSeriesLabel extends view["c" /* View */] {
};
chart_series_common_ChartSeriesLabel.formatProperty = new properties["Property"]({
    name: "format",
    valueConverter: (v) => trimQuotes(v)
});
chart_series_common_ChartSeriesLabel = __decorate([
    Object(view_common["a" /* CSSType */])("ChartSeriesLabel")
], chart_series_common_ChartSeriesLabel);

chart_series_common_ChartSeriesLabel.formatProperty.register(chart_series_common_ChartSeriesLabel);
//# sourceMappingURL=chart-series.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/misc/chart-native-helper.js

function convertToAndroidPaletteMode(nsMode) {
    if (!nsMode) {
        return null;
    }
    if (ChartSeriesPaletteMode.Item === nsMode) {
        return com.telerik.widget.palettes.ChartSeriesPaletteMode.ITEM;
    }
    else if (ChartSeriesPaletteMode.Series === nsMode) {
        return com.telerik.widget.palettes.ChartSeriesPaletteMode.SERIES;
    }
    return null;
}
function convertToIOSPaletteMode(nsMode) {
    if (!nsMode) {
        return null;
    }
    if (ChartSeriesPaletteMode.Item === nsMode) {
        return 1 /* UseItemIndex */;
    }
    else if (ChartSeriesPaletteMode.Series === nsMode) {
        return 0 /* UseSeriesIndex */;
    }
    return null;
}
//# sourceMappingURL=chart-native-helper.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/initializers/chart-initializers.js





class ChartBaseValueMapper {
    onLegendChanged(oldValue, newValue, chart) {
    }
    onPalettesChanged(data, chart) {
    }
    onPalettesPropertyChanged(oldValue, newValue, chart) {
    }
    onSeriesChanged(data, chart) {
    }
    onSeriesPropertyChanged(oldValue, newValue, chart) {
    }
    onAnnotationsChanged(data, chart) {
    }
    onAnnotationsPropertyChanged(oldValue, newValue, chart) {
    }
    onSelectionModeChanged(oldValue, newValue, chart) {
    }
    loadSeries(chart) {
    }
    loadAnnotations(chart) {
    }
    reloadPalettes(chart) {
    }
}
class chart_initializers_CartesianAxisValueMapper {
    onLineThicknessChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.lineStroke = TKStroke.strokeWithColorWidth(axis.lineColor ? axis.lineColor.ios : axis.ios.style.lineStroke.color, newValue);
            axis.update();
        }
    }
    onLineColorChanged(oldValue, newValue, axis) {
        if (newValue !== null && newValue !== undefined) {
            axis.ios.style.lineStroke = TKStroke.strokeWithColorWidth(newValue.ios, axis.lineThickness ? axis.lineThickness : axis.ios.style.lineStroke.width);
            axis.update();
        }
    }
    onLineHiddenChanged(oldValue, newValue, axis) {
        if (!newValue && !isNaN(+axis.lineThickness)) {
            axis.ios.style.lineStroke.width = axis.lineThickness;
        }
        axis.ios.style.lineHidden = newValue;
        axis.update();
    }
    onLabelTextColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.labelStyle.textColor = newValue.ios;
            axis.update();
        }
    }
    onLabelBackgroundColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.labelStyle.fill = TKSolidFill.solidFillWithColor(axis.labelBackgroundColor.ios);
            axis.update();
        }
    }
    onLabelBorderColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.style.labelStyle.stroke = axis.labelBorderWidth ?
                TKStroke.strokeWithColorWidth(newValue.ios, axis.labelBorderWidth) :
                TKStroke.strokeWithColorWidth(newValue.ios, axis.ios.style.labelStyle.stroke.width);
            axis.update();
        }
    }
    onLabelBorderWidthChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.labelStyle.stroke = axis.labelBorderColor ?
                TKStroke.strokeWithColorWidth(axis.labelBorderColor.ios, newValue) :
                TKStroke.strokeWithColorWidth(axis.ios.style.labelStyle.stroke.color, newValue);
            axis.update();
        }
    }
    onLabelMarginChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            const horizontalOffset = axis.ios.isVertical ? newValue : 0;
            const verticalOffset = axis.ios.isVertical ? 0 : newValue;
            axis.ios.style.labelStyle.textOffset = { horizontal: horizontalOffset, vertical: verticalOffset };
            axis.ios.style.labelStyle.firstLabelTextOffset = { horizontal: horizontalOffset, vertical: verticalOffset };
            axis.update();
        }
    }
    onLabelRotationAngleChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.labelStyle.rotationAngle = newValue;
            axis.update();
        }
    }
    onLabelFitModeChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisLabelFitMode.Multiline === newValue) {
                axis.ios.style.labelStyle.fitMode = 1 /* Multiline */;
            }
            else if (ChartAxisLabelFitMode.Rotate === newValue) {
                axis.ios.style.labelStyle.fitMode = 2 /* Rotate */;
            }
            else {
                axis.ios.style.labelStyle.fitMode = 0 /* None */;
            }
            axis.update();
        }
    }
    // NOTE: initially we cannot set new mode to native object since initially we don't know if the axis is horizontal or vertical
    // that's why we set the mode in owner's axis changed call (see CartesianSeriesValueMapper::onHorizontalAxisChanged)
    // But, we need this update for cases when layout mode is changed from code after the chart is shown
    onLabelLayoutModeChanged(oldValue, newValue, axis) {
        if (!newValue) {
            return;
        }
        let textAlignment;
        if (axis.ios.isVertical) {
            textAlignment = (newValue === ChartAxisLabelLayoutMode.Inner) ?
                2 /* Right */ : 1 /* Left */;
        }
        else {
            textAlignment = (newValue === ChartAxisLabelLayoutMode.Inner) ?
                4 /* Top */ : 8 /* Bottom */;
        }
        axis.ios.style.labelStyle.textAlignment = textAlignment;
        axis.ios.style.labelStyle.firstLabelTextAlignment = textAlignment;
        axis.update();
    }
    onLabelFormatChanged(oldValue, newValue, axis) {
        if (newValue) {
            axis.ios.labelFormat = (newValue);
            axis.update();
        }
    }
    onTicksHiddenChanged(oldValue, newValue, axis) {
        axis.ios.style.majorTickStyle.ticksHidden = newValue;
        axis.update();
    }
    onTicksThicknessChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.majorTickStyle.ticksWidth = newValue;
            axis.update();
        }
    }
    onTicksLengthChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.majorTickStyle.ticksLength = newValue;
            axis.update();
        }
    }
    onTicksOffsetChanged(oldValue, newValue, axis) {
        if (!isNaN(newValue)) {
            axis.ios.style.majorTickStyle.ticksOffset = newValue;
            axis.update();
        }
    }
    onTicksColorChanged(oldValue, newValue, axis) {
        if (newValue) {
            let newColor = newValue.ios;
            axis.ios.style.majorTickStyle.ticksFill = TKSolidFill.solidFillWithColor(newColor);
            axis.ios.style.majorTickStyle.ticksStroke = TKStroke.strokeWithColor(newColor);
            axis.update();
        }
    }
    onHorizontalLocationChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisHorizontalLocation.Left === newValue) {
                axis.ios.position = 0 /* Left */;
            }
            else if (ChartAxisHorizontalLocation.Right === newValue) {
                axis.ios.position = 1 /* Right */;
            }
            if (axis.owner && axis.owner.ios) {
                axis.owner.ios.update();
            }
        }
    }
    onVerticalLocationChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (ChartAxisVerticalLocation.Top === newValue) {
                axis.ios.position = 2 /* Top */;
            }
            else if (ChartAxisVerticalLocation.Bottom === newValue) {
                axis.ios.position = 3 /* Bottom */;
            }
            if (axis.owner && axis.owner.ios) {
                axis.owner.ios.update();
            }
        }
    }
    onFontInternalChanged(oldValue, newValue, axis) {
        if (newValue) {
            const defaultLabelSize = 12;
            const labelFontSize = newValue.fontSize || defaultLabelSize;
            const iosFont = newValue.getUIFont(UIFont.systemFontOfSize(labelFontSize));
            axis.ios.style.labelStyle.font = iosFont;
            axis.update();
        }
    }
    onLabelPaddingChanged(newValue, propertyName, axis) {
        const paddingLeftFromStyle = axis.label.style.paddingLeft;
        const paddingLeft = (!propertyName || propertyName === "paddingLeft") && !isNaN(+paddingLeftFromStyle) ?
            +paddingLeftFromStyle : axis.ios.style.labelStyle.insets.left;
        const paddingTopFromStyle = axis.label.style.paddingTop;
        const paddingTop = (!propertyName || propertyName === "paddingTop") && !isNaN(+paddingTopFromStyle) ?
            +paddingTopFromStyle : axis.ios.style.labelStyle.insets.top;
        const paddingRightFromStyle = axis.label.style.paddingRight;
        const paddingRight = (!propertyName || propertyName === "paddingRight") && !isNaN(+paddingRightFromStyle) ?
            +paddingRightFromStyle : axis.ios.style.labelStyle.insets.right;
        const paddingBottomFromStyle = axis.label.style.paddingBottom;
        const paddingBottom = (!propertyName || propertyName === "paddingBottom") && !isNaN(+paddingBottomFromStyle) ?
            +paddingBottomFromStyle : axis.ios.style.labelStyle.insets.bottom;
        let insets = new UIEdgeInsets({
            left: paddingLeft,
            top: paddingTop,
            right: paddingRight,
            bottom: paddingBottom
        });
        axis.ios.style.labelStyle.insets = insets;
        axis.update();
    }
    onLabelSizeChanged(oldValue, newValue, axis) {
        if (newValue) {
            let fontName = axis.ios.style.labelStyle.font.fontName;
            axis.ios.style.labelStyle.font = UIFont.fontWithNameSize(fontName, newValue);
            axis.update();
        }
    }
    onAllowZoomChanged(oldValue, newValue, axis) {
        axis.ios.allowZoom = newValue;
        axis.update();
    }
    onAllowPanChanged(oldValue, newValue, axis) {
        axis.ios.allowPan = newValue;
        axis.update();
    }
    onHiddenChanged(oldValue, newValue, axis) {
        axis.ios.hidden = newValue;
        axis.update();
    }
}
class chart_initializers_CategoricalAxisValueMapper extends chart_initializers_CartesianAxisValueMapper {
    onMajorTickIntervalChanged(oldValue, newValue, axis) {
        if (!isNaN(+newValue)) {
            axis.ios.majorTickInterval = newValue;
            axis.update();
        }
    }
    onPlotModeChanged(oldValue, newValue, axis) {
        switch (newValue) {
            case ChartAxisPlotMode.BetweenTicks:
                axis.ios.setPlotMode(1 /* BetweenTicks */);
                break;
            case ChartAxisPlotMode.OnTicks:
                axis.ios.setPlotMode(0 /* OnTicks */);
                break;
        }
        axis.update();
    }
    onLastLabelVisibilityChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (axis.plotMode && axis.plotMode !== ChartAxisPlotMode.OnTicks) {
                console.log("WARNING: Setting the 'lastLabelVisibility' to 'Hidden' with 'plotMode' set to " + axis.plotMode + " is not supported.");
                return;
            }
            switch (newValue) {
                case ChartAxisLabelVisibility.Hidden: {
                    axis.ios.style.majorTickStyle.maxTickClippingMode = 1 /* Hidden */;
                    axis.ios.style.labelStyle.maxLabelClippingMode = 1 /* Hidden */;
                    axis.update();
                    break;
                }
                case ChartAxisLabelVisibility.Clip:
                case ChartAxisLabelVisibility.Visible: {
                    axis.ios.style.majorTickStyle.maxTickClippingMode = 0 /* Visible */;
                    axis.ios.style.labelStyle.maxLabelClippingMode = 0 /* Visible */;
                    axis.update();
                    break;
                }
                default: {
                    console.log("WARNING: Unsupported 'lastLabelVisibility' set: " + newValue);
                    break;
                }
            }
        }
    }
    onFirstLabelVisibilityChanged(oldValue, newValue, axis) {
        if (newValue) {
            if (axis.plotMode && axis.plotMode !== ChartAxisPlotMode.OnTicks) {
                console.log("WARNING: Setting the 'firstLabelVisibility' to 'Hidden' with 'plotMode' set to " + axis.plotMode + " is not supported.");
                return;
            }
            switch (newValue) {
                case ChartAxisLabelVisibility.Hidden: {
                    axis.ios.style.majorTickStyle.minTickClippingMode = 1 /* Hidden */;
                    axis.ios.style.labelStyle.minLabelClippingMode = 1 /* Hidden */;
                    axis.update();
                    break;
                }
                case ChartAxisLabelVisibility.Clip:
                case ChartAxisLabelVisibility.Visible: {
                    axis.ios.style.majorTickStyle.minTickClippingMode = 0 /* Visible */;
                    axis.ios.style.labelStyle.minLabelClippingMode = 0 /* Visible */;
                    axis.update();
                    break;
                }
                default: {
                    console.log("WARNING: Unsupported 'firstLabelVisibility' set: " + newValue);
                    break;
                }
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////
//  Series value mappers
////////////////////////////////////////////////////////////////////////////////////////////
class chart_initializers_ChartSeriesValueMapper {
    onItemsChanged(oldValue, newValue, series) { }
    onValuePropertyChanged(oldValue, newValue, series) { }
    onShowLabelsChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelStyle(series);
        }
    }
    onLegendTitleChanged(newValue, series) {
        if (series.ios && newValue) {
            series.ios.title = newValue;
            if (series.owner) {
                series.owner.nativeView.legend.reloadItems();
            }
        }
    }
    onSelectionModeChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applySelectionMode(series);
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    onLabelPaddingChanged(newValue, propertyName, series) {
        this.applyLabelInsetsFromStyle(series);
    }
    onFontInternalChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelFontFromStyle(series);
        }
    }
    applySelectionMode(series) {
        switch (series.selectionMode) {
            case ChartSeriesSelectionMode.Series:
                series.ios.selection = 2 /* Series */;
                break;
            case ChartSeriesSelectionMode.DataPoint:
                series.ios.selection = 3 /* DataPoint */;
                break;
            case ChartSeriesSelectionMode.None:
                series.ios.selection = 1 /* None */;
                break;
            case (ChartSeriesSelectionMode.NotSet):
                series.ios.selection = 0 /* NotSet */;
                break;
            case ChartSeriesSelectionMode.DataPointMultiple:
                series.ios.selection = 4 /* DataPointMultiple */;
                break;
        }
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelStyle(series);
        }
    }
    applyLabelFontFromStyle(series) {
        if (series.ios && series.label && series.label.style && series.label.style.fontInternal !== styling_font["a" /* Font */].default) {
            const defaultLabelSize = 10;
            const labelFontSize = series.label.style.fontInternal ? series.label.style.fontInternal.fontSize : defaultLabelSize;
            const uiFont = UIFont.systemFontOfSize(labelFontSize);
            const iosFont = series.label.style.fontInternal ? series.label.style.fontInternal.getUIFont(uiFont) : uiFont;
            series.ios.style.pointLabelStyle.font = iosFont;
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    applyLabelInsetsFromStyle(series) {
        if (!series.ios || !series.label) {
            return;
        }
        const paddingLeft = !isNaN(+series.label.style.paddingLeft) ? +series.label.style.paddingLeft : series.ios.style.pointLabelStyle.insets.left;
        const paddingTop = !isNaN(+series.label.style.paddingTop) ? +series.label.style.paddingTop : series.ios.style.pointLabelStyle.insets.top;
        const paddingRight = !isNaN(+series.label.style.paddingRight) ? +series.label.style.paddingRight : series.ios.style.pointLabelStyle.insets.right;
        const paddingBottom = !isNaN(+series.label.style.paddingBottom) ? +series.label.style.paddingBottom : series.ios.style.pointLabelStyle.insets.bottom;
        let insets = new UIEdgeInsets({
            left: paddingLeft,
            top: paddingTop,
            right: paddingRight,
            bottom: paddingBottom
        });
        series.ios.style.pointLabelStyle.insets = insets;
        if (series.owner) {
            series.updateOwnerChart();
        }
    }
    applyLabelStyle(series) {
        if (!series || !series.ios) {
            return;
        }
        series.ios.style.pointLabelStyle.textHidden = !series.showLabels;
        if (series.labelStyle) {
            if (series.labelStyle.textColor) {
                series.ios.style.pointLabelStyle.textColor = series.labelStyle.textColor.ios;
            }
            if (series.labelStyle.fillColor) {
                series.ios.style.pointLabelStyle.fill = TKSolidFill.solidFillWithColor(series.labelStyle.fillColor.ios);
            }
            if (series.labelStyle.strokeWidth || series.labelStyle.strokeColor) {
                const strokeColor = series.labelStyle.strokeColor ? series.labelStyle.strokeColor.ios : new core_color["a" /* Color */]("Black").ios;
                const stroke = TKStroke.strokeWithColor(strokeColor);
                if (series.labelStyle.strokeWidth) {
                    stroke.width = series.labelStyle.strokeWidth;
                }
                series.ios.style.pointLabelStyle.stroke = stroke;
            }
            if (series.labelStyle.margin) {
                let marginIsVertical = false;
                if (series instanceof chart_series_common_CartesianSeries) {
                    if (series.horizontalAxis instanceof chart_axis_common_CategoricalAxis ||
                        (series.owner && series.owner.horizontalAxis instanceof chart_axis_common_CategoricalAxis)) {
                        marginIsVertical = true;
                    }
                }
                const horizontalOffset = marginIsVertical ? 0 : series.labelStyle.margin;
                const verticalOffset = marginIsVertical ? series.labelStyle.margin : 0;
                series.ios.style.pointLabelStyle.labelOffset = { horizontal: horizontalOffset, vertical: verticalOffset };
            }
            if (series.labelStyle.textFormat) {
                series.ios.style.pointLabelStyle.stringFormat = series.labelStyle.textFormat;
            }
            if (series.labelStyle.fontStyle || series.labelStyle.fontStyle || series.labelStyle.textSize) {
                let font = null;
                let fontSize = !isNaN(+series.labelStyle.textSize) ? series.labelStyle.textSize : 10;
                if (series.labelStyle.fontName) {
                    font = UIFont.fontWithNameSize(series.labelStyle.fontName, fontSize);
                    if (!font) {
                        console.log("WARNING: Cannot create font with given name: " + series.labelStyle.fontName);
                        return;
                    }
                }
                if (!font) {
                    font = UIFont.systemFontOfSize(fontSize);
                }
                if (series.labelStyle.fontStyle) {
                    let traits = 0 /* ClassUnknown */;
                    let fontStyle = series.labelStyle.fontStyle;
                    switch (fontStyle) {
                        case ChartFontStyle.Bold:
                            traits = 2 /* TraitBold */;
                            break;
                        case ChartFontStyle.Italic:
                            traits = 1 /* TraitItalic */;
                            break;
                        case ChartFontStyle.BoldItalic:
                            traits = 2 /* TraitBold */ | 1 /* TraitItalic */;
                            break;
                    }
                    let newFont = UIFont.fontWithDescriptorSize(font.fontDescriptor.fontDescriptorWithSymbolicTraits(traits), fontSize);
                    if (newFont) {
                        font = newFont;
                    }
                }
                if (font) {
                    series.ios.style.pointLabelStyle.font = font;
                }
            }
        }
        this.applyLabelFontFromStyle(series);
        this.applyLabelInsetsFromStyle(series);
        if (series.owner) {
            series.updateOwnerChart();
        }
    }
    seriesCanBeBound(series) {
        return series && series.items;
    }
}
class PieSeriesValueMapper extends chart_initializers_ChartSeriesValueMapper {
    onShowLabelsChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            this.applyLabelStyle(series);
        }
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onItemsChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLabelPropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            this.applyLabelStyle(series);
        }
    }
    onExpandRadiusChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            let radius = newValue;
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log("WARNING : Expand radius factor must be number in range [0,1]");
            }
            else {
                series.ios.expandRadius = radius + 1;
            }
        }
    }
    onOuterRadiusFactorChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            let radius = newValue;
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log("WARNING : Outer radius factor must be number in range [0,1]");
            }
            else {
                series.ios.outerRadius = radius;
                series.updateOwnerChart();
            }
        }
    }
    onShowPercentageChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            series.ios.displayPercentage = (newValue) ? true : false;
            series.updateOwnerChart();
        }
    }
    onStartAngleChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            if (!isNaN(+newValue)) {
                series.ios.startAngle = newValue * Math.PI / 180;
                series.updateOwnerChart();
            }
        }
    }
    onEndAngleChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            if (!isNaN(+newValue)) {
                series.ios.endAngle = series.endAngle * Math.PI / 180;
                series.updateOwnerChart();
            }
        }
    }
    onLegendTitleChanged(newValue, series) {
        console.log("WARNING: legendTitle property is not applicable to Pie series. Use 'legendLabel' instead.");
    }
    onFillColorsChanged(oldValue, newValue, series) {
        this.applyFills(series);
    }
    onStrokeWidthChanged(oldValue, newValue, series) {
        this.applyStrokes(series);
    }
    onStrokeColorsChanged(oldValue, newValue, series) {
        this.applyStrokes(series);
    }
    applyFills(series) {
        if (series.ios && series.fillColors) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.fillColors.length);
            for (let i = 0; i < series.fillColors.length; i++) {
                nativeArray.addObject(TKSolidFill.solidFillWithColor(series.fillColors[i].ios));
            }
            series.ios.style.fills = nativeArray;
        }
    }
    applyStrokes(series) {
        if (series.ios && series.strokeColors && series.strokeWidth) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.strokeColors.length);
            for (let i = 0; i < series.strokeColors.length; i++) {
                nativeArray.addObject(TKStroke.strokeWithColorWidth(series.strokeColors[i].ios, series.strokeWidth));
            }
            series.ios.style.strokes = nativeArray;
        }
    }
    applyColors(series) {
        this.applyFills(series);
        this.applyStrokes(series);
    }
    getNativeData(series) {
        let length = series.items.length;
        let nativeSource = NSMutableArray.new();
        let item, name, value;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            value = item[series.valueProperty];
            if (series.legendLabel) {
                name = item[series.legendLabel];
            }
            else {
                name = "Series " + (i + 1);
            }
            nativeSource.addObject(TKChartDataPoint.alloc().initWithNameValue(name, value));
        }
        return nativeSource;
    }
    setCommonProperties(series) {
        let radius = series.expandRadius;
        if (radius) {
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log("WARNING : Expand radius factor must be number in range [0,1]");
            }
            else {
                series.ios.expandRadius = radius + 1;
            }
        }
        radius = series.outerRadiusFactor;
        if (radius) {
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log("WARNING : Outer radius factor must be number in range [0,1]");
            }
            else {
                series.ios.outerRadius = radius;
            }
        }
        if (!isNaN(series.startAngle)) {
            series.ios.startAngle = series.startAngle * Math.PI / 180;
        }
        if (!isNaN(series.endAngle)) {
            series.ios.endAngle = series.endAngle * Math.PI / 180;
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        series.ios = TKChartPieSeries.alloc().initWithItems(this.getNativeData(series));
        series.ios.adjustSizeToFit = false;
        this.setCommonProperties(series);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyColors(series);
        series.ios.labelDisplayMode = 2 /* Outside */;
        series.ios.visibleInLegend = true;
        series.ios.rotationEnabled = false;
        series.ios.displayPercentage = (series.showPercentage === undefined) ? true : series.showPercentage;
        if (series.owner && series.owner['addSeries']) {
            // only series from xml have owner, manually created series are added on series changed handler
            series.owner['addSeries'](series.ios);
        }
    }
}
class DonutSeriesValueMapper extends PieSeriesValueMapper {
    onInnerRadiusFactorChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            let radius = newValue;
            if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
                console.log("WARNING : Inner radius factor must be number in range (0,1)");
            }
            else {
                series.ios.innerRadius = (series.innerRadiusFactor) ? series.innerRadiusFactor : 0.5;
                series.updateOwnerChart();
            }
        }
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        series.ios = TKChartDonutSeries.alloc().initWithItems(this.getNativeData(series));
        series.ios.adjustSizeToFit = false;
        let radius = series.innerRadiusFactor;
        if (isNaN(+radius) || radius < 0.0 || radius > 1.0) {
            console.log("WARNING : Inner radius factor must be number in range (0,1)");
        }
        else {
            series.ios.innerRadius = (series.innerRadiusFactor) ? series.innerRadiusFactor : 0.5;
        }
        this.setCommonProperties(series);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyColors(series);
        series.ios.labelDisplayMode = 2 /* Outside */;
        series.ios.visibleInLegend = true;
        series.ios.rotationEnabled = false;
        series.ios.displayPercentage = (series.showPercentage === undefined) ? true : series.showPercentage;
        if (series.owner && series.owner['addSeries']) {
            series.owner['addSeries'](series.ios);
        }
    }
}
class chart_initializers_CartesianSeriesValueMapper extends chart_initializers_ChartSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        // since label alignment requires info about horizontal or vertical the axis is, we set appropriate values here
        let labelLayoutMode = series.horizontalAxis.labelLayoutMode;
        if (labelLayoutMode) {
            if (labelLayoutMode === ChartAxisLabelLayoutMode.Inner) {
                series.horizontalAxis.ios.style.labelStyle.textAlignment = 4 /* Top */;
                series.horizontalAxis.ios.style.labelStyle.firstLabelTextAlignment = 4 /* Top */;
            }
            else {
                series.horizontalAxis.ios.style.labelStyle.textAlignment = 8 /* Bottom */;
                series.horizontalAxis.ios.style.labelStyle.firstLabelTextAlignment = 8 /* Bottom */;
            }
        }
        this.updateNativeSeriesAxis(series, oldValue, newValue, false);
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        let labelLayoutMode = series.verticalAxis.labelLayoutMode;
        if (labelLayoutMode) {
            if (labelLayoutMode === ChartAxisLabelLayoutMode.Inner) {
                series.verticalAxis.ios.style.labelStyle.textAlignment = 2 /* Right */;
                series.verticalAxis.ios.style.labelStyle.firstLabelTextAlignment = 2 /* Right */;
            }
            else {
                series.verticalAxis.ios.style.labelStyle.textAlignment = 1 /* Left */;
                series.verticalAxis.ios.style.labelStyle.firstLabelTextAlignment = 1 /* Left */;
            }
        }
        this.updateNativeSeriesAxis(series, oldValue, newValue, true);
    }
    onPaletteModeChanged(oldValue, newValue, series) {
        if (series.ios) {
            this.applyPaletteMode(series);
        }
    }
    applyPaletteMode(series) {
        if (series.ios) {
            let nativePaletteMode = convertToIOSPaletteMode(series.paletteMode);
            if (nativePaletteMode !== null) {
                series.ios.style.paletteMode = nativePaletteMode;
                series.updateOwnerChart();
            }
        }
    }
    onFillColorChanged(oldValue, newValue, series) {
        this.applyFillColor(series);
    }
    onStrokeWidthChanged(oldValue, newValue, series) {
        this.applyStrokeWidth(series);
    }
    onStrokeColorChanged(oldValue, newValue, series) {
        this.applyStrokeColor(series);
    }
    applyFillColor(series) {
        if (series.ios && series.fillColor) {
            series.ios.style.fill = TKSolidFill.solidFillWithColor(series.fillColor.ios);
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    applyStrokeWidth(series) {
        this.applyStroke(series);
    }
    applyStrokeColor(series) {
        this.applyStroke(series);
    }
    applyStroke(series) {
        if (series.ios && series.strokeColor && series.strokeWidth) {
            series.ios.style.stroke = TKStroke.strokeWithColorWidth(series.strokeColor.ios, series.strokeWidth);
            if (series.owner) {
                series.updateOwnerChart();
            }
        }
    }
    applyColors(series) {
        this.applyFillColor(series);
        this.applyStroke(series);
    }
    updateNativeSeriesAxis(series, oldAxis, newAxis, isVertical) {
        if (!series.ios || !series.ios.chart) {
            return;
        }
        const nativeSeries = series.ios;
        const nativeOldAxis = oldAxis ? oldAxis.ios : null;
        const nativeNewAxis = newAxis ? newAxis.ios : null;
        series.ios.chart.replaceSeriesAxisOldNewVertical(nativeSeries, nativeOldAxis, nativeNewAxis, isVertical);
    }
    bindSeriesAxes(series) {
        if (series.horizontalAxis) {
            this.updateNativeSeriesAxis(series, null, series.horizontalAxis, false);
        }
        if (series.verticalAxis) {
            this.updateNativeSeriesAxis(series, null, series.verticalAxis, true);
        }
    }
}
class chart_initializers_CategoricalSeriesValueMapper extends chart_initializers_CartesianSeriesValueMapper {
    onCategoryPropertyChanged(oldValue, newValue, series) {
        if (series.horizontalAxis && series.verticalAxis && series.ios) {
            series.ios.setHorizontalAxis(series.horizontalAxis.ios);
            series.ios.setVerticalAxis(series.verticalAxis.ios);
        }
        this.bind(series);
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onItemsChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onShowLabelsChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            this.applyLabelStyle(series);
        }
    }
    onStackModePropertyChanged(oldValue, newValue, series) {
        if (!series.ios) {
            if (series.stackMode) {
                this.bind(series);
            }
        }
        else {
            this.setStackInfo(series);
        }
    }
    onLabelStyleChanged(oldValue, newValue, series) {
        if (series.ios && newValue) {
            this.applyLabelStyle(series);
        }
    }
    updateNative(series) {
        this.bind(series);
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.categoryProperty;
    }
    bind(series) {
        console.log("WARNING: You should override this bind in class specific initializer");
    }
    // This method must be called by every bind override at an appropriate place where the series should be given a combine mode
    setStackInfo(series) {
        if (!series.stackMode) {
            return;
        }
        switch (series.stackMode) {
            case ChartSeriesStackMode.Stack:
                series.ios.stackInfo = TKChartStackInfo.alloc().initWithIDWithStackMode(1, 0 /* Stack */);
                break;
            case ChartSeriesStackMode.Stack100:
                series.ios.stackInfo = TKChartStackInfo.alloc().initWithIDWithStackMode(1, 1 /* Stack100 */);
                break;
            case ChartSeriesStackMode.None:
                series.ios.stackInfo = null;
                break;
        }
        if (series.ios.chart) {
            series.ios.chart.reloadData();
        }
    }
    /**
    *  Cleans the axes from previous data categories if any.
    *  This method should be called if series items collection is changed.
    */
    cleanCategoryAxes(series) {
        if (series.ios && series.ios.items && series.owner) {
            series.ios.items.removeAllObjects();
            if (series.horizontalAxis &&
                (series.horizontalAxis instanceof chart_axis_common_CategoricalAxis)) {
                series.horizontalAxis.ios.removeAllCategories();
            }
            else if (series.owner.horizontalAxis &&
                (series.owner.horizontalAxis instanceof chart_axis_common_CategoricalAxis)) {
                series.owner.horizontalAxis.ios.removeAllCategories();
            }
            if (series.verticalAxis &&
                (series.verticalAxis instanceof chart_axis_common_CategoricalAxis)) {
                series.verticalAxis.ios.removeAllCategories();
            }
            else if (series.owner.verticalAxis &&
                (series.owner.verticalAxis instanceof chart_axis_common_CategoricalAxis)) {
                series.owner.verticalAxis.ios.removeAllCategories();
            }
        }
    }
}
class chart_initializers_BarSeriesValueMapper extends chart_initializers_CategoricalSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onHorizontalAxisChanged(oldValue, newValue, series);
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onVerticalAxisChanged(oldValue, newValue, series);
    }
    onMinBarSizeChanged(oldValue, newValue, series) {
        if (series.ios) {
            if (!isNaN(newValue)) {
                series.ios.minBarHeight = core["Utils"].layout.toDevicePixels(newValue);
                series.ios.minColumnWidth = core["Utils"].layout.toDevicePixels(newValue);
            }
            else {
                series.ios.maxBarHeight = 0;
                series.ios.maxColumnWidth = 0;
            }
        }
    }
    onMaxBarSizeChanged(oldValue, newValue, series) {
        if (series.ios) {
            if (!isNaN(newValue)) {
                series.ios.maxBarHeight = core["Utils"].layout.toDevicePixels(newValue);
                series.ios.maxColumnWidth = core["Utils"].layout.toDevicePixels(newValue);
            }
            else {
                series.ios.maxBarHeight = 0;
                series.ios.maxColumnWidth = 0;
            }
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let useColumnSeries;
        if (series.horizontalAxis instanceof chart_axis_common_CategoricalAxis ||
            (series.owner && series.owner.horizontalAxis instanceof chart_axis_common_CategoricalAxis)) {
            useColumnSeries = true;
        }
        this.cleanCategoryAxes(series);
        let nativeSource = NSMutableArray.new();
        if (series && series.items) {
            let length = series.items.length;
            for (let i = 0; i < length; i++) {
                let item = series.getItemAtIndex(i);
                let value = item[series.valueProperty];
                let category = item[series.categoryProperty];
                nativeSource.addObject(useColumnSeries ?
                    TKChartDataPoint.alloc().initWithXY(category, value) :
                    TKChartDataPoint.alloc().initWithXY(value, category));
            }
        }
        series.ios = useColumnSeries ?
            TKChartColumnSeries.alloc().initWithItems(nativeSource) :
            TKChartBarSeries.alloc().initWithItems(nativeSource);
        if (!isNaN(series.minBarSize)) {
            series.ios.minColumnWidth = core["Utils"].layout.toDevicePixels(series.minBarSize);
            series.ios.minBarHeight = core["Utils"].layout.toDevicePixels(series.minBarSize);
        }
        else {
            series.ios.minColumnWidth = 0;
            series.ios.minBarHeight = 0;
        }
        if (!isNaN(series.maxBarSize)) {
            series.ios.maxColumnWidth = core["Utils"].layout.toDevicePixels(series.maxBarSize);
            series.ios.maxBarHeight = core["Utils"].layout.toDevicePixels(series.maxBarSize);
        }
        else {
            series.ios.maxColumnWidth = 0;
            series.ios.maxBarHeight = 0;
        }
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class chart_initializers_RangeBarSeriesValueMapper extends chart_initializers_CategoricalSeriesValueMapper {
    onHorizontalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onHorizontalAxisChanged(oldValue, newValue, series);
    }
    onVerticalAxisChanged(oldValue, newValue, series) {
        series.updateNative();
        super.onVerticalAxisChanged(oldValue, newValue, series);
    }
    onHighPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLowPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.highPropertyName && series.lowPropertyName;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let useColumnSeries = false;
        if (series.horizontalAxis instanceof chart_axis_common_CategoricalAxis ||
            (series.owner && series.owner.horizontalAxis instanceof chart_axis_common_CategoricalAxis)) {
            useColumnSeries = true;
        }
        const length = series.items.length;
        let nativeSource = NSMutableArray.new();
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(useColumnSeries ?
                TKChartRangeDataPoint.alloc().initWithXLowHigh(item[series.categoryProperty], item[series.lowPropertyName], item[series.highPropertyName]) :
                TKChartRangeDataPoint.alloc().initWithYLowHigh(item[series.categoryProperty], item[series.lowPropertyName], item[series.highPropertyName]));
        }
        this.cleanCategoryAxes(series);
        series.ios = useColumnSeries ?
            TKChartRangeColumnSeries.alloc().initWithItems(nativeSource) :
            TKChartRangeBarSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class chart_initializers_LineSeriesValueMapper extends chart_initializers_CategoricalSeriesValueMapper {
    getDataPointsForSeries(series) {
        let isCatAxisVertical = false;
        if (series.verticalAxis instanceof chart_axis_common_CategoricalAxis ||
            (series.owner && series.owner.verticalAxis instanceof chart_axis_common_CategoricalAxis)) {
            isCatAxisVertical = true;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(TKChartDataPoint.alloc().initWithXY((isCatAxisVertical) ? item[series.valueProperty] : item[series.categoryProperty], (isCatAxisVertical) ? item[series.categoryProperty] : item[series.valueProperty]));
        }
        return nativeSource;
    }
    applyPaletteMode(series) {
        if (series.paletteMode !== undefined) {
            console.log('WARNING: Property paletteMode is not applicable for series of type: ' + series.constructor.name);
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartLineSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class SplineSeriesValueMapper extends chart_initializers_LineSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartSplineSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class AreaSeriesValueMapper extends chart_initializers_LineSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartAreaSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class SplineAreaSeriesValueMapper extends AreaSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartSplineAreaSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class BubbleSeriesValueMapper extends chart_initializers_CategoricalSeriesValueMapper {
    onBubbleSizePropertyChanged(oldValue, newValue, series) {
        // todo: this property update should recreate the data point, that's why we will remove the current native instance and must create a new one
        this.bind(series);
    }
    onBubbleScalePropertyChanged(oldValue, newValue, series) {
        if (!series.ios) {
            this.bind(series);
        }
        else {
            if (!isNaN(+newValue))
                series.ios.scale = newValue;
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.valueProperty && series.bubbleSizeProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(TKChartBubbleDataPoint.alloc().initWithXYArea(item[series.categoryProperty], item[series.valueProperty], item[series.bubbleSizeProperty]));
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartBubbleSeries.alloc().initWithItems(nativeSource);
        series.ios.scale = series.bubbleScale;
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class OhlcSeriesValueMapper extends chart_initializers_CategoricalSeriesValueMapper {
    onHighPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onLowPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onOpenPropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onClosePropertyNameChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onValuePropertyChanged(oldValue, newValue, series) {
        console.log("WARNING: OHLC series doesn't use valueProperty property.");
    }
    onStrokeColorsChanged(oldValue, newValue, series) {
        this.applyStrokes(series);
    }
    applyColors(series) {
        super.applyColors(series);
        this.applyStrokes(series);
    }
    applyStrokes(series) {
        if (series.ios && series.strokeColors) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.strokeColors.length);
            for (let i = 0; i < series.strokeColors.length; i++) {
                nativeArray.addObject(TKStroke.strokeWithColorWidth(series.strokeColors[i].ios, series.strokeWidth));
            }
            series.ios.style.strokes = nativeArray;
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.openPropertyName && series.highPropertyName && series.lowPropertyName && series.closePropertyName;
    }
    // public onShowLabelsChanged(data: PropertyChangeData, series: chartCommonModule.OhlcSeries) {
    //     if (series.items && series.categoryProperty) {
    //         this.bind(series);
    //     }
    // }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let currentItem = null;
        for (let i = 0; i < series.items.length; i++) {
            currentItem = series.getItemAtIndex(i);
            const categoryValue = currentItem[series.categoryProperty];
            let date = getDateObject(categoryValue);
            nativeSource.addObject(TKChartFinancialDataPoint.dataPointWithXOpenHighLowClose(date, currentItem[series.openPropertyName], currentItem[series.highPropertyName], currentItem[series.lowPropertyName], currentItem[series.closePropertyName]));
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartOhlcSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class CandlestickSeriesValueMapper extends OhlcSeriesValueMapper {
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let item = null;
        for (let i = 0; i < series.items.length; i++) {
            item = series.getItemAtIndex(i);
            const categoryValue = item[series.categoryProperty];
            let date = getDateObject(categoryValue);
            nativeSource.addObject(TKChartFinancialDataPoint.dataPointWithXOpenHighLowClose(date, item[series.openPropertyName], item[series.highPropertyName], item[series.lowPropertyName], item[series.closePropertyName]));
        }
        this.cleanCategoryAxes(series);
        series.ios = TKChartCandlestickSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
    onFillColorsChanged(oldValue, newValue, series) {
        this.applyFills(series);
    }
    applyColors(series) {
        super.applyColors(series);
        this.applyFills(series);
    }
    applyFills(series) {
        if (series.ios && series.fillColors) {
            let nativeArray = NSMutableArray.alloc().initWithCapacity(series.fillColors.length);
            for (let i = 0; i < series.fillColors.length; i++) {
                nativeArray.addObject(TKSolidFill.solidFillWithColor(series.fillColors[i].ios));
            }
            series.ios.style.fills = nativeArray;
            series.ios.style.paletteMode = 1 /* UseItemIndex */;
        }
    }
}
class ScatterSeriesValueMapper extends chart_initializers_CartesianSeriesValueMapper {
    onXPropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onYPropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onItemsChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.xProperty && series.yProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            // NOTE: scatter series are intended for numeric data on X & Y
            nativeSource.addObject(TKChartDataPoint.alloc().initWithXY(item[series.xProperty], item[series.yProperty]));
        }
        series.ios = TKChartScatterSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
class ScatterBubbleSeriesValueMapper extends ScatterSeriesValueMapper {
    onBubbleSizePropertyChanged(oldValue, newValue, series) {
        this.bind(series);
    }
    onBubbleScaleChanged(oldValue, newValue, series) {
        if (series.ios) {
            if (!isNaN(+newValue))
                series.ios.scale = newValue;
        }
        else {
            this.bind(series);
        }
    }
    seriesCanBeBound(series) {
        return super.seriesCanBeBound(series) && series.xProperty && series.yProperty && series.bubbleSizeProperty;
    }
    bind(series) {
        if (!this.seriesCanBeBound(series)) {
            return;
        }
        let nativeSource = NSMutableArray.new();
        let length = series.items.length;
        let item = null;
        for (let i = 0; i < length; i++) {
            item = series.getItemAtIndex(i);
            nativeSource.addObject(TKChartBubbleDataPoint.alloc().initWithXYArea(item[series.xProperty], item[series.yProperty], item[series.bubbleSizeProperty]));
        }
        series.ios = TKChartBubbleSeries.alloc().initWithItems(nativeSource);
        series.ios.scale = series.bubbleScale;
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        this.applyPaletteMode(series);
        this.applyColors(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        if (series.owner) {
            series.owner['addSeries'](series);
        }
    }
}
function getDateObject(categoryValue) {
    let dateFormatter = NSDateFormatter.alloc().init();
    // todo: this date format have to be added as property
    dateFormatter.dateFormat = "dd/MM/yyyy";
    if (typeof categoryValue === "string") {
        return dateFormatter.dateFromString(categoryValue);
    }
    else {
        if (categoryValue instanceof Date) {
            return categoryValue;
        }
    }
    console.log("Error: Not supported value set to 'categoryProperty'");
    return undefined;
}
//# sourceMappingURL=chart-initializers.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/ui-chart.common.js



/*
* Defines the known properties that are collections. This is used by the XML parser.
*/
builder["a" /* Builder */].knownCollections.add("series").add("entries").add("palettes").add("annotations");
class ui_chart_common_RadChartBase extends view["c" /* View */] {
    constructor() {
        super();
        this.on("bindingContextChange", this.baseBindingContextChanged, this);
    }
    get androidView() {
        return undefined;
    }
    get rootLayout() {
        return undefined;
    }
    reloadPalettes() {
        if (this._initializer) {
            this._initializer.reloadPalettes(this);
        }
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new ChartBaseValueMapper();
        }
        return this._initializer;
    }
    updateChart() {
    }
    _addArrayFromBuilder(name, value) {
        if (name === "series") {
            this.series = new observable_array["ObservableArray"](value);
        }
        else if (name === "palettes") {
            this.palettes = new observable_array["ObservableArray"](value);
        }
        else if (name === "annotations") {
            this.annotations = new observable_array["ObservableArray"](value);
        }
    }
    baseBindingContextChanged(data) {
        if (this.series) {
            for (let i = 0; i < this.series.length; i++) {
                this.series.getItem(i).bindingContext = data.value;
                if (this.series.getItem(i).horizontalAxis) {
                    this.series.getItem(i).horizontalAxis.bindingContext = data.value;
                }
                if (this.series.getItem(i).verticalAxis) {
                    this.series.getItem(i).verticalAxis.bindingContext = data.value;
                }
            }
        }
    }
    getAxisByID(axisID) {
        return null;
    }
    onLegendPropertyChanged(oldValue, newValue) {
        this.onLegendChanged(oldValue, newValue);
    }
    onLegendChanged(oldValue, newValue) {
    }
    onPalettesPropertyChanged(oldValue, newValue) {
        this.onPalettesChanged(oldValue, newValue);
    }
    onPalettesChanged(oldValue, newValue) {
        this.initializer.onPalettesPropertyChanged(oldValue, newValue, this);
        if (oldValue instanceof observable["Observable"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, this.PalettesCollectionChangedInternal, this);
        }
        if (newValue instanceof observable["Observable"]) {
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, this.PalettesCollectionChangedInternal, this);
        }
    }
    PalettesCollectionChangedInternal(data) {
        this.initializer.onPalettesChanged(data, this);
    }
    onSeriesPropertyChanged(oldValue, newValue) {
        this.onSeriesChanged(oldValue, newValue);
    }
    onSeriesChanged(oldValue, newValue) {
        this.initializer.onSeriesPropertyChanged(oldValue, newValue, this);
        if (oldValue instanceof observable["Observable"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, this.SeriesCollectionChangedInternal, this);
        }
        if (newValue instanceof observable["Observable"]) {
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, this.SeriesCollectionChangedInternal, this);
        }
    }
    SeriesCollectionChangedInternal(data) {
        this.initializer.onSeriesChanged(data, this);
    }
    onAnnotationsPropertyChanged(oldValue, newValue) {
        this.onAnnotationsChanged(oldValue, newValue);
    }
    onAnnotationsChanged(oldValue, newValue) {
        this.initializer.onAnnotationsPropertyChanged(oldValue, newValue, this);
        if (oldValue instanceof observable["Observable"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, this.AnnotationsCollectionChangedInternal, this);
        }
        if (newValue instanceof observable["Observable"]) {
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, this.AnnotationsCollectionChangedInternal, this);
        }
    }
    AnnotationsCollectionChangedInternal(data) {
        this.initializer.onAnnotationsChanged(data, this);
    }
    onSeriesSelectionModePropertyChanged(oldValue, newValue) {
        this.onSeriesSelectionModeChanged(oldValue, newValue);
    }
    onPointSelectionModePropertyChanged(oldValue, newValue) {
        this.onPointSelectionModeChanged(oldValue, newValue);
    }
    onAllowAnimationsPropertyChanged(oldValue, newValue) {
        this.onAllowAnimationsChanged(oldValue, newValue);
    }
    onSeriesSelectionModeChanged(oldValue, newValue) {
    }
    onPointSelectionModeChanged(oldValue, newValue) {
    }
    onAllowAnimationsChanged(oldValue, newValue) {
    }
}
ui_chart_common_RadChartBase.seriesSelectedEvent = "seriesSelected";
ui_chart_common_RadChartBase.seriesDeselectedEvent = "seriesDeselected";
ui_chart_common_RadChartBase.pointSelectedEvent = "pointSelected";
ui_chart_common_RadChartBase.pointDeselectedEvent = "pointDeselected";
ui_chart_common_RadChartBase.chartZoomedEvent = "chartZoomed";
ui_chart_common_RadChartBase.chartPannedEvent = "chartPanned";
ui_chart_common_RadChartBase.trackballTrackedSelectionEvent = "trackballTrackedSelection";
ui_chart_common_RadChartBase.legendProperty = new properties["Property"]({
    name: "legend",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onLegendPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.seriesProperty = new properties["Property"]({
    name: "series",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onSeriesPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.palettesProperty = new properties["Property"]({
    name: "palettes",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onPalettesPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.annotationsProperty = new properties["Property"]({
    name: "annotations",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onAnnotationsPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.seriesSelectionModeProperty = new properties["Property"]({
    name: "seriesSelectionMode",
    defaultValue: ChartSelectionMode.None,
    valueConverter: (value) => ChartSelectionMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onSeriesSelectionModePropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.pointSelectionModeProperty = new properties["Property"]({
    name: "pointSelectionMode",
    defaultValue: ChartSelectionMode.None,
    valueConverter: (value) => ChartSelectionMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPointSelectionModePropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.allowAnimationsProperty = new properties["Property"]({
    name: "allowAnimations",
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onAllowAnimationsPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadChartBase.legendProperty.register(ui_chart_common_RadChartBase);
ui_chart_common_RadChartBase.seriesProperty.register(ui_chart_common_RadChartBase);
ui_chart_common_RadChartBase.palettesProperty.register(ui_chart_common_RadChartBase);
ui_chart_common_RadChartBase.annotationsProperty.register(ui_chart_common_RadChartBase);
ui_chart_common_RadChartBase.seriesSelectionModeProperty.register(ui_chart_common_RadChartBase);
ui_chart_common_RadChartBase.pointSelectionModeProperty.register(ui_chart_common_RadChartBase);
ui_chart_common_RadChartBase.allowAnimationsProperty.register(ui_chart_common_RadChartBase);
let ui_chart_common_RadCartesianChart = class RadCartesianChart extends ui_chart_common_RadChartBase {
    constructor() {
        super();
        this.on("bindingContextChange", this.bindingContextChanged, this);
    }
    eachChild(callback) {
        if (this.horizontalAxis) {
            callback(this.horizontalAxis);
        }
        if (this.verticalAxis) {
            callback(this.verticalAxis);
        }
        if (this.series) {
            for (let i = 0; i < this.series.length; i++) {
                let currentSeries = this.series.getItem(i);
                callback(currentSeries);
            }
        }
    }
    onGridPropertyChanged(oldValue, newValue) {
        this.onGridChanged(oldValue, newValue);
    }
    onGridChanged(oldValue, newValue) {
    }
    onHorizontalAxisPropertyChanged(oldValue, newValue) {
        this.onHorizontalAxisChanged(oldValue, newValue);
    }
    onVerticalAxisPropertyChanged(oldValue, newValue) {
        this.onVerticalAxisChanged(oldValue, newValue);
    }
    onHorizontalZoomPropertyChanged(oldValue, newValue) {
        this.onHorizontalZoomChanged(oldValue, newValue);
    }
    onVerticalZoomPropertyChanged(oldValue, newValue) {
        this.onVerticalZoomChanged(oldValue, newValue);
    }
    onTrackballPropertyChanged(oldValue, newValue) {
        this.onTrackballChanged(oldValue, newValue);
    }
    onHorizontalAxisChanged(oldValue, newValue) {
        this.updateAxisBindingContext(oldValue, newValue);
    }
    onVerticalAxisChanged(oldValue, newValue) {
        this.updateAxisBindingContext(oldValue, newValue);
    }
    onHorizontalZoomChanged(oldValue, newValue) {
    }
    onVerticalZoomChanged(oldValue, newValue) {
    }
    onTrackballChanged(oldValue, newValue) {
        if (oldValue) {
            oldValue._owner = undefined;
        }
        if (newValue) {
            newValue._owner = this;
        }
    }
    updateAxisBindingContext(oldValue, newValue) {
        if (newValue) {
            newValue.bindingContext = this.bindingContext;
        }
        else {
            if (oldValue) {
                oldValue.bindingContext = null;
            }
        }
    }
    bindingContextChanged(data) {
        if (this.horizontalAxis) {
            this.horizontalAxis.bindingContext = data.value;
        }
        if (this.verticalAxis) {
            this.verticalAxis.bindingContext = data.value;
        }
    }
};
ui_chart_common_RadCartesianChart.gridProperty = new properties["Property"]({
    name: "grid",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onGridPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadCartesianChart.horizontalAxisProperty = new properties["Property"]({
    name: "horizontalAxis",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onHorizontalAxisPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadCartesianChart.verticalAxisProperty = new properties["Property"]({
    name: "verticalAxis",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onVerticalAxisPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadCartesianChart.verticalZoomProperty = new properties["Property"]({
    name: "verticalZoom",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onVerticalZoomPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadCartesianChart.horizontalZoomProperty = new properties["Property"]({
    name: "horizontalZoom",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onHorizontalZoomPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadCartesianChart.trackballProperty = new properties["Property"]({
    name: "trackball",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onTrackballPropertyChanged(oldValue, newValue);
    },
});
ui_chart_common_RadCartesianChart = __decorate([
    Object(view_common["a" /* CSSType */])("RadCartesianChart"),
    __metadata("design:paramtypes", [])
], ui_chart_common_RadCartesianChart);

ui_chart_common_RadCartesianChart.gridProperty.register(ui_chart_common_RadCartesianChart);
ui_chart_common_RadCartesianChart.horizontalAxisProperty.register(ui_chart_common_RadCartesianChart);
ui_chart_common_RadCartesianChart.verticalAxisProperty.register(ui_chart_common_RadCartesianChart);
ui_chart_common_RadCartesianChart.verticalZoomProperty.register(ui_chart_common_RadCartesianChart);
ui_chart_common_RadCartesianChart.horizontalZoomProperty.register(ui_chart_common_RadCartesianChart);
ui_chart_common_RadCartesianChart.trackballProperty.register(ui_chart_common_RadCartesianChart);
let ui_chart_common_RadPieChart = class RadPieChart extends ui_chart_common_RadChartBase {
    eachChild(callback) {
        if (this.series) {
            for (let i = 0; i < this.series.length; i++) {
                let currentSeries = this.series.getItem(i);
                callback(currentSeries);
            }
        }
    }
};
ui_chart_common_RadPieChart = __decorate([
    Object(view_common["a" /* CSSType */])("RadPieChart")
], ui_chart_common_RadPieChart);

function setupCssScope(scopedView, unscopedView) {
    const ngKey = scopedView._ngKey;
    if (ngKey) {
        let ngValue = scopedView[ngKey];
        unscopedView[ngKey] = ngValue;
    }
    const vueKey = scopedView._vueKey;
    if (vueKey) {
        let vueValue = scopedView[vueKey];
        unscopedView[vueKey] = vueValue;
    }
}
//# sourceMappingURL=ui-chart.common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style-properties.js + 2 modules
var style_properties = __webpack_require__(2);

// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-track-ball.common.js


class chart_track_ball_common_Trackball extends view_base["ViewBase"] {
    constructor() {
        super();
    }
    get android() {
        return this._android;
    }
    set android(value) {
        this._android = value;
    }
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    onSnapModePropertyChanged(oldValue, newValue) {
        this.onSnapModeChanged(oldValue, newValue);
    }
    onShowIntersectionPointsPropertyChanged(oldValue, newValue) {
        this.onShowIntersectionPointsChanged(oldValue, newValue);
    }
    onSnapModeChanged(oldValue, newValue) { }
    onShowIntersectionPointsChanged(oldValue, newValue) { }
    onOwnerChanged() { }
}
chart_track_ball_common_Trackball.trackBallContentRequestedEvent = "trackBallContentRequested";
chart_track_ball_common_Trackball.snapModeProperty = new properties["Property"]({
    name: "snapMode",
    defaultValue: ChartTrackballSnapMode.ClosestPoint,
    valueConverter: (value) => ChartTrackballSnapMode[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onSnapModePropertyChanged(oldValue, newValue);
    },
});
chart_track_ball_common_Trackball.showIntersectionPointsProperty = new properties["Property"]({
    name: "showIntersectionPoints",
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onShowIntersectionPointsPropertyChanged(oldValue, newValue);
    },
});
chart_track_ball_common_Trackball.snapModeProperty.register(chart_track_ball_common_Trackball);
chart_track_ball_common_Trackball.showIntersectionPointsProperty.register(chart_track_ball_common_Trackball);
//# sourceMappingURL=chart-track-ball.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/views/chart-series.js




class chart_series_PieSeries extends chart_series_common_PieSeries {
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    [chart_series_common_PieSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
}
class chart_series_DonutSeries extends chart_series_common_DonutSeries {
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    updateOwnerChart() {
        if (this.owner && (this.owner instanceof ui_chart_common_RadPieChart)) {
            this.owner.updateChart();
        }
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new DonutSeriesValueMapper();
        }
        return this._initializer;
    }
    onInnerRadiusFactorChanged(oldValue, newValue) {
        this.initializer.onInnerRadiusFactorChanged(oldValue, newValue, this);
    }
    [chart_series_common_DonutSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
}
////////////////////////////////////////////////////////////////////////
// BarSeries
////////////////////////////////////////////////////////////////////////
class chart_series_BarSeries extends chart_series_common_BarSeries {
    constructor() {
        super();
    }
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    [chart_series_common_BarSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
    updateNative() {
        this.initializer.updateNative(this);
    }
}
////////////////////////////////////////////////////////////////////////
// RangeBarSeries
////////////////////////////////////////////////////////////////////////
class chart_series_RangeBarSeries extends chart_series_common_RangeBarSeries {
    constructor() {
        super();
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_RangeBarSeriesValueMapper();
        }
        return this._initializer;
    }
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    updateNative() {
        this.initializer.updateNative(this);
    }
    [chart_series_common_RangeBarSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
    onHighPropertyNameChanged(oldValue, newValue) {
        this.initializer.onHighPropertyNameChanged(oldValue, newValue, this);
    }
    onLowPropertyNameChanged(oldValue, newValue) {
        this.initializer.onLowPropertyNameChanged(oldValue, newValue, this);
    }
    onValuePropertyChanged(oldValue, newValue) {
        console.log("WARNING: Range bar series doesn't use valueProperty property.");
    }
}
////////////////////////////////////////////////////////////////////////
// LineSeries
////////////////////////////////////////////////////////////////////////
let chart_series_LineSeries = class LineSeries extends chart_series_common_CategoricalSeries {
    constructor() {
        super();
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new chart_initializers_LineSeriesValueMapper();
        }
        return this._initializer;
    }
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    [chart_series_common_CategoricalSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
};
chart_series_LineSeries = __decorate([
    Object(view_common["a" /* CSSType */])("LineSeries"),
    __metadata("design:paramtypes", [])
], chart_series_LineSeries);

let chart_series_SplineSeries = class SplineSeries extends chart_series_LineSeries {
    get initializer() {
        if (!this._initializer) {
            this._initializer = new SplineSeriesValueMapper();
        }
        return this._initializer;
    }
    [chart_series_LineSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
};
chart_series_SplineSeries = __decorate([
    Object(view_common["a" /* CSSType */])("SplineSeries")
], chart_series_SplineSeries);

let chart_series_AreaSeries = class AreaSeries extends chart_series_LineSeries {
    get initializer() {
        if (!this._initializer) {
            this._initializer = new AreaSeriesValueMapper();
        }
        return this._initializer;
    }
    [chart_series_LineSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
};
chart_series_AreaSeries = __decorate([
    Object(view_common["a" /* CSSType */])("AreaSeries")
], chart_series_AreaSeries);

let chart_series_SplineAreaSeries = class SplineAreaSeries extends chart_series_AreaSeries {
    get initializer() {
        if (!this._initializer) {
            this._initializer = new SplineAreaSeriesValueMapper();
        }
        return this._initializer;
    }
    [chart_series_LineSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
};
chart_series_SplineAreaSeries = __decorate([
    Object(view_common["a" /* CSSType */])("SplineAreaSeries")
], chart_series_SplineAreaSeries);

class chart_series_BubbleSeries extends chart_series_common_BubbleSeries {
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new BubbleSeriesValueMapper();
        }
        return this._initializer;
    }
    onBubbleScaleChanged(oldValue, newValue) {
        this.initializer.onBubbleScalePropertyChanged(oldValue, newValue, this);
    }
    onBubbleSizePropertyChanged(oldValue, newValue) {
        this.initializer.onBubbleSizePropertyChanged(oldValue, newValue, this);
    }
    [chart_series_common_BubbleSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
}
class chart_series_ScatterSeries extends chart_series_common_ScatterSeries {
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    [chart_series_common_ScatterSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
}
class chart_series_ScatterBubbleSeries extends chart_series_common_ScatterBubbleSeries {
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    [chart_series_common_ScatterBubbleSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
}
class chart_series_OhlcSeries extends chart_series_common_OhlcSeries {
    get ios() {
        return this._series;
    }
    set ios(value) {
        this._series = value;
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new OhlcSeriesValueMapper();
        }
        return this._initializer;
    }
    [chart_series_common_OhlcSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
    onHighPropertyNameChanged(oldValue, newValue) {
        this.initializer.onHighPropertyNameChanged(oldValue, newValue, this);
    }
    onLowPropertyNameChanged(oldValue, newValue) {
        this.initializer.onLowPropertyNameChanged(oldValue, newValue, this);
    }
    onOpenPropertyNameChanged(oldValue, newValue) {
        this.initializer.onOpenPropertyNameChanged(oldValue, newValue, this);
    }
    onClosePropertyNameChanged(oldValue, newValue) {
        this.initializer.onClosePropertyNameChanged(oldValue, newValue, this);
    }
    onValuePropertyChanged(oldValue, newValue) {
        console.log("WARNING: OHLC series doesn't use valueProperty property.");
    }
}
let chart_series_CandlestickSeries = class CandlestickSeries extends chart_series_OhlcSeries {
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    onFillColorsPropertyChanged(oldValue, newValue) {
        this.onFillColorsChanged(oldValue, newValue);
    }
    onFillColorsChanged(oldValue, newValue) {
        this.initializer.onFillColorsChanged(oldValue, newValue, this);
    }
    get initializer() {
        if (!this._initializer) {
            this._initializer = new CandlestickSeriesValueMapper();
        }
        return this._initializer;
    }
    [chart_series_OhlcSeries.legendTitleProperty.setNative](newValue) {
        this.initializer.onLegendTitleChanged(newValue, this);
    }
};
chart_series_CandlestickSeries.fillColorsProperty = new properties["Property"]({
    name: "fillColors",
    defaultValue: undefined,
    valueConverter: v => v.split(",").map(v1 => new core_color["a" /* Color */](v1)),
    valueChanged: (target, oldValue, newValue) => {
        target.onFillColorsPropertyChanged(oldValue, newValue);
    },
});
chart_series_CandlestickSeries = __decorate([
    Object(view_common["a" /* CSSType */])("CandlestickSeries")
], chart_series_CandlestickSeries);

chart_series_CandlestickSeries.fillColorsProperty.register(chart_series_CandlestickSeries);
//# sourceMappingURL=chart-series.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-cartesian-chart-grid.common.js

class chart_cartesian_chart_grid_common_RadCartesianChartGrid extends view_base["ViewBase"] {
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
        this.onOwnerChanged();
    }
    applyGridStyle() {
    }
    onOwnerChanged() {
    }
    horizontalStripLinesVisibleChanged(oldValue, newValue) {
        this.onHorizontalStripLinesVisibleChanged(oldValue, newValue);
    }
    onHorizontalStripLinesVisibleChanged(oldValue, newValue) {
    }
    verticalStripLinesVisibleChanged(oldValue, newValue) {
        this.onVerticalStripLinesVisibleChanged(oldValue, newValue);
    }
    onVerticalStripLinesVisibleChanged(oldValue, newValue) {
    }
    verticalLinesVisibleChanged(oldValue, newValue) {
        this.onVerticalLinesVisibleChanged(oldValue, newValue);
    }
    onVerticalLinesVisibleChanged(oldValue, newValue) {
    }
    horizontalLinesVisibleChanged(oldValue, newValue) {
        this.onHorizontalLinesVisibleChanged(oldValue, newValue);
    }
    onHorizontalLinesVisibleChanged(oldValue, newValue) {
    }
    verticalStrokeColorChanged(oldValue, newValue) {
        this.onVerticalStrokeColorChanged(oldValue, newValue);
    }
    onVerticalStrokeColorChanged(oldValue, newValue) {
    }
    horizontalStrokeColorChanged(oldValue, newValue) {
        this.onHorizontalStrokeColorChanged(oldValue, newValue);
    }
    onHorizontalStrokeColorChanged(oldValue, newValue) {
    }
    horizontalStrokeWidthChanged(oldValue, newValue) {
        this.onHorizontalStrokeWidthChanged(oldValue, newValue);
    }
    onHorizontalStrokeWidthChanged(oldValue, newValue) {
    }
    verticalStrokeWidthChanged(oldValue, newValue) {
        this.onVerticalStrokeWidthChanged(oldValue, newValue);
    }
    onVerticalStrokeWidthChanged(oldValue, newValue) {
    }
    verticalStripLineColorChanged(oldValue, newValue) {
        this.onVerticalStripLineColorChanged(oldValue, newValue);
    }
    onVerticalStripLineColorChanged(oldValue, newValue) {
    }
    horizontalStripLineColorChanged(oldValue, newValue) {
        this.onHorizontalStripLineColorChanged(oldValue, newValue);
    }
    onHorizontalStripLineColorChanged(oldValue, newValue) {
    }
}
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStrokeColorProperty = new properties["Property"]({
    name: "horizontalStrokeColor",
    defaultValue: undefined,
    valueConverter: stringColorsConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.horizontalStrokeColorChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStrokeColorProperty = new properties["Property"]({
    name: "verticalStrokeColor",
    defaultValue: undefined,
    valueConverter: stringColorsConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.verticalStrokeColorChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStrokeWidthProperty = new properties["Property"]({
    name: "horizontalStrokeWidth",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.horizontalStrokeWidthChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStrokeWidthProperty = new properties["Property"]({
    name: "verticalStrokeWidth",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.verticalStrokeWidthChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStripLineColorProperty = new properties["Property"]({
    name: "verticalStripLineColor",
    defaultValue: undefined,
    valueConverter: stringColorsConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.verticalStripLineColorChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStripLineColorProperty = new properties["Property"]({
    name: "horizontalStripLineColor",
    defaultValue: undefined,
    valueConverter: stringColorsConverter,
    valueChanged: (target, oldValue, newValue) => {
        target.horizontalStripLineColorChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalLinesVisibleProperty = new properties["Property"]({
    name: "verticalLinesVisible",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.verticalLinesVisibleChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalLinesVisibleProperty = new properties["Property"]({
    name: "horizontalLinesVisible",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.horizontalLinesVisibleChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStripLinesVisibleProperty = new properties["Property"]({
    name: "verticalStripLinesVisible",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.verticalStripLinesVisibleChanged(oldValue, newValue);
    },
});
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStripLinesVisibleProperty = new properties["Property"]({
    name: "horizontalStripLinesVisible",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.horizontalStripLinesVisibleChanged(oldValue, newValue);
    },
});
function stringColorsConverter(colorsText) {
    if (colorsText.indexOf(',') > -1) {
        let colorsArray = [];
        let colorsList = colorsText.split(',');
        for (let i = 0; i < colorsList.length; i++) {
            let color = new core_color["a" /* Color */](colorsList[i].trim());
            colorsArray.push(color);
        }
        return colorsArray;
    }
    return new core_color["a" /* Color */](colorsText);
}
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStrokeColorProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStrokeColorProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStrokeWidthProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStrokeWidthProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStripLineColorProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStripLineColorProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalLinesVisibleProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalLinesVisibleProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.verticalStripLinesVisibleProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
chart_cartesian_chart_grid_common_RadCartesianChartGrid.horizontalStripLinesVisibleProperty.register(chart_cartesian_chart_grid_common_RadCartesianChartGrid);
//# sourceMappingURL=chart-cartesian-chart-grid.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-cartesian-chart-grid.js

////////////////////////////////////////////////////////////////////////
// RadCartesianChartGrid
////////////////////////////////////////////////////////////////////////
// NOTE: The workflow that uses exclusively created TKChartGridStyle instance (this._ios) is dummy, but needed.
// We faced with a bug that grid styling has some statics and if we set properties directly to this.owner.ios.gridStyle
// in view with multiple charts the grid of all of them have the same horizontal/vertial lines.
// The native code should be debug and statics removed.
////////////////////////////////////////////////////////////////////////
class chart_cartesian_chart_grid_RadCartesianChartGrid extends chart_cartesian_chart_grid_common_RadCartesianChartGrid {
    constructor() {
        super();
        this._ios = TKChartGridStyle.new();
        this._ios.drawOrder = 1 /* VerticalFirst */;
    }
    onOwnerChanged() {
        this.applyGridStyle();
    }
    applyGridStyle() {
        if (!this.owner) {
            return;
        }
        let style = this.owner._nativeView.gridStyle;
        style.drawOrder = this._ios.drawOrder;
        style.verticalLineStroke = this._ios.verticalLineStroke;
        style.verticalLineAlternateStroke = this._ios.verticalLineAlternateStroke;
        style.verticalLinesHidden = this._ios.verticalLinesHidden;
        style.verticalFill = this._ios.verticalFill;
        style.verticalAlternateFill = this._ios.verticalAlternateFill;
        style.horizontalLineStroke = this._ios.horizontalLineStroke;
        style.horizontalLineAlternateStroke = this._ios.horizontalLineAlternateStroke;
        style.horizontalFill = this._ios.horizontalFill;
        style.horizontalAlternateFill = this._ios.horizontalAlternateFill;
        style.horizontalLinesHidden = this._ios.horizontalLinesHidden;
        this.owner.updateChart();
    }
    updateHorizontalFill(color) {
        if (!color || !this.horizontalStripLinesVisible) {
            this._ios.horizontalFill = null;
            this._ios.horizontalAlternateFill = null;
        }
        else {
            if (color instanceof Array) {
                if (color.length > 1) {
                    // This is a workaround for the fact that in iOS when there is an alternate fill, it is applied first.
                    this._ios.horizontalAlternateFill = TKSolidFill.solidFillWithColor(color[0].ios);
                    this._ios.horizontalFill = TKSolidFill.solidFillWithColor(color[1].ios);
                }
                else {
                    this._ios.horizontalFill = TKSolidFill.solidFillWithColor(color[0].ios);
                    this._ios.horizontalAlternateFill = null;
                }
            }
            else {
                this._ios.horizontalFill = TKSolidFill.solidFillWithColor(color.ios);
                this._ios.horizontalAlternateFill = null;
            }
        }
        this.applyGridStyle();
    }
    updateVerticalFill(color) {
        if (!color || !this.verticalStripLinesVisible) {
            this._ios.verticalFill = null;
            this._ios.verticalAlternateFill = null;
        }
        else {
            if (color instanceof Array) {
                if (color.length > 1) {
                    // This is a workaround for the fact that in iOS when there is an alternate fill, it is applied first.
                    this._ios.verticalAlternateFill = TKSolidFill.solidFillWithColor(color[0].ios);
                    this._ios.verticalFill = TKSolidFill.solidFillWithColor(color[1].ios);
                }
                else {
                    this._ios.verticalFill = TKSolidFill.solidFillWithColor(color[0].ios);
                    this._ios.verticalAlternateFill = null;
                }
            }
            else {
                this._ios.verticalFill = TKSolidFill.solidFillWithColor(color.ios);
                this._ios.verticalAlternateFill = null;
            }
        }
        this.applyGridStyle();
    }
    onVerticalLinesVisibleChanged(oldValue, newValue) {
        this._ios.verticalLinesHidden = (newValue) ? false : true;
        this.applyGridStyle();
    }
    onHorizontalLinesVisibleChanged(oldValue, newValue) {
        this._ios.horizontalLinesHidden = (newValue) ? false : true;
        this.applyGridStyle();
    }
    onHorizontalStripLinesVisibleChanged(oldValue, newValue) {
        this.updateHorizontalFill((newValue) ? this.horizontalStripLineColor : null);
    }
    onVerticalStripLinesVisibleChanged(oldValue, newValue) {
        this.updateVerticalFill((newValue) ? this.verticalStripLineColor : null);
    }
    onVerticalStrokeColorChanged(oldValue, newValue) {
        if (newValue) {
            if (newValue instanceof Array) {
                this._ios.verticalLineStroke.color = newValue[0].ios;
                if (newValue.length > 1) {
                    this._ios.verticalLineAlternateStroke.color = newValue[1].ios;
                }
                else {
                    this._ios.verticalLineAlternateStroke.color = newValue[0].ios;
                }
            }
            else {
                this._ios.verticalLineStroke.color = newValue.ios;
                this._ios.verticalLineAlternateStroke.color = newValue.ios;
            }
            this.applyGridStyle();
        }
    }
    onHorizontalStrokeColorChanged(oldValue, newValue) {
        if (newValue) {
            if (newValue instanceof Array) {
                this._ios.horizontalLineStroke.color = newValue[0].ios;
                if (newValue.length > 1) {
                    this._ios.horizontalLineAlternateStroke.color = newValue[1].ios;
                }
                else {
                    this._ios.horizontalLineAlternateStroke.color = newValue[0].ios;
                }
            }
            else {
                this._ios.horizontalLineStroke.color = newValue.ios;
                this._ios.horizontalLineAlternateStroke.color = newValue.ios;
            }
            this.applyGridStyle();
        }
    }
    onHorizontalStrokeWidthChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this._ios.horizontalLineStroke.width = newValue;
            this._ios.horizontalLineAlternateStroke.width = newValue;
            this.applyGridStyle();
        }
    }
    onVerticalStrokeWidthChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this._ios.verticalLineStroke.width = newValue;
            this._ios.verticalLineAlternateStroke.width = newValue;
            this.applyGridStyle();
        }
    }
    onVerticalStripLineColorChanged(oldValue, newValue) {
        this.updateVerticalFill(newValue);
    }
    onHorizontalStripLineColorChanged(oldValue, newValue) {
        this.updateHorizontalFill(newValue);
    }
}
//# sourceMappingURL=chart-cartesian-chart-grid.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/misc/chart-event-data.common.js
class ChartEventData {
}
class TrackballSelection {
}
class TrackballCustomContentData extends ChartEventData {
}
//# sourceMappingURL=chart-event-data.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/views/chart-legend-view.common.js


class chart_legend_view_common_RadLegendView extends view["c" /* View */] {
    onTitleSizeChanged(oldValue, newValue) {
    }
    onTitleColorChanged(oldValue, newValue) {
    }
    onEnableSelectionChanged(oldValue, newValue) {
    }
    onPositionPropertyChanged(oldValue, newValue) {
        this.onPositionChanged(oldValue, newValue);
    }
    onPositionChanged(oldValue, newValue) {
    }
    onOffsetOriginPropertyChanged(oldValue, newValue) {
        this.onOffsetOriginChanged(oldValue, newValue);
    }
    onOffsetOriginChanged(oldValue, newValue) {
    }
    onHorizontalOffsetPropertyChanged(oldValue, newValue) {
        this.onHorizontalOffsetChanged(oldValue, newValue);
    }
    onHorizontalOffsetChanged(oldValue, newValue) {
    }
    onVerticalOffsetPropertyChanged(oldValue, newValue) {
        this.onVerticalOffsetChanged(oldValue, newValue);
    }
    onVerticalOffsetChanged(oldValue, newValue) {
    }
    onTitlePropertyChanged(oldValue, newValue) {
        this.onTitleChanged(oldValue, newValue);
    }
    onTitleChanged(oldValue, newValue) {
    }
    updateLegendView(chartView) {
    }
    updateLegendTitle() {
    }
    updateListViewForTheme() {
    }
}
chart_legend_view_common_RadLegendView.titleSizeProperty = new properties["Property"]({
    name: 'titleSize',
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onTitleSizeChanged(oldValue, newValue);
    }
});
chart_legend_view_common_RadLegendView.titleColorProperty = new properties["Property"]({
    name: 'titleColor',
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onTitleColorChanged(oldValue, newValue);
    }
});
chart_legend_view_common_RadLegendView.enableSelectionProperty = new properties["Property"]({
    name: 'enableSelection',
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onEnableSelectionChanged(oldValue, newValue);
    }
});
chart_legend_view_common_RadLegendView.positionProperty = new properties["Property"]({
    name: "position",
    defaultValue: ChartLegendPosition.Bottom,
    valueConverter: (value) => ChartLegendPosition[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onPositionPropertyChanged(oldValue, newValue);
    },
});
chart_legend_view_common_RadLegendView.offsetOriginProperty = new properties["Property"]({
    name: "offsetOrigin",
    defaultValue: ChartLegendOffsetOrigin.TopLeft,
    valueConverter: (value) => ChartLegendOffsetOrigin[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onOffsetOriginPropertyChanged(oldValue, newValue);
    },
});
chart_legend_view_common_RadLegendView.horizontalOffsetProperty = new properties["Property"]({
    name: "horizontalOffset",
    defaultValue: 0,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onHorizontalOffsetPropertyChanged(oldValue, newValue);
    },
});
chart_legend_view_common_RadLegendView.verticalOffsetProperty = new properties["Property"]({
    name: "verticalOffset",
    defaultValue: 0,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onVerticalOffsetPropertyChanged(oldValue, newValue);
    },
});
chart_legend_view_common_RadLegendView.titleProperty = new properties["Property"]({
    name: "title",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onTitlePropertyChanged(oldValue, newValue);
    },
});
chart_legend_view_common_RadLegendView.positionProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.offsetOriginProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.horizontalOffsetProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.verticalOffsetProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.titleProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.titleSizeProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.titleColorProperty.register(chart_legend_view_common_RadLegendView);
chart_legend_view_common_RadLegendView.enableSelectionProperty.register(chart_legend_view_common_RadLegendView);
//# sourceMappingURL=chart-legend-view.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/views/chart-legend-view.js




////////////////////////////////////////////////////////////////////////
// RadLegendView
////////////////////////////////////////////////////////////////////////
class chart_legend_view_RadLegendView extends chart_legend_view_common_RadLegendView {
    [chart_legend_view_common_RadLegendView.positionProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    [chart_legend_view_common_RadLegendView.verticalOffsetProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    [chart_legend_view_common_RadLegendView.horizontalOffsetProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    [chart_legend_view_common_RadLegendView.offsetOriginProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    [chart_legend_view_common_RadLegendView.titleProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    [chart_legend_view_common_RadLegendView.titleSizeProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    [chart_legend_view_common_RadLegendView.titleColorProperty.setNative](newValue) {
        this.updateLegendView(this._chart);
    }
    updateLegendPosition(chartView) {
        if (!this.position) {
            return;
        }
        switch (this.position) {
            case ChartLegendPosition.Left:
                chartView.ios.legend.style.position = 0 /* Left */;
                break;
            case ChartLegendPosition.Right:
                chartView.ios.legend.style.position = 1 /* Right */;
                break;
            case ChartLegendPosition.Top:
                chartView.ios.legend.style.position = 2 /* Top */;
                break;
            case ChartLegendPosition.Bottom:
                chartView.ios.legend.style.position = 3 /* Bottom */;
                break;
            case ChartLegendPosition.Floating:
                chartView.ios.legend.style.position = 4 /* Floating */;
                break;
        }
        if (this.position === ChartLegendPosition.Floating) {
            switch (this.offsetOrigin) {
                case ChartLegendOffsetOrigin.TopLeft:
                    chartView.ios.legend.style.offsetOrigin = 0 /* TopLeft */;
                    break;
                case ChartLegendOffsetOrigin.TopRight:
                    chartView.ios.legend.style.offsetOrigin = 1 /* TopRight */;
                    break;
                case ChartLegendOffsetOrigin.BottomLeft:
                    chartView.ios.legend.style.offsetOrigin = 2 /* BottomLeft */;
                    break;
                case ChartLegendOffsetOrigin.BottomRight:
                    chartView.ios.legend.style.offsetOrigin = 3 /* BottomRight */;
                    break;
                default:
                    chartView.ios.legend.style.offsetOrigin = 0 /* TopLeft */;
            }
            chartView.ios.legend.style.offset = {
                horizontal: (isNaN(this.horizontalOffset)) ? 0 : this.horizontalOffset,
                vertical: (isNaN(this.verticalOffset)) ? 0 : this.verticalOffset
            };
        }
        chartView.ios.setNeedsLayout();
    }
    updateLegendView(chartView) {
        if (!(chartView)) {
            return;
        }
        if (!(chartView instanceof ui_chart_common_RadChartBase)) {
            return;
        }
        if (!this._chart) {
            this._chart = chartView;
        }
        chartView.nativeView.legend.hidden = false;
        if (this.position) {
            this.updateLegendPosition(chartView);
        }
        if (this.title) {
            chartView.nativeView.legend.titleLabel.text = this.title;
            chartView.nativeView.legend.titleLabel.lineBreakMode = 0 /* ByWordWrapping */;
            chartView.nativeView.legend.showTitle = true;
        }
        if (this.titleColor !== undefined) {
            chartView.nativeView.legend.titleLabel.textColor = this.titleColor.ios;
        }
        if (this.titleSize !== undefined && !isNaN(this.titleSize)) {
            let currentFontName = chartView.nativeView.legend.titleLabel.font.fontName;
            let nativeSize = core["Utils"].layout.toDevicePixels(this.titleSize);
            if (currentFontName) {
                chartView.nativeView.legend.titleLabel.font = UIFont.fontWithNameSize(currentFontName, nativeSize);
            }
            else {
                chartView.nativeView.legend.titleLabel.font = UIFont.systemFontOfSize(nativeSize);
            }
        }
        chartView.nativeView.legend.allowSelection = this.enableSelection;
        chartView.updateChart();
    }
}
//# sourceMappingURL=chart-legend-view.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/views/chart-axis.js


////////////////////////////////////////////////////////////////////////
// LinearAxis
////////////////////////////////////////////////////////////////////////
class chart_axis_LinearAxis extends chart_axis_common_LinearAxis {
    constructor() {
        super();
        this._ios = TKChartNumericAxis.new();
        this._ios.offset = 0;
        this._ios.baseline = 0;
    }
    get ios() {
        return this._ios;
    }
    onMajorStepChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this.ios.majorTickInterval = +newValue;
            this.update();
        }
    }
    onMinimumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            const max = this.ios.range ? this.ios.range.maximum : null;
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(numValue, max);
        }
    }
    onMaximumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            const min = this.ios.range ? this.ios.range.minimum : null;
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(min, numValue);
        }
    }
}
////////////////////////////////////////////////////////////////////////
// CategoricalAxis
////////////////////////////////////////////////////////////////////////
class chart_axis_CategoricalAxis extends chart_axis_common_CategoricalAxis {
    constructor() {
        super();
        this._ios = TKChartCategoryAxis.alloc().init();
        this._ios.offset = 0;
        this._ios.baseline = 0;
    }
    get ios() {
        return this._ios;
    }
}
////////////////////////////////////////////////////////////////////////
// DateTimeContinuousAxis
////////////////////////////////////////////////////////////////////////
class chart_axis_DateTimeContinuousAxis extends chart_axis_common_DateTimeContinuousAxis {
    constructor() {
        super();
        this._ios = TKChartDateTimeAxis.new();
        this._ios.majorTickIntervalUnit = 5 /* Months */;
        this._ios.minorTickIntervalUnit = 5 /* Months */;
        this._ios.majorTickInterval = 1;
        this._ios.setPlotMode(1 /* BetweenTicks */);
    }
    get dateFormatter() {
        if (this._dateFormatter) {
            return this._dateFormatter;
        }
        this._dateFormatter = NSDateFormatter.alloc().init();
        // note: currently only this format is supported in xml
        this._dateFormatter.dateFormat = "dd/MM/yyyy";
        return this._dateFormatter;
    }
    get ios() {
        return this._ios;
    }
    onMinimumChanged(oldValue, newValue) {
        if (newValue && this.maximum) {
            this.updateRange();
        }
    }
    onMaximumChanged(oldValue, newValue) {
        if (newValue && this.minimum) {
            this.updateRange();
        }
    }
    updateRange() {
        let minDate = this.minimum;
        if (typeof this.minimum === "string") {
            minDate = this.dateFormatter.dateFromString(this.minimum);
        }
        let maxDate = this.maximum;
        if (typeof this.maximum === "string") {
            maxDate = this.dateFormatter.dateFromString(this.maximum);
        }
        this.ios.range = TKRange.rangeWithMinimumAndMaximum(minDate, maxDate);
        this.update();
    }
    onPlotModeChanged(oldValue, newValue) {
        if (newValue) {
            switch (newValue) {
                case ChartAxisPlotMode.BetweenTicks:
                    this.ios.setPlotMode(1 /* BetweenTicks */);
                    break;
                case ChartAxisPlotMode.OnTicks:
                    this.ios.setPlotMode(0 /* OnTicks */);
                    break;
            }
            this.update();
        }
    }
    onDateFormatChanged(oldValue, newValue) {
        if (newValue) {
            let dateFormatter = NSDateFormatter.alloc().init();
            dateFormatter.dateFormat = newValue;
            this.ios.labelFormatter = dateFormatter;
            this.update();
        }
    }
    onLabelFormatChanged(oldValue, newValue) {
        console.log("WARNING: labelFormat property is not supported for DateTimeContinuousAxis. Use dateFormat instead");
    }
    onMajorStepUnitChanged(oldValue, newValue) {
        if (newValue) {
            // todo: consider minorTickIntervalUnit property value. It is used for financial series and determins the width of candlesticks.
            switch (newValue) {
                case ChartAxisDateTimeComponent.Second:
                    this.ios.majorTickIntervalUnit = 0 /* Seconds */;
                    this.ios.minorTickIntervalUnit = 0 /* Seconds */;
                    break;
                case ChartAxisDateTimeComponent.Minute:
                    this.ios.majorTickIntervalUnit = 1 /* Minutes */;
                    this.ios.minorTickIntervalUnit = 1 /* Minutes */;
                    break;
                case ChartAxisDateTimeComponent.Hour:
                    this.ios.majorTickIntervalUnit = 2 /* Hours */;
                    this.ios.minorTickIntervalUnit = 2 /* Hours */;
                    break;
                case ChartAxisDateTimeComponent.Day:
                    this.ios.majorTickIntervalUnit = 3 /* Days */;
                    this.ios.minorTickIntervalUnit = 3 /* Days */;
                    break;
                case ChartAxisDateTimeComponent.Week:
                    this.ios.majorTickIntervalUnit = 4 /* Weeks */;
                    this.ios.minorTickIntervalUnit = 4 /* Weeks */;
                    break;
                case ChartAxisDateTimeComponent.Month:
                    this.ios.majorTickIntervalUnit = 5 /* Months */;
                    this.ios.minorTickIntervalUnit = 5 /* Months */;
                    break;
                case ChartAxisDateTimeComponent.Year:
                    this.ios.majorTickIntervalUnit = 6 /* Years */;
                    this.ios.minorTickIntervalUnit = 6 /* Years */;
                    break;
            }
            this.update();
        }
    }
    onMajorStepChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this.ios.majorTickInterval = +newValue;
            this.update();
        }
    }
}
////////////////////////////////////////////////////////////////////////
// DateTimeCategoricalAxis
////////////////////////////////////////////////////////////////////////
class chart_axis_DateTimeCategoricalAxis extends chart_axis_common_DateTimeCategoricalAxis {
    constructor() {
        super();
        this._ios = TKChartDateTimeCategoryAxis.new();
    }
    get ios() {
        return this._ios;
    }
    onDateFormatChanged(oldValue, newValue) {
        if (newValue) {
            let dateFormatter = NSDateFormatter.alloc().init();
            dateFormatter.dateFormat = newValue;
            this.ios.labelFormatter = dateFormatter;
            this.update();
        }
    }
    onLabelFormatChanged(oldValue, newValue) {
        console.log("WARNING: labelFormat property is not supported for DateTimeCategoricalAxis. Use dateFormat instead.");
    }
    onDateTimeComponentChanged(oldValue, newValue) {
        if (newValue) {
            switch (newValue) {
                case ChartAxisDateTimeComponent.Second:
                    this.ios.dateComponent = 128 /* SecondCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Minute:
                    this.ios.dateComponent = 64 /* MinuteCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Hour:
                    this.ios.dateComponent = 32 /* HourCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Day:
                    this.ios.dateComponent = 16 /* DayCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Week:
                    this.ios.dateComponent = 4096 /* WeekOfMonthCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Month:
                    this.ios.dateComponent = 8 /* MonthCalendarUnit */;
                    break;
                case ChartAxisDateTimeComponent.Year:
                    this.ios.dateComponent = 4 /* YearCalendarUnit */;
                    break;
            }
            this.update();
        }
    }
}
////////////////////////////////////////////////////////////////////////
// LogarithmicAxis
////////////////////////////////////////////////////////////////////////
class chart_axis_LogarithmicAxis extends chart_axis_common_LogarithmicAxis {
    constructor() {
        super();
        this._ios = TKChartLogarithmicAxis.new();
    }
    get ios() {
        return this._ios;
    }
    onExponentStepChanged(oldValue, newValue) {
        if (!isNaN(+newValue) && newValue > 0) {
            this._ios.exponentStep = newValue;
            this.update();
        }
    }
    onLogarithmBaseChanged(oldValue, newValue) {
        if (!isNaN(newValue)) {
            this._ios.logarithmBase = newValue;
            this.update();
        }
    }
    onMajorStepChanged(oldValue, newValue) {
        console.log("WARNING: majorStep property is not used for LogarithmicAxis. Use exponentStep property instead.");
    }
    onMinimumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            if (this.ios.range) {
                this.ios.range.minimum = numValue;
            }
            else {
                this.ios.range = TKRange.rangeWithMinimumAndMaximum(numValue, null);
            }
            this.update();
        }
    }
    onMaximumChanged(oldValue, newValue) {
        const numValue = +newValue;
        if (!isNaN(numValue)) {
            if (this.ios.range) {
                this.ios.range.maximum = numValue;
            }
            else {
                this.ios.range = TKRange.rangeWithMinimumAndMaximum(null, numValue);
            }
            this.update();
        }
    }
}
//# sourceMappingURL=chart-axis.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-palette.common.js


class chart_palette_common_Palette extends view_base["ViewBase"] {
    constructor() {
        super();
        this.entries = new observable_array["ObservableArray"]();
    }
    _addArrayFromBuilder(name, value) {
        if (name === "entries") {
            this.entries = new observable_array["ObservableArray"](value);
            for (let i = 0; i < this.entries.length; i++) {
                this.entries.getItem(i).ownerPalette = this;
            }
        }
    }
    onEntriesPropertyChanged(oldValue, newValue) {
        this.onEntriesChanged(oldValue, newValue);
    }
    onEntriesChanged(oldValue, newValue) {
        if (oldValue instanceof observable["Observable"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, this.entriesCollectionChangedInternal, this);
        }
        if (newValue instanceof observable["Observable"]) {
            const collection = newValue;
            if (collection.length >= 0) {
                for (let i = 0; i < collection.length; i++) {
                    this.entries.getItem(i).ownerPalette = this;
                }
                this.updateOwner();
            }
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, this.entriesCollectionChangedInternal, this);
        }
    }
    entriesCollectionChangedInternal(data) {
        if (data.eventName && data.eventName.toLowerCase() === "change") {
            if (data.action && data.action.toLowerCase() === "add") {
                for (let i = 0; i < data.addedCount; i++) {
                    this.entries.getItem(data.index).ownerPalette = this;
                }
            }
        }
        this.updateOwner();
    }
    seriesNamePropertyChanged(oldValue, newValue) {
        this.onSeriesNamePropertyChanged(oldValue, newValue);
    }
    onSeriesNamePropertyChanged(oldValue, newValue) {
        this.updateOwner();
    }
    seriesStatePropertyChanged(oldValue, newValue) {
        this.onSeriesStatePropertyChanged(oldValue, newValue);
    }
    onSeriesStatePropertyChanged(oldValue, newValue) {
        this.updateOwner();
    }
    updateOwner() {
        if (this.owner && this.owner.reloadPalettes) {
            this.owner.reloadPalettes();
        }
    }
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
    }
}
chart_palette_common_Palette.entriesProperty = new properties["Property"]({
    name: "entries",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onEntriesPropertyChanged(oldValue, newValue);
    },
});
chart_palette_common_Palette.seriesNameProperty = new properties["Property"]({
    name: "seriesName",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.seriesNamePropertyChanged(oldValue, newValue);
    },
});
chart_palette_common_Palette.seriesStateProperty = new properties["Property"]({
    name: "seriesState",
    defaultValue: undefined,
    valueConverter: (value) => ChartPaletteSeriesState[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.seriesStatePropertyChanged(oldValue, newValue);
    },
});
chart_palette_common_Palette.entriesProperty.register(chart_palette_common_Palette);
chart_palette_common_Palette.seriesNameProperty.register(chart_palette_common_Palette);
chart_palette_common_Palette.seriesStateProperty.register(chart_palette_common_Palette);
class chart_palette_common_PaletteEntry extends view_base["ViewBase"] {
    fillColorPropertyChanged(oldValue, newValue) {
        this.onFillColorChanged(oldValue, newValue);
    }
    strokeWidthPropertyChanged(oldValue, newValue) {
        this.onStrokeWidthChanged(oldValue, newValue);
    }
    strokeColorPropertyChanged(oldValue, newValue) {
        this.onStrokeColorChanged(oldValue, newValue);
    }
    onFillColorChanged(oldValue, newValue) {
        this.updateOwner();
    }
    onStrokeWidthChanged(oldValue, newValue) {
        this.updateOwner();
    }
    onStrokeColorChanged(oldValue, newValue) {
        this.updateOwner();
    }
    updateOwner() {
        if (this.ownerPalette && this.ownerPalette.owner && this.ownerPalette.owner.reloadPalettes) {
            this.ownerPalette.owner.reloadPalettes();
        }
    }
    get ownerPalette() {
        return this._owner;
    }
    set ownerPalette(value) {
        this._owner = value;
    }
}
chart_palette_common_PaletteEntry.fillColorProperty = new properties["Property"]({
    name: "fillColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.fillColorPropertyChanged(oldValue, newValue);
    },
});
chart_palette_common_PaletteEntry.strokeWidthProperty = new properties["Property"]({
    name: "strokeWidth",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.strokeWidthPropertyChanged(oldValue, newValue);
    },
});
chart_palette_common_PaletteEntry.strokeColorProperty = new properties["Property"]({
    name: "strokeColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.strokeColorPropertyChanged(oldValue, newValue);
    },
});
chart_palette_common_PaletteEntry.fillColorProperty.register(chart_palette_common_PaletteEntry);
chart_palette_common_PaletteEntry.strokeWidthProperty.register(chart_palette_common_PaletteEntry);
chart_palette_common_PaletteEntry.strokeColorProperty.register(chart_palette_common_PaletteEntry);
//# sourceMappingURL=chart-palette.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-annotation.common.js


class chart_annotation_common_CartesianChartAnnotation extends view_base["ViewBase"] {
    onAxisIdPropertyChanged(oldValue, newValue) {
        this.onAxisIdChanged(oldValue, newValue);
    }
    onZPositionPropertyChanged(oldValue, newValue) {
        this.onZPositionChanged(oldValue, newValue);
    }
    onHiddenPropertyChanged(oldValue, newValue) {
        this.onHiddenChanged(oldValue, newValue);
    }
    onStrokeWidthPropertyChanged(oldValue, newValue) {
        this.onStrokeWidthChanged(oldValue, newValue);
    }
    onStrokeColorPropertyChanged(oldValue, newValue) {
        this.onStrokeColorChanged(oldValue, newValue);
    }
    onStrokeDashPatternPropertyChanged(oldValue, newValue) {
        this.onStrokeDashPatternChanged(oldValue, newValue);
    }
    onAxisIdChanged(oldValue, newValue) {
    }
    onZPositionChanged(oldValue, newValue) {
    }
    onHiddenChanged(oldValue, newValue) {
    }
    onStrokeWidthChanged(oldValue, newValue) {
    }
    onStrokeColorChanged(oldValue, newValue) {
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
    }
    onOwnerChanged() {
    }
    get owner() {
        return this._owner;
    }
    set owner(value) {
        this._owner = value;
        this.onOwnerChanged();
    }
}
chart_annotation_common_CartesianChartAnnotation.axisIdProperty = new properties["Property"]({
    name: "axisId",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onAxisIdPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_CartesianChartAnnotation.zPositionProperty = new properties["Property"]({
    name: "zPosition",
    defaultValue: undefined,
    valueConverter: (value) => ChartAnnotationZPosition[toPascalCase(value)],
    valueChanged: (target, oldValue, newValue) => {
        target.onZPositionPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_CartesianChartAnnotation.hiddenProperty = new properties["Property"]({
    name: "hidden",
    defaultValue: undefined,
    valueConverter: view_base["booleanConverter"],
    valueChanged: (target, oldValue, newValue) => {
        target.onHiddenPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_CartesianChartAnnotation.strokeWidthProperty = new properties["Property"]({
    name: "strokeWidth",
    defaultValue: undefined,
    valueConverter: parseFloat,
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeWidthPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_CartesianChartAnnotation.strokeColorProperty = new properties["Property"]({
    name: "strokeColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeColorPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_CartesianChartAnnotation.strokeDashPatternProperty = new properties["Property"]({
    name: "strokeDashPattern",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onStrokeDashPatternPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_CartesianChartAnnotation.axisIdProperty.register(chart_annotation_common_CartesianChartAnnotation);
chart_annotation_common_CartesianChartAnnotation.zPositionProperty.register(chart_annotation_common_CartesianChartAnnotation);
chart_annotation_common_CartesianChartAnnotation.hiddenProperty.register(chart_annotation_common_CartesianChartAnnotation);
chart_annotation_common_CartesianChartAnnotation.strokeWidthProperty.register(chart_annotation_common_CartesianChartAnnotation);
chart_annotation_common_CartesianChartAnnotation.strokeColorProperty.register(chart_annotation_common_CartesianChartAnnotation);
chart_annotation_common_CartesianChartAnnotation.strokeDashPatternProperty.register(chart_annotation_common_CartesianChartAnnotation);
class chart_annotation_common_ChartGridLineAnnotation extends chart_annotation_common_CartesianChartAnnotation {
    onValuePropertyChanged(oldValue, newValue) {
        this.onValueChanged(oldValue, newValue);
    }
    onValueChanged(oldValue, newValue) {
    }
}
chart_annotation_common_ChartGridLineAnnotation.valueProperty = new properties["Property"]({
    name: "value",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onValuePropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_ChartGridLineAnnotation.valueProperty.register(chart_annotation_common_ChartGridLineAnnotation);
class chart_annotation_common_ChartPlotBandAnnotation extends chart_annotation_common_CartesianChartAnnotation {
    onMinValuePropertyChanged(oldValue, newValue) {
        this.onMinValueChanged(oldValue, newValue);
    }
    onMaxValuePropertyChanged(oldValue, newValue) {
        this.onMaxValueChanged(oldValue, newValue);
    }
    onFillColorPropertyChanged(oldValue, newValue) {
        this.onFillColorChanged(oldValue, newValue);
    }
    onMinValueChanged(oldValue, newValue) {
    }
    onMaxValueChanged(oldValue, newValue) {
    }
    onFillColorChanged(oldValue, newValue) {
    }
}
chart_annotation_common_ChartPlotBandAnnotation.minValueProperty = new properties["Property"]({
    name: "minValue",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMinValuePropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_ChartPlotBandAnnotation.maxValueProperty = new properties["Property"]({
    name: "maxValue",
    defaultValue: undefined,
    valueChanged: (target, oldValue, newValue) => {
        target.onMaxValuePropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_ChartPlotBandAnnotation.fillColorProperty = new properties["Property"]({
    name: "fillColor",
    defaultValue: undefined,
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
    valueChanged: (target, oldValue, newValue) => {
        target.onFillColorPropertyChanged(oldValue, newValue);
    },
});
chart_annotation_common_ChartPlotBandAnnotation.minValueProperty.register(chart_annotation_common_ChartPlotBandAnnotation);
chart_annotation_common_ChartPlotBandAnnotation.maxValueProperty.register(chart_annotation_common_ChartPlotBandAnnotation);
chart_annotation_common_ChartPlotBandAnnotation.fillColorProperty.register(chart_annotation_common_ChartPlotBandAnnotation);
//# sourceMappingURL=chart-annotation.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-annotation.js



class chart_annotation_ChartGridLineAnnotation extends chart_annotation_common_ChartGridLineAnnotation {
    constructor() {
        super();
        this._ios = TKChartGridLineAnnotation.new();
        this._ios.style.stroke = TKStroke.strokeWithColor(new core_color["a" /* Color */]("Black").ios);
    }
    get ios() {
        return this._ios;
    }
    update() {
        if (this.owner && this.owner.nativeView) {
            this.owner.nativeView.updateAnnotations();
        }
    }
    onOwnerChanged() {
        if (!this.axisId) {
            console.log("WARNING: axisId property is mandatory for any annotation.");
            return;
        }
        if (!this.owner) {
            return;
        }
        let forAxis = this.owner.getAxisByID(this.axisId);
        if (forAxis) {
            this._ios.axis = forAxis.ios;
        }
        this.update();
    }
    onValueChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.value = newValue;
            this.update();
        }
    }
    onAxisIdChanged(oldValue, newValue) {
        if (newValue && this.owner) {
            let forAxis = this.owner.getAxisByID(this.axisId);
            if (forAxis) {
                this._ios.axis = forAxis.ios;
                this.update();
            }
        }
    }
    onZPositionChanged(oldValue, newValue) {
        switch (newValue) {
            case ChartAnnotationZPosition.BelowSeries:
                this._ios.zPosition = 0 /* BelowSeries */;
                break;
            case ChartAnnotationZPosition.AboveSeries:
                this._ios.zPosition = 1 /* AboveSeries */;
                break;
        }
    }
    onHiddenChanged(oldValue, newValue) {
        this._ios.hidden = newValue;
        this.update();
    }
    onStrokeWidthChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this._ios.style.stroke.width = core["Utils"].layout.toDeviceIndependentPixels(newValue);
            this.update();
        }
    }
    onStrokeColorChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.style.stroke.color = newValue.ios;
            this.update();
        }
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
        if (newValue) {
            let array = JSON.parse("[" + newValue + "]");
            if (array instanceof Array) {
                let nativeSource = NSMutableArray.new();
                let item, name, value;
                for (let i = 0; i < array.length; i++) {
                    item = array[i];
                    nativeSource.addObject(item);
                }
                this._ios.style.stroke.dashPattern = nativeSource;
                this.update();
            }
        }
    }
}
class chart_annotation_ChartPlotBandAnnotation extends chart_annotation_common_ChartPlotBandAnnotation {
    constructor() {
        super();
        this._ios = TKChartBandAnnotation.new();
        this._ios.style.stroke = TKStroke.strokeWithColor(new core_color["a" /* Color */]("Black").ios);
    }
    get ios() {
        return this._ios;
    }
    update() {
        if (this.owner && this.owner.nativeView) {
            this.owner.nativeView.updateAnnotations();
        }
    }
    onOwnerChanged() {
        if (!this.axisId) {
            console.log("WARNING: axisId property is mandatory for any annotation.");
            return;
        }
        if (!this.owner) {
            return;
        }
        let forAxis = this.owner.getAxisByID(this.axisId);
        if (forAxis) {
            this._ios.axis = forAxis.ios;
            this.update();
        }
    }
    onMinValueChanged(oldValue, newValue) {
        if (this.ios.range) {
            this.ios.range.minimum = newValue;
        }
        else {
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(newValue, (this.maxValue !== undefined) ? this.maxValue : newValue);
        }
        this.update();
    }
    onMaxValueChanged(oldValue, newValue) {
        if (this.ios.range) {
            this.ios.range.maximum = newValue;
        }
        else {
            this.ios.range = TKRange.rangeWithMinimumAndMaximum((this.minValue !== undefined) ? this.minValue : newValue, newValue);
        }
        this.update();
    }
    onFillColorChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.style.fill = TKSolidFill.solidFillWithColor(newValue.ios);
            this.update();
        }
    }
    onAxisIdChanged(oldValue, newValue) {
        if (newValue && this.owner) {
            let forAxis = this.owner.getAxisByID(this.axisId);
            if (forAxis) {
                this._ios.axis = forAxis.ios;
                this.update();
            }
        }
    }
    onZPositionChanged(oldValue, newValue) {
        if (newValue) {
            switch (newValue) {
                case ChartAnnotationZPosition.BelowSeries:
                    this._ios.zPosition = 0 /* BelowSeries */;
                    break;
                case ChartAnnotationZPosition.AboveSeries:
                    this._ios.zPosition = 1 /* AboveSeries */;
                    break;
            }
            this.update();
        }
    }
    onHiddenChanged(oldValue, newValue) {
        this._ios.hidden = newValue;
        this.update();
    }
    onStrokeWidthChanged(oldValue, newValue) {
        if (!isNaN(+newValue)) {
            this._ios.style.stroke.width = newValue;
            this.update();
        }
    }
    onStrokeColorChanged(oldValue, newValue) {
        if (newValue) {
            this._ios.style.stroke.color = newValue.ios;
            this.update();
        }
    }
    onStrokeDashPatternChanged(oldValue, newValue) {
        if (newValue) {
            let array = JSON.parse("[" + newValue + "]");
            if (array instanceof Array) {
                let nativeSource = NSMutableArray.new();
                let item, name, value;
                for (let i = 0; i < array.length; i++) {
                    item = array[i];
                    nativeSource.addObject(item);
                }
                this._ios.style.stroke.dashPattern = nativeSource;
                this.update();
            }
        }
    }
}
//# sourceMappingURL=chart-annotation.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/visualization/parts/chart-track-ball.js


class chart_track_ball_Trackball extends chart_track_ball_common_Trackball {
    // private _ios: TKChartTrackball;
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
        this.updateNativeSnapMode(this.snapMode);
        this.updateShowIntersectionPoints(this.showIntersectionPoints);
    }
    constructor() {
        super();
    }
    onSnapModeChanged(oldValue, newValue) {
        if (!this._ios) {
            return;
        }
        if (newValue) {
            this.updateNativeSnapMode(newValue);
        }
    }
    onShowIntersectionPointsChanged(oldValue, newValue) {
        if (!this._ios) {
            return;
        }
        if (newValue) {
            this.updateShowIntersectionPoints(newValue);
        }
    }
    updateShowIntersectionPoints(value) {
        if (value) {
            this.ios.line.style.pointShape.size = CGSizeMake(4, 4);
        }
        else {
            this.ios.line.style.pointShape.size = CGSizeZero;
        }
    }
    updateNativeSnapMode(snapMode) {
        if (snapMode === ChartTrackballSnapMode.ClosestPoint) {
            this.ios.snapMode = 0 /* ClosestPoint */;
        }
        else if (snapMode === ChartTrackballSnapMode.AllClosestPoints) {
            this.ios.snapMode = 1 /* AllClosestPoints */;
        }
    }
}
//# sourceMappingURL=chart-track-ball.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/nativescript-ui-chart/ui-chart.js


















var ui_chart_ChartDelegateImpl = /** @class */ (function (_super) {
    __extends(ChartDelegateImpl, _super);
    function ChartDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ChartDelegateImpl.new = function () {
        return _super.new.call(this);
    };
    ChartDelegateImpl.prototype.initWithOwner = function (owner) {
        this._owner = owner;
        return this;
    };
    ChartDelegateImpl.prototype.chartTrackballLabelForDatapointInSeries = function (chart, point, series) {
        if (this._owner instanceof ui_chart_common_RadCartesianChart) {
            var cartesianChart = this._owner;
            if (cartesianChart.trackball) {
                var chartSeries = this._owner.series.getItem ? this._owner.series.getItem(series.index) : this._owner.series[series.index];
                var pointIndex = series.items.indexOfObject(point);
                var eventData = {
                    object: cartesianChart.trackball,
                    eventName: chart_track_ball_common_Trackball.trackBallContentRequestedEvent,
                    pointIndex: pointIndex,
                    seriesIndex: series.index,
                    series: chartSeries,
                    pointData: chartSeries.getItemAtIndex(pointIndex),
                    content: undefined
                };
                cartesianChart.trackball.notify(eventData);
                return eventData.content;
            }
        }
        return undefined;
    };
    ChartDelegateImpl.prototype.chartDidSelectSeries = function (chart, series) {
        var selectedSeries = null;
        for (var i = 0; i < this._owner.series.length; i++) {
            if (this._owner.series.getItem(i).ios.index === series.index) {
                selectedSeries = this._owner.series.getItem(i);
                break;
            }
        }
        var args = {
            eventName: ui_chart_common_RadChartBase.seriesSelectedEvent,
            object: this._owner,
            series: selectedSeries,
            pointIndex: null,
            pointData: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidDeselectSeries = function (chart, series) {
        var deselectedSeries = null;
        for (var i = 0; i < this._owner.series.length; i++) {
            if (this._owner.series.getItem(i).ios.index === series.index) {
                deselectedSeries = this._owner.series.getItem(i);
                break;
            }
        }
        var args = {
            eventName: ui_chart_common_RadChartBase.seriesDeselectedEvent,
            object: this._owner,
            series: deselectedSeries,
            pointIndex: null,
            pointData: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidSelectPointInSeriesAtIndex = function (chart, point, series, index) {
        var args = {
            eventName: ui_chart_common_RadChartBase.pointSelectedEvent,
            object: this._owner,
            series: series,
            pointIndex: index,
            pointData: point
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidDeselectPointInSeriesAtIndex = function (chart, point, series, index) {
        var args = {
            eventName: ui_chart_common_RadChartBase.pointDeselectedEvent,
            object: this._owner,
            series: series,
            pointIndex: index,
            pointData: point
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidZoom = function (chart) {
        var args = {
            eventName: ui_chart_common_RadChartBase.chartZoomedEvent,
            object: this._owner,
            pointData: null,
            pointIndex: null,
            series: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidPan = function (chart) {
        var args = {
            eventName: ui_chart_common_RadChartBase.chartPannedEvent,
            object: this._owner,
            pointData: null,
            pointIndex: null,
            series: null
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartTrackballDidTrackSelection = function (chart, selection) {
        var args = {
            eventName: ui_chart_common_RadChartBase.trackballTrackedSelectionEvent,
            object: this._owner,
            selection: selection
        };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartPaletteItemForSeriesAtIndex = function (chart, series, index) {
        var paletteIndex = index;
        if (series.style.paletteMode === TKChartSeriesStylePaletteMode.UseSeriesIndex) {
            var seriesName = this._owner.series.getItem(series.index).seriesName;
            paletteIndex = this._owner.findConsequentIndexOfSeries(seriesName, series.index);
        }
        // check and return palette items if any for SELECTED state from top to low priority of property values
        if (series.isSelected &&
            (TKChartSeriesSelection.Series === series.selection ||
                TKChartSelectionMode.None !== chart.seriesSelectionMode)) {
            return this._owner.getPaletteItemWithIndexForStateOfSeries("selected", paletteIndex, series.tag);
        }
        if (series.pointIsSelected(index) &&
            (TKChartSeriesSelection.DataPoint === series.selection ||
                TKChartSeriesSelection.DataPointMultiple === series.selection)) {
            if (this._owner instanceof ui_chart_RadPieChart) {
                if (this._owner.chartSelectionPalette) {
                    return this._owner.chartSelectionPalette.items[paletteIndex % this._owner.chartSelectionPalette.items.count];
                }
                else {
                    return null;
                }
            }
            return this._owner.getPaletteItemWithIndexForStateOfSeries("selected", paletteIndex, series.tag);
        }
        // check and return palette items if any for NORMAL state
        var retVal = null;
        if (this._owner instanceof ui_chart_RadPieChart) {
            retVal = (this._owner.chartPalette) ? this._owner.chartPalette.items[paletteIndex % this._owner.chartPalette.items.count] : null;
        }
        else {
            retVal = this._owner.getPaletteItemWithIndexForStateOfSeries("normal", paletteIndex, series.tag);
        }
        return retVal;
    };
    ChartDelegateImpl.ObjCProtocols = [TKChartDelegate];
    return ChartDelegateImpl;
}(NSObject));
class ui_chart_RadPieChart extends ui_chart_common_RadPieChart {
    constructor() {
        super();
        this._loaded = false;
        this._ios = TKChart.new();
        this._ios.dataPointSelectionMode = 0 /* None */;
        this._ios.seriesSelectionMode = 0 /* None */;
        this._delegate = ui_chart_ChartDelegateImpl.new().initWithOwner(this);
        this._ios.allowAnimations = true;
    }
    get _nativeView() {
        return this._ios;
    }
    addSeries(newSeries) {
        this._nativeView.removeAllData();
        this._nativeView.addSeries(newSeries);
        if (this.palettes) {
            this.loadPalette(this.palettes);
        }
        if (this.chartPalette) {
            this.series.getItem(0).ios.style.paletteMode = 1 /* UseItemIndex */;
            this._nativeView.legend.update();
        }
    }
    createNativeView() {
        return this._nativeView;
    }
    initNativeView() {
        super.initNativeView();
        this.updateLegend();
    }
    updateChart() {
        if (this._loaded) {
            this._nativeView.update();
        }
    }
    updateLegend() {
        if (this._loaded && this.legend) {
            this.legend.updateLegendView(this);
        }
    }
    onLoaded() {
        super.onLoaded();
        this._ios.delegate = this._delegate;
        this._loaded = true;
        this.updateLegend();
    }
    onUnloaded() {
        super.onUnloaded();
        this._ios.delegate = null;
        this._loaded = false;
    }
    [ui_chart_common_RadChartBase.legendProperty.setNative](newValue) {
        this.updateLegend();
    }
    onSeriesChanged(oldValue, newValue) {
        super.onSeriesChanged(oldValue, newValue);
        if (oldValue) {
            for (let i = 0; i < oldValue.length; ++i) {
                oldValue[i].owner = undefined;
                this._removeView(oldValue[i]);
            }
        }
        if (this.series) {
            for (let i = 0; i < this.series.length; ++i) {
                this.series.getItem(i).owner = this;
                this._addView(this.series.getItem(i));
                if (this.series.getItem(i).ios) {
                    // if this is not a series instance from xml we must add it
                    this.addSeries(this.series.getItem(i).ios);
                }
            }
        }
        this.updateChart();
    }
    onPalettesChanged(oldValue, newValue) {
        super.onPalettesChanged(oldValue, newValue);
        if (newValue instanceof observable_array["ObservableArray"]) {
            let newPalettes = newValue;
            for (let i = 0; i < newPalettes.length; ++i) {
                newPalettes.getItem(i).owner = this;
            }
        }
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    reloadPalettes() {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    loadPalette(newPalettes) {
        if (!this._nativeView || !this.series) {
            return;
        }
        if (newPalettes) {
            for (let i = 0; i < this.series.length; ++i) {
                let palettesForSeries = this.getPalettesForSeries(newPalettes, this.series.getItem(i));
                if (palettesForSeries.length > 0) {
                    this.applyPalettesToSeries(palettesForSeries, this.series.getItem(i));
                }
            }
        }
    }
    PalettesCollectionChangedInternal(data) {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    getPalettesForSeries(source, series) {
        const palettes = [];
        for (let i = 0; i < source.length; i++) {
            let palette = source.getItem(i);
            if (palette.seriesName === series[seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    }
    applyPalettesToSeries(palette, series) {
        if (!series.ios) {
            return;
        }
        let selectionPalette, normalPalette;
        for (let i = 0; i < palette.length; ++i) {
            if (palette[i].seriesState === ChartPaletteSeriesState.Selected) {
                selectionPalette = palette[i];
            }
            else {
                normalPalette = palette[i];
            }
        }
        this.chartPalette = (normalPalette) ? this.buildNativePaletteForSeries(normalPalette, series) : null;
        this.chartSelectionPalette = (selectionPalette) ? this.buildNativePaletteForSeries(selectionPalette, series) : null;
        if (this.chartPalette && this.series && this.series.length > 0) {
            this.series.getItem(0).ios.style.paletteMode = 1 /* UseItemIndex */;
            this._nativeView.legend.update();
        }
    }
    buildNativePaletteForSeries(palette, series) {
        let seriesPalette = TKChartPalette.new();
        let paletteEntry;
        let currentPaletteEntry;
        for (let i = 0; i < palette.entries.length; ++i) {
            currentPaletteEntry = (series.ios.style.palette) ? series.ios.style.palette.items[i % series.ios.style.palette.itemsCount] : null;
            paletteEntry = palette.entries.getItem(i);
            let stroke = TKStroke.new();
            if (!isNaN(paletteEntry.strokeWidth)) {
                stroke.width = paletteEntry.strokeWidth;
            }
            else {
                stroke.width = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.width : 2;
            }
            if (paletteEntry.strokeColor) {
                stroke.color = paletteEntry.strokeColor.ios;
            }
            else {
                stroke.color = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.color : (new core_color["a" /* Color */]("Black")).ios;
            }
            let solidFill = TKSolidFill.new();
            if (paletteEntry.fillColor) {
                solidFill.color = paletteEntry.fillColor.ios;
            }
            else {
                solidFill.color = (currentPaletteEntry && currentPaletteEntry.fill) ? currentPaletteEntry.fill.color : (new core_color["a" /* Color */]("Blue")).ios;
            }
            seriesPalette.addPaletteItem(TKChartPaletteItem.paletteItemWithStrokeAndFill(stroke, solidFill));
        }
        return seriesPalette;
    }
    onSeriesSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (newValue) {
            if (ChartSelectionMode.Single === newValue) {
                this._nativeView.seriesSelectionMode = 1 /* Single */;
            }
            else if (ChartSelectionMode.Multiple === newValue) {
                this._nativeView.seriesSelectionMode = 2 /* Multiple */;
            }
            else if (ChartSelectionMode.None === newValue) {
                this._nativeView.seriesSelectionMode = 0 /* None */;
            }
        }
    }
    onPointSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (newValue) {
            if (ChartSelectionMode.Single === newValue) {
                this._nativeView.dataPointSelectionMode = 1 /* Single */;
            }
            else if (ChartSelectionMode.Multiple === newValue) {
                this._nativeView.dataPointSelectionMode = 2 /* Multiple */;
            }
            else if (ChartSelectionMode.None === newValue) {
                this._nativeView.dataPointSelectionMode = 0 /* None */;
            }
        }
    }
    onAllowAnimationsChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        this._nativeView.allowAnimations = newValue;
    }
}
class ui_chart_RadCartesianChart extends ui_chart_common_RadCartesianChart {
    constructor() {
        super();
        this._ios = TKChart.new();
        this._ios.dataPointSelectionMode = 0 /* None */;
        this._ios.seriesSelectionMode = 0 /* None */;
        this._ios.allowAnimations = true;
        this._delegate = ui_chart_ChartDelegateImpl.new().initWithOwner(this);
        this._chartNormalPalettesMap = new Map();
        this._chartSelectionPalettesMap = new Map();
    }
    get _nativeView() {
        return this._ios;
    }
    createNativeView() {
        this._ngKey = Object.keys(this).find(key => key.startsWith('_ngcontent'));
        this._vueKey = Object.keys(this).find(key => key.startsWith('data-v'));
        return this._nativeView;
    }
    initNativeView() {
        super.initNativeView();
    }
    onLoaded() {
        super.onLoaded();
        this._ios.delegate = this._delegate;
        this._loaded = true;
        this.updateLegend();
    }
    onUnloaded() {
        super.onUnloaded();
        this._ios.delegate = null;
        this._loaded = false;
    }
    [ui_chart_common_RadCartesianChart.horizontalAxisProperty.setNative](value) {
        this.updateNativeHorizontalAxis(this.horizontalAxis.ios, this.horizontalAxis);
    }
    [ui_chart_common_RadCartesianChart.verticalAxisProperty.setNative](value) {
        this.updateNativeVerticalAxis(this.verticalAxis.ios, this.verticalAxis);
    }
    updateChart() {
        if (this._loaded) {
            this._nativeView.update();
        }
    }
    updateLegend() {
        if (this._loaded && this.legend) {
            this.legend.updateLegendView(this);
        }
    }
    reloadPalettes() {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    [ui_chart_common_RadChartBase.legendProperty.setNative](newValue) {
        this.updateLegend();
    }
    SeriesCollectionChangedInternal(data) {
        let curSeries;
        for (let i = 0; i < this.series.length; ++i) {
            curSeries = this.series.getItem(i);
            curSeries.owner = this;
            // in case of bar series we need to recreate the ios instance according to the owner structure
            if (curSeries instanceof chart_series_BarSeries || curSeries instanceof chart_series_RangeBarSeries) {
                curSeries['updateNative']();
            }
        }
        this.loadChart();
    }
    onSeriesChanged(oldValue, newValue) {
        super.onSeriesChanged(oldValue, newValue);
        if (oldValue) {
            for (let i = 0; i < oldValue.length; ++i) {
                oldValue.getItem(i).owner = undefined;
                this._removeView(oldValue.getItem(i));
            }
        }
        if (this.series) {
            let curSeries;
            for (let i = 0; i < this.series.length; ++i) {
                curSeries = this.series.getItem(i);
                curSeries.owner = this;
                this._addView(curSeries);
                // in case of bar series we need to recreate the ios instance according to the owner structure
                if (curSeries instanceof chart_series_BarSeries || curSeries instanceof chart_series_RangeBarSeries) {
                    curSeries['updateNative']();
                }
            }
        }
        this.loadChart();
    }
    addSeries(newSeries) {
        this.loadChart();
    }
    getAxisByID(axisID) {
        if (this.horizontalAxis && this.horizontalAxis.id === axisID) {
            return this.horizontalAxis;
        }
        if (this.verticalAxis && this.verticalAxis.id === axisID) {
            return this.verticalAxis;
        }
        if (this.series) {
            let axes;
            for (let i = 0; i < this.series.length; ++i) {
                axes = this.series.getItem(i).horizontalAxis;
                if (axes && axes.id === axisID) {
                    return axes;
                }
                axes = this.series.getItem(i).verticalAxis;
                if (axes && axes.id === axisID) {
                    return axes;
                }
            }
        }
        return null;
    }
    [style_properties["paddingLeftProperty"].getDefault]() {
        return this._ios.insets.left;
    }
    [style_properties["paddingLeftProperty"].setNative](value) {
        let borderLeft = isNaN(+this.style.borderLeftWidth) ? 0 : +this.style.borderLeftWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: value + borderLeft,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [style_properties["borderLeftWidthProperty"].getDefault]() {
        return 0;
    }
    [style_properties["borderLeftWidthProperty"].setNative](value) {
        let paddingLeft = isNaN(+this.style.paddingLeft) ? 0 : +this.style.paddingLeft;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: value + paddingLeft,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [style_properties["paddingTopProperty"].getDefault]() {
        return this._ios.insets.top;
    }
    [style_properties["paddingTopProperty"].setNative](value) {
        let borderTop = isNaN(+this.style.borderTopWidth) ? 0 : +this.style.borderTopWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: value + borderTop,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [style_properties["borderTopWidthProperty"].getDefault]() {
        return 0;
    }
    [style_properties["borderTopWidthProperty"].setNative](value) {
        let paddingTop = isNaN(+this.style.paddingTop) ? 0 : +this.style.paddingTop;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: value + paddingTop,
            right: currentInsets.right,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [style_properties["paddingRightProperty"].getDefault]() {
        return this._ios.insets.right;
    }
    [style_properties["paddingRightProperty"].setNative](value) {
        let borderRight = isNaN(+this.style.borderRightWidth) ? 0 : +this.style.borderRightWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: value + borderRight,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [style_properties["borderRightWidthProperty"].getDefault]() {
        return 0;
    }
    [style_properties["borderRightWidthProperty"].setNative](value) {
        let paddingRight = isNaN(+this.style.paddingRight) ? 0 : +this.style.paddingRight;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: value + paddingRight,
            bottom: currentInsets.bottom
        });
        this._ios.insets = insets;
    }
    [style_properties["paddingBottomProperty"].getDefault]() {
        return this._ios.insets.bottom;
    }
    [style_properties["paddingBottomProperty"].setNative](value) {
        let borderBottom = isNaN(+this.style.borderBottomWidth) ? 0 : +this.style.borderBottomWidth;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: value + borderBottom,
        });
        this._ios.insets = insets;
    }
    [style_properties["borderBottomWidthProperty"].getDefault]() {
        return 0;
    }
    [style_properties["borderBottomWidthProperty"].setNative](value) {
        let paddingBottom = isNaN(+this.style.paddingBottom) ? 0 : +this.style.paddingBottom;
        let currentInsets = this._ios.insets;
        let insets = new UIEdgeInsets({
            left: currentInsets.left,
            top: currentInsets.top,
            right: currentInsets.right,
            bottom: value + paddingBottom
        });
        this._ios.insets = insets;
    }
    AnnotationsCollectionChangedInternal(data) {
        if (data.eventName && data.eventName.toLowerCase() === "change") {
            if (data.action && data.action.toLowerCase() === "add") {
                if (this._nativeView && this.annotations) {
                    for (let i = 0; i < data.addedCount; i++) {
                        this._nativeView.addAnnotation(this.annotations.getItem(data.index + i).ios);
                        this.annotations.getItem(data.index + i).owner = this;
                    }
                }
                return;
            }
            if (data.action && data.action.toLowerCase() === "splice") {
                for (let annIdx = 0; annIdx < data.removed.length; annIdx++) {
                    this._nativeView.removeAnnotation(data.removed[annIdx].ios);
                }
                return;
            }
        }
    }
    onAnnotationsChanged(oldValue, newValue) {
        super.onAnnotationsChanged(oldValue, newValue);
        if (oldValue) {
            for (let i = 0; i < oldValue.length; ++i) {
                oldValue[i].owner = undefined;
            }
        }
        if (this.annotations) {
            for (let i = 0; i < this.annotations.length; ++i) {
                this.annotations.getItem(i).owner = this;
            }
        }
        this.loadChart();
    }
    onHorizontalAxisChanged(oldValue, newValue) {
        super.onHorizontalAxisChanged(oldValue, newValue);
        if (oldValue) {
            this._removeView(oldValue);
        }
        if (newValue) {
            this._addView(newValue);
        }
        // since label alignment requires info about horizontal or vertical the axis is, we set appropriate values here
        let theAxis = newValue;
        if (theAxis && theAxis.labelLayoutMode) {
            if (theAxis.labelLayoutMode === ChartAxisLabelLayoutMode.Inner) {
                theAxis.ios.style.labelStyle.textAlignment = 4 /* Top */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 4 /* Top */;
            }
            else {
                theAxis.ios.style.labelStyle.textAlignment = 8 /* Bottom */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 8 /* Bottom */;
            }
        }
        // in case of oready added bar series we need to recreate the ios instance according to the owner structure
        if (this.series && this.series.length > 0) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i) instanceof chart_series_BarSeries || this.series.getItem(i) instanceof chart_series_RangeBarSeries) {
                    this.series.getItem(i).updateNative();
                }
            }
        }
        this.updateNativeHorizontalAxis(this._nativeView, theAxis);
    }
    onVerticalAxisChanged(oldValue, newValue) {
        super.onVerticalAxisChanged(oldValue, newValue);
        if (oldValue) {
            this._removeView(oldValue);
        }
        if (newValue) {
            this._addView(newValue);
        }
        let theAxis = newValue;
        if (theAxis && theAxis.labelLayoutMode) {
            if (theAxis.labelLayoutMode === ChartAxisLabelLayoutMode.Inner) {
                theAxis.ios.style.labelStyle.textAlignment = 2 /* Right */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 2 /* Right */;
            }
            else {
                theAxis.ios.style.labelStyle.textAlignment = 1 /* Left */;
                theAxis.ios.style.labelStyle.firstLabelTextAlignment = 1 /* Left */;
            }
        }
        // in case of oready added bar series we need to recreate the ios instance according to the owner structure
        if (this.series && this.series.length > 0) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i) instanceof chart_series_BarSeries || this.series.getItem(i) instanceof chart_series_RangeBarSeries) {
                    this.series.getItem(i).updateNative();
                }
            }
        }
        this.updateNativeVerticalAxis(this._nativeView, theAxis);
    }
    updateNativeVerticalAxis(nativeView, verticalAxis) {
        if (!nativeView || !verticalAxis) {
            return;
        }
        if (!verticalAxis.horizontalLocation) {
            verticalAxis.ios.position = 0 /* Left */;
        }
        nativeView.yAxis = verticalAxis.ios;
        verticalAxis.owner = this;
    }
    updateNativeHorizontalAxis(nativeView, horizontalAxis) {
        if (!nativeView || !horizontalAxis) {
            return;
        }
        if (!horizontalAxis.verticalLocation) {
            horizontalAxis.ios.position = 3 /* Bottom */;
        }
        nativeView.xAxis = horizontalAxis.ios;
        horizontalAxis.owner = this;
    }
    loadChart() {
        if (this._nativeView && this.series) {
            this._nativeView.removeAllData();
            this.updateNativeHorizontalAxis(this._nativeView, this.horizontalAxis);
            this.updateNativeVerticalAxis(this._nativeView, this.verticalAxis);
            let assignedChartHorizontalAxis = !!this.horizontalAxis;
            let assignedChartVerticalAxis = !!this.verticalAxis;
            for (let i = 0; i < this.series.length; ++i) {
                const currentSeries = this.series.getItem(i);
                if (!assignedChartHorizontalAxis && !!currentSeries.horizontalAxis) {
                    this.updateNativeHorizontalAxis(this._nativeView, currentSeries.horizontalAxis);
                    assignedChartHorizontalAxis = true;
                }
                if (!assignedChartVerticalAxis && !!currentSeries.verticalAxis) {
                    this.updateNativeVerticalAxis(this._nativeView, currentSeries.verticalAxis);
                    assignedChartVerticalAxis = true;
                }
                if (currentSeries.ios) {
                    this.updateNativeHorizontalAxis(currentSeries.ios, currentSeries.horizontalAxis);
                    this.updateNativeVerticalAxis(currentSeries.ios, currentSeries.verticalAxis);
                    this._nativeView.addSeries(currentSeries.ios);
                }
            }
            if (this.horizontalZoom || this.verticalZoom) {
                this.updateZoom();
            }
            if (this.palettes) {
                this.loadPalette(this.palettes);
            }
            if (this.grid) {
                this.grid.applyGridStyle();
            }
            if (this.annotations) {
                for (let i = 0; i < this.annotations.length; ++i) {
                    if (this.annotations.getItem(i).ios && this.annotations.getItem(i).axisId) {
                        this._nativeView.addAnnotation(this.annotations.getItem(i).ios);
                    }
                }
            }
            this._nativeView.update();
        }
    }
    updateZoom() {
        if (!this.horizontalZoom && !this.verticalZoom) {
            return;
        }
        if (this.horizontalZoom && this.horizontalAxis) {
            this.horizontalAxis.ios.zoom = this.horizontalZoom;
        }
        if (this.verticalZoom && this.verticalAxis) {
            this.verticalAxis.ios.zoom = this.verticalZoom;
        }
        if (this.series) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i).ios) {
                    if (this.series.getItem(i).horizontalAxis && this.horizontalZoom) {
                        this.series.getItem(i).horizontalAxis.ios.zoom = this.horizontalZoom;
                    }
                    if (this.series.getItem(i).verticalAxis && this.verticalZoom) {
                        this.series.getItem(i).verticalAxis.ios.zoom = this.verticalZoom;
                    }
                }
            }
        }
    }
    onGridChanged(oldValue, newValue) {
        if (newValue instanceof chart_cartesian_chart_grid_RadCartesianChartGrid) {
            newValue.owner = this;
        }
    }
    onPalettesChanged(oldValue, newValue) {
        super.onPalettesChanged(oldValue, newValue);
        if (newValue instanceof observable_array["ObservableArray"]) {
            let newPalettes = newValue;
            for (let i = 0; i < newPalettes.length; ++i) {
                newPalettes.getItem(i).owner = this;
            }
        }
        this.loadPalette(this.palettes);
    }
    PalettesCollectionChangedInternal(data) {
        this.loadPalette(this.palettes);
        this.updateChart();
    }
    loadPalette(palettes) {
        if (!this._nativeView || !this.series) {
            return;
        }
        if (this.palettes && this.palettes.length > 0) {
            for (let i = 0; i < this.series.length; ++i) {
                if (this.series.getItem(i).ios) {
                    // tag will keep the number of series in current collection
                    this.series.getItem(i).ios.tag = i;
                }
            }
            for (let i = 0; i < this.series.length; ++i) {
                let entriesForSeries = this.getPalettesForSeries(palettes, this.series.getItem(i));
                if (entriesForSeries.length > 0) {
                    this.applyPalettesToSeries(entriesForSeries, this.series.getItem(i));
                }
            }
        }
    }
    getPalettesForSeries(source, series) {
        const palettes = [];
        for (let i = 0; i < source.length; i++) {
            let palette = source.getItem(i);
            if (palette.seriesName === series[seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    }
    applyPalettesToSeries(palettes, series) {
        if (!series.ios) {
            return;
        }
        let selectionPalette, normalPalette;
        for (let i = 0; i < palettes.length; ++i) {
            if (palettes[i].seriesState === ChartPaletteSeriesState.Selected) {
                selectionPalette = palettes[i];
            }
            else {
                normalPalette = palettes[i];
            }
        }
        let normal = (normalPalette) ? this.buildNativePaletteForSeries(normalPalette, series) : null;
        if (normal) {
            if (normal) {
                this._chartNormalPalettesMap.set(normalPalette.seriesName, normal);
            }
        }
        let tmp = (selectionPalette) ? this._chartSelectionPalettesMap.get(selectionPalette.seriesName) : null;
        if (!tmp) {
            let selection = (selectionPalette) ? this.buildNativePaletteForSeries(selectionPalette, series) : null;
            if (selection) {
                this._chartSelectionPalettesMap.set(selectionPalette.seriesName, selection);
            }
        }
    }
    buildNativePaletteForSeries(palette, series) {
        let seriesPalette = TKChartPalette.new();
        let paletteEntry;
        let currentPaletteEntry;
        for (let i = 0; i < palette.entries.length; ++i) {
            currentPaletteEntry = (series.ios.style.palette) ? series.ios.style.palette.items.objectAtIndex(i % series.ios.style.palette.itemsCount) : null;
            paletteEntry = palette.entries.getItem(i);
            let stroke = TKStroke.new();
            if (!isNaN(paletteEntry.strokeWidth)) {
                stroke.width = paletteEntry.strokeWidth;
            }
            else {
                stroke.width = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.width : 2;
            }
            if (paletteEntry.strokeColor) {
                stroke.color = paletteEntry.strokeColor.ios;
            }
            else {
                stroke.color = (currentPaletteEntry && currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.color : (new core_color["a" /* Color */]("Black")).ios;
            }
            let solidFill = TKSolidFill.new();
            if (paletteEntry.fillColor) {
                solidFill.color = paletteEntry.fillColor.ios;
            }
            else {
                solidFill.color = (currentPaletteEntry && currentPaletteEntry.fill) ? currentPaletteEntry.fill.color : (new core_color["a" /* Color */]("Blue")).ios;
            }
            seriesPalette.addPaletteItem(TKChartPaletteItem.paletteItemWithStrokeAndFill(stroke, solidFill));
        }
        return seriesPalette;
    }
    /** Finds the corresponding palette item for selected series
     * @param index - the index of the palette item that should be used
     * @param seriesIndex - the index of series in {N} chart's series collection
     */
    getPaletteItemWithIndexForStateOfSeries(state, index, seriesIndex) {
        let item = null;
        let map = (state === "selected") ? this._chartSelectionPalettesMap : this._chartNormalPalettesMap;
        let palette = (this.series.getItem(seriesIndex)) ? map.get(this.series.getItem(seriesIndex).seriesName) : null;
        if (palette) {
            item = palette.items[index % palette.items.count];
        }
        return item;
    }
    /**
     * Finds the series' consequent number in group of series with the same seriesName value
     */
    findConsequentIndexOfSeries(groupName, nativeIndex) {
        let itemIndex = 0;
        let seriesName;
        for (let i = 0; i < this.series.length; ++i) {
            seriesName = this.series.getItem(i).seriesName;
            if (seriesName === groupName && this.series.getItem(i).ios && this.series.getItem(i).ios.index < nativeIndex) {
                itemIndex++;
            }
        }
        return itemIndex;
    }
    onSeriesSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        switch (newValue) {
            case ChartSelectionMode.Single:
                this._nativeView.seriesSelectionMode = 1 /* Single */;
                break;
            case ChartSelectionMode.Multiple:
                this._nativeView.seriesSelectionMode = 2 /* Multiple */;
                break;
            case ChartSelectionMode.None:
                this._nativeView.seriesSelectionMode = 0 /* None */;
                break;
        }
    }
    onPointSelectionModeChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        switch (newValue) {
            case ChartSelectionMode.Single:
                this._nativeView.dataPointSelectionMode = 1 /* Single */;
                break;
            case ChartSelectionMode.Multiple:
                this._nativeView.dataPointSelectionMode = 2 /* Multiple */;
                break;
            case ChartSelectionMode.None:
                this._nativeView.dataPointSelectionMode = 0 /* None */;
                break;
        }
    }
    onAllowAnimationsChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        this._nativeView.allowAnimations = newValue;
    }
    onHorizontalZoomChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (!isNaN(+newValue) && newValue > 1) {
            this.updateZoom();
        }
        else {
            console.log("WARNING: Horizontal zoom must be a number greater or equal to 1");
        }
    }
    onVerticalZoomChanged(oldValue, newValue) {
        if (!this._nativeView) {
            return;
        }
        if (!isNaN(+newValue) && newValue > 1) {
            this.updateZoom();
        }
        else {
            console.log("WARNING: Vertical zoom must be a number greater or equal to 1");
        }
    }
    onTrackballChanged(oldValue, newValue) {
        super.onTrackballChanged(oldValue, newValue);
        if (newValue && (newValue instanceof chart_track_ball_common_Trackball)) {
            this._nativeView.allowTrackball = true;
            this.trackball.ios = this._nativeView.trackball;
        }
        else {
            this._nativeView.allowTrackball = false;
        }
    }
}
//# sourceMappingURL=ui-chart.ios.js.map; 
if (false ) {} 

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CSSUtils; });
const MODAL = 'modal';
const ROOT = 'root';
const cssClasses = [];
var CSSUtils;
(function (CSSUtils) {
    CSSUtils.CLASS_PREFIX = 'ns-';
    CSSUtils.MODAL_ROOT_VIEW_CSS_CLASS = `${CSSUtils.CLASS_PREFIX}${MODAL}`;
    CSSUtils.ROOT_VIEW_CSS_CLASS = `${CSSUtils.CLASS_PREFIX}${ROOT}`;
    function getSystemCssClasses() {
        return cssClasses;
    }
    CSSUtils.getSystemCssClasses = getSystemCssClasses;
    function pushToSystemCssClasses(value) {
        cssClasses.push(value);
        return cssClasses.length;
    }
    CSSUtils.pushToSystemCssClasses = pushToSystemCssClasses;
    function removeSystemCssClass(value) {
        const index = cssClasses.indexOf(value);
        let removedElement;
        if (index > -1) {
            removedElement = cssClasses.splice(index, 1);
        }
        return removedElement;
    }
    CSSUtils.removeSystemCssClass = removeSystemCssClass;
    function getModalRootViewCssClass() {
        return CSSUtils.MODAL_ROOT_VIEW_CSS_CLASS;
    }
    CSSUtils.getModalRootViewCssClass = getModalRootViewCssClass;
    function getRootViewCssClasses() {
        return [CSSUtils.ROOT_VIEW_CSS_CLASS, ...cssClasses];
    }
    CSSUtils.getRootViewCssClasses = getRootViewCssClasses;
    function pushToRootViewCssClasses(value) {
        return pushToSystemCssClasses(value) + 1; // because of ROOT_VIEW_CSS_CLASS
    }
    CSSUtils.pushToRootViewCssClasses = pushToRootViewCssClasses;
    function removeFromRootViewCssClasses(value) {
        return removeSystemCssClass(value);
    }
    CSSUtils.removeFromRootViewCssClasses = removeFromRootViewCssClasses;
})(CSSUtils || (CSSUtils = {}));
//# sourceMappingURL=system-classes.js.map; 
if (false ) {} 

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "isFileOrResourcePath", function() { return /* reexport */ utils_common["k" /* isFileOrResourcePath */]; });
__webpack_require__.d(__webpack_exports__, "ImageSource", function() { return /* binding */ image_source_ImageSource; });
__webpack_require__.d(__webpack_exports__, "fromAsset", function() { return /* binding */ fromAsset; });
__webpack_require__.d(__webpack_exports__, "fromResource", function() { return /* binding */ fromResource; });
__webpack_require__.d(__webpack_exports__, "fromFile", function() { return /* binding */ fromFile; });
__webpack_require__.d(__webpack_exports__, "fromData", function() { return /* binding */ fromData; });
__webpack_require__.d(__webpack_exports__, "fromFontIconCode", function() { return /* binding */ fromFontIconCode; });
__webpack_require__.d(__webpack_exports__, "fromBase64", function() { return /* binding */ fromBase64; });
__webpack_require__.d(__webpack_exports__, "fromNativeSource", function() { return /* binding */ fromNativeSource; });
__webpack_require__.d(__webpack_exports__, "fromUrl", function() { return /* binding */ fromUrl; });
__webpack_require__.d(__webpack_exports__, "fromFileOrResource", function() { return /* binding */ fromFileOrResource; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/font.js
var styling_font = __webpack_require__(22);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/file-system/index.js + 1 modules
var file_system = __webpack_require__(21);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/image-source/image-source-common.js
function getScaledDimensions(width, height, maxSize) {
    if (height >= width) {
        if (height <= maxSize) {
            // if image already smaller than the required height
            return { width, height };
        }
        return {
            width: Math.round((maxSize * width) / height),
            height: maxSize,
        };
    }
    if (width <= maxSize) {
        // if image already smaller than the required width
        return { width, height };
    }
    return {
        width: maxSize,
        height: Math.round((maxSize * height) / width),
    };
}
//# sourceMappingURL=image-source-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/image-source/index.js

// Types.




let http;
function ensureHttp() {
    if (!http) {
        http = __webpack_require__(18);
    }
}
class image_source_ImageSource {
    constructor(nativeSource) {
        if (nativeSource) {
            this.setNativeSource(nativeSource);
        }
    }
    get height() {
        if (this.ios) {
            return this.ios.size.height;
        }
        return NaN;
    }
    get width() {
        if (this.ios) {
            return this.ios.size.width;
        }
        return NaN;
    }
    get rotationAngle() {
        return NaN;
    }
    set rotationAngle(_value) {
        // compatibility with Android
    }
    static fromAsset(asset) {
        return new Promise((resolve, reject) => {
            asset.getImageAsync((image, err) => {
                if (image) {
                    resolve(new image_source_ImageSource(image));
                }
                else {
                    reject(err);
                }
            });
        });
    }
    static fromUrl(url) {
        ensureHttp();
        return http.getImage(url);
    }
    static fromResourceSync(name) {
        const nativeSource = UIImage.tns_safeImageNamed(name) || UIImage.tns_safeImageNamed(`${name}.jpg`);
        return nativeSource ? new image_source_ImageSource(nativeSource) : null;
    }
    static fromResource(name) {
        return new Promise((resolve, reject) => {
            try {
                UIImage.tns_safeDecodeImageNamedCompletion(name, (image) => {
                    if (image) {
                        resolve(new image_source_ImageSource(image));
                    }
                    else {
                        UIImage.tns_safeDecodeImageNamedCompletion(`${name}.jpg`, (image) => {
                            resolve(new image_source_ImageSource(image));
                        });
                    }
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    static fromFileSync(path) {
        const uiImage = UIImage.imageWithContentsOfFile(getFileName(path));
        return uiImage ? new image_source_ImageSource(uiImage) : null;
    }
    static fromFile(path) {
        return new Promise((resolve, reject) => {
            try {
                UIImage.tns_decodeImageWidthContentsOfFileCompletion(getFileName(path), (uiImage) => {
                    resolve(new image_source_ImageSource(uiImage));
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    static fromFileOrResourceSync(path) {
        if (!Object(utils_common["k" /* isFileOrResourcePath */])(path)) {
            throw new Error('Path "' + '" is not a valid file or resource.');
        }
        if (path.indexOf(utils_common["b" /* RESOURCE_PREFIX */]) === 0) {
            return image_source_ImageSource.fromResourceSync(path.substr(utils_common["b" /* RESOURCE_PREFIX */].length));
        }
        return image_source_ImageSource.fromFileSync(path);
    }
    static fromDataSync(data) {
        const uiImage = UIImage.imageWithData(data);
        return uiImage ? new image_source_ImageSource(uiImage) : null;
    }
    static fromData(data) {
        return new Promise((resolve, reject) => {
            try {
                UIImage.tns_decodeImageWithDataCompletion(data, (uiImage) => {
                    resolve(new image_source_ImageSource(uiImage));
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    static fromBase64Sync(source) {
        let uiImage;
        if (typeof source === 'string') {
            const data = NSData.alloc().initWithBase64EncodedStringOptions(source, 1 /* IgnoreUnknownCharacters */);
            uiImage = UIImage.imageWithData(data);
        }
        return uiImage ? new image_source_ImageSource(uiImage) : null;
    }
    static fromBase64(source) {
        return new Promise((resolve, reject) => {
            try {
                const data = NSData.alloc().initWithBase64EncodedStringOptions(source, 1 /* IgnoreUnknownCharacters */);
                const main_queue = dispatch_get_current_queue();
                const background_queue = dispatch_get_global_queue(21 /* QOS_CLASS_DEFAULT */, 0);
                dispatch_async(background_queue, () => {
                    const uiImage = UIImage.imageWithData(data);
                    dispatch_async(main_queue, () => {
                        resolve(new image_source_ImageSource(uiImage));
                    });
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    static fromFontIconCodeSync(source, font, color) {
        font = font || styling_font["a" /* Font */].default;
        let fontSize = utils_common["n" /* layout */].toDevicePixels(font.fontSize);
        if (!fontSize) {
            // TODO: Consider making 36 font size as default for optimal look on TabView and ActionBar
            fontSize = UIFont.labelFontSize;
        }
        const density = utils_common["n" /* layout */].getDisplayDensity();
        const scaledFontSize = fontSize * density;
        const attributes = {
            [NSFontAttributeName]: font.getUIFont(UIFont.systemFontOfSize(scaledFontSize)),
        };
        if (color) {
            attributes[NSForegroundColorAttributeName] = color.ios;
        }
        const attributedString = NSAttributedString.alloc().initWithStringAttributes(source, attributes);
        UIGraphicsBeginImageContextWithOptions(attributedString.size(), false, 0.0);
        attributedString.drawAtPoint(CGPointMake(0, 0));
        const iconImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return iconImage ? new image_source_ImageSource(iconImage) : null;
    }
    fromAsset(asset) {
        console.log('fromAsset() is deprecated. Use ImageSource.fromAsset() instead.');
        return image_source_ImageSource.fromAsset(asset).then((imgSource) => {
            this.setNativeSource(imgSource.ios);
            return this;
        });
    }
    loadFromResource(name) {
        console.log('loadFromResource() is deprecated. Use ImageSource.fromResourceSync() instead.');
        const imgSource = image_source_ImageSource.fromResourceSync(name);
        this.ios = imgSource ? imgSource.ios : null;
        return !!this.ios;
    }
    fromResource(name) {
        console.log('fromResource() is deprecated. Use ImageSource.fromResource() instead.');
        return image_source_ImageSource.fromResource(name).then((imgSource) => {
            this.ios = imgSource.ios;
            return !!this.ios;
        });
    }
    loadFromFile(path) {
        console.log('loadFromFile() is deprecated. Use ImageSource.fromFileSync() instead.');
        const imgSource = image_source_ImageSource.fromFileSync(path);
        this.ios = imgSource ? imgSource.ios : null;
        return !!this.ios;
    }
    fromFile(path) {
        console.log('fromFile() is deprecated. Use ImageSource.fromFile() instead.');
        return image_source_ImageSource.fromFile(path).then((imgSource) => {
            this.ios = imgSource.ios;
            return !!this.ios;
        });
    }
    loadFromData(data) {
        console.log('loadFromData() is deprecated. Use ImageSource.fromDataSync() instead.');
        const imgSource = image_source_ImageSource.fromDataSync(data);
        this.ios = imgSource ? imgSource.ios : null;
        return !!this.ios;
    }
    fromData(data) {
        console.log('fromData() is deprecated. Use ImageSource.fromData() instead.');
        return image_source_ImageSource.fromData(data).then((imgSource) => {
            this.ios = imgSource.ios;
            return !!this.ios;
        });
    }
    loadFromBase64(source) {
        console.log('loadFromBase64() is deprecated. Use ImageSource.fromBase64Sync() instead.');
        const imgSource = image_source_ImageSource.fromBase64Sync(source);
        this.ios = imgSource ? imgSource.ios : null;
        return !!this.ios;
    }
    fromBase64(source) {
        console.log('fromBase64() is deprecated. Use ImageSource.fromBase64() instead.');
        return image_source_ImageSource.fromBase64(source).then((imgSource) => {
            this.ios = imgSource.ios;
            return !!this.ios;
        });
    }
    loadFromFontIconCode(source, font, color) {
        console.log('loadFromFontIconCode() is deprecated. Use ImageSource.fromFontIconCodeSync() instead.');
        const imgSource = image_source_ImageSource.fromFontIconCodeSync(source, font, color);
        this.ios = imgSource ? imgSource.ios : null;
        return !!this.ios;
    }
    setNativeSource(source) {
        if (source && !(source instanceof UIImage)) {
            throw new Error('The method setNativeSource() expects UIImage instance.');
        }
        this.ios = source;
    }
    saveToFile(path, format, quality) {
        if (!this.ios) {
            return false;
        }
        if (quality) {
            quality = (quality - 0) / (100 - 0); // Normalize quality on a scale of 0 to 1
        }
        const data = getImageData(this.ios, format, quality);
        if (data) {
            return NSFileManager.defaultManager.createFileAtPathContentsAttributes(path, data, null);
        }
        return false;
    }
    toBase64String(format, quality) {
        let res = null;
        if (!this.ios) {
            return res;
        }
        if (quality) {
            quality = (quality - 0) / (100 - 0); // Normalize quality on a scale of 0 to 1
        }
        const data = getImageData(this.ios, format, quality);
        if (data) {
            res = data.base64Encoding();
        }
        return res;
    }
    resize(maxSize, options) {
        const size = this.ios.size;
        const dim = getScaledDimensions(size.width, size.height, maxSize);
        const newSize = CGSizeMake(dim.width, dim.height);
        UIGraphicsBeginImageContextWithOptions(newSize, true, this.ios.scale);
        this.ios.drawInRect(CGRectMake(0, 0, newSize.width, newSize.height));
        const resizedImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return new image_source_ImageSource(resizedImage);
    }
}
function getFileName(path) {
    let fileName = typeof path === 'string' ? path.trim() : '';
    if (fileName.indexOf('~/') === 0) {
        fileName = file_system["path"].join(file_system["knownFolders"].currentApp().path, fileName.replace('~/', ''));
    }
    return fileName;
}
function getImageData(instance, format, quality = 0.9) {
    let data = null;
    switch (format) {
        case 'png':
            data = UIImagePNGRepresentation(instance);
            break;
        case 'jpeg':
        case 'jpg':
            data = UIImageJPEGRepresentation(instance, quality);
            break;
    }
    return data;
}
function fromAsset(asset) {
    console.log('fromAsset() is deprecated. Use ImageSource.fromAsset() instead.');
    return image_source_ImageSource.fromAsset(asset);
}
function fromResource(name) {
    console.log('fromResource() is deprecated. Use ImageSource.fromResourceSync() instead.');
    return image_source_ImageSource.fromResourceSync(name);
}
function fromFile(path) {
    console.log('fromFile() is deprecated. Use ImageSource.fromFileSync() instead.');
    return image_source_ImageSource.fromFileSync(path);
}
function fromData(data) {
    console.log('fromData() is deprecated. Use ImageSource.fromDataSync() instead.');
    return image_source_ImageSource.fromDataSync(data);
}
function fromFontIconCode(source, font, color) {
    console.log('fromFontIconCode() is deprecated. Use ImageSource.fromFontIconCodeSync() instead.');
    return image_source_ImageSource.fromFontIconCodeSync(source, font, color);
}
function fromBase64(source) {
    console.log('fromBase64() is deprecated. Use ImageSource.fromBase64Sync() instead.');
    return image_source_ImageSource.fromBase64Sync(source);
}
function fromNativeSource(nativeSource) {
    console.log('fromNativeSource() is deprecated. Use ImageSource constructor instead.');
    return new image_source_ImageSource(nativeSource);
}
function fromUrl(url) {
    console.log('fromUrl() is deprecated. Use ImageSource.fromUrl() instead.');
    return image_source_ImageSource.fromUrl(url);
}
function fromFileOrResource(path) {
    console.log('fromFileOrResource() is deprecated. Use ImageSource.fromFileOrResourceSync() instead.');
    return image_source_ImageSource.fromFileOrResourceSync(path);
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DialogStrings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return inputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return capitalizationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getCurrentPage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getButtonColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getLabelColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getTextFieldColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isDialogOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return parseLoginOptions; });
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);


var DialogStrings;
(function (DialogStrings) {
    DialogStrings.STRING = 'string';
    DialogStrings.PROMPT = 'Prompt';
    DialogStrings.CONFIRM = 'Confirm';
    DialogStrings.ALERT = 'Alert';
    DialogStrings.LOGIN = 'Login';
    DialogStrings.OK = 'OK';
    DialogStrings.CANCEL = 'Cancel';
})(DialogStrings || (DialogStrings = {}));
/**
 * Defines the input type for prompt dialog.
 */
var inputType;
(function (inputType) {
    /**
     * Plain text input type.
     */
    inputType.text = 'text';
    /**
     * Password input type.
     */
    inputType.password = 'password';
    /**
     * Email input type.
     */
    inputType.email = 'email';
    /**
     * Number input type
     */
    inputType.number = 'number';
    /**
     * Decimal input type
     */
    inputType.decimal = 'decimal';
    /**
     * Phone input type
     */
    inputType.phone = 'phone';
})(inputType || (inputType = {}));
/**
 * Defines the capitalization type for prompt dialog.
 */
var capitalizationType;
(function (capitalizationType) {
    /**
     * No automatic capitalization.
     */
    capitalizationType.none = 'none';
    /**
     * Capitalizes every character.
     */
    capitalizationType.all = 'all';
    /**
     * Capitalize the first word of each sentence.
     */
    capitalizationType.sentences = 'sentences';
    /**
     * Capitalize the first letter of every word.
     */
    capitalizationType.words = 'words';
})(capitalizationType || (capitalizationType = {}));
function getCurrentPage() {
    let topmostFrame = _frame__WEBPACK_IMPORTED_MODULE_0__["Frame"].topmost();
    if (topmostFrame) {
        return topmostFrame.currentPage;
    }
    return undefined;
}
function applySelectors(view, callback) {
    let currentPage = getCurrentPage();
    if (currentPage) {
        let styleScope = currentPage._styleScope;
        if (styleScope) {
            view._inheritStyleScope(styleScope);
            view.onLoaded();
            callback(view);
            view.onUnloaded();
        }
    }
}
let button;
let label;
let textField;
function getButtonColors() {
    if (!button) {
        const Button = __webpack_require__(100).Button;
        button = new Button();
        if (true) {
            button._setupUI({});
        }
    }
    let buttonColor;
    let buttonBackgroundColor;
    applySelectors(button, (btn) => {
        buttonColor = btn.color;
        buttonBackgroundColor = btn.backgroundColor;
    });
    return { color: buttonColor, backgroundColor: buttonBackgroundColor };
}
function getLabelColor() {
    if (!label) {
        const Label = __webpack_require__(46).Label;
        label = new Label();
        if (true) {
            label._setupUI({});
        }
    }
    let labelColor;
    applySelectors(label, (lbl) => {
        labelColor = lbl.color;
    });
    return labelColor;
}
function getTextFieldColor() {
    if (!textField) {
        const TextField = __webpack_require__(101).TextField;
        textField = new TextField();
        if (true) {
            textField._setupUI({});
        }
    }
    let textFieldColor;
    applySelectors(textField, (tf) => {
        textFieldColor = tf.color;
    });
    return textFieldColor;
}
function isDialogOptions(arg) {
    return arg && (arg.message || arg.title);
}
function parseLoginOptions(args) {
    // Handle options object first
    if (args.length === 1 && Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isObject */ "j"])(args[0])) {
        return args[0];
    }
    let options = {
        title: DialogStrings.LOGIN,
        okButtonText: DialogStrings.OK,
        cancelButtonText: DialogStrings.CANCEL,
    };
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"])(args[0])) {
        options.message = args[0];
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"])(args[1])) {
        options.userNameHint = args[1];
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"])(args[2])) {
        options.passwordHint = args[2];
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"])(args[3])) {
        options.userName = args[3];
    }
    if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"])(args[4])) {
        options.password = args[4];
    }
    return options;
}
//# sourceMappingURL=dialogs-common.js.map; 
if (false ) {} 

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ layout_base_LayoutBase; });

// UNUSED EXPORTS: LayoutBaseCommon, clipToBoundsProperty, isPassThroughParentEnabledProperty

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/index.js
var view = __webpack_require__(3);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view-base/index.js
var view_base = __webpack_require__(15);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var properties = __webpack_require__(1);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/layout-base-common.js



class layout_base_common_LayoutBaseCommon extends view["b" /* CustomLayoutView */] {
    constructor() {
        super(...arguments);
        this._subViews = new Array();
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof view["c" /* View */]) {
            this.addChild(value);
        }
    }
    getChildrenCount() {
        return this._subViews.length;
    }
    // overrides the base property.
    get _childrenCount() {
        return this._subViews.length;
    }
    getChildAt(index) {
        return this._subViews[index];
    }
    getChildIndex(child) {
        return this._subViews.indexOf(child);
    }
    getChildById(id) {
        return Object(view_base["getViewById"])(this, id);
    }
    _registerLayoutChild(child) {
        //Overridden
    }
    _unregisterLayoutChild(child) {
        //Overridden
    }
    addChild(child) {
        // TODO: Do we need this method since we have the core logic in the View implementation?
        this._subViews.push(child);
        this._addView(child);
        this._registerLayoutChild(child);
    }
    insertChild(child, atIndex) {
        this._subViews.splice(atIndex, 0, child);
        this._addView(child, atIndex);
        this._registerLayoutChild(child);
    }
    removeChild(child) {
        this._removeView(child);
        // TODO: consider caching the index on the child.
        const index = this._subViews.indexOf(child);
        this._subViews.splice(index, 1);
        this._unregisterLayoutChild(child);
    }
    removeChildren() {
        while (this.getChildrenCount() !== 0) {
            this.removeChild(this._subViews[this.getChildrenCount() - 1]);
        }
    }
    get padding() {
        return this.style.padding;
    }
    set padding(value) {
        this.style.padding = value;
    }
    get paddingTop() {
        return this.style.paddingTop;
    }
    set paddingTop(value) {
        this.style.paddingTop = value;
    }
    get paddingRight() {
        return this.style.paddingRight;
    }
    set paddingRight(value) {
        this.style.paddingRight = value;
    }
    get paddingBottom() {
        return this.style.paddingBottom;
    }
    set paddingBottom(value) {
        this.style.paddingBottom = value;
    }
    get paddingLeft() {
        return this.style.paddingLeft;
    }
    set paddingLeft(value) {
        this.style.paddingLeft = value;
    }
    _childIndexToNativeChildIndex(index) {
        if (index === undefined) {
            return undefined;
        }
        let result = 0;
        for (let i = 0; i < index && i < this._subViews.length; i++) {
            result += this._subViews[i]._getNativeViewsCount();
        }
        return result;
    }
    eachChildView(callback) {
        for (let i = 0, length = this._subViews.length; i < length; i++) {
            const retVal = callback(this._subViews[i]);
            if (retVal === false) {
                break;
            }
        }
    }
    eachLayoutChild(callback) {
        let lastChild = null;
        this.eachChildView((cv) => {
            cv._eachLayoutView((lv) => {
                if (lastChild && !lastChild.isCollapsed) {
                    callback(lastChild, false);
                }
                lastChild = lv;
            });
            return true;
        });
        if (lastChild && !lastChild.isCollapsed) {
            callback(lastChild, true);
        }
    }
}
const clipToBoundsProperty = new properties["Property"]({
    name: 'clipToBounds',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
clipToBoundsProperty.register(layout_base_common_LayoutBaseCommon);
const isPassThroughParentEnabledProperty = new properties["Property"]({
    name: 'isPassThroughParentEnabled',
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
});
isPassThroughParentEnabledProperty.register(layout_base_common_LayoutBaseCommon);
//# sourceMappingURL=layout-base-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/layout-base.js


class layout_base_LayoutBase extends layout_base_common_LayoutBaseCommon {
    addChild(child) {
        super.addChild(child);
        this.requestLayout();
    }
    insertChild(child, atIndex) {
        super.insertChild(child, atIndex);
        this.requestLayout();
    }
    removeChild(child) {
        super.removeChild(child);
        this.requestLayout();
    }
    _setNativeClipToBounds() {
        if (this.clipToBounds) {
            this.nativeViewProtected.clipsToBounds = true;
        }
        else {
            super._setNativeClipToBounds();
        }
    }
    [clipToBoundsProperty.getDefault]() {
        return false;
    }
    [clipToBoundsProperty.setNative](value) {
        this._setNativeClipToBounds();
    }
    [isPassThroughParentEnabledProperty.setNative](value) {
        this.nativeViewProtected.setPassThroughParent(value);
    }
}
//# sourceMappingURL=layout-base.ios.js.map; 
if (false ) {} 

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IOSHelper; });
/* harmony import */ var _view_helper_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
// Requires




const majorVersion = _utils__WEBPACK_IMPORTED_MODULE_1__[/* iOSNativeHelper */ "a"].MajorVersion;
var UILayoutViewController = /** @class */ (function (_super) {
    __extends(UILayoutViewController, _super);
    function UILayoutViewController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UILayoutViewController.initWithOwner = function (owner) {
        var controller = UILayoutViewController.new();
        controller.owner = owner;
        return controller;
    };
    UILayoutViewController.prototype.viewDidLoad = function () {
        _super.prototype.viewDidLoad.call(this);
        // Unify translucent and opaque bars layout
        // this.edgesForExtendedLayout = UIRectEdgeBottom;
        this.extendedLayoutIncludesOpaqueBars = true;
    };
    UILayoutViewController.prototype.viewWillLayoutSubviews = function () {
        _super.prototype.viewWillLayoutSubviews.call(this);
        var owner = this.owner.get();
        if (owner) {
            IOSHelper.updateConstraints(this, owner);
        }
    };
    UILayoutViewController.prototype.viewDidLayoutSubviews = function () {
        _super.prototype.viewDidLayoutSubviews.call(this);
        var owner = this.owner.get();
        if (owner) {
            if (majorVersion >= 11) {
                // Handle nested UILayoutViewController safe area application.
                // Currently, UILayoutViewController can be nested only in a TabView.
                // The TabView itself is handled by the OS, so we check the TabView's parent (usually a Page, but can be a Layout).
                var tabViewItem = owner.parent;
                var tabView = tabViewItem && tabViewItem.parent;
                var parent = tabView && tabView.parent;
                // Handle Angular scenario where TabView is in a ProxyViewContainer
                // It is possible to wrap components in ProxyViewContainers indefinitely
                // Not using instanceof ProxyViewContainer to avoid circular dependency
                // TODO: Try moving UILayoutViewController out of view module
                while (parent && !parent.nativeViewProtected) {
                    parent = parent.parent;
                }
                if (parent) {
                    var parentPageInsetsTop = parent.nativeViewProtected.safeAreaInsets.top;
                    var currentInsetsTop = this.view.safeAreaInsets.top;
                    var additionalInsetsTop = Math.max(parentPageInsetsTop - currentInsetsTop, 0);
                    var parentPageInsetsBottom = parent.nativeViewProtected.safeAreaInsets.bottom;
                    var currentInsetsBottom = this.view.safeAreaInsets.bottom;
                    var additionalInsetsBottom = Math.max(parentPageInsetsBottom - currentInsetsBottom, 0);
                    if (additionalInsetsTop > 0 || additionalInsetsBottom > 0) {
                        var additionalInsets = new UIEdgeInsets({
                            top: additionalInsetsTop,
                            left: 0,
                            bottom: additionalInsetsBottom,
                            right: 0,
                        });
                        this.additionalSafeAreaInsets = additionalInsets;
                    }
                }
            }
            IOSHelper.layoutView(this, owner);
        }
    };
    UILayoutViewController.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this.owner.get();
        if (!owner) {
            return;
        }
        IOSHelper.updateAutoAdjustScrollInsets(this, owner);
        if (!owner.parent) {
            owner.callLoaded();
        }
    };
    UILayoutViewController.prototype.viewDidDisappear = function (animated) {
        _super.prototype.viewDidDisappear.call(this, animated);
        var owner = this.owner.get();
        if (owner && !owner.parent) {
            owner.callUnloaded();
        }
    };
    // Mind implementation for other controllers
    UILayoutViewController.prototype.traitCollectionDidChange = function (previousTraitCollection) {
        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
        if (majorVersion >= 13) {
            var owner = this.owner.get();
            if (owner && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection(previousTraitCollection)) {
                owner.notify({
                    eventName: IOSHelper.traitCollectionColorAppearanceChangedEvent,
                    object: owner,
                });
            }
        }
    };
    return UILayoutViewController;
}(UIViewController));
var UIAdaptivePresentationControllerDelegateImp = /** @class */ (function (_super) {
    __extends(UIAdaptivePresentationControllerDelegateImp, _super);
    function UIAdaptivePresentationControllerDelegateImp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIAdaptivePresentationControllerDelegateImp.initWithOwnerAndCallback = function (owner, whenClosedCallback) {
        var instance = _super.new.call(this);
        instance.owner = owner;
        instance.closedCallback = whenClosedCallback;
        return instance;
    };
    UIAdaptivePresentationControllerDelegateImp.prototype.presentationControllerDidDismiss = function (presentationController) {
        var owner = this.owner.get();
        if (owner && typeof this.closedCallback === 'function') {
            this.closedCallback();
        }
    };
    UIAdaptivePresentationControllerDelegateImp.ObjCProtocols = [UIAdaptivePresentationControllerDelegate];
    return UIAdaptivePresentationControllerDelegateImp;
}(NSObject));
var UIPopoverPresentationControllerDelegateImp = /** @class */ (function (_super) {
    __extends(UIPopoverPresentationControllerDelegateImp, _super);
    function UIPopoverPresentationControllerDelegateImp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIPopoverPresentationControllerDelegateImp.initWithOwnerAndCallback = function (owner, whenClosedCallback) {
        var instance = _super.new.call(this);
        instance.owner = owner;
        instance.closedCallback = whenClosedCallback;
        return instance;
    };
    UIPopoverPresentationControllerDelegateImp.prototype.popoverPresentationControllerDidDismissPopover = function (popoverPresentationController) {
        var owner = this.owner.get();
        if (owner && typeof this.closedCallback === 'function') {
            this.closedCallback();
        }
    };
    UIPopoverPresentationControllerDelegateImp.ObjCProtocols = [UIPopoverPresentationControllerDelegate];
    return UIPopoverPresentationControllerDelegateImp;
}(NSObject));
class IOSHelper {
    static getParentWithViewController(view) {
        while (view && !view.viewController) {
            view = view.parent;
        }
        // Note: Might return undefined if no parent with viewController is found
        return view;
    }
    static updateAutoAdjustScrollInsets(controller, owner) {
        if (majorVersion <= 10) {
            owner._automaticallyAdjustsScrollViewInsets = false;
            // This API is deprecated, but has no alternative for <= iOS 10
            // Defaults to true and results to appliyng the insets twice together with our logic
            // for iOS 11+ we use the contentInsetAdjustmentBehavior property in scrollview
            // https://developer.apple.com/documentation/uikit/uiviewcontroller/1621372-automaticallyadjustsscrollviewin
            controller.automaticallyAdjustsScrollViewInsets = false;
        }
    }
    static updateConstraints(controller, owner) {
        if (majorVersion <= 10) {
            const layoutGuide = IOSHelper.initLayoutGuide(controller);
            controller.view.safeAreaLayoutGuide = layoutGuide;
        }
    }
    static initLayoutGuide(controller) {
        const rootView = controller.view;
        const layoutGuide = UILayoutGuide.new();
        rootView.addLayoutGuide(layoutGuide);
        NSLayoutConstraint.activateConstraints([layoutGuide.topAnchor.constraintEqualToAnchor(controller.topLayoutGuide.bottomAnchor), layoutGuide.bottomAnchor.constraintEqualToAnchor(controller.bottomLayoutGuide.topAnchor), layoutGuide.leadingAnchor.constraintEqualToAnchor(rootView.leadingAnchor), layoutGuide.trailingAnchor.constraintEqualToAnchor(rootView.trailingAnchor)]);
        return layoutGuide;
    }
    static layoutView(controller, owner) {
        let layoutGuide = controller.view.safeAreaLayoutGuide;
        if (!layoutGuide) {
            _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].write(`safeAreaLayoutGuide during layout of ${owner}. Creating fallback constraints, but layout might be wrong.`, _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].categories.Layout, _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].messageType.error);
            layoutGuide = IOSHelper.initLayoutGuide(controller);
        }
        const safeArea = layoutGuide.layoutFrame;
        let position = IOSHelper.getPositionFromFrame(safeArea);
        const safeAreaSize = safeArea.size;
        const hasChildViewControllers = controller.childViewControllers.count > 0;
        if (hasChildViewControllers) {
            const fullscreen = controller.view.frame;
            position = IOSHelper.getPositionFromFrame(fullscreen);
        }
        const safeAreaWidth = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(safeAreaSize.width));
        const safeAreaHeight = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(safeAreaSize.height));
        const widthSpec = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(safeAreaWidth, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        const heightSpec = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(safeAreaHeight, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        _view_helper_common__WEBPACK_IMPORTED_MODULE_0__[/* ViewHelper */ "a"].measureChild(null, owner, widthSpec, heightSpec);
        _view_helper_common__WEBPACK_IMPORTED_MODULE_0__[/* ViewHelper */ "a"].layoutChild(null, owner, position.left, position.top, position.right, position.bottom);
        if (owner.parent) {
            owner.parent._layoutParent();
        }
    }
    static getPositionFromFrame(frame) {
        const left = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(frame.origin.x));
        const top = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(frame.origin.y));
        const right = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(frame.origin.x + frame.size.width));
        const bottom = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(frame.origin.y + frame.size.height));
        return { left, right, top, bottom };
    }
    static getFrameFromPosition(position, insets) {
        insets = insets || { left: 0, top: 0, right: 0, bottom: 0 };
        const left = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(position.left + insets.left);
        const top = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(position.top + insets.top);
        const width = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(position.right - position.left - insets.left - insets.right);
        const height = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(position.bottom - position.top - insets.top - insets.bottom);
        return CGRectMake(left, top, width, height);
    }
    static shrinkToSafeArea(view, frame) {
        const insets = view.getSafeAreaInsets();
        if (insets.left || insets.top) {
            const position = IOSHelper.getPositionFromFrame(frame);
            const adjustedFrame = IOSHelper.getFrameFromPosition(position, insets);
            if (_trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].write(this + ' :shrinkToSafeArea: ' + JSON.stringify(IOSHelper.getPositionFromFrame(adjustedFrame)), _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].categories.Layout);
            }
            return adjustedFrame;
        }
        return null;
    }
    static expandBeyondSafeArea(view, frame) {
        const availableSpace = IOSHelper.getAvailableSpaceFromParent(view, frame);
        const safeArea = availableSpace.safeArea;
        const fullscreen = availableSpace.fullscreen;
        const inWindow = availableSpace.inWindow;
        const position = IOSHelper.getPositionFromFrame(frame);
        const safeAreaPosition = IOSHelper.getPositionFromFrame(safeArea);
        const fullscreenPosition = IOSHelper.getPositionFromFrame(fullscreen);
        const inWindowPosition = IOSHelper.getPositionFromFrame(inWindow);
        const adjustedPosition = position;
        if (position.left && inWindowPosition.left <= safeAreaPosition.left) {
            adjustedPosition.left = fullscreenPosition.left;
        }
        if (position.top && inWindowPosition.top <= safeAreaPosition.top) {
            adjustedPosition.top = fullscreenPosition.top;
        }
        if (inWindowPosition.right < fullscreenPosition.right && inWindowPosition.right >= safeAreaPosition.right + fullscreenPosition.left) {
            adjustedPosition.right += fullscreenPosition.right - inWindowPosition.right;
        }
        if (inWindowPosition.bottom < fullscreenPosition.bottom && inWindowPosition.bottom >= safeAreaPosition.bottom + fullscreenPosition.top) {
            adjustedPosition.bottom += fullscreenPosition.bottom - inWindowPosition.bottom;
        }
        const adjustedFrame = CGRectMake(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(adjustedPosition.left), _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(adjustedPosition.top), _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(adjustedPosition.right - adjustedPosition.left), _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(adjustedPosition.bottom - adjustedPosition.top));
        if (_trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].write(view + ' :expandBeyondSafeArea: ' + JSON.stringify(IOSHelper.getPositionFromFrame(adjustedFrame)), _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].categories.Layout);
        }
        return adjustedFrame;
    }
    static getAvailableSpaceFromParent(view, frame) {
        if (!view) {
            return;
        }
        let scrollView = null;
        let viewControllerView = null;
        if (view.viewController) {
            viewControllerView = view.viewController.view;
        }
        else {
            let parent = view.parent;
            while (parent && !parent.viewController && !(parent.nativeViewProtected instanceof UIScrollView)) {
                parent = parent.parent;
            }
            if (parent.nativeViewProtected instanceof UIScrollView) {
                scrollView = parent.nativeViewProtected;
            }
            else if (parent.viewController) {
                viewControllerView = parent.viewController.view;
            }
        }
        let fullscreen = null;
        let safeArea = null;
        if (viewControllerView) {
            safeArea = viewControllerView.safeAreaLayoutGuide.layoutFrame;
            fullscreen = viewControllerView.frame;
        }
        else if (scrollView) {
            const insets = scrollView.safeAreaInsets;
            safeArea = CGRectMake(insets.left, insets.top, scrollView.contentSize.width - insets.left - insets.right, scrollView.contentSize.height - insets.top - insets.bottom);
            fullscreen = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height);
        }
        const locationInWindow = view.getLocationInWindow();
        let inWindowLeft = locationInWindow.x;
        let inWindowTop = locationInWindow.y;
        if (scrollView) {
            inWindowLeft += scrollView.contentOffset.x;
            inWindowTop += scrollView.contentOffset.y;
        }
        const inWindow = CGRectMake(inWindowLeft, inWindowTop, frame.size.width, frame.size.height);
        return {
            safeArea: safeArea,
            fullscreen: fullscreen,
            inWindow: inWindow,
        };
    }
}
IOSHelper.traitCollectionColorAppearanceChangedEvent = 'traitCollectionColorAppearanceChanged';
IOSHelper.UILayoutViewController = UILayoutViewController;
IOSHelper.UIAdaptivePresentationControllerDelegateImp = UIAdaptivePresentationControllerDelegateImp;
IOSHelper.UIPopoverPresentationControllerDelegateImp = UIPopoverPresentationControllerDelegateImp;
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "iOSApplication", function() { return /* reexport */ application["iOSApplication"]; });
__webpack_require__.d(__webpack_exports__, "AndroidApplication", function() { return /* reexport */ application["AndroidApplication"]; });
__webpack_require__.d(__webpack_exports__, "Application", function() { return /* binding */ Application; });
__webpack_require__.d(__webpack_exports__, "ApplicationSettings", function() { return /* binding */ ApplicationSettings; });
__webpack_require__.d(__webpack_exports__, "Color", function() { return /* reexport */ color["a" /* Color */]; });
__webpack_require__.d(__webpack_exports__, "Connectivity", function() { return /* binding */ Connectivity; });
__webpack_require__.d(__webpack_exports__, "CSSUtils", function() { return /* reexport */ system_classes["a" /* CSSUtils */]; });
__webpack_require__.d(__webpack_exports__, "ObservableArray", function() { return /* reexport */ observable_array["ObservableArray"]; });
__webpack_require__.d(__webpack_exports__, "ChangeType", function() { return /* reexport */ observable_array["ChangeType"]; });
__webpack_require__.d(__webpack_exports__, "Observable", function() { return /* reexport */ observable["Observable"]; });
__webpack_require__.d(__webpack_exports__, "WrappedValue", function() { return /* reexport */ observable["WrappedValue"]; });
__webpack_require__.d(__webpack_exports__, "fromObject", function() { return /* reexport */ observable["fromObject"]; });
__webpack_require__.d(__webpack_exports__, "fromObjectRecursive", function() { return /* reexport */ observable["fromObjectRecursive"]; });
__webpack_require__.d(__webpack_exports__, "VirtualArray", function() { return /* reexport */ virtual_array_VirtualArray; });
__webpack_require__.d(__webpack_exports__, "File", function() { return /* reexport */ file_system["File"]; });
__webpack_require__.d(__webpack_exports__, "FileSystemEntity", function() { return /* reexport */ file_system["FileSystemEntity"]; });
__webpack_require__.d(__webpack_exports__, "Folder", function() { return /* reexport */ file_system["Folder"]; });
__webpack_require__.d(__webpack_exports__, "knownFolders", function() { return /* reexport */ file_system["knownFolders"]; });
__webpack_require__.d(__webpack_exports__, "path", function() { return /* reexport */ file_system["path"]; });
__webpack_require__.d(__webpack_exports__, "getFileAccess", function() { return /* reexport */ file_system["getFileAccess"]; });
__webpack_require__.d(__webpack_exports__, "Http", function() { return /* binding */ Http; });
__webpack_require__.d(__webpack_exports__, "ImageAsset", function() { return /* reexport */ image_asset["a" /* ImageAsset */]; });
__webpack_require__.d(__webpack_exports__, "ImageSource", function() { return /* reexport */ image_source["ImageSource"]; });
__webpack_require__.d(__webpack_exports__, "ModuleNameResolver", function() { return /* reexport */ module_name_resolver["a" /* ModuleNameResolver */]; });
__webpack_require__.d(__webpack_exports__, "_setResolver", function() { return /* reexport */ module_name_resolver["b" /* _setResolver */]; });
__webpack_require__.d(__webpack_exports__, "isAndroid", function() { return /* reexport */ platform["isAndroid"]; });
__webpack_require__.d(__webpack_exports__, "isIOS", function() { return /* reexport */ platform["isIOS"]; });
__webpack_require__.d(__webpack_exports__, "Screen", function() { return /* reexport */ platform["Screen"]; });
__webpack_require__.d(__webpack_exports__, "Device", function() { return /* reexport */ platform["Device"]; });
__webpack_require__.d(__webpack_exports__, "platformNames", function() { return /* reexport */ platform["platformNames"]; });
__webpack_require__.d(__webpack_exports__, "profile", function() { return /* reexport */ profiling["f" /* profile */]; });
__webpack_require__.d(__webpack_exports__, "profilingEnable", function() { return /* reexport */ profiling["c" /* enable */]; });
__webpack_require__.d(__webpack_exports__, "profilingDisable", function() { return /* reexport */ profiling["a" /* disable */]; });
__webpack_require__.d(__webpack_exports__, "profilingTime", function() { return /* reexport */ profiling["l" /* time */]; });
__webpack_require__.d(__webpack_exports__, "profilingUptime", function() { return /* reexport */ profiling["n" /* uptime */]; });
__webpack_require__.d(__webpack_exports__, "profilingStart", function() { return /* reexport */ profiling["h" /* start */]; });
__webpack_require__.d(__webpack_exports__, "profilingStop", function() { return /* reexport */ profiling["j" /* stop */]; });
__webpack_require__.d(__webpack_exports__, "profilingIsRunning", function() { return /* reexport */ profiling["d" /* isRunning */]; });
__webpack_require__.d(__webpack_exports__, "profilingDumpProfiles", function() { return /* reexport */ profiling["b" /* dumpProfiles */]; });
__webpack_require__.d(__webpack_exports__, "profilingResetProfiles", function() { return /* reexport */ profiling["g" /* resetProfiles */]; });
__webpack_require__.d(__webpack_exports__, "profilingStartCPU", function() { return /* reexport */ profiling["i" /* startCPUProfile */]; });
__webpack_require__.d(__webpack_exports__, "profilingStopCPU", function() { return /* reexport */ profiling["k" /* stopCPUProfile */]; });
__webpack_require__.d(__webpack_exports__, "encoding", function() { return /* reexport */ core_text["encoding"]; });
__webpack_require__.d(__webpack_exports__, "Trace", function() { return /* reexport */ trace["a" /* Trace */]; });
__webpack_require__.d(__webpack_exports__, "ActionBar", function() { return /* reexport */ ui["ActionBar"]; });
__webpack_require__.d(__webpack_exports__, "ActionItem", function() { return /* reexport */ ui["ActionItem"]; });
__webpack_require__.d(__webpack_exports__, "ActionItems", function() { return /* reexport */ ui["ActionItems"]; });
__webpack_require__.d(__webpack_exports__, "NavigationButton", function() { return /* reexport */ ui["NavigationButton"]; });
__webpack_require__.d(__webpack_exports__, "ActivityIndicator", function() { return /* reexport */ ui["ActivityIndicator"]; });
__webpack_require__.d(__webpack_exports__, "Animation", function() { return /* reexport */ ui["Animation"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeAnimation", function() { return /* reexport */ ui["KeyframeAnimation"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeAnimationInfo", function() { return /* reexport */ ui["KeyframeAnimationInfo"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeDeclaration", function() { return /* reexport */ ui["KeyframeDeclaration"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeInfo", function() { return /* reexport */ ui["KeyframeInfo"]; });
__webpack_require__.d(__webpack_exports__, "BottomNavigation", function() { return /* reexport */ ui["BottomNavigation"]; });
__webpack_require__.d(__webpack_exports__, "Builder", function() { return /* reexport */ ui["Builder"]; });
__webpack_require__.d(__webpack_exports__, "sanitizeModuleName", function() { return /* reexport */ ui["sanitizeModuleName"]; });
__webpack_require__.d(__webpack_exports__, "Button", function() { return /* reexport */ ui["Button"]; });
__webpack_require__.d(__webpack_exports__, "ContentView", function() { return /* reexport */ ui["ContentView"]; });
__webpack_require__.d(__webpack_exports__, "Binding", function() { return /* reexport */ ui["Binding"]; });
__webpack_require__.d(__webpack_exports__, "ControlStateChangeListener", function() { return /* reexport */ ui["ControlStateChangeListener"]; });
__webpack_require__.d(__webpack_exports__, "ViewBase", function() { return /* reexport */ ui["ViewBase"]; });
__webpack_require__.d(__webpack_exports__, "eachDescendant", function() { return /* reexport */ ui["eachDescendant"]; });
__webpack_require__.d(__webpack_exports__, "getAncestor", function() { return /* reexport */ ui["getAncestor"]; });
__webpack_require__.d(__webpack_exports__, "getViewById", function() { return /* reexport */ ui["getViewById"]; });
__webpack_require__.d(__webpack_exports__, "booleanConverter", function() { return /* reexport */ ui["booleanConverter"]; });
__webpack_require__.d(__webpack_exports__, "View", function() { return /* reexport */ ui["View"]; });
__webpack_require__.d(__webpack_exports__, "CSSType", function() { return /* reexport */ ui["CSSType"]; });
__webpack_require__.d(__webpack_exports__, "ContainerView", function() { return /* reexport */ ui["ContainerView"]; });
__webpack_require__.d(__webpack_exports__, "ViewHelper", function() { return /* reexport */ ui["ViewHelper"]; });
__webpack_require__.d(__webpack_exports__, "IOSHelper", function() { return /* reexport */ ui["IOSHelper"]; });
__webpack_require__.d(__webpack_exports__, "isUserInteractionEnabledProperty", function() { return /* reexport */ ui["isUserInteractionEnabledProperty"]; });
__webpack_require__.d(__webpack_exports__, "PseudoClassHandler", function() { return /* reexport */ ui["PseudoClassHandler"]; });
__webpack_require__.d(__webpack_exports__, "Property", function() { return /* reexport */ ui["Property"]; });
__webpack_require__.d(__webpack_exports__, "CoercibleProperty", function() { return /* reexport */ ui["CoercibleProperty"]; });
__webpack_require__.d(__webpack_exports__, "InheritedProperty", function() { return /* reexport */ ui["InheritedProperty"]; });
__webpack_require__.d(__webpack_exports__, "CssProperty", function() { return /* reexport */ ui["CssProperty"]; });
__webpack_require__.d(__webpack_exports__, "InheritedCssProperty", function() { return /* reexport */ ui["InheritedCssProperty"]; });
__webpack_require__.d(__webpack_exports__, "ShorthandProperty", function() { return /* reexport */ ui["ShorthandProperty"]; });
__webpack_require__.d(__webpack_exports__, "CssAnimationProperty", function() { return /* reexport */ ui["CssAnimationProperty"]; });
__webpack_require__.d(__webpack_exports__, "unsetValue", function() { return /* reexport */ ui["unsetValue"]; });
__webpack_require__.d(__webpack_exports__, "makeParser", function() { return /* reexport */ ui["makeParser"]; });
__webpack_require__.d(__webpack_exports__, "makeValidator", function() { return /* reexport */ ui["makeValidator"]; });
__webpack_require__.d(__webpack_exports__, "addWeakEventListener", function() { return /* reexport */ ui["addWeakEventListener"]; });
__webpack_require__.d(__webpack_exports__, "removeWeakEventListener", function() { return /* reexport */ ui["removeWeakEventListener"]; });
__webpack_require__.d(__webpack_exports__, "DatePicker", function() { return /* reexport */ ui["DatePicker"]; });
__webpack_require__.d(__webpack_exports__, "DialogStrings", function() { return /* reexport */ ui["DialogStrings"]; });
__webpack_require__.d(__webpack_exports__, "action", function() { return /* reexport */ ui["action"]; });
__webpack_require__.d(__webpack_exports__, "alert", function() { return /* reexport */ ui["alert"]; });
__webpack_require__.d(__webpack_exports__, "confirm", function() { return /* reexport */ ui["confirm"]; });
__webpack_require__.d(__webpack_exports__, "login", function() { return /* reexport */ ui["login"]; });
__webpack_require__.d(__webpack_exports__, "prompt", function() { return /* reexport */ ui["prompt"]; });
__webpack_require__.d(__webpack_exports__, "getCurrentPage", function() { return /* reexport */ ui["getCurrentPage"]; });
__webpack_require__.d(__webpack_exports__, "Dialogs", function() { return /* reexport */ ui["Dialogs"]; });
__webpack_require__.d(__webpack_exports__, "inputType", function() { return /* reexport */ ui["inputType"]; });
__webpack_require__.d(__webpack_exports__, "capitalizationType", function() { return /* reexport */ ui["capitalizationType"]; });
__webpack_require__.d(__webpack_exports__, "placeholderColorProperty", function() { return /* reexport */ ui["placeholderColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "keyboardTypeProperty", function() { return /* reexport */ ui["keyboardTypeProperty"]; });
__webpack_require__.d(__webpack_exports__, "returnKeyTypeProperty", function() { return /* reexport */ ui["returnKeyTypeProperty"]; });
__webpack_require__.d(__webpack_exports__, "editableProperty", function() { return /* reexport */ ui["editableProperty"]; });
__webpack_require__.d(__webpack_exports__, "updateTextTriggerProperty", function() { return /* reexport */ ui["updateTextTriggerProperty"]; });
__webpack_require__.d(__webpack_exports__, "autocapitalizationTypeProperty", function() { return /* reexport */ ui["autocapitalizationTypeProperty"]; });
__webpack_require__.d(__webpack_exports__, "autocorrectProperty", function() { return /* reexport */ ui["autocorrectProperty"]; });
__webpack_require__.d(__webpack_exports__, "hintProperty", function() { return /* reexport */ ui["hintProperty"]; });
__webpack_require__.d(__webpack_exports__, "maxLengthProperty", function() { return /* reexport */ ui["maxLengthProperty"]; });
__webpack_require__.d(__webpack_exports__, "EditableTextBase", function() { return /* reexport */ ui["EditableTextBase"]; });
__webpack_require__.d(__webpack_exports__, "_updateCharactersInRangeReplacementString", function() { return /* reexport */ ui["_updateCharactersInRangeReplacementString"]; });
__webpack_require__.d(__webpack_exports__, "Enums", function() { return /* reexport */ ui["Enums"]; });
__webpack_require__.d(__webpack_exports__, "Frame", function() { return /* reexport */ ui["Frame"]; });
__webpack_require__.d(__webpack_exports__, "setActivityCallbacks", function() { return /* reexport */ ui["setActivityCallbacks"]; });
__webpack_require__.d(__webpack_exports__, "GesturesObserver", function() { return /* reexport */ ui["GesturesObserver"]; });
__webpack_require__.d(__webpack_exports__, "TouchAction", function() { return /* reexport */ ui["TouchAction"]; });
__webpack_require__.d(__webpack_exports__, "GestureTypes", function() { return /* reexport */ ui["GestureTypes"]; });
__webpack_require__.d(__webpack_exports__, "GestureStateTypes", function() { return /* reexport */ ui["GestureStateTypes"]; });
__webpack_require__.d(__webpack_exports__, "SwipeDirection", function() { return /* reexport */ ui["SwipeDirection"]; });
__webpack_require__.d(__webpack_exports__, "HtmlView", function() { return /* reexport */ ui["HtmlView"]; });
__webpack_require__.d(__webpack_exports__, "Image", function() { return /* reexport */ ui["Image"]; });
__webpack_require__.d(__webpack_exports__, "ImageCache", function() { return /* reexport */ ui["ImageCache"]; });
__webpack_require__.d(__webpack_exports__, "Label", function() { return /* reexport */ ui["Label"]; });
__webpack_require__.d(__webpack_exports__, "AbsoluteLayout", function() { return /* reexport */ ui["AbsoluteLayout"]; });
__webpack_require__.d(__webpack_exports__, "DockLayout", function() { return /* reexport */ ui["DockLayout"]; });
__webpack_require__.d(__webpack_exports__, "FlexboxLayout", function() { return /* reexport */ ui["FlexboxLayout"]; });
__webpack_require__.d(__webpack_exports__, "GridLayout", function() { return /* reexport */ ui["GridLayout"]; });
__webpack_require__.d(__webpack_exports__, "GridUnitType", function() { return /* reexport */ ui["GridUnitType"]; });
__webpack_require__.d(__webpack_exports__, "ItemSpec", function() { return /* reexport */ ui["ItemSpec"]; });
__webpack_require__.d(__webpack_exports__, "StackLayout", function() { return /* reexport */ ui["StackLayout"]; });
__webpack_require__.d(__webpack_exports__, "WrapLayout", function() { return /* reexport */ ui["WrapLayout"]; });
__webpack_require__.d(__webpack_exports__, "LayoutBase", function() { return /* reexport */ ui["LayoutBase"]; });
__webpack_require__.d(__webpack_exports__, "ListPicker", function() { return /* reexport */ ui["ListPicker"]; });
__webpack_require__.d(__webpack_exports__, "ListView", function() { return /* reexport */ ui["ListView"]; });
__webpack_require__.d(__webpack_exports__, "Page", function() { return /* reexport */ ui["Page"]; });
__webpack_require__.d(__webpack_exports__, "PageBase", function() { return /* reexport */ ui["PageBase"]; });
__webpack_require__.d(__webpack_exports__, "Placeholder", function() { return /* reexport */ ui["Placeholder"]; });
__webpack_require__.d(__webpack_exports__, "Progress", function() { return /* reexport */ ui["Progress"]; });
__webpack_require__.d(__webpack_exports__, "ProxyViewContainer", function() { return /* reexport */ ui["ProxyViewContainer"]; });
__webpack_require__.d(__webpack_exports__, "Repeater", function() { return /* reexport */ ui["Repeater"]; });
__webpack_require__.d(__webpack_exports__, "ScrollView", function() { return /* reexport */ ui["ScrollView"]; });
__webpack_require__.d(__webpack_exports__, "SearchBar", function() { return /* reexport */ ui["SearchBar"]; });
__webpack_require__.d(__webpack_exports__, "SegmentedBar", function() { return /* reexport */ ui["SegmentedBar"]; });
__webpack_require__.d(__webpack_exports__, "SegmentedBarItem", function() { return /* reexport */ ui["SegmentedBarItem"]; });
__webpack_require__.d(__webpack_exports__, "Slider", function() { return /* reexport */ ui["Slider"]; });
__webpack_require__.d(__webpack_exports__, "addTaggedAdditionalCSS", function() { return /* reexport */ ui["addTaggedAdditionalCSS"]; });
__webpack_require__.d(__webpack_exports__, "removeTaggedAdditionalCSS", function() { return /* reexport */ ui["removeTaggedAdditionalCSS"]; });
__webpack_require__.d(__webpack_exports__, "resolveFileNameFromUrl", function() { return /* reexport */ ui["resolveFileNameFromUrl"]; });
__webpack_require__.d(__webpack_exports__, "Background", function() { return /* reexport */ ui["Background"]; });
__webpack_require__.d(__webpack_exports__, "animationTimingFunctionConverter", function() { return /* reexport */ ui["animationTimingFunctionConverter"]; });
__webpack_require__.d(__webpack_exports__, "timeConverter", function() { return /* reexport */ ui["timeConverter"]; });
__webpack_require__.d(__webpack_exports__, "Font", function() { return /* reexport */ ui["Font"]; });
__webpack_require__.d(__webpack_exports__, "Style", function() { return /* reexport */ ui["Style"]; });
__webpack_require__.d(__webpack_exports__, "PercentLength", function() { return /* reexport */ ui["PercentLength"]; });
__webpack_require__.d(__webpack_exports__, "Length", function() { return /* reexport */ ui["Length"]; });
__webpack_require__.d(__webpack_exports__, "zeroLength", function() { return /* reexport */ ui["zeroLength"]; });
__webpack_require__.d(__webpack_exports__, "minWidthProperty", function() { return /* reexport */ ui["minWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "minHeightProperty", function() { return /* reexport */ ui["minHeightProperty"]; });
__webpack_require__.d(__webpack_exports__, "widthProperty", function() { return /* reexport */ ui["widthProperty"]; });
__webpack_require__.d(__webpack_exports__, "heightProperty", function() { return /* reexport */ ui["heightProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginLeftProperty", function() { return /* reexport */ ui["marginLeftProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginRightProperty", function() { return /* reexport */ ui["marginRightProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginTopProperty", function() { return /* reexport */ ui["marginTopProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginBottomProperty", function() { return /* reexport */ ui["marginBottomProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingLeftProperty", function() { return /* reexport */ ui["paddingLeftProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingRightProperty", function() { return /* reexport */ ui["paddingRightProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingTopProperty", function() { return /* reexport */ ui["paddingTopProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingBottomProperty", function() { return /* reexport */ ui["paddingBottomProperty"]; });
__webpack_require__.d(__webpack_exports__, "HorizontalAlignment", function() { return /* reexport */ ui["HorizontalAlignment"]; });
__webpack_require__.d(__webpack_exports__, "horizontalAlignmentProperty", function() { return /* reexport */ ui["horizontalAlignmentProperty"]; });
__webpack_require__.d(__webpack_exports__, "VerticalAlignment", function() { return /* reexport */ ui["VerticalAlignment"]; });
__webpack_require__.d(__webpack_exports__, "verticalAlignmentProperty", function() { return /* reexport */ ui["verticalAlignmentProperty"]; });
__webpack_require__.d(__webpack_exports__, "rotateProperty", function() { return /* reexport */ ui["rotateProperty"]; });
__webpack_require__.d(__webpack_exports__, "rotateXProperty", function() { return /* reexport */ ui["rotateXProperty"]; });
__webpack_require__.d(__webpack_exports__, "rotateYProperty", function() { return /* reexport */ ui["rotateYProperty"]; });
__webpack_require__.d(__webpack_exports__, "perspectiveProperty", function() { return /* reexport */ ui["perspectiveProperty"]; });
__webpack_require__.d(__webpack_exports__, "scaleXProperty", function() { return /* reexport */ ui["scaleXProperty"]; });
__webpack_require__.d(__webpack_exports__, "scaleYProperty", function() { return /* reexport */ ui["scaleYProperty"]; });
__webpack_require__.d(__webpack_exports__, "translateXProperty", function() { return /* reexport */ ui["translateXProperty"]; });
__webpack_require__.d(__webpack_exports__, "translateYProperty", function() { return /* reexport */ ui["translateYProperty"]; });
__webpack_require__.d(__webpack_exports__, "transformConverter", function() { return /* reexport */ ui["transformConverter"]; });
__webpack_require__.d(__webpack_exports__, "backgroundInternalProperty", function() { return /* reexport */ ui["backgroundInternalProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundImageProperty", function() { return /* reexport */ ui["backgroundImageProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundColorProperty", function() { return /* reexport */ ui["backgroundColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "BackgroundRepeat", function() { return /* reexport */ ui["BackgroundRepeat"]; });
__webpack_require__.d(__webpack_exports__, "backgroundRepeatProperty", function() { return /* reexport */ ui["backgroundRepeatProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundSizeProperty", function() { return /* reexport */ ui["backgroundSizeProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundPositionProperty", function() { return /* reexport */ ui["backgroundPositionProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopColorProperty", function() { return /* reexport */ ui["borderTopColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderRightColorProperty", function() { return /* reexport */ ui["borderRightColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomColorProperty", function() { return /* reexport */ ui["borderBottomColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderLeftColorProperty", function() { return /* reexport */ ui["borderLeftColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopWidthProperty", function() { return /* reexport */ ui["borderTopWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderRightWidthProperty", function() { return /* reexport */ ui["borderRightWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomWidthProperty", function() { return /* reexport */ ui["borderBottomWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderLeftWidthProperty", function() { return /* reexport */ ui["borderLeftWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopLeftRadiusProperty", function() { return /* reexport */ ui["borderTopLeftRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopRightRadiusProperty", function() { return /* reexport */ ui["borderTopRightRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomRightRadiusProperty", function() { return /* reexport */ ui["borderBottomRightRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomLeftRadiusProperty", function() { return /* reexport */ ui["borderBottomLeftRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "clipPathProperty", function() { return /* reexport */ ui["clipPathProperty"]; });
__webpack_require__.d(__webpack_exports__, "zIndexProperty", function() { return /* reexport */ ui["zIndexProperty"]; });
__webpack_require__.d(__webpack_exports__, "opacityProperty", function() { return /* reexport */ ui["opacityProperty"]; });
__webpack_require__.d(__webpack_exports__, "colorProperty", function() { return /* reexport */ ui["colorProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontInternalProperty", function() { return /* reexport */ ui["fontInternalProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontFamilyProperty", function() { return /* reexport */ ui["fontFamilyProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontSizeProperty", function() { return /* reexport */ ui["fontSizeProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontStyleProperty", function() { return /* reexport */ ui["fontStyleProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontWeightProperty", function() { return /* reexport */ ui["fontWeightProperty"]; });
__webpack_require__.d(__webpack_exports__, "Visibility", function() { return /* reexport */ ui["Visibility"]; });
__webpack_require__.d(__webpack_exports__, "visibilityProperty", function() { return /* reexport */ ui["visibilityProperty"]; });
__webpack_require__.d(__webpack_exports__, "androidElevationProperty", function() { return /* reexport */ ui["androidElevationProperty"]; });
__webpack_require__.d(__webpack_exports__, "androidDynamicElevationOffsetProperty", function() { return /* reexport */ ui["androidDynamicElevationOffsetProperty"]; });
__webpack_require__.d(__webpack_exports__, "CssAnimationParser", function() { return /* reexport */ ui["CssAnimationParser"]; });
__webpack_require__.d(__webpack_exports__, "parseKeyframeDeclarations", function() { return /* reexport */ ui["parseKeyframeDeclarations"]; });
__webpack_require__.d(__webpack_exports__, "CSSHelper", function() { return /* reexport */ ui["CSSHelper"]; });
__webpack_require__.d(__webpack_exports__, "Switch", function() { return /* reexport */ ui["Switch"]; });
__webpack_require__.d(__webpack_exports__, "TabContentItem", function() { return /* reexport */ ui["TabContentItem"]; });
__webpack_require__.d(__webpack_exports__, "TabNavigationBase", function() { return /* reexport */ ui["TabNavigationBase"]; });
__webpack_require__.d(__webpack_exports__, "getIconSpecSize", function() { return /* reexport */ ui["getIconSpecSize"]; });
__webpack_require__.d(__webpack_exports__, "tabStripProperty", function() { return /* reexport */ ui["tabStripProperty"]; });
__webpack_require__.d(__webpack_exports__, "TabStrip", function() { return /* reexport */ ui["TabStrip"]; });
__webpack_require__.d(__webpack_exports__, "TabStripItem", function() { return /* reexport */ ui["TabStripItem"]; });
__webpack_require__.d(__webpack_exports__, "TabView", function() { return /* reexport */ ui["TabView"]; });
__webpack_require__.d(__webpack_exports__, "TabViewItem", function() { return /* reexport */ ui["TabViewItem"]; });
__webpack_require__.d(__webpack_exports__, "Tabs", function() { return /* reexport */ ui["Tabs"]; });
__webpack_require__.d(__webpack_exports__, "TextBase", function() { return /* reexport */ ui["TextBase"]; });
__webpack_require__.d(__webpack_exports__, "getTransformedText", function() { return /* reexport */ ui["getTransformedText"]; });
__webpack_require__.d(__webpack_exports__, "letterSpacingProperty", function() { return /* reexport */ ui["letterSpacingProperty"]; });
__webpack_require__.d(__webpack_exports__, "textAlignmentProperty", function() { return /* reexport */ ui["textAlignmentProperty"]; });
__webpack_require__.d(__webpack_exports__, "textDecorationProperty", function() { return /* reexport */ ui["textDecorationProperty"]; });
__webpack_require__.d(__webpack_exports__, "textTransformProperty", function() { return /* reexport */ ui["textTransformProperty"]; });
__webpack_require__.d(__webpack_exports__, "whiteSpaceProperty", function() { return /* reexport */ ui["whiteSpaceProperty"]; });
__webpack_require__.d(__webpack_exports__, "lineHeightProperty", function() { return /* reexport */ ui["lineHeightProperty"]; });
__webpack_require__.d(__webpack_exports__, "FormattedString", function() { return /* reexport */ ui["FormattedString"]; });
__webpack_require__.d(__webpack_exports__, "Span", function() { return /* reexport */ ui["Span"]; });
__webpack_require__.d(__webpack_exports__, "TextField", function() { return /* reexport */ ui["TextField"]; });
__webpack_require__.d(__webpack_exports__, "TextView", function() { return /* reexport */ ui["TextView"]; });
__webpack_require__.d(__webpack_exports__, "TimePicker", function() { return /* reexport */ ui["TimePicker"]; });
__webpack_require__.d(__webpack_exports__, "Transition", function() { return /* reexport */ ui["Transition"]; });
__webpack_require__.d(__webpack_exports__, "WebView", function() { return /* reexport */ ui["WebView"]; });
__webpack_require__.d(__webpack_exports__, "Utils", function() { return /* binding */ Utils; });
__webpack_require__.d(__webpack_exports__, "XmlParser", function() { return /* reexport */ xml["c" /* XmlParser */]; });
__webpack_require__.d(__webpack_exports__, "ParserEventType", function() { return /* reexport */ xml["b" /* ParserEventType */]; });
__webpack_require__.d(__webpack_exports__, "ParserEvent", function() { return /* reexport */ xml["a" /* ParserEvent */]; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/globals/index.js
var globals = __webpack_require__(75);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/application/index.js
var application = __webpack_require__(30);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/application/application-common.js
var application_common = __webpack_require__(57);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/application-settings/index.js + 1 modules
var application_settings = __webpack_require__(45);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/color/index.js + 2 modules
var color = __webpack_require__(6);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/connectivity/index.js
var connectionType;
(function (connectionType) {
    connectionType[connectionType["none"] = 0] = "none";
    connectionType[connectionType["wifi"] = 1] = "wifi";
    connectionType[connectionType["mobile"] = 2] = "mobile";
    connectionType[connectionType["ethernet"] = 3] = "ethernet";
    connectionType[connectionType["bluetooth"] = 4] = "bluetooth";
    connectionType[connectionType["vpn"] = 5] = "vpn";
})(connectionType || (connectionType = {}));
function _createReachability(host) {
    if (host) {
        return SCNetworkReachabilityCreateWithName(null, host);
    }
    else {
        const zeroAddress = new interop.Reference(sockaddr, {
            sa_len: 16,
            sa_family: 2,
        });
        return SCNetworkReachabilityCreateWithAddress(null, zeroAddress);
    }
}
function _getReachabilityFlags(host) {
    const reachability = _createReachability(host);
    const flagsRef = new interop.Reference();
    const gotFlags = SCNetworkReachabilityGetFlags(reachability, flagsRef);
    if (!gotFlags) {
        return null;
    }
    return flagsRef.value;
}
function _getConnectionType(host) {
    const flags = _getReachabilityFlags(host);
    return _getConnectionTypeFromFlags(flags);
}
function _getConnectionTypeFromFlags(flags) {
    if (!flags) {
        return connectionType.none;
    }
    const isReachable = flags & 2 /* kSCNetworkReachabilityFlagsReachable */;
    const connectionRequired = flags & 4 /* kSCNetworkReachabilityFlagsConnectionRequired */;
    if (!isReachable || connectionRequired) {
        return connectionType.none;
    }
    const isWWAN = flags & 262144 /* kSCNetworkReachabilityFlagsIsWWAN */;
    if (isWWAN) {
        return connectionType.mobile;
    }
    let keys;
    if (typeof CFNetworkCopySystemProxySettings !== 'undefined') {
        const cfDict = CFNetworkCopySystemProxySettings();
        // Only works on iOS device so guarded to help Simulator testing
        if (cfDict && cfDict.takeUnretainedValue) {
            const nsDict = cfDict.takeUnretainedValue();
            keys = nsDict.objectForKey('__SCOPED__');
        }
    }
    if (isVPNConnected(keys)) {
        return connectionType.vpn;
    }
    /*
    TODO try improving with CBCentralManager since toggling bluetooth
      with multiple connections fails to detect switch, require key added
      to Info.plist.
     */
    if (isBluetoothConnected(keys)) {
        return connectionType.bluetooth;
    }
    return connectionType.wifi;
}
function isBluetoothConnected(keys) {
    if (!keys) {
        return false;
    }
    const allKeys = keys.allKeys;
    const size = allKeys.count;
    let isBlueTooth = false;
    for (let i = 0; i < size; i++) {
        const key = allKeys.objectAtIndex(i);
        if (key === 'en4') {
            isBlueTooth = true;
            break;
        }
    }
    return isBlueTooth;
}
function isVPNConnected(keys) {
    if (!keys) {
        return false;
    }
    const allKeys = keys.allKeys;
    const size = allKeys.count;
    let isVPN = false;
    for (let i = 0; i < size; i++) {
        const key = allKeys.objectAtIndex(i);
        if (key === 'tap' || key === 'tun' || key === 'ppp' || key === 'ipsec' || key === 'ipsec0' || key === 'utun1') {
            isVPN = true;
            break;
        }
    }
    return isVPN;
}
function getConnectionType() {
    return _getConnectionType();
}
// Start/Stop Monitoring
function _reachabilityCallback(target, flags, info) {
    if (_connectionTypeChangedCallback) {
        const newConnectionType = _getConnectionTypeFromFlags(flags);
        _connectionTypeChangedCallback(newConnectionType);
    }
}
const _reachabilityCallbackFunctionRef = new interop.FunctionReference(_reachabilityCallback);
let _monitorReachabilityRef;
let _connectionTypeChangedCallback;
function startMonitoring(connectionTypeChangedCallback) {
    if (!_monitorReachabilityRef) {
        _monitorReachabilityRef = _createReachability();
        _connectionTypeChangedCallback = zonedCallback(connectionTypeChangedCallback);
        SCNetworkReachabilitySetCallback(_monitorReachabilityRef, _reachabilityCallbackFunctionRef, null);
        SCNetworkReachabilityScheduleWithRunLoop(_monitorReachabilityRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        _connectionTypeChangedCallback(_getConnectionType());
    }
}
function stopMonitoring() {
    if (_monitorReachabilityRef) {
        SCNetworkReachabilityUnscheduleFromRunLoop(_monitorReachabilityRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        _monitorReachabilityRef = undefined;
        _connectionTypeChangedCallback = undefined;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/css/system-classes.js
var system_classes = __webpack_require__(24);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable-array/index.js
var observable_array = __webpack_require__(14);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable/index.js
var observable = __webpack_require__(5);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/data/virtual-array/index.js


/**
 * Advanced array like class that helps loading items on demand.
 */
class virtual_array_VirtualArray extends observable["Observable"] {
    constructor(length = 0) {
        super();
        this._length = length;
        this._cache = {};
        this._requestedIndexes = [];
        this._loadedIndexes = [];
    }
    /**
     * Gets or sets length for the virtual array.
     */
    get length() {
        return this._length;
    }
    set length(value) {
        if (this._length !== value) {
            const index = this._length;
            const count = value - this._length;
            this._length = value;
            this.notify({
                eventName: observable_array["ChangeType"].Change,
                object: this,
                action: count > 0 ? observable_array["ChangeType"].Add : observable_array["ChangeType"].Delete,
                index: index,
                removed: new Array(count < 0 ? Math.abs(count) : 0),
                addedCount: count > 0 ? count : 0,
            });
        }
    }
    get loadSize() {
        return this._loadSize;
    }
    set loadSize(value) {
        this._loadSize = value;
    }
    getItem(index) {
        const item = this._cache[index];
        if (item === undefined) {
            if (index >= 0 && index < this.length && this._requestedIndexes.indexOf(index) < 0 && this._loadedIndexes.indexOf(index) < 0) {
                this.requestItems(index);
            }
        }
        return item;
    }
    setItem(index, value) {
        if (this._cache[index] !== value) {
            this.load(index, [value]);
        }
    }
    /**
     * Loads items from an array starting at index.
     */
    load(index, items) {
        for (let i = 0; i < items.length; i++) {
            const itemIndex = index + i;
            this._cache[itemIndex] = items[i];
            this._requestedIndexes.splice(this._requestedIndexes.indexOf(itemIndex), 1);
            if (this._loadedIndexes.indexOf(itemIndex) < 0) {
                this._loadedIndexes.push(itemIndex);
            }
        }
        // Remove requested but never loaded indexes.
        if (this._requestedIndexes.length > 0) {
            for (let i = 0; i < this.loadSize - items.length; i++) {
                this._requestedIndexes.splice(this._requestedIndexes.indexOf(index + i), 1);
            }
        }
        this.notify({
            eventName: observable_array["ChangeType"].Change,
            object: this,
            action: observable_array["ChangeType"].Update,
            index: index,
            removed: new Array(items.length),
            addedCount: items.length,
        });
    }
    requestItems(index) {
        const indexesToLoad = [];
        const pageIndex = this._loadSize > 0 ? this._loadSize * Math.floor(index / this._loadSize) : index;
        let count = 0;
        let start = -1;
        for (let i = 0; i < this.loadSize; i++) {
            const itemIndex = pageIndex + i;
            if (itemIndex >= this._length) {
                break;
            }
            if (this._loadedIndexes.indexOf(itemIndex) < 0) {
                if (start < 0) {
                    start = itemIndex;
                }
                indexesToLoad.push(itemIndex);
                if (this._requestedIndexes.indexOf(itemIndex) < 0) {
                    this._requestedIndexes.push(itemIndex);
                }
                count++;
            }
            else {
                if (count > 0) {
                    this.notify({
                        eventName: virtual_array_VirtualArray.itemsLoadingEvent,
                        object: this,
                        index: start,
                        count: count,
                    });
                }
                start = -1;
                count = 0;
            }
        }
        if (start >= 0 && count > 0) {
            this.notify({
                eventName: virtual_array_VirtualArray.itemsLoadingEvent,
                object: this,
                index: start,
                count: count,
            });
        }
    }
}
/**
 * String value used when hooking to change event.
 */
virtual_array_VirtualArray.changeEvent = observable_array["ChangeType"].Change;
/**
 * String value used when hooking to itemsLoading event.
 */
virtual_array_VirtualArray.itemsLoadingEvent = 'itemsLoading';
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/file-system/index.js + 1 modules
var file_system = __webpack_require__(21);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/http/index.js
var http = __webpack_require__(18);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/http/http-request/index.js + 1 modules
var http_request = __webpack_require__(55);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/image-asset/index.js + 1 modules
var image_asset = __webpack_require__(88);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/image-source/index.js + 1 modules
var image_source = __webpack_require__(25);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/module-name-resolver/index.js
var module_name_resolver = __webpack_require__(36);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/platform/index.js
var platform = __webpack_require__(13);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/profiling/index.js
var profiling = __webpack_require__(9);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/text/index.js + 1 modules
var core_text = __webpack_require__(61);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/timer/index.js
var timer = __webpack_require__(74);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/trace/index.js
var trace = __webpack_require__(0);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/index.js + 54 modules
var ui = __webpack_require__(87);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/index.js
var utils = __webpack_require__(19);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/mainthread-helper.js
var mainthread_helper = __webpack_require__(77);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/native-helper.js
var native_helper = __webpack_require__(38);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/debug.js
var debug = __webpack_require__(41);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/types.js
var types = __webpack_require__(10);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/xml/index.js
var xml = __webpack_require__(44);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/index.js
/// <reference path="./global-types.d.ts" />
// Init globals first (use import to ensure it's always at the top)



const Application = {
    launchEvent: application_common["launchEvent"],
    displayedEvent: application_common["displayedEvent"],
    uncaughtErrorEvent: application_common["uncaughtErrorEvent"],
    discardedErrorEvent: application_common["discardedErrorEvent"],
    suspendEvent: application_common["suspendEvent"],
    resumeEvent: application_common["resumeEvent"],
    exitEvent: application_common["exitEvent"],
    lowMemoryEvent: application_common["lowMemoryEvent"],
    orientationChangedEvent: application_common["orientationChangedEvent"],
    systemAppearanceChangedEvent: application_common["systemAppearanceChangedEvent"],
    systemAppearanceChanged: application_common["systemAppearanceChanged"],
    getMainEntry: application["getMainEntry"],
    getRootView: application["getRootView"],
    resetRootView: application["_resetRootView"],
    getResources: application_common["getResources"],
    setResources: application_common["setResources"],
    setCssFileName: application_common["setCssFileName"],
    getCssFileName: application_common["getCssFileName"],
    loadAppCss: application_common["loadAppCss"],
    addCss: application["addCss"],
    on: application_common["on"],
    off: application_common["off"],
    notify: application_common["notify"],
    hasListeners: application_common["hasListeners"],
    run: application["run"],
    orientation: application["orientation"],
    getNativeApplication: application["getNativeApplication"],
    hasLaunched: application_common["hasLaunched"],
    systemAppearance: application["systemAppearance"],
    android: application_common["android"],
    ios: application["ios"],
};
// Export all methods from "application-settings" as ApplicationSettings

const ApplicationSettings = {
    clear: application_settings["clear"],
    flush: application_settings["flush"],
    hasKey: application_settings["hasKey"],
    remove: application_settings["remove"],
    setString: application_settings["setString"],
    getString: application_settings["getString"],
    getAllKeys: application_settings["getAllKeys"],
    getBoolean: application_settings["getBoolean"],
    setBoolean: application_settings["setBoolean"],
    getNumber: application_settings["getNumber"],
    setNumber: application_settings["setNumber"],
};


const Connectivity = {
    connectionType: connectionType,
    getConnectionType: getConnectionType,
    startMonitoring: startMonitoring,
    stopMonitoring: stopMonitoring,
};





// Export all methods from "http" as Http

const Http = {
    getFile: http["getFile"],
    getImage: http["getImage"],
    getJSON: http["getJSON"],
    getString: http["getString"],
    request: http_request["request"],
};




// Profiling


// for developers to be explicit if they desire around globals (allows access via Utils below)





const Utils = {
    GC: utils["b" /* GC */],
    RESOURCE_PREFIX: utils_common["b" /* RESOURCE_PREFIX */],
    FILE_PREFIX: utils_common["a" /* FILE_PREFIX */],
    isFontIconURI: utils_common["l" /* isFontIconURI */],
    isDataURI: utils_common["j" /* isDataURI */],
    isFileOrResourcePath: utils_common["k" /* isFileOrResourcePath */],
    executeOnMainThread: utils_common["g" /* executeOnMainThread */],
    mainThreadify: utils_common["o" /* mainThreadify */],
    isMainThread: mainthread_helper["b" /* isMainThread */],
    dispatchToMainThread: mainthread_helper["a" /* dispatchToMainThread */],
    releaseNativeObject: utils["y" /* releaseNativeObject */],
    getModuleName: utils_common["h" /* getModuleName */],
    openFile: utils["w" /* openFile */],
    openUrl: utils["x" /* openUrl */],
    isRealDevice: utils["r" /* isRealDevice */],
    layout: utils_common["n" /* layout */],
    android: utils["e" /* ad */],
    // legacy (a lot of plugins use the shorthand "ad" Utils.ad instead of Utils.android)
    ad: utils["e" /* ad */],
    ios: native_helper["a" /* iOSNativeHelper */],
    setTimeout: timer["setTimeout"],
    setInterval: timer["setInterval"],
    clearInterval: timer["clearInterval"],
    clearTimeout: timer["clearTimeout"],
    Source: debug["Source"],
    ClassInfo: types["a" /* ClassInfo */],
    getClass: types["c" /* getClass */],
    getBaseClasses: types["b" /* getBaseClasses */],
    getClassInfo: types["d" /* getClassInfo */],
    isBoolean: types["e" /* isBoolean */],
    isDefined: types["f" /* isDefined */],
    isFunction: types["g" /* isFunction */],
    isNullOrUndefined: types["h" /* isNullOrUndefined */],
    isNumber: types["i" /* isNumber */],
    isObject: types["j" /* isObject */],
    isString: types["k" /* isString */],
    isUndefined: types["l" /* isUndefined */],
    toUIString: types["m" /* toUIString */],
    verifyCallback: types["n" /* verifyCallback */],
};

//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iOSApplication", function() { return iOSApplication; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ios", function() { return iosApp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMainEntry", function() { return getMainEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRootView", function() { return getRootView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCss", function() { return addCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_resetRootView", function() { return _resetRootView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNativeApplication", function() { return getNativeApplication; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientation", function() { return orientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "systemAppearance", function() { return systemAppearance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AndroidApplication", function() { return AndroidApplication; });
/* harmony import */ var _application_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasLaunched", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["hasLaunched"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "launchEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["launchEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "suspendEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["suspendEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "displayedEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["displayedEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resumeEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["resumeEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exitEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["exitEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lowMemoryEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["lowMemoryEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uncaughtErrorEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["uncaughtErrorEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "discardedErrorEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["discardedErrorEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "orientationChangedEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["orientationChangedEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "systemAppearanceChangedEvent", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["systemAppearanceChangedEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getResources", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["getResources"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setResources", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["setResources"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "android", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["android"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "on", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["on"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "off", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["off"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notify", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["notify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasListeners", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["hasListeners"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setApplication", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["setApplication"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "livesync", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["livesync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setCssFileName", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["setCssFileName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCssFileName", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["getCssFileName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadAppCss", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["loadAppCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "orientationChanged", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["orientationChanged"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autoSystemAppearanceChanged", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["autoSystemAppearanceChanged"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setAutoSystemAppearanceChanged", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["setAutoSystemAppearanceChanged"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "systemAppearanceChanged", function() { return _application_common__WEBPACK_IMPORTED_MODULE_0__["systemAppearanceChanged"]; });

/* harmony import */ var _ui_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _css_system_classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _ui_core_view_view_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38);
// Use requires to ensure order of imports is maintained
const { displayedEvent, exitEvent, getCssFileName, launchEvent, livesync, lowMemoryEvent, notify, on, orientationChanged, orientationChangedEvent, resumeEvent, setApplication, suspendEvent, systemAppearanceChanged, systemAppearanceChangedEvent } = __webpack_require__(57);
// First reexport so that app module is initialized.

// TODO: Remove this and get it from global to decouple builder for angular






const IOS_PLATFORM = 'ios';
const getVisibleViewController = _utils__WEBPACK_IMPORTED_MODULE_6__[/* iOSNativeHelper */ "a"].getVisibleViewController;
const majorVersion = _utils__WEBPACK_IMPORTED_MODULE_6__[/* iOSNativeHelper */ "a"].MajorVersion;
// NOTE: UIResponder with implementation of window - related to https://github.com/NativeScript/ios-runtime/issues/430
// TODO: Refactor the UIResponder to use Typescript extends when this issue is resolved:
// https://github.com/NativeScript/ios-runtime/issues/1012
const Responder = UIResponder.extend({
    get window() {
        return iosApp ? iosApp.window : undefined;
    },
    set window(setWindow) {
        // NOOP
    },
}, {
    protocols: [UIApplicationDelegate],
});
var NotificationObserver = /** @class */ (function (_super) {
    __extends(NotificationObserver, _super);
    function NotificationObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NotificationObserver.initWithCallback = function (onReceiveCallback) {
        var observer = _super.new.call(this);
        observer._onReceiveCallback = onReceiveCallback;
        return observer;
    };
    NotificationObserver.prototype.onReceive = function (notification) {
        this._onReceiveCallback(notification);
    };
    NotificationObserver.ObjCExposedMethods = {
        onReceive: { returns: interop.types.void, params: [NSNotification] },
    };
    return NotificationObserver;
}(NSObject));
let displayedOnce = false;
let displayedLinkTarget;
let displayedLink;
var CADisplayLinkTarget = /** @class */ (function (_super) {
    __extends(CADisplayLinkTarget, _super);
    function CADisplayLinkTarget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CADisplayLinkTarget.prototype.onDisplayed = function (link) {
        link.invalidate();
        var ios = UIApplication.sharedApplication;
        var object = iosApp;
        displayedOnce = true;
        notify({
            eventName: displayedEvent,
            object: object,
            ios: ios,
        });
        displayedLinkTarget = null;
        displayedLink = null;
    };
    CADisplayLinkTarget.ObjCExposedMethods = {
        onDisplayed: { returns: interop.types.void, params: [CADisplayLink] },
    };
    return CADisplayLinkTarget;
}(NSObject));
/* tslint:disable */
class iOSApplication {
    constructor() {
        /* tslint:enable */
        this._backgroundColor = majorVersion <= 12 || !UIColor.systemBackgroundColor ? UIColor.whiteColor : UIColor.systemBackgroundColor;
        this._observers = new Array();
        this.addNotificationObserver(UIApplicationDidFinishLaunchingNotification, this.didFinishLaunchingWithOptions.bind(this));
        this.addNotificationObserver(UIApplicationDidBecomeActiveNotification, this.didBecomeActive.bind(this));
        this.addNotificationObserver(UIApplicationDidEnterBackgroundNotification, this.didEnterBackground.bind(this));
        this.addNotificationObserver(UIApplicationWillTerminateNotification, this.willTerminate.bind(this));
        this.addNotificationObserver(UIApplicationDidReceiveMemoryWarningNotification, this.didReceiveMemoryWarning.bind(this));
        this.addNotificationObserver(UIApplicationDidChangeStatusBarOrientationNotification, this.didChangeStatusBarOrientation.bind(this));
    }
    get orientation() {
        if (!this._orientation) {
            const statusBarOrientation = UIApplication.sharedApplication.statusBarOrientation;
            this._orientation = this.getOrientationValue(statusBarOrientation);
        }
        return this._orientation;
    }
    get rootController() {
        if (NativeScriptEmbedder.sharedInstance().delegate && !this._window) {
            this._window = UIApplication.sharedApplication.delegate.window;
        }
        return this._window.rootViewController;
    }
    get systemAppearance() {
        // userInterfaceStyle is available on UITraitCollection since iOS 12.
        if (majorVersion <= 11) {
            return null;
        }
        if (!this._systemAppearance) {
            const userInterfaceStyle = this.rootController.traitCollection.userInterfaceStyle;
            this._systemAppearance = getSystemAppearanceValue(userInterfaceStyle);
        }
        return this._systemAppearance;
    }
    get nativeApp() {
        return UIApplication.sharedApplication;
    }
    get window() {
        return this._window;
    }
    get delegate() {
        return this._delegate;
    }
    set delegate(value) {
        if (this._delegate !== value) {
            this._delegate = value;
        }
    }
    get rootView() {
        return this._rootView;
    }
    addNotificationObserver(notificationName, onReceiveCallback) {
        const observer = NotificationObserver.initWithCallback(onReceiveCallback);
        NSNotificationCenter.defaultCenter.addObserverSelectorNameObject(observer, 'onReceive', notificationName, null);
        this._observers.push(observer);
        return observer;
    }
    removeNotificationObserver(observer, notificationName) {
        const index = this._observers.indexOf(observer);
        if (index >= 0) {
            this._observers.splice(index, 1);
            NSNotificationCenter.defaultCenter.removeObserverNameObject(observer, notificationName, null);
        }
    }
    didFinishLaunchingWithOptions(notification) {
        if (!displayedOnce) {
            displayedLinkTarget = CADisplayLinkTarget.new();
            displayedLink = CADisplayLink.displayLinkWithTargetSelector(displayedLinkTarget, 'onDisplayed');
            displayedLink.addToRunLoopForMode(NSRunLoop.mainRunLoop, NSDefaultRunLoopMode);
            displayedLink.addToRunLoopForMode(NSRunLoop.mainRunLoop, UITrackingRunLoopMode);
        }
        this._window = UIWindow.alloc().initWithFrame(UIScreen.mainScreen.bounds);
        // TODO: Expose Window module so that it can we styled from XML & CSS
        this._window.backgroundColor = this._backgroundColor;
        this.notifyAppStarted(notification);
    }
    notifyAppStarted(notification) {
        const args = {
            eventName: launchEvent,
            object: this,
            ios: (notification && notification.userInfo && notification.userInfo.objectForKey('UIApplicationLaunchOptionsLocalNotificationKey')) || null,
        };
        notify(args);
        notify({
            eventName: 'loadAppCss',
            object: this,
            cssFile: getCssFileName(),
        });
        // this._window will be undefined when NS app is embedded in a native one
        if (this._window) {
            this.setWindowContent(args.root);
        }
        else {
            this._window = UIApplication.sharedApplication.delegate.window;
        }
    }
    didBecomeActive(notification) {
        const ios = UIApplication.sharedApplication;
        const object = this;
        notify({ eventName: resumeEvent, object, ios });
        const rootView = this._rootView;
        if (rootView && !rootView.isLoaded) {
            rootView.callLoaded();
        }
    }
    didEnterBackground(notification) {
        notify({
            eventName: suspendEvent,
            object: this,
            ios: UIApplication.sharedApplication,
        });
        const rootView = this._rootView;
        if (rootView && rootView.isLoaded) {
            rootView.callUnloaded();
        }
    }
    willTerminate(notification) {
        notify({
            eventName: exitEvent,
            object: this,
            ios: UIApplication.sharedApplication,
        });
        const rootView = this._rootView;
        if (rootView && rootView.isLoaded) {
            rootView.callUnloaded();
        }
    }
    didChangeStatusBarOrientation(notification) {
        const statusBarOrientation = UIApplication.sharedApplication.statusBarOrientation;
        const newOrientation = this.getOrientationValue(statusBarOrientation);
        if (this._orientation !== newOrientation) {
            this._orientation = newOrientation;
            orientationChanged(getRootView(), newOrientation);
            notify({
                eventName: orientationChangedEvent,
                ios: this,
                newValue: this._orientation,
                object: this,
            });
        }
    }
    didReceiveMemoryWarning(notification) {
        notify({
            eventName: lowMemoryEvent,
            object: this,
            ios: UIApplication.sharedApplication,
        });
    }
    getOrientationValue(orientation) {
        switch (orientation) {
            case 3 /* LandscapeRight */:
            case 4 /* LandscapeLeft */:
                return 'landscape';
            case 2 /* PortraitUpsideDown */:
            case 1 /* Portrait */:
                return 'portrait';
            case 0 /* Unknown */:
                return 'unknown';
        }
    }
    _onLivesync(context) {
        // Handle application root module
        const isAppRootModuleChanged = context && context.path && context.path.includes(getMainEntry().moduleName) && context.type !== 'style';
        // Set window content when:
        // + Application root module is changed
        // + View did not handle the change
        // Note:
        // The case when neither app root module is changed, nor livesync is handled on View,
        // then changes will not apply until navigate forward to the module.
        if (isAppRootModuleChanged || (this._rootView && !this._rootView._onLivesync(context))) {
            this.setWindowContent();
        }
    }
    setWindowContent(view) {
        if (this._rootView) {
            // if we already have a root view, we reset it.
            this._rootView._onRootViewReset();
        }
        const rootView = createRootView(view);
        const controller = getViewController(rootView);
        this._rootView = rootView;
        // setup view as styleScopeHost
        rootView._setupAsRootView({});
        setViewControllerView(rootView);
        const haveController = this._window.rootViewController !== null;
        this._window.rootViewController = controller;
        setRootViewsSystemAppearanceCssClass(rootView);
        if (!haveController) {
            this._window.makeKeyAndVisible();
        }
        rootView.on(_ui_core_view_view_helper__WEBPACK_IMPORTED_MODULE_3__[/* IOSHelper */ "a"].traitCollectionColorAppearanceChangedEvent, () => {
            const userInterfaceStyle = controller.traitCollection.userInterfaceStyle;
            const newSystemAppearance = getSystemAppearanceValue(userInterfaceStyle);
            if (this._systemAppearance !== newSystemAppearance) {
                this._systemAppearance = newSystemAppearance;
                systemAppearanceChanged(rootView, newSystemAppearance);
                notify({
                    eventName: systemAppearanceChangedEvent,
                    ios: this,
                    newValue: this._systemAppearance,
                    object: this,
                });
            }
        });
    }
}
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_5__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [NSNotification]),
    __metadata("design:returntype", void 0)
], iOSApplication.prototype, "didFinishLaunchingWithOptions", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_5__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [NSNotification]),
    __metadata("design:returntype", void 0)
], iOSApplication.prototype, "didBecomeActive", null);
/* tslint:disable */
const iosApp = new iOSApplication();
/* tslint:enable */

setApplication(iosApp);
// attach on global, so it can be overwritten in NativeScript Angular
global.__onLiveSyncCore = function (context) {
    iosApp._onLivesync(context);
};
let mainEntry;
function createRootView(v) {
    let rootView = v;
    if (!rootView) {
        // try to navigate to the mainEntry (if specified)
        if (!mainEntry) {
            throw new Error('Main entry is missing. App cannot be started. Verify app bootstrap.');
        }
        else {
            // console.log('createRootView mainEntry:', mainEntry);
            rootView = _ui_builder__WEBPACK_IMPORTED_MODULE_1__[/* Builder */ "a"].createViewFromEntry(mainEntry);
        }
    }
    // console.log('createRootView rootView:', rootView);
    setRootViewsCssClasses(rootView);
    return rootView;
}
function getMainEntry() {
    return mainEntry;
}
function getRootView() {
    return iosApp.rootView;
}
let started = false;
function run(entry) {
    mainEntry = typeof entry === 'string' ? { moduleName: entry } : entry;
    started = true;
    if (!iosApp.nativeApp) {
        // Normal NativeScript app will need UIApplicationMain.
        UIApplicationMain(0, null, null, iosApp && iosApp.delegate ? NSStringFromClass(iosApp.delegate) : NSStringFromClass(Responder));
    }
    else {
        // TODO: this rootView should be held alive until rootController dismissViewController is called.
        const rootView = createRootView();
        if (rootView) {
            // Attach to the existing iOS app
            const window = iosApp.nativeApp.keyWindow || (iosApp.nativeApp.windows.count > 0 && iosApp.nativeApp.windows[0]);
            if (window) {
                const rootController = window.rootViewController;
                if (rootController) {
                    const controller = getViewController(rootView);
                    rootView._setupAsRootView({});
                    let embedderDelegate = NativeScriptEmbedder.sharedInstance().delegate;
                    if (embedderDelegate) {
                        embedderDelegate.presentNativeScriptApp(controller);
                    }
                    else {
                        let visibleVC = getVisibleViewController(rootController);
                        visibleVC.presentViewControllerAnimatedCompletion(controller, true, null);
                    }
                    // Mind root view CSS classes in future work
                    // on embedding NativeScript applications
                    setRootViewsSystemAppearanceCssClass(rootView);
                    rootView.on(_ui_core_view_view_helper__WEBPACK_IMPORTED_MODULE_3__[/* IOSHelper */ "a"].traitCollectionColorAppearanceChangedEvent, () => {
                        const userInterfaceStyle = controller.traitCollection.userInterfaceStyle;
                        const newSystemAppearance = getSystemAppearanceValue(userInterfaceStyle);
                        if (this._systemAppearance !== newSystemAppearance) {
                            this._systemAppearance = newSystemAppearance;
                            notify({
                                eventName: systemAppearanceChangedEvent,
                                ios: this,
                                newValue: this._systemAppearance,
                                object: this,
                            });
                        }
                    });
                    iosApp.notifyAppStarted();
                }
            }
        }
    }
}
function addCss(cssText, attributeScoped) {
    notify({
        eventName: 'cssChanged',
        object: iosApp,
        cssText: cssText,
    });
    if (!attributeScoped) {
        const rootView = getRootView();
        if (rootView) {
            rootView._onCssStateChange();
        }
    }
}
function _resetRootView(entry) {
    mainEntry = typeof entry === 'string' ? { moduleName: entry } : entry;
    iosApp.setWindowContent();
}
function getNativeApplication() {
    return iosApp.nativeApp;
}
function getSystemAppearanceValue(userInterfaceStyle) {
    switch (userInterfaceStyle) {
        case 2 /* Dark */:
            return 'dark';
        case 1 /* Light */:
        case 0 /* Unspecified */:
            return 'light';
    }
}
function getViewController(rootView) {
    let viewController = rootView.viewController || rootView.ios;
    if (!(viewController instanceof UIViewController)) {
        // We set UILayoutViewController dynamically to the root view if it doesn't have a view controller
        // At the moment the root view doesn't have its native view created. We set it in the setViewControllerView func
        viewController = _ui_core_view_view_helper__WEBPACK_IMPORTED_MODULE_3__[/* IOSHelper */ "a"].UILayoutViewController.initWithOwner(new WeakRef(rootView));
        rootView.viewController = viewController;
    }
    return viewController;
}
function setViewControllerView(view) {
    const viewController = view.viewController || view.ios;
    const nativeView = view.ios || view.nativeViewProtected;
    if (!nativeView || !viewController) {
        throw new Error('Root should be either UIViewController or UIView');
    }
    if (viewController instanceof _ui_core_view_view_helper__WEBPACK_IMPORTED_MODULE_3__[/* IOSHelper */ "a"].UILayoutViewController) {
        viewController.view.addSubview(nativeView);
    }
}
function setRootViewsCssClasses(rootView) {
    const deviceType = _platform__WEBPACK_IMPORTED_MODULE_4__["Device"].deviceType.toLowerCase();
    _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].pushToSystemCssClasses(`${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${IOS_PLATFORM}`);
    _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].pushToSystemCssClasses(`${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${deviceType}`);
    _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].pushToSystemCssClasses(`${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${iosApp.orientation}`);
    rootView.cssClasses.add(_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].ROOT_VIEW_CSS_CLASS);
    const rootViewCssClasses = _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].getSystemCssClasses();
    rootViewCssClasses.forEach((c) => rootView.cssClasses.add(c));
}
function setRootViewsSystemAppearanceCssClass(rootView) {
    if (majorVersion >= 13) {
        const systemAppearanceCssClass = `${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${iosApp.systemAppearance}`;
        _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].pushToSystemCssClasses(systemAppearanceCssClass);
        rootView.cssClasses.add(systemAppearanceCssClass);
    }
}
function orientation() {
    return iosApp.orientation;
}
function systemAppearance() {
    return iosApp.systemAppearance;
}
global.__onLiveSync = function __onLiveSync(context) {
    if (!started) {
        return;
    }
    const rootView = getRootView();
    livesync(rootView, context);
};
// core exports this symbol so apps may import them in general
// technically they are only available for use when running that platform
// helps avoid a webpack nonexistent warning
const AndroidApplication = undefined;
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CSSType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return viewMatchesModuleContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PseudoClassHandler; });
/* unused harmony export _rootModalViews */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ViewCommon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return automationTextProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return originXProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return originYProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isEnabledProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isUserInteractionEnabledProperty; });
/* unused harmony export iosOverflowSafeAreaProperty */
/* unused harmony export iosOverflowSafeAreaEnabledProperty */
/* harmony import */ var _view_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _bindable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _view_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
/* harmony import */ var _gestures__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(69);
/* harmony import */ var _gestures__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(17);
/* harmony import */ var _css_system_classes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(24);
/* harmony import */ var _builder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(42);
/* harmony import */ var _builder_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(37);
/* harmony import */ var _styling_style_scope__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(50);












// helpers (these are okay re-exported here)

let animationModule;
function ensureAnimationModule() {
    if (!animationModule) {
        animationModule = __webpack_require__(68);
    }
}
function CSSType(type) {
    return (cls) => {
        cls.prototype.cssType = type;
    };
}
function viewMatchesModuleContext(view, context, types) {
    return context && view._moduleName && context.type && types.some((type) => type === context.type) && context.path && context.path.includes(view._moduleName);
}
function PseudoClassHandler(...pseudoClasses) {
    const stateEventNames = pseudoClasses.map((s) => ':' + s);
    const listeners = Symbol('listeners');
    return (target, propertyKey, descriptor) => {
        function update(change) {
            let prev = this[listeners] || 0;
            let next = prev + change;
            if (prev <= 0 && next > 0) {
                this[propertyKey](true);
            }
            else if (prev > 0 && next <= 0) {
                this[propertyKey](false);
            }
        }
        stateEventNames.forEach((s) => (target[s] = update));
    };
}
const _rootModalViews = new Array();
class ViewCommon extends _view_base__WEBPACK_IMPORTED_MODULE_0__["ViewBase"] {
    constructor() {
        super(...arguments);
        this._gestureObservers = {};
    }
    get css() {
        const scope = this._styleScope;
        return scope && scope.css;
    }
    set css(value) {
        this._updateStyleScope(undefined, undefined, value);
    }
    addCss(cssString) {
        this._updateStyleScope(undefined, cssString);
    }
    addCssFile(cssFileName) {
        this._updateStyleScope(cssFileName);
    }
    changeCssFile(cssFileName) {
        const scope = this._styleScope;
        if (scope && cssFileName) {
            scope.changeCssFile(cssFileName);
            this._onCssStateChange();
        }
    }
    _updateStyleScope(cssFileName, cssString, css) {
        let scope = this._styleScope;
        if (!scope) {
            scope = new _styling_style_scope__WEBPACK_IMPORTED_MODULE_12__["StyleScope"]();
            this.setScopeProperty(scope, cssFileName, cssString, css);
            this._inheritStyleScope(scope);
            this._isStyleScopeHost = true;
        }
        else {
            this.setScopeProperty(scope, cssFileName, cssString, css);
            this._onCssStateChange();
        }
    }
    setScopeProperty(scope, cssFileName, cssString, css) {
        if (cssFileName !== undefined) {
            scope.addCssFile(cssFileName);
        }
        else if (cssString !== undefined) {
            scope.addCss(cssString);
        }
        else if (css !== undefined) {
            scope.css = css;
        }
    }
    _closeAllModalViewsInternal() {
        if (_rootModalViews && _rootModalViews.length > 0) {
            _rootModalViews.forEach((v) => {
                v.closeModal();
            });
            return true;
        }
        return false;
    }
    _getRootModalViews() {
        return _rootModalViews;
    }
    _onLivesync(context) {
        if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`${this}._onLivesync(${JSON.stringify(context)})`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Livesync);
        }
        if (this._closeAllModalViewsInternal()) {
            return true;
        }
        if (this._handleLivesync(context)) {
            return true;
        }
        let handled = false;
        this.eachChildView((child) => {
            if (child._onLivesync(context)) {
                handled = true;
                return false;
            }
        });
        return handled;
    }
    _handleLivesync(context) {
        if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`${this}._handleLivesync(${JSON.stringify(context)})`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Livesync);
        }
        // Handle local CSS
        if (viewMatchesModuleContext(this, context, ['style'])) {
            if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`Change Handled: Changing CSS for ${this}`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Livesync);
            }
            // Always load styles with ".css" extension. Even when changes are in ".scss" ot ".less" files
            const cssModuleName = `${Object(_builder_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_11__[/* sanitizeModuleName */ "a"])(context.path)}.css`;
            this.changeCssFile(cssModuleName);
            return true;
        }
        // Handle script/markup changes in custom components by falling back to page refresh
        if (viewMatchesModuleContext(this, context, ['markup', 'script']) && this.page && this.page.frame) {
            if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`Change Handled: Changing ${context.type} for ${this} inside ${this.page}`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Livesync);
            }
            return this.page.frame._handleLivesync({
                type: context.type,
                path: this.page._moduleName,
            });
        }
        return false;
    }
    _setupAsRootView(context) {
        super._setupAsRootView(context);
        if (!this._styleScope) {
            this._updateStyleScope();
        }
    }
    _observe(type, callback, thisArg) {
        if (!this._gestureObservers[type]) {
            this._gestureObservers[type] = [];
        }
        this._gestureObservers[type].push(Object(_gestures__WEBPACK_IMPORTED_MODULE_7__["observe"])(this, type, callback, thisArg));
    }
    getGestureObservers(type) {
        return this._gestureObservers[type];
    }
    addEventListener(arg, callback, thisArg) {
        if (typeof arg === 'string') {
            arg = Object(_bindable__WEBPACK_IMPORTED_MODULE_1__[/* getEventOrGestureName */ "b"])(arg);
            let gesture = Object(_gestures__WEBPACK_IMPORTED_MODULE_8__[/* fromString */ "f"])(arg);
            if (gesture && !this._isEvent(arg)) {
                this._observe(gesture, callback, thisArg);
            }
            else {
                let events = arg.split(',');
                if (events.length > 0) {
                    for (let i = 0; i < events.length; i++) {
                        let evt = events[i].trim();
                        let gst = Object(_gestures__WEBPACK_IMPORTED_MODULE_8__[/* fromString */ "f"])(evt);
                        if (gst && !this._isEvent(arg)) {
                            this._observe(gst, callback, thisArg);
                        }
                        else {
                            super.addEventListener(evt, callback, thisArg);
                        }
                    }
                }
                else {
                    super.addEventListener(arg, callback, thisArg);
                }
            }
        }
        else if (typeof arg === 'number') {
            this._observe(arg, callback, thisArg);
        }
    }
    removeEventListener(arg, callback, thisArg) {
        if (typeof arg === 'string') {
            let gesture = Object(_gestures__WEBPACK_IMPORTED_MODULE_8__[/* fromString */ "f"])(arg);
            if (gesture && !this._isEvent(arg)) {
                this._disconnectGestureObservers(gesture);
            }
            else {
                let events = arg.split(',');
                if (events.length > 0) {
                    for (let i = 0; i < events.length; i++) {
                        let evt = events[i].trim();
                        let gst = Object(_gestures__WEBPACK_IMPORTED_MODULE_8__[/* fromString */ "f"])(evt);
                        if (gst && !this._isEvent(arg)) {
                            this._disconnectGestureObservers(gst);
                        }
                        else {
                            super.removeEventListener(evt, callback, thisArg);
                        }
                    }
                }
                else {
                    super.removeEventListener(arg, callback, thisArg);
                }
            }
        }
        else if (typeof arg === 'number') {
            this._disconnectGestureObservers(arg);
        }
    }
    onBackPressed() {
        return false;
    }
    _getFragmentManager() {
        return undefined;
    }
    getModalOptions(args) {
        if (args.length === 0) {
            throw new Error('showModal without parameters is deprecated. Please call showModal on a view instance instead.');
        }
        else {
            let options = null;
            if (args.length === 2) {
                options = args[1];
            }
            else {
                if (args[0] instanceof ViewCommon) {
                    console.log('showModal(view: ViewBase, context: any, closeCallback: Function, fullscreen?: boolean, animated?: boolean, stretched?: boolean) ' + 'is deprecated. Use showModal(view: ViewBase, modalOptions: ShowModalOptions) instead.');
                }
                else {
                    console.log('showModal(moduleName: string, context: any, closeCallback: Function, fullscreen?: boolean, animated?: boolean, stretched?: boolean) ' + 'is deprecated. Use showModal(moduleName: string, modalOptions: ShowModalOptions) instead.');
                }
                options = {
                    context: args[1],
                    closeCallback: args[2],
                    fullscreen: args[3],
                    animated: args[4],
                    stretched: args[5],
                };
            }
            const firstArgument = args[0];
            const view = firstArgument instanceof ViewCommon ? firstArgument : _builder__WEBPACK_IMPORTED_MODULE_10__[/* Builder */ "a"].createViewFromEntry({
                moduleName: firstArgument,
            });
            return { view, options };
        }
    }
    showModal() {
        const { view, options } = this.getModalOptions(arguments);
        view._showNativeModalView(this, options);
        return view;
    }
    closeModal(...args) {
        let closeCallback = this._closeModalCallback;
        if (closeCallback) {
            closeCallback.apply(undefined, arguments);
        }
        else {
            let parent = this.parent;
            if (parent) {
                parent.closeModal(...args);
            }
        }
    }
    get modal() {
        return this._modal;
    }
    _showNativeModalView(parent, options) {
        _rootModalViews.push(this);
        this.cssClasses.add(_css_system_classes__WEBPACK_IMPORTED_MODULE_9__[/* CSSUtils */ "a"].MODAL_ROOT_VIEW_CSS_CLASS);
        const modalRootViewCssClasses = _css_system_classes__WEBPACK_IMPORTED_MODULE_9__[/* CSSUtils */ "a"].getSystemCssClasses();
        modalRootViewCssClasses.forEach((c) => this.cssClasses.add(c));
        parent._modal = this;
        this._modalParent = parent;
        this._modalContext = options.context;
        const that = this;
        this._closeModalCallback = function (...originalArgs) {
            if (that._closeModalCallback) {
                const modalIndex = _rootModalViews.indexOf(that);
                _rootModalViews.splice(modalIndex);
                that._modalParent = null;
                that._modalContext = null;
                that._closeModalCallback = null;
                that._dialogClosed();
                parent._modal = null;
                const whenClosedCallback = () => {
                    if (typeof options.closeCallback === 'function') {
                        options.closeCallback.apply(undefined, originalArgs);
                    }
                };
                that._hideNativeModalView(parent, whenClosedCallback);
            }
        };
    }
    _raiseLayoutChangedEvent() {
        const args = {
            eventName: ViewCommon.layoutChangedEvent,
            object: this,
        };
        this.notify(args);
    }
    _raiseShownModallyEvent() {
        const args = {
            eventName: ViewCommon.shownModallyEvent,
            object: this,
            context: this._modalContext,
            closeCallback: this._closeModalCallback,
        };
        this.notify(args);
    }
    _raiseShowingModallyEvent() {
        const args = {
            eventName: ViewCommon.showingModallyEvent,
            object: this,
            context: this._modalContext,
            closeCallback: this._closeModalCallback,
        };
        this.notify(args);
    }
    _isEvent(name) {
        return this.constructor && `${name}Event` in this.constructor;
    }
    _disconnectGestureObservers(type) {
        let observers = this.getGestureObservers(type);
        if (observers) {
            for (let i = 0; i < observers.length; i++) {
                observers[i].disconnect();
            }
        }
    }
    // START Style property shortcuts
    get borderColor() {
        return this.style.borderColor;
    }
    set borderColor(value) {
        this.style.borderColor = value;
    }
    get borderTopColor() {
        return this.style.borderTopColor;
    }
    set borderTopColor(value) {
        this.style.borderTopColor = value;
    }
    get borderRightColor() {
        return this.style.borderRightColor;
    }
    set borderRightColor(value) {
        this.style.borderRightColor = value;
    }
    get borderBottomColor() {
        return this.style.borderBottomColor;
    }
    set borderBottomColor(value) {
        this.style.borderBottomColor = value;
    }
    get borderLeftColor() {
        return this.style.borderLeftColor;
    }
    set borderLeftColor(value) {
        this.style.borderLeftColor = value;
    }
    get borderWidth() {
        return this.style.borderWidth;
    }
    set borderWidth(value) {
        this.style.borderWidth = value;
    }
    get borderTopWidth() {
        return this.style.borderTopWidth;
    }
    set borderTopWidth(value) {
        this.style.borderTopWidth = value;
    }
    get borderRightWidth() {
        return this.style.borderRightWidth;
    }
    set borderRightWidth(value) {
        this.style.borderRightWidth = value;
    }
    get borderBottomWidth() {
        return this.style.borderBottomWidth;
    }
    set borderBottomWidth(value) {
        this.style.borderBottomWidth = value;
    }
    get borderLeftWidth() {
        return this.style.borderLeftWidth;
    }
    set borderLeftWidth(value) {
        this.style.borderLeftWidth = value;
    }
    get borderRadius() {
        return this.style.borderRadius;
    }
    set borderRadius(value) {
        this.style.borderRadius = value;
    }
    get borderTopLeftRadius() {
        return this.style.borderTopLeftRadius;
    }
    set borderTopLeftRadius(value) {
        this.style.borderTopLeftRadius = value;
    }
    get borderTopRightRadius() {
        return this.style.borderTopRightRadius;
    }
    set borderTopRightRadius(value) {
        this.style.borderTopRightRadius = value;
    }
    get borderBottomRightRadius() {
        return this.style.borderBottomRightRadius;
    }
    set borderBottomRightRadius(value) {
        this.style.borderBottomRightRadius = value;
    }
    get borderBottomLeftRadius() {
        return this.style.borderBottomLeftRadius;
    }
    set borderBottomLeftRadius(value) {
        this.style.borderBottomLeftRadius = value;
    }
    get color() {
        return this.style.color;
    }
    set color(value) {
        this.style.color = value;
    }
    get background() {
        return this.style.background;
    }
    set background(value) {
        this.style.background = value;
    }
    get backgroundColor() {
        return this.style.backgroundColor;
    }
    set backgroundColor(value) {
        this.style.backgroundColor = value;
    }
    get backgroundImage() {
        return this.style.backgroundImage;
    }
    set backgroundImage(value) {
        this.style.backgroundImage = value;
    }
    get backgroundSize() {
        return this.style.backgroundSize;
    }
    set backgroundSize(value) {
        this.style.backgroundSize = value;
    }
    get backgroundPosition() {
        return this.style.backgroundPosition;
    }
    set backgroundPosition(value) {
        this.style.backgroundPosition = value;
    }
    get backgroundRepeat() {
        return this.style.backgroundRepeat;
    }
    set backgroundRepeat(value) {
        this.style.backgroundRepeat = value;
    }
    get minWidth() {
        return this.style.minWidth;
    }
    set minWidth(value) {
        this.style.minWidth = value;
    }
    get minHeight() {
        return this.style.minHeight;
    }
    set minHeight(value) {
        this.style.minHeight = value;
    }
    get width() {
        return this.style.width;
    }
    set width(value) {
        this.style.width = value;
    }
    get height() {
        return this.style.height;
    }
    set height(value) {
        this.style.height = value;
    }
    get margin() {
        return this.style.margin;
    }
    set margin(value) {
        this.style.margin = value;
    }
    get marginLeft() {
        return this.style.marginLeft;
    }
    set marginLeft(value) {
        this.style.marginLeft = value;
    }
    get marginTop() {
        return this.style.marginTop;
    }
    set marginTop(value) {
        this.style.marginTop = value;
    }
    get marginRight() {
        return this.style.marginRight;
    }
    set marginRight(value) {
        this.style.marginRight = value;
    }
    get marginBottom() {
        return this.style.marginBottom;
    }
    set marginBottom(value) {
        this.style.marginBottom = value;
    }
    get horizontalAlignment() {
        return this.style.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.style.horizontalAlignment = value;
    }
    get verticalAlignment() {
        return this.style.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.style.verticalAlignment = value;
    }
    get visibility() {
        return this.style.visibility;
    }
    set visibility(value) {
        this.style.visibility = value;
    }
    get opacity() {
        return this.style.opacity;
    }
    set opacity(value) {
        this.style.opacity = value;
    }
    get rotate() {
        return this.style.rotate;
    }
    set rotate(value) {
        this.style.rotate = value;
    }
    get rotateX() {
        return this.style.rotateX;
    }
    set rotateX(value) {
        this.style.rotateX = value;
    }
    get rotateY() {
        return this.style.rotateY;
    }
    set rotateY(value) {
        this.style.rotateY = value;
    }
    get perspective() {
        return this.style.perspective;
    }
    set perspective(value) {
        this.style.perspective = value;
    }
    get textTransform() {
        return this.style.textTransform;
    }
    set textTransform(value) {
        this.style.textTransform = value;
    }
    get translateX() {
        return this.style.translateX;
    }
    set translateX(value) {
        this.style.translateX = value;
    }
    get translateY() {
        return this.style.translateY;
    }
    set translateY(value) {
        this.style.translateY = value;
    }
    get scaleX() {
        return this.style.scaleX;
    }
    set scaleX(value) {
        this.style.scaleX = value;
    }
    get scaleY() {
        return this.style.scaleY;
    }
    set scaleY(value) {
        this.style.scaleY = value;
    }
    get androidElevation() {
        return this.style.androidElevation;
    }
    set androidElevation(value) {
        this.style.androidElevation = value;
    }
    get androidDynamicElevationOffset() {
        return this.style.androidDynamicElevationOffset;
    }
    set androidDynamicElevationOffset(value) {
        this.style.androidDynamicElevationOffset = value;
    }
    get isLayoutValid() {
        return this._isLayoutValid;
    }
    get cssType() {
        if (!this._cssType) {
            this._cssType = this.typeName.toLowerCase();
        }
        return this._cssType;
    }
    set cssType(type) {
        this._cssType = type.toLowerCase();
    }
    get isLayoutRequired() {
        return true;
    }
    measure(widthMeasureSpec, heightMeasureSpec) {
        this._setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec);
    }
    layout(left, top, right, bottom) {
        this._setCurrentLayoutBounds(left, top, right, bottom);
    }
    getMeasuredWidth() {
        return this._measuredWidth & _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].MEASURED_SIZE_MASK || 0;
    }
    getMeasuredHeight() {
        return this._measuredHeight & _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].MEASURED_SIZE_MASK || 0;
    }
    getMeasuredState() {
        return (this._measuredWidth & _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].MEASURED_STATE_MASK) | ((this._measuredHeight >> _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].MEASURED_HEIGHT_STATE_SHIFT) & (_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].MEASURED_STATE_MASK >> _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].MEASURED_HEIGHT_STATE_SHIFT));
    }
    setMeasuredDimension(measuredWidth, measuredHeight) {
        this._measuredWidth = measuredWidth;
        this._measuredHeight = measuredHeight;
        if (_trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(this + ' :setMeasuredDimension: ' + measuredWidth + ', ' + measuredHeight, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Layout);
        }
    }
    requestLayout() {
        this._isLayoutValid = false;
        super.requestLayout();
    }
    static resolveSizeAndState(size, specSize, specMode, childMeasuredState) {
        return _view_helper__WEBPACK_IMPORTED_MODULE_5__[/* ViewHelper */ "a"].resolveSizeAndState(size, specSize, specMode, childMeasuredState);
    }
    static combineMeasuredStates(curState, newState) {
        return _view_helper__WEBPACK_IMPORTED_MODULE_5__[/* ViewHelper */ "a"].combineMeasuredStates(curState, newState);
    }
    static layoutChild(parent, child, left, top, right, bottom, setFrame = true) {
        _view_helper__WEBPACK_IMPORTED_MODULE_5__[/* ViewHelper */ "a"].layoutChild(parent, child, left, top, right, bottom);
    }
    static measureChild(parent, child, widthMeasureSpec, heightMeasureSpec) {
        return _view_helper__WEBPACK_IMPORTED_MODULE_5__[/* ViewHelper */ "a"].measureChild(parent, child, widthMeasureSpec, heightMeasureSpec);
    }
    _setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec) {
        let changed = this._currentWidthMeasureSpec !== widthMeasureSpec || this._currentHeightMeasureSpec !== heightMeasureSpec;
        this._currentWidthMeasureSpec = widthMeasureSpec;
        this._currentHeightMeasureSpec = heightMeasureSpec;
        return changed;
    }
    _getCurrentLayoutBounds() {
        return { left: 0, top: 0, right: 0, bottom: 0 };
    }
    /**
     * Returns two booleans - the first if "boundsChanged" the second is "sizeChanged".
     */
    _setCurrentLayoutBounds(left, top, right, bottom) {
        this._isLayoutValid = true;
        let boundsChanged = this._oldLeft !== left || this._oldTop !== top || this._oldRight !== right || this._oldBottom !== bottom;
        let sizeChanged = this._oldRight - this._oldLeft !== right - left || this._oldBottom - this._oldTop !== bottom - top;
        this._oldLeft = left;
        this._oldTop = top;
        this._oldRight = right;
        this._oldBottom = bottom;
        return { boundsChanged, sizeChanged };
    }
    eachChild(callback) {
        this.eachChildView(callback);
    }
    eachChildView(callback) {
        //
    }
    _getNativeViewsCount() {
        return this._isAddedToNativeVisualTree ? 1 : 0;
    }
    _eachLayoutView(callback) {
        return callback(this);
    }
    focus() {
        return undefined;
    }
    getSafeAreaInsets() {
        return { left: 0, top: 0, right: 0, bottom: 0 };
    }
    getLocationInWindow() {
        return undefined;
    }
    getLocationOnScreen() {
        return undefined;
    }
    getLocationRelativeTo(otherView) {
        return undefined;
    }
    getActualSize() {
        let currentBounds = this._getCurrentLayoutBounds();
        if (!currentBounds) {
            return undefined;
        }
        return {
            width: _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(currentBounds.right - currentBounds.left),
            height: _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(currentBounds.bottom - currentBounds.top),
        };
    }
    animate(animation) {
        return this.createAnimation(animation).play();
    }
    createAnimation(animation) {
        ensureAnimationModule();
        if (!this._localAnimations) {
            this._localAnimations = new Set();
        }
        animation.target = this;
        const anim = new animationModule.Animation([animation]);
        this._localAnimations.add(anim);
        return anim;
    }
    _removeAnimation(animation) {
        const localAnimations = this._localAnimations;
        if (localAnimations && localAnimations.has(animation)) {
            localAnimations.delete(animation);
            if (animation.isPlaying) {
                animation.cancel();
            }
            return true;
        }
        return false;
    }
    resetNativeView() {
        if (this._localAnimations) {
            this._localAnimations.forEach((a) => this._removeAnimation(a));
        }
        super.resetNativeView();
    }
    _setNativeViewFrame(nativeView, frame) {
        //
    }
    _getValue() {
        throw new Error('The View._getValue is obsolete. There is a new property system.');
    }
    _setValue() {
        throw new Error('The View._setValue is obsolete. There is a new property system.');
    }
    _updateEffectiveLayoutValues(parentWidthMeasureSize, parentWidthMeasureMode, parentHeightMeasureSize, parentHeightMeasureMode) {
        const style = this.style;
        const availableWidth = parentWidthMeasureMode === _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].UNSPECIFIED ? -1 : parentWidthMeasureSize;
        this.effectiveWidth = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["PercentLength"].toDevicePixels(style.width, -2, availableWidth);
        this.effectiveMarginLeft = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["PercentLength"].toDevicePixels(style.marginLeft, 0, availableWidth);
        this.effectiveMarginRight = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["PercentLength"].toDevicePixels(style.marginRight, 0, availableWidth);
        const availableHeight = parentHeightMeasureMode === _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].UNSPECIFIED ? -1 : parentHeightMeasureSize;
        this.effectiveHeight = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["PercentLength"].toDevicePixels(style.height, -2, availableHeight);
        this.effectiveMarginTop = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["PercentLength"].toDevicePixels(style.marginTop, 0, availableHeight);
        this.effectiveMarginBottom = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["PercentLength"].toDevicePixels(style.marginBottom, 0, availableHeight);
    }
    _setNativeClipToBounds() {
        //
    }
    _redrawNativeBackground(value) {
        //
    }
    _onAttachedToWindow() {
        //
    }
    _onDetachedFromWindow() {
        //
    }
    _hasAncestorView(ancestorView) {
        let matcher = (view) => view === ancestorView;
        for (let parent = this.parent; parent != null; parent = parent.parent) {
            if (matcher(parent)) {
                return true;
            }
        }
        return false;
    }
}
ViewCommon.layoutChangedEvent = 'layoutChanged';
ViewCommon.shownModallyEvent = 'shownModally';
ViewCommon.showingModallyEvent = 'showingModally';
const automationTextProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'automationText',
});
automationTextProperty.register(ViewCommon);
const originXProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'originX',
    defaultValue: 0.5,
    valueConverter: (v) => parseFloat(v),
});
originXProperty.register(ViewCommon);
const originYProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'originY',
    defaultValue: 0.5,
    valueConverter: (v) => parseFloat(v),
});
originYProperty.register(ViewCommon);
const isEnabledProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'isEnabled',
    defaultValue: true,
    valueConverter: _view_base__WEBPACK_IMPORTED_MODULE_0__["booleanConverter"],
    valueChanged(target, oldValue, newValue) {
        target._goToVisualState(newValue ? 'normal' : 'disabled');
    },
});
isEnabledProperty.register(ViewCommon);
const isUserInteractionEnabledProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'isUserInteractionEnabled',
    defaultValue: true,
    valueConverter: _view_base__WEBPACK_IMPORTED_MODULE_0__["booleanConverter"],
});
isUserInteractionEnabledProperty.register(ViewCommon);
const iosOverflowSafeAreaProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'iosOverflowSafeArea',
    defaultValue: false,
    valueConverter: _view_base__WEBPACK_IMPORTED_MODULE_0__["booleanConverter"],
});
iosOverflowSafeAreaProperty.register(ViewCommon);
const iosOverflowSafeAreaEnabledProperty = new _properties__WEBPACK_IMPORTED_MODULE_3__["InheritedProperty"]({
    name: 'iosOverflowSafeAreaEnabled',
    defaultValue: true,
    valueConverter: _view_base__WEBPACK_IMPORTED_MODULE_0__["booleanConverter"],
});
iosOverflowSafeAreaEnabledProperty.register(ViewCommon);
//# sourceMappingURL=view-common.js.map; 
if (false ) {} 

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyboardType", function() { return KeyboardType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReturnKeyType", function() { return ReturnKeyType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextAlignment", function() { return TextAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDecoration", function() { return TextDecoration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextTransform", function() { return TextTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WhiteSpace", function() { return WhiteSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Orientation", function() { return Orientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeviceOrientation", function() { return DeviceOrientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HorizontalAlignment", function() { return HorizontalAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalAlignment", function() { return VerticalAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stretch", function() { return Stretch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Visibility", function() { return Visibility; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontAttributes", function() { return FontAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeviceType", function() { return DeviceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UpdateTextTrigger", function() { return UpdateTextTrigger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Accuracy", function() { return Accuracy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dock", function() { return Dock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocapitalizationType", function() { return AutocapitalizationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationBarVisibility", function() { return NavigationBarVisibility; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AndroidActionBarIconVisibility", function() { return AndroidActionBarIconVisibility; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AndroidActionItemPosition", function() { return AndroidActionItemPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOSActionItemPosition", function() { return IOSActionItemPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageFormat", function() { return ImageFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontStyle", function() { return FontStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontWeight", function() { return FontWeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackgroundRepeat", function() { return BackgroundRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationCurve", function() { return AnimationCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusBarStyle", function() { return StatusBarStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SystemAppearance", function() { return SystemAppearance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Enums", function() { return Enums; });
var KeyboardType;
(function (KeyboardType) {
    KeyboardType.datetime = 'datetime';
    KeyboardType.phone = 'phone';
    KeyboardType.number = 'number';
    KeyboardType.url = 'url';
    KeyboardType.email = 'email';
    KeyboardType.integer = 'integer';
})(KeyboardType || (KeyboardType = {}));
var ReturnKeyType;
(function (ReturnKeyType) {
    ReturnKeyType.done = 'done';
    ReturnKeyType.next = 'next';
    ReturnKeyType.go = 'go';
    ReturnKeyType.search = 'search';
    ReturnKeyType.send = 'send';
})(ReturnKeyType || (ReturnKeyType = {}));
class TextAlignment {
}
TextAlignment.left = 'left';
TextAlignment.center = 'center';
TextAlignment.right = 'right';
var TextDecoration;
(function (TextDecoration) {
    TextDecoration.none = 'none';
    TextDecoration.underline = 'underline';
    TextDecoration.lineThrough = 'line-through';
})(TextDecoration || (TextDecoration = {}));
var TextTransform;
(function (TextTransform) {
    TextTransform.none = 'none';
    TextTransform.capitalize = 'capitalize';
    TextTransform.uppercase = 'uppercase';
    TextTransform.lowercase = 'lowercase';
})(TextTransform || (TextTransform = {}));
var WhiteSpace;
(function (WhiteSpace) {
    WhiteSpace.normal = 'normal';
    WhiteSpace.nowrap = 'nowrap';
})(WhiteSpace || (WhiteSpace = {}));
var Orientation;
(function (Orientation) {
    Orientation.horizontal = 'horizontal';
    Orientation.vertical = 'vertical';
})(Orientation || (Orientation = {}));
var DeviceOrientation;
(function (DeviceOrientation) {
    DeviceOrientation.portrait = 'portrait';
    DeviceOrientation.landscape = 'landscape';
    DeviceOrientation.unknown = 'unknown';
})(DeviceOrientation || (DeviceOrientation = {}));
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment.left = 'left';
    HorizontalAlignment.center = 'center';
    HorizontalAlignment.right = 'right';
    HorizontalAlignment.stretch = 'stretch';
})(HorizontalAlignment || (HorizontalAlignment = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment.top = 'top';
    VerticalAlignment.middle = 'middle';
    VerticalAlignment.bottom = 'bottom';
    VerticalAlignment.stretch = 'stretch';
})(VerticalAlignment || (VerticalAlignment = {}));
var Stretch;
(function (Stretch) {
    Stretch.none = 'none';
    Stretch.aspectFill = 'aspectFill';
    Stretch.aspectFit = 'aspectFit';
    Stretch.fill = 'fill';
})(Stretch || (Stretch = {}));
var Visibility;
(function (Visibility) {
    Visibility.visible = 'visible';
    Visibility.collapse = 'collapse';
    Visibility.collapsed = 'collapsed';
    Visibility.hidden = 'hidden';
})(Visibility || (Visibility = {}));
var FontAttributes;
(function (FontAttributes) {
    FontAttributes.Normal = 0;
    FontAttributes.Bold = 1;
    FontAttributes.Italic = 1 << 1;
})(FontAttributes || (FontAttributes = {}));
var DeviceType;
(function (DeviceType) {
    DeviceType.Phone = 'Phone';
    DeviceType.Tablet = 'Tablet';
})(DeviceType || (DeviceType = {}));
var UpdateTextTrigger;
(function (UpdateTextTrigger) {
    UpdateTextTrigger.focusLost = 'focusLost';
    UpdateTextTrigger.textChanged = 'textChanged';
})(UpdateTextTrigger || (UpdateTextTrigger = {}));
var Accuracy;
(function (Accuracy) {
    Accuracy.any = 300;
    Accuracy.high = 3;
})(Accuracy || (Accuracy = {}));
var Dock;
(function (Dock) {
    Dock.left = 'left';
    Dock.top = 'top';
    Dock.right = 'right';
    Dock.bottom = 'bottom';
})(Dock || (Dock = {}));
var AutocapitalizationType;
(function (AutocapitalizationType) {
    AutocapitalizationType.none = 'none';
    AutocapitalizationType.words = 'words';
    AutocapitalizationType.sentences = 'sentences';
    AutocapitalizationType.allCharacters = 'allcharacters';
})(AutocapitalizationType || (AutocapitalizationType = {}));
var NavigationBarVisibility;
(function (NavigationBarVisibility) {
    NavigationBarVisibility.auto = 'auto';
    NavigationBarVisibility.never = 'never';
    NavigationBarVisibility.always = 'always';
})(NavigationBarVisibility || (NavigationBarVisibility = {}));
var AndroidActionBarIconVisibility;
(function (AndroidActionBarIconVisibility) {
    AndroidActionBarIconVisibility.auto = 'auto';
    AndroidActionBarIconVisibility.never = 'never';
    AndroidActionBarIconVisibility.always = 'always';
})(AndroidActionBarIconVisibility || (AndroidActionBarIconVisibility = {}));
var AndroidActionItemPosition;
(function (AndroidActionItemPosition) {
    AndroidActionItemPosition.actionBar = 'actionBar';
    AndroidActionItemPosition.actionBarIfRoom = 'actionBarIfRoom';
    AndroidActionItemPosition.popup = 'popup';
})(AndroidActionItemPosition || (AndroidActionItemPosition = {}));
var IOSActionItemPosition;
(function (IOSActionItemPosition) {
    IOSActionItemPosition.left = 'left';
    IOSActionItemPosition.right = 'right';
})(IOSActionItemPosition || (IOSActionItemPosition = {}));
var ImageFormat;
(function (ImageFormat) {
    ImageFormat.png = 'png';
    ImageFormat.jpeg = 'jpeg';
    ImageFormat.jpg = 'jpg';
})(ImageFormat || (ImageFormat = {}));
var FontStyle;
(function (FontStyle) {
    FontStyle.normal = 'normal';
    FontStyle.italic = 'italic';
})(FontStyle || (FontStyle = {}));
var FontWeight;
(function (FontWeight) {
    FontWeight.thin = '100';
    FontWeight.extraLight = '200';
    FontWeight.light = '300';
    FontWeight.normal = 'normal'; // 400
    FontWeight.medium = '500';
    FontWeight.semiBold = '600';
    FontWeight.bold = 'bold'; // 700
    FontWeight.extraBold = '800';
    FontWeight.black = '900';
})(FontWeight || (FontWeight = {}));
var BackgroundRepeat;
(function (BackgroundRepeat) {
    BackgroundRepeat.repeat = 'repeat';
    BackgroundRepeat.repeatX = 'repeat-x';
    BackgroundRepeat.repeatY = 'repeat-y';
    BackgroundRepeat.noRepeat = 'no-repeat';
})(BackgroundRepeat || (BackgroundRepeat = {}));
let animation;
var AnimationCurve;
(function (AnimationCurve) {
    AnimationCurve.ease = 'ease';
    AnimationCurve.easeIn = 'easeIn';
    AnimationCurve.easeOut = 'easeOut';
    AnimationCurve.easeInOut = 'easeInOut';
    AnimationCurve.linear = 'linear';
    AnimationCurve.spring = 'spring';
    function cubicBezier(x1, y1, x2, y2) {
        animation = animation || __webpack_require__(68);
        return new animation.CubicBezierAnimationCurve(x1, y1, x2, y2);
    }
    AnimationCurve.cubicBezier = cubicBezier;
})(AnimationCurve || (AnimationCurve = {}));
var StatusBarStyle;
(function (StatusBarStyle) {
    StatusBarStyle.light = 'light';
    StatusBarStyle.dark = 'dark';
})(StatusBarStyle || (StatusBarStyle = {}));
var SystemAppearance;
(function (SystemAppearance) {
    SystemAppearance.light = 'light';
    SystemAppearance.dark = 'dark';
})(SystemAppearance || (SystemAppearance = {}));
const Enums = {
    Accuracy,
    AndroidActionBarIconVisibility,
    AndroidActionItemPosition,
    AnimationCurve,
    AutocapitalizationType,
    BackgroundRepeat,
    DeviceOrientation,
    DeviceType,
    Dock,
    FontAttributes,
    FontStyle,
    FontWeight,
    HorizontalAlignment,
    IOSActionItemPosition,
    ImageFormat,
    KeyboardType,
    NavigationBarVisibility,
    Orientation,
    ReturnKeyType,
    StatusBarStyle,
    Stretch,
    SystemAppearance,
    TextAlignment,
    TextDecoration,
    TextTransform,
    UpdateTextTrigger,
    VerticalAlignment,
    Visibility,
    WhiteSpace,
};
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FontStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return FontWeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return parseFontFamily; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return genericFontFamilies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return parseFont; });
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);


class Font {
    constructor(fontFamily, fontSize, fontStyle, fontWeight) {
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.fontStyle = fontStyle;
        this.fontWeight = fontWeight;
    }
    get isItalic() {
        return this.fontStyle === FontStyle.ITALIC;
    }
    get isBold() {
        return this.fontWeight === FontWeight.SEMI_BOLD || this.fontWeight === FontWeight.BOLD || this.fontWeight === '700' || this.fontWeight === FontWeight.EXTRA_BOLD || this.fontWeight === FontWeight.BLACK;
    }
    static equals(value1, value2) {
        // both values are falsy
        if (!value1 && !value2) {
            return true;
        }
        // only one is falsy
        if (!value1 || !value2) {
            return false;
        }
        return value1.fontFamily === value2.fontFamily && value1.fontSize === value2.fontSize && value1.fontStyle === value2.fontStyle && value1.fontWeight === value2.fontWeight;
    }
}
Font.default = undefined;
var FontStyle;
(function (FontStyle) {
    FontStyle.NORMAL = 'normal';
    FontStyle.ITALIC = 'italic';
    FontStyle.isValid = Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["makeValidator"])(FontStyle.NORMAL, FontStyle.ITALIC);
    FontStyle.parse = Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["makeParser"])(FontStyle.isValid);
})(FontStyle || (FontStyle = {}));
var FontWeight;
(function (FontWeight) {
    FontWeight.THIN = '100';
    FontWeight.EXTRA_LIGHT = '200';
    FontWeight.LIGHT = '300';
    FontWeight.NORMAL = 'normal';
    FontWeight.MEDIUM = '500';
    FontWeight.SEMI_BOLD = '600';
    FontWeight.BOLD = 'bold';
    FontWeight.EXTRA_BOLD = '800';
    FontWeight.BLACK = '900';
    FontWeight.isValid = Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["makeValidator"])(FontWeight.THIN, FontWeight.EXTRA_LIGHT, FontWeight.LIGHT, FontWeight.NORMAL, '400', FontWeight.MEDIUM, FontWeight.SEMI_BOLD, FontWeight.BOLD, '700', FontWeight.EXTRA_BOLD, FontWeight.BLACK);
    FontWeight.parse = Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["makeParser"])(FontWeight.isValid);
})(FontWeight || (FontWeight = {}));
function parseFontFamily(value) {
    const result = new Array();
    if (!value) {
        return result;
    }
    const split = value.split(',');
    for (let i = 0; i < split.length; i++) {
        let str = split[i].trim().replace(/['"]+/g, '');
        if (str) {
            result.push(str);
        }
    }
    return result;
}
var genericFontFamilies;
(function (genericFontFamilies) {
    genericFontFamilies.serif = 'serif';
    genericFontFamilies.sansSerif = 'sans-serif';
    genericFontFamilies.monospace = 'monospace';
    genericFontFamilies.system = 'system';
})(genericFontFamilies || (genericFontFamilies = {}));
const styles = new Set();
[FontStyle.NORMAL, FontStyle.ITALIC].forEach((val, i, a) => styles.add(val));
// http://www.w3schools.com/cssref/pr_font_weight.asp
//- normal(same as 400)
//- bold(same as 700)
//- 100(Thin) (API16 -thin)
//- 200(Extra Light / Ultra Light) (API16 -light)
//- 300(Light) (API16 -light)
//- 400(Normal)
//- 500(Medium) (API21 -medium)
//- 600(Semi Bold / Demi Bold) (API21 -medium)
//- 700(Bold) (API16 -bold)
//- 800(Extra Bold / Ultra Bold) (API16 -bold)
//- 900(Black / Heavy) (API21 -black)
const weights = new Set();
[FontWeight.THIN, FontWeight.EXTRA_LIGHT, FontWeight.LIGHT, FontWeight.NORMAL, '400', FontWeight.MEDIUM, FontWeight.SEMI_BOLD, FontWeight.BOLD, '700', FontWeight.EXTRA_BOLD, FontWeight.BLACK].forEach((val, i, a) => weights.add(val));
function parseFont(fontValue) {
    let result = {
        fontStyle: 'normal',
        fontVariant: 'normal',
        fontWeight: 'normal',
    };
    const parts = fontValue.split(/\s+/);
    let part;
    while ((part = parts.shift())) {
        if (part === 'normal') {
            // nothing to do here
        }
        else if (part === 'small-caps') {
            // The only supported font variant in shorthand font
            result.fontVariant = part;
        }
        else if (styles.has(part)) {
            result.fontStyle = part;
        }
        else if (weights.has(part)) {
            result.fontWeight = part;
        }
        else if (!result.fontSize) {
            let sizes = part.split('/');
            result.fontSize = sizes[0];
            result.lineHeight = sizes.length > 1 ? sizes[1] : undefined;
        }
        else {
            result.fontFamily = part;
            if (parts.length) {
                result.fontFamily += ' ' + parts.join(' ');
            }
            break;
        }
    }
    return result;
}
//# sourceMappingURL=font-common.js.map; 
if (false ) {} 

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getTransformedText; });
/* harmony import */ var _text_base_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _styling_font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _span__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38);
// Types

// Requires








const majorVersion = _utils__WEBPACK_IMPORTED_MODULE_6__[/* iOSNativeHelper */ "a"].MajorVersion;
var UILabelClickHandlerImpl = /** @class */ (function (_super) {
    __extends(UILabelClickHandlerImpl, _super);
    function UILabelClickHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UILabelClickHandlerImpl.initWithOwner = function (owner) {
        var handler = UILabelClickHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    UILabelClickHandlerImpl.prototype.linkTap = function (tapGesture) {
        var owner = this._owner.get();
        if (owner) {
            // https://stackoverflow.com/a/35789589
            var label = owner.nativeTextViewProtected;
            var layoutManager = NSLayoutManager.alloc().init();
            var textContainer = NSTextContainer.alloc().initWithSize(CGSizeZero);
            var textStorage = NSTextStorage.alloc().initWithAttributedString(owner.nativeTextViewProtected['attributedText']);
            layoutManager.addTextContainer(textContainer);
            textStorage.addLayoutManager(layoutManager);
            textContainer.lineFragmentPadding = 0;
            textContainer.lineBreakMode = label.lineBreakMode;
            textContainer.maximumNumberOfLines = label.numberOfLines;
            var labelSize = label.bounds.size;
            textContainer.size = labelSize;
            var locationOfTouchInLabel = tapGesture.locationInView(label);
            var textBoundingBox = layoutManager.usedRectForTextContainer(textContainer);
            var textContainerOffset = CGPointMake((labelSize.width - textBoundingBox.size.width) * 0.5 - textBoundingBox.origin.x, (labelSize.height - textBoundingBox.size.height) * 0.5 - textBoundingBox.origin.y);
            var locationOfTouchInTextContainer = CGPointMake(locationOfTouchInLabel.x - textContainerOffset.x, locationOfTouchInLabel.y - textContainerOffset.y);
            var indexOfCharacter = layoutManager.characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(locationOfTouchInTextContainer, textContainer, null);
            var span = null;
            // try to find the corresponding span using the spanRanges
            for (var i = 0; i < owner._spanRanges.length; i++) {
                var range = owner._spanRanges[i];
                if (range.location <= indexOfCharacter && range.location + range.length > indexOfCharacter) {
                    if (owner.formattedText && owner.formattedText.spans.length > i) {
                        span = owner.formattedText.spans.getItem(i);
                    }
                    break;
                }
            }
            if (span && span.tappable) {
                // if the span is found and tappable emit the linkTap event
                span._emit(_span__WEBPACK_IMPORTED_MODULE_3__[/* Span */ "a"].linkTapEvent);
            }
        }
    };
    UILabelClickHandlerImpl.ObjCExposedMethods = {
        linkTap: { returns: interop.types.void, params: [interop.types.id] },
    };
    return UILabelClickHandlerImpl;
}(NSObject));
class TextBase extends _text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* TextBaseCommon */ "a"] {
    constructor() {
        super(...arguments);
        this._tappable = false;
    }
    initNativeView() {
        super.initNativeView();
        this._setTappableState(false);
    }
    _setTappableState(tappable) {
        if (this._tappable !== tappable) {
            this._tappable = tappable;
            if (this._tappable) {
                const tapHandler = UILabelClickHandlerImpl.initWithOwner(new WeakRef(this));
                // associate handler with menuItem or it will get collected by JSC.
                this.handler = tapHandler;
                this._tapGestureRecognizer = UITapGestureRecognizer.alloc().initWithTargetAction(tapHandler, 'linkTap');
                this.nativeViewProtected.userInteractionEnabled = true;
                this.nativeViewProtected.addGestureRecognizer(this._tapGestureRecognizer);
            }
            else {
                this.nativeViewProtected.userInteractionEnabled = false;
                this.nativeViewProtected.removeGestureRecognizer(this._tapGestureRecognizer);
            }
        }
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textProperty */ "i"].getDefault]() {
        return _text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* resetSymbol */ "f"];
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textProperty */ "i"].setNative](value) {
        const reset = value === _text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* resetSymbol */ "f"];
        if (!reset && this.formattedText) {
            return;
        }
        this._setNativeText(reset);
        this._requestLayoutOnTextChanged();
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* formattedTextProperty */ "b"].setNative](value) {
        this._setNativeText();
        this._setTappableState(isStringTappable(value));
        _text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textProperty */ "i"].nativeValueChange(this, !value ? '' : value.toString());
        this._requestLayoutOnTextChanged();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["colorProperty"].getDefault]() {
        let nativeView = this.nativeTextViewProtected;
        if (nativeView instanceof UIButton) {
            return nativeView.titleColorForState(0 /* Normal */);
        }
        else {
            return nativeView.textColor;
        }
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["colorProperty"].setNative](value) {
        const color = value instanceof _color__WEBPACK_IMPORTED_MODULE_2__[/* Color */ "a"] ? value.ios : value;
        this._setColor(color);
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["fontInternalProperty"].getDefault]() {
        let nativeView = this.nativeTextViewProtected;
        nativeView = nativeView instanceof UIButton ? nativeView.titleLabel : nativeView;
        return nativeView.font;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["fontInternalProperty"].setNative](value) {
        if (!(value instanceof _styling_font__WEBPACK_IMPORTED_MODULE_1__[/* Font */ "a"]) || !this.formattedText) {
            let nativeView = this.nativeTextViewProtected;
            nativeView = nativeView instanceof UIButton ? nativeView.titleLabel : nativeView;
            const font = value instanceof _styling_font__WEBPACK_IMPORTED_MODULE_1__[/* Font */ "a"] ? value.getUIFont(nativeView.font) : value;
            nativeView.font = font;
        }
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textAlignmentProperty */ "g"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        switch (value) {
            case 'initial':
            case 'left':
                nativeView.textAlignment = 0 /* Left */;
                break;
            case 'center':
                nativeView.textAlignment = 1 /* Center */;
                break;
            case 'right':
                nativeView.textAlignment = 2 /* Right */;
                break;
        }
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textDecorationProperty */ "h"].setNative](value) {
        this._setNativeText();
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textTransformProperty */ "j"].setNative](value) {
        this._setNativeText();
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* letterSpacingProperty */ "d"].setNative](value) {
        this._setNativeText();
    }
    [_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* lineHeightProperty */ "e"].setNative](value) {
        this._setNativeText();
    }
    _setNativeText(reset = false) {
        if (reset) {
            const nativeView = this.nativeTextViewProtected;
            if (nativeView instanceof UIButton) {
                // Clear attributedText or title won't be affected.
                nativeView.setAttributedTitleForState(null, 0 /* Normal */);
                nativeView.setTitleForState(null, 0 /* Normal */);
            }
            else {
                // Clear attributedText or text won't be affected.
                nativeView.attributedText = null;
                nativeView.text = null;
            }
            return;
        }
        if (this.formattedText) {
            this.setFormattedTextDecorationAndTransform();
        }
        else {
            this.setTextDecorationAndTransform();
        }
    }
    _setColor(color) {
        if (this.nativeTextViewProtected instanceof UIButton) {
            this.nativeTextViewProtected.setTitleColorForState(color, 0 /* Normal */);
            this.nativeTextViewProtected.titleLabel.textColor = color;
        }
        else {
            this.nativeTextViewProtected.textColor = color;
        }
    }
    setFormattedTextDecorationAndTransform() {
        const attrText = this.createNSMutableAttributedString(this.formattedText);
        // TODO: letterSpacing should be applied per Span.
        if (this.letterSpacing !== 0) {
            attrText.addAttributeValueRange(NSKernAttributeName, this.letterSpacing * this.nativeTextViewProtected.font.pointSize, { location: 0, length: attrText.length });
        }
        if (this.style.lineHeight) {
            const paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.minimumLineHeight = this.lineHeight;
            // make sure a possible previously set text alignment setting is not lost when line height is specified
            if (this.nativeTextViewProtected instanceof UIButton) {
                paragraphStyle.alignment = this.nativeTextViewProtected.titleLabel.textAlignment;
            }
            else {
                paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            }
            if (this.nativeTextViewProtected instanceof UILabel) {
                // make sure a possible previously set line break mode is not lost when line height is specified
                paragraphStyle.lineBreakMode = this.nativeTextViewProtected.lineBreakMode;
            }
            attrText.addAttributeValueRange(NSParagraphStyleAttributeName, paragraphStyle, { location: 0, length: attrText.length });
        }
        else if (this.nativeTextViewProtected instanceof UITextView) {
            const paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            attrText.addAttributeValueRange(NSParagraphStyleAttributeName, paragraphStyle, { location: 0, length: attrText.length });
        }
        if (this.nativeTextViewProtected instanceof UIButton) {
            this.nativeTextViewProtected.setAttributedTitleForState(attrText, 0 /* Normal */);
        }
        else {
            if (majorVersion >= 13 && UIColor.labelColor) {
                this.nativeTextViewProtected.textColor = UIColor.labelColor;
            }
            this.nativeTextViewProtected.attributedText = attrText;
        }
    }
    setTextDecorationAndTransform() {
        const style = this.style;
        const dict = new Map();
        switch (style.textDecoration) {
            case 'none':
                break;
            case 'underline':
                dict.set(NSUnderlineStyleAttributeName, 1 /* Single */);
                break;
            case 'line-through':
                dict.set(NSStrikethroughStyleAttributeName, 1 /* Single */);
                break;
            case 'underline line-through':
                dict.set(NSUnderlineStyleAttributeName, 1 /* Single */);
                dict.set(NSStrikethroughStyleAttributeName, 1 /* Single */);
                break;
            default:
                throw new Error(`Invalid text decoration value: ${style.textDecoration}. Valid values are: 'none', 'underline', 'line-through', 'underline line-through'.`);
        }
        if (style.letterSpacing !== 0 && this.nativeTextViewProtected.font) {
            const kern = style.letterSpacing * this.nativeTextViewProtected.font.pointSize;
            dict.set(NSKernAttributeName, kern);
            if (this.nativeTextViewProtected instanceof UITextField) {
                this.nativeTextViewProtected.defaultTextAttributes.setValueForKey(kern, NSKernAttributeName);
            }
        }
        const isTextView = this.nativeTextViewProtected instanceof UITextView;
        if (style.lineHeight) {
            const paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.lineSpacing = style.lineHeight;
            // make sure a possible previously set text alignment setting is not lost when line height is specified
            if (this.nativeTextViewProtected instanceof UIButton) {
                paragraphStyle.alignment = this.nativeTextViewProtected.titleLabel.textAlignment;
            }
            else {
                paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            }
            if (this.nativeTextViewProtected instanceof UILabel) {
                // make sure a possible previously set line break mode is not lost when line height is specified
                paragraphStyle.lineBreakMode = this.nativeTextViewProtected.lineBreakMode;
            }
            dict.set(NSParagraphStyleAttributeName, paragraphStyle);
        }
        else if (isTextView) {
            const paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            dict.set(NSParagraphStyleAttributeName, paragraphStyle);
        }
        const source = getTransformedText(Object(_utils_types__WEBPACK_IMPORTED_MODULE_5__[/* isNullOrUndefined */ "h"])(this.text) ? '' : `${this.text}`, this.textTransform);
        if (dict.size > 0 || isTextView) {
            if (isTextView && this.nativeTextViewProtected.font) {
                // UITextView's font seems to change inside.
                dict.set(NSFontAttributeName, this.nativeTextViewProtected.font);
            }
            const result = NSMutableAttributedString.alloc().initWithString(source);
            result.setAttributesRange(dict, {
                location: 0,
                length: source.length,
            });
            if (this.nativeTextViewProtected instanceof UIButton) {
                this.nativeTextViewProtected.setAttributedTitleForState(result, 0 /* Normal */);
            }
            else {
                this.nativeTextViewProtected.attributedText = result;
            }
        }
        else {
            if (this.nativeTextViewProtected instanceof UIButton) {
                // Clear attributedText or title won't be affected.
                this.nativeTextViewProtected.setAttributedTitleForState(null, 0 /* Normal */);
                this.nativeTextViewProtected.setTitleForState(source, 0 /* Normal */);
            }
            else {
                // Clear attributedText or text won't be affected.
                this.nativeTextViewProtected.attributedText = undefined;
                this.nativeTextViewProtected.text = source;
            }
        }
        if (!style.color && majorVersion >= 13 && UIColor.labelColor) {
            this._setColor(UIColor.labelColor);
        }
    }
    createNSMutableAttributedString(formattedString) {
        let mas = NSMutableAttributedString.alloc().init();
        this._spanRanges = [];
        if (formattedString && formattedString.parent) {
            for (let i = 0, spanStart = 0, length = formattedString.spans.length; i < length; i++) {
                const span = formattedString.spans.getItem(i);
                const text = span.text;
                const textTransform = formattedString.parent.textTransform;
                let spanText = Object(_utils_types__WEBPACK_IMPORTED_MODULE_5__[/* isNullOrUndefined */ "h"])(text) ? '' : `${text}`;
                if (textTransform !== 'none' && textTransform !== 'initial') {
                    spanText = getTransformedText(spanText, textTransform);
                }
                const nsAttributedString = this.createMutableStringForSpan(span, spanText);
                mas.insertAttributedStringAtIndex(nsAttributedString, spanStart);
                this._spanRanges.push({
                    location: spanStart,
                    length: spanText.length,
                });
                spanStart += spanText.length;
            }
        }
        return mas;
    }
    getBaselineOffset(font, align) {
        if (!align || ['stretch', 'baseline'].includes(align)) {
            return 0;
        }
        if (align === 'top') {
            return -this.fontSize - font.descender - font.ascender - font.leading / 2;
        }
        if (align === 'bottom') {
            return font.descender + font.leading / 2;
        }
        if (align === 'text-top') {
            return -this.fontSize - font.descender - font.ascender;
        }
        if (align === 'text-bottom') {
            return font.descender;
        }
        if (align === 'middle') {
            return (font.descender - font.ascender) / 2 - font.descender;
        }
        if (align === 'super') {
            return -this.fontSize * 0.4;
        }
        if (align === 'sub') {
            return (font.descender - font.ascender) * 0.4;
        }
    }
    createMutableStringForSpan(span, text) {
        const viewFont = this.nativeTextViewProtected.font;
        const attrDict = {};
        const style = span.style;
        const align = style.verticalAlignment;
        const font = new _styling_font__WEBPACK_IMPORTED_MODULE_1__[/* Font */ "a"](style.fontFamily, style.fontSize, style.fontStyle, style.fontWeight);
        const iosFont = font.getUIFont(viewFont);
        attrDict[NSFontAttributeName] = iosFont;
        if (span.color) {
            attrDict[NSForegroundColorAttributeName] = span.color.ios;
        }
        // We don't use isSet function here because defaultValue for backgroundColor is null.
        const backgroundColor = (style.backgroundColor || span.parent.backgroundColor || span.parent.parent.backgroundColor);
        if (backgroundColor) {
            attrDict[NSBackgroundColorAttributeName] = backgroundColor.ios;
        }
        const textDecoration = Object(_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* getClosestPropertyValue */ "c"])(_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* textDecorationProperty */ "h"], span);
        if (textDecoration) {
            const underline = textDecoration.indexOf('underline') !== -1;
            if (underline) {
                attrDict[NSUnderlineStyleAttributeName] = underline;
            }
            const strikethrough = textDecoration.indexOf('line-through') !== -1;
            if (strikethrough) {
                attrDict[NSStrikethroughStyleAttributeName] = strikethrough;
            }
        }
        if (align) {
            attrDict[NSBaselineOffsetAttributeName] = this.getBaselineOffset(iosFont, align);
        }
        return NSMutableAttributedString.alloc().initWithStringAttributes(text, attrDict);
    }
}
function getTransformedText(text, textTransform) {
    if (!text || !Object(_utils_types__WEBPACK_IMPORTED_MODULE_5__[/* isString */ "k"])(text)) {
        return '';
    }
    switch (textTransform) {
        case 'uppercase':
            return NSStringFromNSAttributedString(text).uppercaseString;
        case 'lowercase':
            return NSStringFromNSAttributedString(text).lowercaseString;
        case 'capitalize':
            return NSStringFromNSAttributedString(text).capitalizedString;
        default:
            return text;
    }
}
function NSStringFromNSAttributedString(source) {
    return NSString.stringWithString((source instanceof NSAttributedString && source.string) || source);
}
function isStringTappable(formattedString) {
    if (!formattedString) {
        return false;
    }
    for (let i = 0, length = formattedString.spans.length; i < length; i++) {
        const span = formattedString.spans.getItem(i);
        if (span.tappable) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextBaseCommon; });
/* unused harmony export isBold */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return textProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return formattedTextProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getClosestPropertyValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return textAlignmentProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return textTransformProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return whiteSpaceProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return textDecorationProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return letterSpacingProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return lineHeightProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return resetSymbol; });
/* harmony import */ var _formatted_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _styling_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
// Requires.






const CHILD_SPAN = 'Span';
const CHILD_FORMATTED_TEXT = 'formattedText';
const CHILD_FORMATTED_STRING = 'FormattedString';
class TextBaseCommon extends _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"] {
    /***
     * In the NativeScript Core; by default the nativeTextViewProtected points to the same value as nativeViewProtected.
     * At this point no internal NS components need this indirection functionality.
     * This indirection is used to allow support usage by third party components so they don't have to duplicate functionality.
     *
     * A third party component can just override the `nativeTextViewProtected` getter and return a different internal view and that view would be
     * what all TextView/TextInput class features would be applied to.
     *
     * A example is the Android MaterialDesign TextInput class, it has a wrapper view of a TextInputLayout
     *    https://developer.android.com/reference/com/google/android/material/textfield/TextInputLayout
     * which wraps the actual TextInput.  This wrapper layout (TextInputLayout) must be assigned to the nativeViewProtected as the entire
     * NS Core uses nativeViewProtected for everything related to layout, so that it can be measured, added to the parent view as a child, ect.
     *
     * However, its internal view would be the actual TextView/TextInput and to allow that sub-view to have the normal TextView/TextInput
     * class features, which we expose and to allow them to work on it, the internal TextView/TextInput is what the needs to have the class values applied to it.
     *
     * So all code that works on what is expected to be a TextView/TextInput should use `nativeTextViewProtected` so that any third party
     * components that need to have two separate components can work properly without them having to duplicate all the TextBase (and decendants) functionality
     * by just overriding the nativeTextViewProtected getter.
     **/
    get nativeTextViewProtected() {
        return this.nativeViewProtected;
    }
    get fontFamily() {
        return this.style.fontFamily;
    }
    set fontFamily(value) {
        this.style.fontFamily = value;
    }
    get fontSize() {
        return this.style.fontSize;
    }
    set fontSize(value) {
        this.style.fontSize = value;
    }
    get fontStyle() {
        return this.style.fontStyle;
    }
    set fontStyle(value) {
        this.style.fontStyle = value;
    }
    get fontWeight() {
        return this.style.fontWeight;
    }
    set fontWeight(value) {
        this.style.fontWeight = value;
    }
    get letterSpacing() {
        return this.style.letterSpacing;
    }
    set letterSpacing(value) {
        this.style.letterSpacing = value;
    }
    get lineHeight() {
        return this.style.lineHeight;
    }
    set lineHeight(value) {
        this.style.lineHeight = value;
    }
    get textAlignment() {
        return this.style.textAlignment;
    }
    set textAlignment(value) {
        this.style.textAlignment = value;
    }
    get textDecoration() {
        return this.style.textDecoration;
    }
    set textDecoration(value) {
        this.style.textDecoration = value;
    }
    get textTransform() {
        return this.style.textTransform;
    }
    set textTransform(value) {
        this.style.textTransform = value;
    }
    get whiteSpace() {
        return this.style.whiteSpace;
    }
    set whiteSpace(value) {
        this.style.whiteSpace = value;
    }
    get padding() {
        return this.style.padding;
    }
    set padding(value) {
        this.style.padding = value;
    }
    get paddingTop() {
        return this.style.paddingTop;
    }
    set paddingTop(value) {
        this.style.paddingTop = value;
    }
    get paddingRight() {
        return this.style.paddingRight;
    }
    set paddingRight(value) {
        this.style.paddingRight = value;
    }
    get paddingBottom() {
        return this.style.paddingBottom;
    }
    set paddingBottom(value) {
        this.style.paddingBottom = value;
    }
    get paddingLeft() {
        return this.style.paddingLeft;
    }
    set paddingLeft(value) {
        this.style.paddingLeft = value;
    }
    _onFormattedTextContentsChanged(data) {
        if (this.nativeViewProtected) {
            // Notifications from the FormattedString start arriving before the Android view is even created.
            this[formattedTextProperty.setNative](data.value);
        }
    }
    _addChildFromBuilder(name, value) {
        if (name === CHILD_SPAN) {
            if (!this.formattedText) {
                const formattedText = new _formatted_string__WEBPACK_IMPORTED_MODULE_0__[/* FormattedString */ "a"]();
                formattedText.spans.push(value);
                this.formattedText = formattedText;
            }
            else {
                this.formattedText.spans.push(value);
            }
        }
        else if (name === CHILD_FORMATTED_TEXT || name === CHILD_FORMATTED_STRING) {
            this.formattedText = value;
        }
    }
    _requestLayoutOnTextChanged() {
        this.requestLayout();
    }
    eachChild(callback) {
        let text = this.formattedText;
        if (text) {
            callback(text);
        }
    }
    _setNativeText(reset = false) {
        //
    }
}
TextBaseCommon.prototype._isSingleLine = false;
function isBold(fontWeight) {
    return fontWeight === 'bold' || fontWeight === '700' || fontWeight === '800' || fontWeight === '900';
}
const textProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["Property"]({
    name: 'text',
    defaultValue: '',
    affectsLayout: false,
});
textProperty.register(TextBaseCommon);
const formattedTextProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["Property"]({
    name: 'formattedText',
    affectsLayout: true,
    valueChanged: onFormattedTextPropertyChanged,
});
formattedTextProperty.register(TextBaseCommon);
function onFormattedTextPropertyChanged(textBase, oldValue, newValue) {
    if (oldValue) {
        oldValue.off(_data_observable__WEBPACK_IMPORTED_MODULE_4__["Observable"].propertyChangeEvent, textBase._onFormattedTextContentsChanged, textBase);
        textBase._removeView(oldValue);
    }
    if (newValue) {
        const oldParent = newValue.parent;
        // In case formattedString is attached to new TextBase
        if (oldParent) {
            oldParent._removeView(newValue);
        }
        textBase._addView(newValue);
        newValue.on(_data_observable__WEBPACK_IMPORTED_MODULE_4__["Observable"].propertyChangeEvent, textBase._onFormattedTextContentsChanged, textBase);
    }
}
function getClosestPropertyValue(property, span) {
    if (property.isSet(span.style)) {
        return span.style[property.name];
    }
    else if (property.isSet(span.parent.style)) {
        // parent is FormattedString
        return span.parent.style[property.name];
    }
    else if (property.isSet(span.parent.parent.style)) {
        // parent.parent is TextBase
        return span.parent.parent.style[property.name];
    }
}
const textAlignmentConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeValidator"])('initial', 'left', 'center', 'right'));
const textAlignmentProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["InheritedCssProperty"]({
    name: 'textAlignment',
    cssName: 'text-align',
    defaultValue: 'initial',
    valueConverter: textAlignmentConverter,
});
textAlignmentProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_3__[/* Style */ "a"]);
const textTransformConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeValidator"])('initial', 'none', 'capitalize', 'uppercase', 'lowercase'));
const textTransformProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["CssProperty"]({
    name: 'textTransform',
    cssName: 'text-transform',
    defaultValue: 'initial',
    valueConverter: textTransformConverter,
});
textTransformProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_3__[/* Style */ "a"]);
const whiteSpaceConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeValidator"])('initial', 'normal', 'nowrap'));
const whiteSpaceProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["CssProperty"]({
    name: 'whiteSpace',
    cssName: 'white-space',
    defaultValue: 'initial',
    affectsLayout: true,
    valueConverter: whiteSpaceConverter,
});
whiteSpaceProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_3__[/* Style */ "a"]);
const textDecorationConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_2__["makeValidator"])('none', 'underline', 'line-through', 'underline line-through'));
const textDecorationProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["CssProperty"]({
    name: 'textDecoration',
    cssName: 'text-decoration',
    defaultValue: 'none',
    valueConverter: textDecorationConverter,
});
textDecorationProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_3__[/* Style */ "a"]);
const letterSpacingProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["InheritedCssProperty"]({
    name: 'letterSpacing',
    cssName: 'letter-spacing',
    defaultValue: 0,
    affectsLayout: true,
    valueConverter: (v) => parseFloat(v),
});
letterSpacingProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_3__[/* Style */ "a"]);
const lineHeightProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_2__["InheritedCssProperty"]({
    name: 'lineHeight',
    cssName: 'line-height',
    affectsLayout: true,
    valueConverter: (v) => parseFloat(v),
});
lineHeightProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_3__[/* Style */ "a"]);
const resetSymbol = Symbol('textPropertyDefault');
//# sourceMappingURL=text-base-common.js.map; 
if (false ) {} 

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ModuleNameResolver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return resolveModuleName; });
/* unused harmony export clearCache */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _setResolver; });
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _application_application_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _qualifier_matcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(105);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);




class ModuleNameResolver {
    constructor(context, moduleListProvider = global.getRegisteredModules) {
        this.context = context;
        this.moduleListProvider = moduleListProvider;
        this._cache = {};
    }
    resolveModuleName(path, ext) {
        const key = path + ext;
        let result = this._cache[key];
        if (result === undefined) {
            result = this.resolveModuleNameImpl(path, ext);
            this._cache[key] = result;
        }
        if (_trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].write(`path: '${path}' with ext: '${ext}' resolved: '${result}'`, _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].categories.ModuleNameResolver);
        }
        return result;
    }
    clearCache() {
        this._cache = {};
    }
    resolveModuleNameImpl(path, ext) {
        let result = null;
        ext = ext ? '.' + ext : '';
        // This call will return a clean path without qualifiers
        path = Object(_qualifier_matcher__WEBPACK_IMPORTED_MODULE_2__[/* stripQualifiers */ "b"])(path);
        let candidates = this.getCandidates(path, ext);
        result = Object(_qualifier_matcher__WEBPACK_IMPORTED_MODULE_2__[/* findMatch */ "a"])(path, ext, candidates, this.context);
        return result;
    }
    getCandidates(path, ext) {
        const candidates = this.moduleListProvider().filter((moduleName) => moduleName.startsWith(path) && (!ext || moduleName.endsWith(ext)));
        return candidates;
    }
}
let resolverInstance;
function resolveModuleName(path, ext) {
    if (global.__snapshot) {
        return resolveModuleSnapshot(path, ext);
    }
    if (!resolverInstance) {
        resolverInstance = new ModuleNameResolver({
            width: _platform__WEBPACK_IMPORTED_MODULE_0__["Screen"].mainScreen.widthDIPs,
            height: _platform__WEBPACK_IMPORTED_MODULE_0__["Screen"].mainScreen.heightDIPs,
            os: _platform__WEBPACK_IMPORTED_MODULE_0__["Device"].os,
            deviceType: _platform__WEBPACK_IMPORTED_MODULE_0__["Device"].deviceType,
        });
    }
    return resolverInstance.resolveModuleName(path, ext);
}
function resolveModuleSnapshot(path, ext) {
    _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].write(`Resolving module in SNAPSHOT context - path: '${path}' with ext: '${ext}'`, _trace__WEBPACK_IMPORTED_MODULE_3__[/* Trace */ "a"].categories.ModuleNameResolver);
    // Platform module when in snapshot. So resolve modules with default android phone.
    // NB: The only module name that should ever be resolved while in snapshot is app.css, because it is
    // applied explicitly in the snapshot by [NativeScriptSnapshotPlugin](https://github.com/NativeScript/nativescript-dev-webpack/blob/48b26f412fd70c19dc0b9c7763e08e9505a0ae11/plugins/NativeScriptSnapshotPlugin/index.js#L48-L56)
    return new ModuleNameResolver({
        width: 400,
        height: 800,
        os: 'Android',
        deviceType: 'Phone',
    }).resolveModuleName(path, ext);
}
function clearCache() {
    if (resolverInstance) {
        resolverInstance.clearCache();
    }
}
function _setResolver(resolver) {
    resolverInstance = resolver;
}
_application_application_common__WEBPACK_IMPORTED_MODULE_1__["on"]('livesync', (args) => clearCache());
_application_application_common__WEBPACK_IMPORTED_MODULE_1__["on"]('orientationChanged', (args) => {
    resolverInstance = undefined;
});
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return sanitizeModuleName; });
/**
 * Helps sanitize a module name if it is prefixed with '~/', '~' or '/'
 * @param moduleName the name
 * @param removeExtension whether to remove extension
 */
function sanitizeModuleName(moduleName, removeExtension = true) {
    moduleName = moduleName.trim();
    if (moduleName.startsWith('~/')) {
        moduleName = moduleName.substring(2);
    }
    else if (moduleName.startsWith('~')) {
        moduleName = moduleName.substring(1);
    }
    else if (moduleName.startsWith('/')) {
        moduleName = moduleName.substring(1);
    }
    if (removeExtension) {
        const extToRemove = ['js', 'ts', 'xml', 'html', 'css', 'scss'];
        const extensionRegEx = new RegExp(`(.*)\\.(?:${extToRemove.join('|')})`, 'i');
        moduleName = moduleName.replace(extensionRegEx, '$1');
    }
    return moduleName;
}
//# sourceMappingURL=module-name-sanitizer.js.map; 
if (false ) {} 

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return iOSNativeHelper; });
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);

const radToDeg = Math.PI / 180;
function isOrientationLandscape(orientation) {
    return orientation === 3 /* LandscapeLeft */ /* 3 */ || orientation === 4 /* LandscapeRight */ /* 4 */;
}
function openFileAtRootModule(filePath) {
    try {
        const appPath = iOSNativeHelper.getCurrentAppPath();
        let path = iOSNativeHelper.isRealDevice() ? filePath.replace('~', appPath) : filePath;
        const controller = UIDocumentInteractionController.interactionControllerWithURL(NSURL.fileURLWithPath(path));
        controller.delegate = iOSNativeHelper.createUIDocumentInteractionControllerDelegate();
        return controller.presentPreviewAnimated(true);
    }
    catch (e) {
        _trace__WEBPACK_IMPORTED_MODULE_0__[/* Trace */ "a"].write('Error in openFile', _trace__WEBPACK_IMPORTED_MODULE_0__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_0__[/* Trace */ "a"].messageType.error);
    }
    return false;
}
var iOSNativeHelper;
(function (iOSNativeHelper) {
    // TODO: remove for NativeScript 7.0
    function getter(_this, property) {
        console.log('utils.ios.getter() is deprecated; use the respective native property instead');
        if (typeof property === 'function') {
            return property.call(_this);
        }
        else {
            return property;
        }
    }
    iOSNativeHelper.getter = getter;
    let collections;
    (function (collections) {
        function jsArrayToNSArray(str) {
            return NSArray.arrayWithArray(str);
        }
        collections.jsArrayToNSArray = jsArrayToNSArray;
        function nsArrayToJSArray(a) {
            const arr = [];
            if (a !== undefined) {
                let count = a.count;
                for (let i = 0; i < count; i++) {
                    arr.push(a.objectAtIndex(i));
                }
            }
            return arr;
        }
        collections.nsArrayToJSArray = nsArrayToJSArray;
    })(collections = iOSNativeHelper.collections || (iOSNativeHelper.collections = {}));
    function isLandscape() {
        console.log('utils.ios.isLandscape() is deprecated; use application.orientation instead');
        const deviceOrientation = UIDevice.currentDevice.orientation;
        const statusBarOrientation = UIApplication.sharedApplication.statusBarOrientation;
        const isDeviceOrientationLandscape = isOrientationLandscape(deviceOrientation);
        const isStatusBarOrientationLandscape = isOrientationLandscape(statusBarOrientation);
        return isDeviceOrientationLandscape || isStatusBarOrientationLandscape;
    }
    iOSNativeHelper.isLandscape = isLandscape;
    iOSNativeHelper.MajorVersion = NSString.stringWithString(UIDevice.currentDevice.systemVersion).intValue;
    function openFile(filePath) {
        console.log('utils.ios.openFile() is deprecated; use utils.openFile() instead');
        return openFileAtRootModule(filePath);
    }
    iOSNativeHelper.openFile = openFile;
    function getCurrentAppPath() {
        const currentDir = __dirname;
        const tnsModulesIndex = currentDir.indexOf('/tns_modules');
        // Module not hosted in ~/tns_modules when bundled. Use current dir.
        let appPath = currentDir;
        if (tnsModulesIndex !== -1) {
            // Strip part after tns_modules to obtain app root
            appPath = currentDir.substring(0, tnsModulesIndex);
        }
        return appPath;
    }
    iOSNativeHelper.getCurrentAppPath = getCurrentAppPath;
    function joinPaths(...paths) {
        if (!paths || paths.length === 0) {
            return '';
        }
        return NSString.stringWithString(NSString.pathWithComponents(paths)).stringByStandardizingPath;
    }
    iOSNativeHelper.joinPaths = joinPaths;
    function getVisibleViewController(rootViewController) {
        if (rootViewController.presentedViewController) {
            return getVisibleViewController(rootViewController.presentedViewController);
        }
        if (rootViewController.isKindOfClass(UINavigationController.class())) {
            return getVisibleViewController(rootViewController.visibleViewController);
        }
        if (rootViewController.isKindOfClass(UITabBarController.class())) {
            return getVisibleViewController(rootViewController);
        }
        return rootViewController;
    }
    iOSNativeHelper.getVisibleViewController = getVisibleViewController;
    function applyRotateTransform(transform, x, y, z) {
        if (x) {
            transform = CATransform3DRotate(transform, x * radToDeg, 1, 0, 0);
        }
        if (y) {
            transform = CATransform3DRotate(transform, y * radToDeg, 0, 1, 0);
        }
        if (z) {
            transform = CATransform3DRotate(transform, z * radToDeg, 0, 0, 1);
        }
        return transform;
    }
    iOSNativeHelper.applyRotateTransform = applyRotateTransform;
    function createUIDocumentInteractionControllerDelegate() {
        var UIDocumentInteractionControllerDelegateImpl = /** @class */ (function (_super) {
    __extends(UIDocumentInteractionControllerDelegateImpl, _super);
    function UIDocumentInteractionControllerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIDocumentInteractionControllerDelegateImpl.prototype.getViewController = function () {
        var app = UIApplication.sharedApplication;
        return app.keyWindow.rootViewController;
    };
    UIDocumentInteractionControllerDelegateImpl.prototype.documentInteractionControllerViewControllerForPreview = function (controller) {
        return this.getViewController();
    };
    UIDocumentInteractionControllerDelegateImpl.prototype.documentInteractionControllerViewForPreview = function (controller) {
        return this.getViewController().view;
    };
    UIDocumentInteractionControllerDelegateImpl.prototype.documentInteractionControllerRectForPreview = function (controller) {
        return this.getViewController().view.frame;
    };
    UIDocumentInteractionControllerDelegateImpl.ObjCProtocols = [UIDocumentInteractionControllerDelegate];
    return UIDocumentInteractionControllerDelegateImpl;
}(NSObject));
        return new UIDocumentInteractionControllerDelegateImpl();
    }
    iOSNativeHelper.createUIDocumentInteractionControllerDelegate = createUIDocumentInteractionControllerDelegate;
    function isRealDevice() {
        try {
            // https://stackoverflow.com/a/5093092/4936697
            const sourceType = UIImagePickerControllerSourceType.UIImagePickerControllerSourceTypeCamera;
            const mediaTypes = UIImagePickerController.availableMediaTypesForSourceType(sourceType);
            return mediaTypes;
        }
        catch (e) {
            return true;
        }
    }
    iOSNativeHelper.isRealDevice = isRealDevice;
})(iOSNativeHelper || (iOSNativeHelper = {}));
//# sourceMappingURL=native-helper.ios.js.map; 
if (false ) {} 

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getNetwork; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return setNetwork; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return setDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return setCSS; });
/* unused harmony export NetworkAgent */
let network;
function getNetwork() {
    return network;
}
function setNetwork(newNetwork) {
    network = newNetwork;
}
let dom;
function getDOM() {
    return dom;
}
function setDOM(newDOM) {
    dom = newDOM;
}
let css;
function getCSS() {
    return css;
}
function setCSS(newCSS) {
    css = newCSS;
}
var NetworkAgent;
(function (NetworkAgent) {
    function responseReceived(requestId, result, headers) {
        const requestIdStr = requestId.toString();
        // Content-Type and content-type are both common in headers spelling
        const mimeType = headers['Content-Type'] || headers['content-type'] || 'application/octet-stream';
        const contentLengthHeader = headers['Content-Length'] || headers['content-length'];
        let contentLength = parseInt(contentLengthHeader, 10);
        if (isNaN(contentLength)) {
            contentLength = 0;
        }
        const response = {
            url: result.url || '',
            status: result.statusCode,
            statusText: result.statusText || '',
            headers: headers,
            mimeType: mimeType,
            fromDiskCache: false,
            connectionReused: true,
            connectionId: 0,
            encodedDataLength: contentLength,
            securityState: 'info',
        };
        const responseData = {
            requestId: requestIdStr,
            type: mimeTypeToType(response.mimeType),
            response: response,
            timestamp: getTimeStamp(),
        };
        global.__inspector.responseReceived(responseData);
        global.__inspector.loadingFinished({
            requestId: requestIdStr,
            timestamp: getTimeStamp(),
            encodedDataLength: contentLength,
        });
        const hasTextContent = responseData.type === 'Document' || responseData.type === 'Script';
        let data;
        if (!hasTextContent) {
            if (responseData.type === 'Image') {
                const bitmap = result.responseAsImage;
                if (bitmap) {
                    const outputStream = new java.io.ByteArrayOutputStream();
                    bitmap.compress(android.graphics.Bitmap.CompressFormat.PNG, 100, outputStream);
                    const base64Image = android.util.Base64.encodeToString(outputStream.toByteArray(), android.util.Base64.DEFAULT);
                    data = base64Image;
                }
            }
        }
        else {
            data = result.responseAsString;
        }
        const successfulRequestData = {
            requestId: requestIdStr,
            data: data,
            hasTextContent: hasTextContent,
        };
        global.__inspector.dataForRequestId(successfulRequestData);
    }
    NetworkAgent.responseReceived = responseReceived;
    function requestWillBeSent(requestId, options) {
        const request = {
            url: options.url,
            method: options.method,
            headers: options.headers || {},
            postData: options.content ? options.content.toString() : '',
            initialPriority: 'Medium',
            referrerPolicy: 'no-referrer-when-downgrade',
        };
        const requestData = {
            requestId: requestId.toString(),
            url: request.url,
            request: request,
            timestamp: getTimeStamp(),
            type: 'Document',
            wallTime: 0,
        };
        global.__inspector.requestWillBeSent(requestData);
    }
    NetworkAgent.requestWillBeSent = requestWillBeSent;
    function getTimeStamp() {
        const d = new Date();
        return Math.round(d.getTime() / 1000);
    }
    function mimeTypeToType(mimeType) {
        let type = 'Document';
        if (mimeType) {
            if (mimeType.indexOf('image') === 0) {
                type = 'Image';
            }
            else if (mimeType.indexOf('javascript') !== -1 || mimeType.indexOf('json') !== -1) {
                type = 'Script';
            }
        }
        return type;
    }
})(NetworkAgent || (NetworkAgent = {}));
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NavigationType; });
var NavigationType;
(function (NavigationType) {
    NavigationType[NavigationType["back"] = 0] = "back";
    NavigationType[NavigationType["forward"] = 1] = "forward";
    NavigationType[NavigationType["replace"] = 2] = "replace";
})(NavigationType || (NavigationType = {}));
//# sourceMappingURL=frame-interfaces.js.map; 
if (false ) {} 

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Source", function() { return Source; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScopeError", function() { return ScopeError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceError", function() { return SourceError; });
/* harmony import */ var _file_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);

let debug = true;
let applicationRootPath;
function ensureAppRootPath() {
    if (!applicationRootPath) {
        applicationRootPath = _file_system__WEBPACK_IMPORTED_MODULE_0__["knownFolders"].currentApp().path;
        applicationRootPath = applicationRootPath.substr(0, applicationRootPath.length - 'app/'.length);
    }
}
class Source {
    constructor(uri, line, column) {
        ensureAppRootPath();
        if (uri.length > applicationRootPath.length && uri.substr(0, applicationRootPath.length) === applicationRootPath) {
            this._uri = 'file://' + uri.substr(applicationRootPath.length);
        }
        else {
            this._uri = uri;
        }
        this._line = line;
        this._column = column;
    }
    get uri() {
        return this._uri;
    }
    get line() {
        return this._line;
    }
    get column() {
        return this._column;
    }
    toString() {
        return this._uri + ':' + this._line + ':' + this._column;
    }
    static get(object) {
        return object[Source._source];
    }
    static set(object, src) {
        object[Source._source] = src;
    }
}
Source._source = Symbol('source');
class ScopeError extends Error {
    constructor(inner, message) {
        let formattedMessage;
        if (message && inner.message) {
            formattedMessage = message + '\n > ' + inner.message.replace('\n', '\n  ');
        }
        else {
            formattedMessage = message || inner.message || undefined;
        }
        super(formattedMessage);
        this.stack =  false ? undefined : inner.stack;
        this.message = formattedMessage;
    }
}
class SourceError extends ScopeError {
    constructor(child, source, message) {
        super(child, message ? message + ' @' + source + '' : source + '');
    }
}
//# sourceMappingURL=debug.js.map; 
if (false ) {} 

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Builder; });
/* unused harmony export parse */
/* unused harmony export parseMultipleTemplates */
/* unused harmony export load */
/* unused harmony export createViewFromEntry */
/* harmony import */ var _utils_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _xml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _component_builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _module_name_sanitizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _module_name_resolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36);
// Types.








const ios = _platform__WEBPACK_IMPORTED_MODULE_4__["platformNames"].ios.toLowerCase();
const android = _platform__WEBPACK_IMPORTED_MODULE_4__["platformNames"].android.toLowerCase();
const defaultNameSpaceMatcher = /tns\.xsd$/i;
class Builder {
    static createViewFromEntry(entry) {
        if (entry.create) {
            const view = entry.create();
            if (!view) {
                throw new Error('Failed to create View with entry.create() function.');
            }
            return view;
        }
        else if (entry.moduleName) {
            const moduleName = Object(_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_6__[/* sanitizeModuleName */ "a"])(entry.moduleName);
            const resolvedCodeModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(moduleName, ''); //`${moduleName}.xml`;
            let moduleExports = resolvedCodeModuleName ? global.loadModule(resolvedCodeModuleName, true) : null;
            if (moduleExports && moduleExports.createPage) {
                // Exports has a createPage() method
                const view = moduleExports.createPage();
                const resolvedCssModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(moduleName, 'css'); //entry.moduleName + ".css";
                if (resolvedCssModuleName) {
                    view.addCssFile(resolvedCssModuleName);
                }
                return view;
            }
            else {
                const componentModule = loadInternal(moduleName, moduleExports);
                const componentView = componentModule && componentModule.component;
                return componentView;
            }
        }
        throw new Error('Failed to load page XML file for module: ' + entry.moduleName);
    }
    static parse(value, context) {
        if (typeof value === 'function') {
            return value();
        }
        else {
            const exports = context ? getExports(context) : undefined;
            const componentModule = parseInternal(value, exports);
            return componentModule && componentModule.component;
        }
    }
    static load(pathOrOptions, context) {
        let componentModule;
        if (typeof pathOrOptions === 'string') {
            const moduleName = Object(_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_6__[/* sanitizeModuleName */ "a"])(pathOrOptions);
            componentModule = loadInternal(moduleName, context);
        }
        else {
            componentModule = loadCustomComponent(pathOrOptions.path, pathOrOptions.name, pathOrOptions.attributes, pathOrOptions.exports, pathOrOptions.page, true);
        }
        return componentModule && componentModule.component;
    }
    static parseMultipleTemplates(value, context) {
        const dummyComponent = `<ListView><ListView.itemTemplates>${value}</ListView.itemTemplates></ListView>`;
        return parseInternal(dummyComponent, context).component['itemTemplates'];
    }
}
// ui plugin developers can add to these to define their own custom types if needed
Builder.knownTemplates = new Set(['itemTemplate']);
Builder.knownMultiTemplates = new Set(['itemTemplates']);
Builder.knownCollections = new Set(['items', 'spans', 'actionItems']);
function parse(value, context) {
    console.log('parse() is deprecated. Use Builder.parse() instead.');
    return Builder.parse(value, context);
}
function parseMultipleTemplates(value, context) {
    console.log('parseMultipleTemplates() is deprecated. Use Builder.parseMultipleTemplates() instead.');
    return Builder.parseMultipleTemplates(value, context);
}
function load(pathOrOptions, context) {
    console.log('load() is deprecated. Use Builder.load() instead.');
    return Builder.load(pathOrOptions, context);
}
function createViewFromEntry(entry) {
    console.log('createViewFromEntry() is deprecated. Use Builder.createViewFromEntry() instead.');
    return Builder.createViewFromEntry(entry);
}
function loadInternal(moduleName, moduleExports) {
    let componentModule;
    const resolvedXmlModule = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(moduleName, 'xml');
    if (resolvedXmlModule) {
        const text = global.loadModule(resolvedXmlModule, true);
        componentModule = parseInternal(text, moduleExports, resolvedXmlModule, moduleName);
    }
    const componentView = componentModule && componentModule.component;
    if (componentView) {
        // Save exports to root component (will be used for templates).
        componentView.exports = moduleExports;
        // Save _moduleName - used for livesync
        componentView._moduleName = moduleName;
    }
    if (!componentModule) {
        throw new Error('Failed to load component from module: ' + moduleName);
    }
    return componentModule;
}
function loadCustomComponent(componentNamespace, componentName, attributes, context, parentPage, isRootComponent = true, moduleNamePath) {
    if (!parentPage && context) {
        // Read the parent page that was passed down below
        // https://github.com/NativeScript/NativeScript/issues/1639
        parentPage = context['_parentPage'];
        delete context['_parentPage'];
    }
    let result;
    componentNamespace = Object(_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_6__[/* sanitizeModuleName */ "a"])(componentNamespace);
    const moduleName = `${componentNamespace}/${componentName}`;
    const resolvedCodeModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(moduleName, '');
    const resolvedXmlModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(moduleName, 'xml');
    let resolvedCssModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(moduleName, 'css');
    if (resolvedXmlModuleName) {
        // Custom components with XML
        let subExports = context;
        if (resolvedCodeModuleName) {
            // Component has registered code module.
            subExports = global.loadModule(resolvedCodeModuleName, true);
        }
        // Pass the parent page down the chain in case of custom components nested on many levels. Use the context for piggybacking.
        // https://github.com/NativeScript/NativeScript/issues/1639
        if (!subExports) {
            subExports = {};
        }
        subExports['_parentPage'] = parentPage;
        result = loadInternal(moduleName, subExports);
        // Attributes will be transferred to the custom component
        if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isDefined */ "f"])(result) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isDefined */ "f"])(result.component) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isDefined */ "f"])(attributes)) {
            for (let attr in attributes) {
                Object(_component_builder__WEBPACK_IMPORTED_MODULE_3__[/* setPropertyValue */ "b"])(result.component, subExports, context, attr, attributes[attr]);
            }
        }
    }
    else {
        // Custom components without XML
        result = Object(_component_builder__WEBPACK_IMPORTED_MODULE_3__[/* getComponentModule */ "a"])(componentName, componentNamespace, attributes, context, moduleNamePath, isRootComponent);
        // The namespace is the JS module and the (componentName is the name of the class in the module)
        // So if there is no componentNamespace/componentName.{qualifiers}.css we should also look for
        // componentNamespace.{qualifiers}.css
        if (!resolvedCssModuleName) {
            resolvedCssModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_7__[/* resolveModuleName */ "c"])(componentNamespace, 'css');
        }
    }
    // Add CSS from webpack module if exists.
    if (parentPage && resolvedCssModuleName) {
        parentPage.addCssFile(resolvedCssModuleName);
    }
    return result;
}
function getExports(instance) {
    const isView = !!instance._domId;
    if (!isView) {
        return instance.exports || instance;
    }
    let exportObject = instance.exports;
    let parent = instance.parent;
    while (exportObject === undefined && parent) {
        exportObject = parent.exports;
        parent = parent.parent;
    }
    return exportObject;
}
function parseInternal(value, context, xmlModule, moduleName) {
    let start;
    let ui;
    const errorFormat = _utils_debug__WEBPACK_IMPORTED_MODULE_0__["debug"] && xmlModule ? xml2ui.SourceErrorFormat(xmlModule) : xml2ui.PositionErrorFormat;
    const componentSourceTracker = _utils_debug__WEBPACK_IMPORTED_MODULE_0__["debug"] && xmlModule
        ? xml2ui.ComponentSourceTracker(xmlModule)
        : () => {
            // no-op
        };
    (start = new xml2ui.XmlStringParser(errorFormat)).pipe(new xml2ui.PlatformFilter()).pipe(new xml2ui.XmlStateParser((ui = new xml2ui.ComponentParser(context, errorFormat, componentSourceTracker, moduleName))));
    start.parse(value);
    return ui.rootComponentModule;
}
var xml2ui;
(function (xml2ui) {
    class XmlProducerBase {
        pipe(next) {
            this._next = next;
            return next;
        }
        next(args) {
            this._next.parse(args);
        }
    }
    xml2ui.XmlProducerBase = XmlProducerBase;
    class XmlStringParser extends XmlProducerBase {
        constructor(error) {
            super();
            this.error = error || PositionErrorFormat;
        }
        parse(value) {
            const xmlParser = new _xml__WEBPACK_IMPORTED_MODULE_1__[/* XmlParser */ "c"]((args) => {
                try {
                    this.next(args);
                }
                catch (e) {
                    throw this.error(e, args.position);
                }
            }, (e, p) => {
                throw this.error(e, p);
            }, true);
            if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(value)) {
                xmlParser.parse(value);
            }
            else if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isObject */ "j"])(value) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(value.default)) {
                xmlParser.parse(value.default);
            }
        }
    }
    xml2ui.XmlStringParser = XmlStringParser;
    function PositionErrorFormat(e, p) {
        return new _utils_debug__WEBPACK_IMPORTED_MODULE_0__["ScopeError"](e, 'Parsing XML at ' + p.line + ':' + p.column);
    }
    xml2ui.PositionErrorFormat = PositionErrorFormat;
    function SourceErrorFormat(uri) {
        return (e, p) => {
            const source = p ? new _utils_debug__WEBPACK_IMPORTED_MODULE_0__["Source"](uri, p.line, p.column) : new _utils_debug__WEBPACK_IMPORTED_MODULE_0__["Source"](uri, -1, -1);
            e = new _utils_debug__WEBPACK_IMPORTED_MODULE_0__["SourceError"](e, source, 'Building UI from XML.');
            return e;
        };
    }
    xml2ui.SourceErrorFormat = SourceErrorFormat;
    function ComponentSourceTracker(uri) {
        return (component, p) => {
            if (!_utils_debug__WEBPACK_IMPORTED_MODULE_0__["Source"].get(component)) {
                const source = p ? new _utils_debug__WEBPACK_IMPORTED_MODULE_0__["Source"](uri, p.line, p.column) : new _utils_debug__WEBPACK_IMPORTED_MODULE_0__["Source"](uri, -1, -1);
                _utils_debug__WEBPACK_IMPORTED_MODULE_0__["Source"].set(component, source);
            }
        };
    }
    xml2ui.ComponentSourceTracker = ComponentSourceTracker;
    class PlatformFilter extends XmlProducerBase {
        parse(args) {
            if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].StartElement) {
                if (PlatformFilter.isPlatform(args.elementName)) {
                    if (this.currentPlatformContext) {
                        throw new Error("Already in '" + this.currentPlatformContext + "' platform context and cannot switch to '" + args.elementName + "' platform! Platform tags cannot be nested.");
                    }
                    this.currentPlatformContext = args.elementName;
                    return;
                }
            }
            if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].EndElement) {
                if (PlatformFilter.isPlatform(args.elementName)) {
                    this.currentPlatformContext = undefined;
                    return;
                }
            }
            if (this.currentPlatformContext && !PlatformFilter.isCurentPlatform(this.currentPlatformContext)) {
                return;
            }
            this.next(args);
        }
        static isPlatform(value) {
            if (value) {
                const toLower = value.toLowerCase();
                return toLower === android || toLower === ios;
            }
            return false;
        }
        static isCurentPlatform(value) {
            return value && value.toLowerCase() === _platform__WEBPACK_IMPORTED_MODULE_4__["Device"].os.toLowerCase();
        }
    }
    xml2ui.PlatformFilter = PlatformFilter;
    class XmlArgsReplay extends XmlProducerBase {
        constructor(args, errorFormat) {
            super();
            this.args = args;
            this.error = errorFormat;
        }
        replay() {
            this.args.forEach((args) => {
                try {
                    this.next(args);
                }
                catch (e) {
                    throw this.error(e, args.position);
                }
            });
        }
    }
    xml2ui.XmlArgsReplay = XmlArgsReplay;
    /**
     * It is a state pattern
     * https://en.wikipedia.org/wiki/State_pattern
     */
    class XmlStateParser {
        constructor(state) {
            this.state = state;
        }
        parse(args) {
            this.state = this.state.parse(args);
        }
    }
    xml2ui.XmlStateParser = XmlStateParser;
    class TemplateParser {
        constructor(parent, templateProperty, setTemplateProperty = true) {
            this.parent = parent;
            this._context = templateProperty.context;
            this._recordedXmlStream = new Array();
            this._templateProperty = templateProperty;
            this._nestingLevel = 0;
            this._state = 0 /* EXPECTING_START */;
            this._setTemplateProperty = setTemplateProperty;
        }
        parse(args) {
            if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].StartElement) {
                this.parseStartElement(args.prefix, args.namespace, args.elementName, args.attributes);
            }
            else if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].EndElement) {
                this.parseEndElement(args.prefix, args.elementName);
            }
            this._recordedXmlStream.push(args);
            return this._state === 2 /* FINISHED */ ? this.parent : this;
        }
        get elementName() {
            return this._templateProperty.elementName;
        }
        parseStartElement(prefix, namespace, elementName, attributes) {
            if (this._state === 0 /* EXPECTING_START */) {
                this._state = 1 /* PARSING */;
            }
            else if (this._state === 2 /* FINISHED */) {
                throw new Error('Template must have exactly one root element but multiple elements were found.');
            }
            this._nestingLevel++;
        }
        parseEndElement(prefix, elementName) {
            if (this._state === 0 /* EXPECTING_START */) {
                throw new Error('Template must have exactly one root element but none was found.');
            }
            else if (this._state === 2 /* FINISHED */) {
                throw new Error('No more closing elements expected for this template.');
            }
            this._nestingLevel--;
            if (this._nestingLevel === 0) {
                this._state = 2 /* FINISHED */;
                if (this._setTemplateProperty && this._templateProperty.name in this._templateProperty.parent.component) {
                    let template = this.buildTemplate();
                    this._templateProperty.parent.component[this._templateProperty.name] = template;
                }
            }
        }
        buildTemplate() {
            const context = this._context;
            const errorFormat = this._templateProperty.errorFormat;
            const sourceTracker = this._templateProperty.sourceTracker;
            const template = Object(_profiling__WEBPACK_IMPORTED_MODULE_5__[/* profile */ "f"])('Template()', () => {
                let start;
                let ui;
                (start = new xml2ui.XmlArgsReplay(this._recordedXmlStream, errorFormat))
                    // No platform filter, it has been filtered already
                    .pipe(new XmlStateParser((ui = new ComponentParser(context, errorFormat, sourceTracker))));
                start.replay();
                return ui.rootComponentModule.component;
            });
            return template;
        }
    }
    xml2ui.TemplateParser = TemplateParser;
    class MultiTemplateParser {
        constructor(parent, templateProperty) {
            this.parent = parent;
            this.templateProperty = templateProperty;
            this._childParsers = new Array();
        }
        get value() {
            return this._value;
        }
        parse(args) {
            if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].StartElement && args.elementName === 'template') {
                let childParser = new TemplateParser(this, this.templateProperty, false);
                childParser['key'] = args.attributes['key'];
                this._childParsers.push(childParser);
                return childParser;
            }
            if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].EndElement) {
                let name = ComponentParser.getComplexPropertyName(args.elementName);
                if (name === this.templateProperty.name) {
                    let templates = new Array();
                    for (let i = 0; i < this._childParsers.length; i++) {
                        templates.push({
                            key: this._childParsers[i]['key'],
                            createView: this._childParsers[i].buildTemplate(),
                        });
                    }
                    this._value = templates;
                    return this.parent.parse(args);
                }
            }
            return this;
        }
    }
    xml2ui.MultiTemplateParser = MultiTemplateParser;
    class ComponentParser {
        constructor(context, errorFormat, sourceTracker, moduleName) {
            this.moduleName = moduleName;
            this.parents = new Array();
            this.complexProperties = new Array();
            this.context = context;
            this.error = errorFormat;
            this.sourceTracker = sourceTracker;
        }
        buildComponent(args) {
            if (args.prefix && args.namespace) {
                // Custom components
                return loadCustomComponent(args.namespace, args.elementName, args.attributes, this.context, this.currentRootView, !this.currentRootView, this.moduleName);
            }
            else {
                // Default components
                let namespace = args.namespace;
                if (defaultNameSpaceMatcher.test(namespace || '')) {
                    //Ignore the default ...tns.xsd namespace URL
                    namespace = undefined;
                }
                return Object(_component_builder__WEBPACK_IMPORTED_MODULE_3__[/* getComponentModule */ "a"])(args.elementName, namespace, args.attributes, this.context, this.moduleName, !this.currentRootView);
            }
        }
        parse(args) {
            // Get the current parent.
            const parent = this.parents[this.parents.length - 1];
            const complexProperty = this.complexProperties[this.complexProperties.length - 1];
            // Create component instance from every element declaration.
            if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].StartElement) {
                if (ComponentParser.isComplexProperty(args.elementName)) {
                    const name = ComponentParser.getComplexPropertyName(args.elementName);
                    const complexProperty = {
                        parent: parent,
                        name: name,
                        items: [],
                    };
                    this.complexProperties.push(complexProperty);
                    if (ComponentParser.isKnownTemplate(name, parent.exports)) {
                        return new TemplateParser(this, {
                            context: (parent ? getExports(parent.component) : null) || this.context,
                            parent: parent,
                            name: name,
                            elementName: args.elementName,
                            templateItems: [],
                            errorFormat: this.error,
                            sourceTracker: this.sourceTracker,
                        });
                    }
                    if (ComponentParser.isKnownMultiTemplate(name, parent.exports)) {
                        const parser = new MultiTemplateParser(this, {
                            context: (parent ? getExports(parent.component) : null) || this.context,
                            parent: parent,
                            name: name,
                            elementName: args.elementName,
                            templateItems: [],
                            errorFormat: this.error,
                            sourceTracker: this.sourceTracker,
                        });
                        complexProperty.parser = parser;
                        return parser;
                    }
                }
                else {
                    const componentModule = this.buildComponent(args);
                    if (componentModule) {
                        this.sourceTracker(componentModule.component, args.position);
                        if (parent) {
                            if (complexProperty) {
                                // Add component to complex property of parent component.
                                ComponentParser.addToComplexProperty(parent, complexProperty, componentModule);
                            }
                            else if (parent.component._addChildFromBuilder) {
                                parent.component._addChildFromBuilder(args.elementName, componentModule.component);
                            }
                        }
                        else if (this.parents.length === 0) {
                            // Set root component.
                            this.rootComponentModule = componentModule;
                            if (this.rootComponentModule) {
                                this.currentRootView = this.rootComponentModule.component;
                                if (this.currentRootView.exports) {
                                    this.context = this.currentRootView.exports;
                                }
                            }
                        }
                        // Add the component instance to the parents scope collection.
                        this.parents.push(componentModule);
                    }
                }
            }
            else if (args.eventType === _xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEventType */ "b"].EndElement) {
                if (ComponentParser.isComplexProperty(args.elementName)) {
                    if (complexProperty) {
                        if (complexProperty.parser) {
                            parent.component[complexProperty.name] = complexProperty.parser.value;
                        }
                        else if (parent && parent.component._addArrayFromBuilder) {
                            // If parent is AddArrayFromBuilder call the interface method to populate the array property.
                            parent.component._addArrayFromBuilder(complexProperty.name, complexProperty.items);
                            complexProperty.items = [];
                        }
                    }
                    // Remove the last complexProperty from the complexProperties collection (move to the previous complexProperty scope).
                    this.complexProperties.pop();
                }
                else {
                    // Remove the last parent from the parents collection (move to the previous parent scope).
                    this.parents.pop();
                }
            }
            return this;
        }
        static isComplexProperty(name) {
            return Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(name) && name.indexOf('.') !== -1;
        }
        static getComplexPropertyName(fullName) {
            let name;
            if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_2__[/* isString */ "k"])(fullName)) {
                const names = fullName.split('.');
                name = names[names.length - 1];
            }
            return name;
        }
        static isKnownTemplate(name, exports) {
            return Builder.knownTemplates.has(name);
        }
        static isKnownMultiTemplate(name, exports) {
            return Builder.knownMultiTemplates.has(name);
        }
        static addToComplexProperty(parent, complexProperty, elementModule) {
            // If property name is known collection we populate array with elements.
            const parentComponent = parent.component;
            if (ComponentParser.isKnownCollection(complexProperty.name, parent.exports)) {
                complexProperty.items.push(elementModule.component);
            }
            else if (parentComponent._addChildFromBuilder) {
                parentComponent._addChildFromBuilder(complexProperty.name, elementModule.component);
            }
            else {
                // Or simply assign the value;
                parentComponent[complexProperty.name] = elementModule.component;
            }
        }
        static isKnownCollection(name, context) {
            return Builder.knownCollections.has(name);
        }
    }
    ComponentParser.KNOWNCOLLECTIONS = 'knownCollections';
    ComponentParser.KNOWNTEMPLATES = 'knownTemplates';
    ComponentParser.KNOWNMULTITEMPLATES = 'knownMultiTemplates';
    __decorate([
        _profiling__WEBPACK_IMPORTED_MODULE_5__[/* profile */ "f"],
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [_xml__WEBPACK_IMPORTED_MODULE_1__[/* ParserEvent */ "a"]]),
        __metadata("design:returntype", Object)
    ], ComponentParser.prototype, "buildComponent", null);
    xml2ui.ComponentParser = ComponentParser;
})(xml2ui || (xml2ui = {}));
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addWeakEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return removeWeakEventListener; });
const handlersForEventName = new Map();
const sourcesMap = new WeakMap();
class TargetHandlerPair {
    constructor(target, handler) {
        this.tagetRef = new WeakRef(target);
        this.handler = handler;
    }
}
function getHandlerForEventName(eventName) {
    let handler = handlersForEventName.get(eventName);
    if (!handler) {
        handler = function (eventData) {
            const source = eventData.object;
            const sourceEventMap = sourcesMap.get(source);
            if (!sourceEventMap) {
                // There is no event map for this source - it is safe to detach the listener;
                source.removeEventListener(eventName, handlersForEventName.get(eventName));
                return;
            }
            const targetHandlerPairList = sourceEventMap.get(eventName);
            if (!targetHandlerPairList) {
                return;
            }
            const deadPairsIndexes = [];
            let pair;
            let target;
            for (let i = 0; i < targetHandlerPairList.length; i++) {
                pair = targetHandlerPairList[i];
                target = pair.tagetRef.get();
                if (target) {
                    pair.handler.call(target, eventData);
                }
                else {
                    deadPairsIndexes.push(i);
                }
            }
            if (deadPairsIndexes.length === targetHandlerPairList.length) {
                // There are no alive targets for this event - unsubscribe
                source.removeEventListener(eventName, handlersForEventName.get(eventName));
                sourceEventMap.delete(eventName);
            }
            else {
                for (let j = deadPairsIndexes.length - 1; j >= 0; j--) {
                    targetHandlerPairList.splice(deadPairsIndexes[j], 1);
                }
            }
        };
        handlersForEventName.set(eventName, handler);
    }
    return handler;
}
function validateArgs(source, eventName, handler, target) {
    if (!source) {
        throw new Error('source is null or undefined');
    }
    if (!target) {
        throw new Error('target is null or undefined');
    }
    if (typeof eventName !== 'string') {
        throw new Error('eventName is not a string');
    }
    if (typeof handler !== 'function') {
        throw new Error('handler is not a function');
    }
}
function addWeakEventListener(source, eventName, handler, target) {
    validateArgs(source, eventName, handler, target);
    let shouldAttach = false;
    let sourceEventMap = sourcesMap.get(source);
    if (!sourceEventMap) {
        sourceEventMap = new Map();
        sourcesMap.set(source, sourceEventMap);
        shouldAttach = true;
    }
    let pairList = sourceEventMap.get(eventName);
    if (!pairList) {
        pairList = new Array();
        sourceEventMap.set(eventName, pairList);
        shouldAttach = true;
    }
    pairList.push(new TargetHandlerPair(target, handler));
    if (shouldAttach) {
        source.addEventListener(eventName, getHandlerForEventName(eventName));
    }
}
function removeWeakEventListener(source, eventName, handler, target) {
    validateArgs(source, eventName, handler, target);
    const handlerForEventWithName = handlersForEventName.get(eventName);
    if (!handlerForEventWithName) {
        // We have never created handler for event with this name;
        return;
    }
    const sourceEventMap = sourcesMap.get(source);
    if (!sourceEventMap) {
        return;
    }
    const targetHandlerPairList = sourceEventMap.get(eventName);
    if (!targetHandlerPairList) {
        return;
    }
    // Remove all pairs that match given target and handler or have a dead target
    const targetHandlerPairsToRemove = [];
    let pair;
    let registeredTarget;
    for (let i = 0; i < targetHandlerPairList.length; i++) {
        pair = targetHandlerPairList[i];
        registeredTarget = pair.tagetRef.get();
        if (!registeredTarget || (registeredTarget === target && handler === pair.handler)) {
            targetHandlerPairsToRemove.push(i);
        }
    }
    if (targetHandlerPairsToRemove.length === targetHandlerPairList.length) {
        // There are no alive targets for this event - unsubscribe
        source.removeEventListener(eventName, handlerForEventWithName);
        sourceEventMap.delete(eventName);
    }
    else {
        for (let j = targetHandlerPairsToRemove.length - 1; j >= 0; j--) {
            targetHandlerPairList.splice(targetHandlerPairsToRemove[j], 1);
        }
    }
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ParserEventType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ParserEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return XmlParser; });
/* harmony import */ var _js_libs_easysax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/* harmony import */ var _js_libs_easysax__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_js_libs_easysax__WEBPACK_IMPORTED_MODULE_0__);
// TODO: Delete `nativescript-core/xml/xml.js` from source control after
// https://github.com/NativeScript/nativescript-dev-webpack/issues/932
const easysax = __webpack_require__(104);

class ParserEventType {
}
ParserEventType.StartElement = 'StartElement';
ParserEventType.EndElement = 'EndElement';
ParserEventType.Text = 'Text';
ParserEventType.CDATA = 'CDATA';
ParserEventType.Comment = 'Comment';
class ParserEvent {
    constructor(eventType, position, prefix, namespace, elementName, attributes, data) {
        this._eventType = eventType;
        this._position = position;
        this._prefix = prefix;
        this._namespace = namespace;
        this._elementName = elementName;
        this._attributes = attributes;
        this._data = data;
    }
    toString() {
        return JSON.stringify({
            eventType: this.eventType,
            position: this.position,
            prefix: this.prefix,
            namespace: this.namespace,
            elementName: this.elementName,
            attributes: this.attributes,
            data: this.data,
        });
    }
    get eventType() {
        return this._eventType;
    }
    get position() {
        return this._position;
    }
    get prefix() {
        return this._prefix;
    }
    get namespace() {
        return this._namespace;
    }
    get elementName() {
        return this._elementName;
    }
    get attributes() {
        return this._attributes;
    }
    get data() {
        return this._data;
    }
}
let _ampCodes;
const _entitySearchRegEx = /&#(\d+);|&#x([0123456789abcdef]+);|&(\w+);/gi;
function _generateAmpMap() {
    const objCodes = {
        Tab: 9,
        NewLine: 10,
        excl: 33,
        quot: 34,
        QUOT: 34,
        num: 35,
        dollar: 36,
        percent: 37,
        amp: 38,
        AMP: 38,
        apos: 39,
        lpar: 40,
        rpar: 41,
        ast: 42,
        midast: 42,
        plus: 43,
        comma: 44,
        period: 46,
        sol: 47,
        colon: 58,
        semi: 59,
        lt: 60,
        LT: 60,
        equals: 61,
        gt: 62,
        GT: 62,
        quest: 63,
        commat: 64,
        lsqb: 91,
        lbrack: 91,
        bsol: 92,
        rsqb: 92,
        rbrack: 92,
        Hat: 94,
        lowbar: 95,
        grave: 96,
        DiacriticalGrave: 96,
        lcub: 123,
        lbrace: 123,
        verbar: 124,
        vert: 124,
        VerticalLine: 124,
        rcub: 125,
        rbrace: 125,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        brkbar: 166,
        sect: 167,
        uml: 168,
        copy: 169,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        reg: 174,
        macr: 175,
        hibar: 175,
        deg: 176,
        plusmn: 177,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        sup1: 185,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        Agrave: 192,
        Aacute: 193,
        Acirc: 194,
        Atilde: 195,
        Auml: 196,
        Aring: 197,
        AElig: 198,
        Ccedil: 199,
        Egrave: 200,
        Eacute: 201,
        Ecirc: 202,
        Euml: 203,
        Igrave: 204,
        Iacute: 205,
        Icirc: 206,
        Iuml: 207,
        ETH: 208,
        Dstrok: 208,
        Ntilde: 209,
        Ograve: 210,
        Oacute: 211,
        Ocirc: 212,
        Otilde: 213,
        Ouml: 214,
        times: 215,
        Oslash: 216,
        Ugrave: 217,
        Uacute: 218,
        Ucirc: 219,
        Uuml: 220,
        Yacute: 221,
        THORN: 222,
        szlig: 223,
        agrave: 224,
        aacute: 225,
        acirc: 226,
        atilde: 227,
        auml: 228,
        aring: 229,
        aelig: 230,
        ccedil: 231,
        egrave: 232,
        eacute: 233,
        ecirc: 234,
        euml: 235,
        igrave: 236,
        iacute: 237,
        icirc: 238,
        iuml: 239,
        eth: 240,
        ntilde: 241,
        ograve: 242,
        oacute: 243,
        ocirc: 244,
        otilde: 245,
        ouml: 246,
        divide: 247,
        oslash: 248,
        ugrave: 249,
        uacute: 250,
        ucirc: 251,
        uuml: 252,
        yacute: 253,
        thorn: 254,
        yuml: 255,
        fnof: 402,
        imped: 437,
        gacute: 501,
        jmath: 567,
        circ: 710,
        caron: 711,
        Hacek: 711,
        breve: 728,
        Breve: 728,
        dot: 729,
        DiacriticalDot: 729,
        ring: 730,
        ogon: 731,
        tilde: 732,
        DiacriticalTilde: 732,
        dblac: 733,
        DiacriticalDoubleAcute: 733,
        DownBreve: 785,
        UnderBar: 818,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929 /* 930 is not real */,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        epsiv: 949,
        varepsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigmav: 962,
        varsigma: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetav: 977,
        vartheta: 977,
        thetasym: 977,
        Upsi: 978,
        upsih: 978,
        straightphi: 981,
        piv: 982,
        varpi: 982,
        Gammad: 988,
        gammad: 989,
        digamma: 989,
        kappav: 1008,
        varkappa: 1008,
        rhov: 1009,
        varrho: 1009,
        epsi: 1013,
        straightepsilon: 1013,
        bepsi: 1014,
        backepsilon: 1014,
        /* Skipped Codes 1015 - 1119 */ euro: 8364,
        trade: 8482,
        TRADE: 8482,
        forall: 8704,
        part: 8706,
        larr: 8592,
        rarr: 8593,
        hyphen: 8208,
        dash: 8208,
        ndash: 8211,
        mdash: 8212,
        horbar: 8213,
        Vert: 8214,
        Verbar: 8214,
        lsquo: 8216,
        OpenCurlyQuote: 8216,
        rsquo: 8217,
        rsquor: 8217,
        CloseCurlyQuote: 8217,
        lsquor: 8218,
        sbquo: 8218,
        ldquo: 8220,
        OpenCurlyDoubleQuote: 8220,
        rdquo: 8221,
        rdquor: 8221,
        CloseCurlyDoubleQuote: 8221,
        ldquor: 8222,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        ddagger: 8225,
        bull: 8226,
        bullet: 8226,
        nldr: 8229,
        hellip: 8230,
        mldr: 8230,
        hybull: 8259,
        tdot: 8411,
        TripleDot: 8411,
        DotDot: 8412,
        star: 9734,
        phone: 9742,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830,
        female: 9792,
        male: 9794,
        check: 10003,
        checkmark: 10003,
        cross: 10007,
        VerticalSeparator: 10072,
        EmptySmallSquare: 9723,
        FilledSmallSquare: 9724,
        starf: 9733,
        bigstar: 9733,
        square: 9633,
        squ: 9633,
        Square: 9633,
    };
    const ampCodes = new Map();
    for (let key in objCodes) {
        if (objCodes.hasOwnProperty(key)) {
            ampCodes.set(key, objCodes[key]);
        }
    }
    return ampCodes;
}
// android-specific implementation, which pre-populates the map to get it saved into the heap blob
if (global.__snapshot) {
    _ampCodes = _generateAmpMap();
}
function _HandleAmpEntities(found, decimalValue, hexValue, wordValue) {
    if (wordValue) {
        if (!_ampCodes) {
            _ampCodes = _generateAmpMap();
        }
        const res = _ampCodes.get(wordValue);
        if (res) {
            return String.fromCodePoint(res);
        }
        // Invalid word; so we just return it
        return found;
    }
    if (decimalValue) {
        return String.fromCodePoint(parseInt(decimalValue, 10));
    }
    return String.fromCodePoint(parseInt(hexValue, 16));
}
class XmlParser {
    constructor(onEvent, onError, processNamespaces) {
        this._processNamespaces = processNamespaces;
        this._parser = new _js_libs_easysax__WEBPACK_IMPORTED_MODULE_0__["EasySAXParser"]();
        const that = this;
        this._parser.on('startNode', function (elem, attr, uq, tagend, str, pos) {
            let attributes = attr();
            if (attributes === true) {
                //HACK: For some reason easysax returns the true literal when an element has no attributes.
                attributes = undefined;
            }
            if (attributes) {
                for (let key in attributes) {
                    if (attributes.hasOwnProperty(key)) {
                        // Convert entities such as &gt; to >
                        attributes[key] = XmlParser._dereferenceEntities(attributes[key]);
                    }
                }
            }
            let prefix = undefined;
            let namespace = undefined;
            let name = elem;
            if (that._processNamespaces) {
                const stackEntry = XmlParser._getNamespacesStackEntry(attributes);
                that._namespaceStack.push(stackEntry);
                const resolved = that._resolveNamespace(name);
                prefix = resolved.prefix;
                namespace = resolved.namespace;
                name = resolved.name;
            }
            onEvent(new ParserEvent(ParserEventType.StartElement, pos(), prefix, namespace, name, attributes, undefined));
        });
        this._parser.on('textNode', function (text, uq, pos) {
            const data = uq(XmlParser._dereferenceEntities(text)); // Decode entity references such as &lt; and &gt;
            onEvent(new ParserEvent(ParserEventType.Text, pos(), undefined, undefined, undefined, undefined, data));
        });
        this._parser.on('endNode', function (elem, uq, tagstart, str, pos) {
            let prefix = undefined;
            let namespace = undefined;
            let name = elem;
            if (that._processNamespaces) {
                const resolved = that._resolveNamespace(name);
                prefix = resolved.prefix;
                namespace = resolved.namespace;
                name = resolved.name;
            }
            onEvent(new ParserEvent(ParserEventType.EndElement, pos(), prefix, namespace, name, undefined, undefined));
            if (that._processNamespaces) {
                that._namespaceStack.pop();
            }
        });
        this._parser.on('cdata', function (data, res, pos) {
            onEvent(new ParserEvent(ParserEventType.CDATA, pos(), undefined, undefined, undefined, undefined, data));
        });
        this._parser.on('comment', function (text, uq, pos) {
            onEvent(new ParserEvent(ParserEventType.Comment, pos(), undefined, undefined, undefined, undefined, text));
        });
        if (onError) {
            this._parser.on('error', function (msg, pos) {
                onError(new Error(msg), pos());
            });
        }
    }
    get angularSyntax() {
        return this._parser.angularSyntax;
    }
    set angularSyntax(value) {
        this._parser.angularSyntax = value;
    }
    parse(xmlString) {
        if (this._processNamespaces) {
            this._namespaceStack = [];
        }
        this._parser.parse(xmlString);
    }
    static _getNamespacesStackEntry(attributes) {
        const stackEntry = {};
        if (!attributes) {
            return stackEntry;
        }
        let attributeName;
        let namespacePrefix;
        for (let key in attributes) {
            if (!attributes.hasOwnProperty(key)) {
                continue;
            }
            attributeName = key;
            if (attributeName.indexOf('xmlns') !== 0) {
                // This is a normal attribute, so go on.
                continue;
            }
            namespacePrefix = '';
            if (attributeName.indexOf(':') !== -1) {
                namespacePrefix = attributeName.split(':')[1];
            }
            stackEntry[namespacePrefix] = attributes[key];
        }
        return stackEntry;
    }
    _resolveNamespace(fullName) {
        const result = {
            prefix: undefined,
            namespace: undefined,
            name: undefined,
        };
        result.prefix = '';
        if (fullName.indexOf(':') !== -1) {
            const split = fullName.split(':');
            result.prefix = split[0];
            result.name = split[1];
        }
        else {
            result.name = fullName;
        }
        let stackEntry;
        for (let i = this._namespaceStack.length - 1; i >= 0; i--) {
            stackEntry = this._namespaceStack[i];
            for (let key in stackEntry) {
                if (!stackEntry.hasOwnProperty(key)) {
                    continue;
                }
                if (result.prefix === key) {
                    result.namespace = stackEntry[key];
                    return result;
                }
            }
        }
        return result;
    }
    static _dereferenceEntities(s) {
        s = String(s);
        if (s.length > 3 && s.indexOf('&') !== -1) {
            s = s.replace(_entitySearchRegEx, _HandleAmpEntities);
        }
        return s;
    }
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "hasKey", function() { return /* binding */ hasKey; });
__webpack_require__.d(__webpack_exports__, "getBoolean", function() { return /* binding */ getBoolean; });
__webpack_require__.d(__webpack_exports__, "getString", function() { return /* binding */ getString; });
__webpack_require__.d(__webpack_exports__, "getNumber", function() { return /* binding */ getNumber; });
__webpack_require__.d(__webpack_exports__, "setBoolean", function() { return /* binding */ setBoolean; });
__webpack_require__.d(__webpack_exports__, "setString", function() { return /* binding */ setString; });
__webpack_require__.d(__webpack_exports__, "setNumber", function() { return /* binding */ setNumber; });
__webpack_require__.d(__webpack_exports__, "remove", function() { return /* binding */ remove; });
__webpack_require__.d(__webpack_exports__, "clear", function() { return /* binding */ clear; });
__webpack_require__.d(__webpack_exports__, "flush", function() { return /* binding */ flush; });
__webpack_require__.d(__webpack_exports__, "getAllKeys", function() { return /* binding */ getAllKeys; });

// CONCATENATED MODULE: ../node_modules/@nativescript/core/application-settings/application-settings-common.js
function checkKey(key) {
    if (typeof key !== 'string') {
        throw new Error("key: '" + key + "' must be a string");
    }
}
function ensureValidValue(value, valueType) {
    if (typeof value !== valueType) {
        throw new Error("value: '" + value + "' must be a " + valueType);
    }
}
//# sourceMappingURL=application-settings-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/native-helper.js
var native_helper = __webpack_require__(38);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/application-settings/index.js


const userDefaults = NSUserDefaults.standardUserDefaults;
function hasKey(key) {
    checkKey(key);
    return userDefaults.objectForKey(key) !== null;
}
// utils.ios.getters
function getBoolean(key, defaultValue) {
    checkKey(key);
    if (hasKey(key)) {
        return userDefaults.boolForKey(key);
    }
    return defaultValue;
}
function getString(key, defaultValue) {
    checkKey(key);
    if (hasKey(key)) {
        return userDefaults.stringForKey(key);
    }
    return defaultValue;
}
function getNumber(key, defaultValue) {
    checkKey(key);
    if (hasKey(key)) {
        return userDefaults.doubleForKey(key);
    }
    return defaultValue;
}
// setters
function setBoolean(key, value) {
    checkKey(key);
    ensureValidValue(value, 'boolean');
    userDefaults.setBoolForKey(value, key);
}
function setString(key, value) {
    checkKey(key);
    ensureValidValue(value, 'string');
    userDefaults.setObjectForKey(value, key);
}
function setNumber(key, value) {
    checkKey(key);
    ensureValidValue(value, 'number');
    userDefaults.setDoubleForKey(value, key);
}
function remove(key) {
    checkKey(key);
    userDefaults.removeObjectForKey(key);
}
function clear() {
    userDefaults.removePersistentDomainForName(NSBundle.mainBundle.bundleIdentifier);
}
function flush() {
    return userDefaults.synchronize();
}
function getAllKeys() {
    return native_helper["a" /* iOSNativeHelper */].collections.nsArrayToJSArray(userDefaults.dictionaryRepresentation().allKeys);
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony import */ var _styling_background__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(102);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _core_view_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);
/* harmony import */ var _text_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var _text_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4);
/* harmony import */ var _styling_background__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(63);







var FixedSize;
(function (FixedSize) {
    FixedSize[FixedSize["NONE"] = 0] = "NONE";
    FixedSize[FixedSize["WIDTH"] = 1] = "WIDTH";
    FixedSize[FixedSize["HEIGHT"] = 2] = "HEIGHT";
    FixedSize[FixedSize["BOTH"] = 3] = "BOTH";
})(FixedSize || (FixedSize = {}));
let Label = class Label extends _text_base__WEBPACK_IMPORTED_MODULE_5__[/* TextBase */ "a"] {
    createNativeView() {
        const view = TNSLabel.new();
        view.userInteractionEnabled = true;
        return view;
    }
    // @ts-ignore
    get ios() {
        return this.nativeTextViewProtected;
    }
    get textWrap() {
        return this.style.whiteSpace === 'normal';
    }
    set textWrap(value) {
        if (typeof value === 'string') {
            value = Object(_core_view_base__WEBPACK_IMPORTED_MODULE_2__["booleanConverter"])(value);
        }
        this.style.whiteSpace = value ? 'normal' : 'nowrap';
    }
    _requestLayoutOnTextChanged() {
        if (this._fixedSize === FixedSize.BOTH) {
            return;
        }
        if (this._fixedSize === FixedSize.WIDTH && !this.textWrap && this.getMeasuredHeight() > 0) {
            // Single line label with fixed width will skip request layout on text change.
            return;
        }
        super._requestLayoutOnTextChanged();
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        let nativeView = this.nativeTextViewProtected;
        if (nativeView) {
            const width = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].getMeasureSpecSize(widthMeasureSpec);
            const widthMode = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].getMeasureSpecMode(widthMeasureSpec);
            const height = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].getMeasureSpecSize(heightMeasureSpec);
            const heightMode = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].getMeasureSpecMode(heightMeasureSpec);
            this._fixedSize = (widthMode === _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].EXACTLY ? FixedSize.WIDTH : FixedSize.NONE) | (heightMode === _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].EXACTLY ? FixedSize.HEIGHT : FixedSize.NONE);
            let nativeSize;
            if (this.textWrap) {
                // https://github.com/NativeScript/NativeScript/issues/4834
                // NOTE: utils.measureNativeView(...) relies on UIView.sizeThatFits(...) that
                // seems to have various issues when laying out UILabel instances.
                // We use custom measure logic here that relies on overriden
                // UILabel.textRectForBounds:limitedToNumberOfLines: in TNSLabel widget.
                nativeSize = this._measureNativeView(width, widthMode, height, heightMode);
            }
            else {
                // https://github.com/NativeScript/NativeScript/issues/6059
                // NOTE: _measureNativeView override breaks a scenario with StackLayout that arranges
                // labels horizontally (with textWrap=false) e.g. we are measuring label #2 within 356px,
                // label #2 needs more, and decides to show ellipsis(...) but because of this its native size
                // returned from UILabel.textRectForBounds:limitedToNumberOfLines: logic becomes 344px, so
                // StackLayout tries to measure label #3 within the remaining 12px which is wrong;
                // label #2 with ellipsis should take the whole 356px and label #3 should not be visible at all.
                nativeSize = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].measureNativeView(nativeView, width, widthMode, height, heightMode);
            }
            let labelWidth = nativeSize.width;
            if (this.textWrap && widthMode === _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].AT_MOST) {
                labelWidth = Math.min(labelWidth, width);
            }
            const measureWidth = Math.max(labelWidth, this.effectiveMinWidth);
            const measureHeight = Math.max(nativeSize.height, this.effectiveMinHeight);
            const widthAndState = _core_view__WEBPACK_IMPORTED_MODULE_3__[/* View */ "c"].resolveSizeAndState(measureWidth, width, widthMode, 0);
            const heightAndState = _core_view__WEBPACK_IMPORTED_MODULE_3__[/* View */ "c"].resolveSizeAndState(measureHeight, height, heightMode, 0);
            this.setMeasuredDimension(widthAndState, heightAndState);
        }
    }
    _measureNativeView(width, widthMode, height, heightMode) {
        const view = this.nativeTextViewProtected;
        const nativeSize = view.textRectForBoundsLimitedToNumberOfLines(CGRectMake(0, 0, widthMode === 0 /* layout.UNSPECIFIED */ ? Number.POSITIVE_INFINITY : _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(width), heightMode === 0 /* layout.UNSPECIFIED */ ? Number.POSITIVE_INFINITY : _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(height)), 0).size;
        nativeSize.width = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDevicePixels(nativeSize.width));
        nativeSize.height = _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDevicePixels(nativeSize.height));
        return nativeSize;
    }
    [_text_base__WEBPACK_IMPORTED_MODULE_6__[/* whiteSpaceProperty */ "k"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        switch (value) {
            case 'normal':
                nativeView.lineBreakMode = 0 /* ByWordWrapping */;
                nativeView.numberOfLines = 0;
                break;
            case 'nowrap':
            case 'initial':
                nativeView.lineBreakMode = 4 /* ByTruncatingTail */;
                nativeView.numberOfLines = 1;
                break;
        }
    }
    _redrawNativeBackground(value) {
        if (value instanceof _styling_background__WEBPACK_IMPORTED_MODULE_0__[/* Background */ "a"]) {
            _styling_background__WEBPACK_IMPORTED_MODULE_8__[/* ios */ "a"].createBackgroundUIColor(this, (color) => {
                const cgColor = color ? color.CGColor : null;
                this.nativeTextViewProtected.layer.backgroundColor = cgColor;
            }, true);
        }
        this._setNativeClipToBounds();
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["borderTopWidthProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectiveBorderTopWidth),
            right: border.right,
            bottom: border.bottom,
            left: border.left,
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["borderRightWidthProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: border.top,
            right: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectiveBorderRightWidth),
            bottom: border.bottom,
            left: border.left,
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["borderBottomWidthProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: border.top,
            right: border.right,
            bottom: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectiveBorderBottomWidth),
            left: border.left,
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["borderLeftWidthProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: border.top,
            right: border.right,
            bottom: border.bottom,
            left: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectiveBorderLeftWidth),
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["paddingTopProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const padding = nativeView.padding;
        nativeView.padding = {
            top: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectivePaddingTop),
            right: padding.right,
            bottom: padding.bottom,
            left: padding.left,
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["paddingRightProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const padding = nativeView.padding;
        nativeView.padding = {
            top: padding.top,
            right: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectivePaddingRight),
            bottom: padding.bottom,
            left: padding.left,
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["paddingBottomProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const padding = nativeView.padding;
        nativeView.padding = {
            top: padding.top,
            right: padding.right,
            bottom: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectivePaddingBottom),
            left: padding.left,
        };
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_1__["paddingLeftProperty"].setNative](value) {
        const nativeView = this.nativeTextViewProtected;
        const padding = nativeView.padding;
        nativeView.padding = {
            top: padding.top,
            right: padding.right,
            bottom: padding.bottom,
            left: _utils__WEBPACK_IMPORTED_MODULE_7__[/* layout */ "n"].toDeviceIndependentPixels(this.effectivePaddingLeft),
        };
    }
};
Label = __decorate([
    Object(_core_view__WEBPACK_IMPORTED_MODULE_4__[/* CSSType */ "a"])('Label')
], Label);

Label.prototype.recycleNativeView = 'auto';
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LinearGradient; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

class LinearGradient {
    static parse(value) {
        const result = new LinearGradient();
        result.angle = value.angle;
        result.colorStops = value.colors.map((color) => {
            const offset = color.offset || null;
            let offsetUnit;
            if (offset && offset.unit === '%') {
                offsetUnit = {
                    unit: '%',
                    value: offset.value,
                };
            }
            return {
                color: new _color__WEBPACK_IMPORTED_MODULE_0__[/* Color */ "a"](color.argb),
                offset: offsetUnit,
            };
        });
        return result;
    }
    static equals(first, second) {
        if (!first && !second) {
            return true;
        }
        else if (!first || !second) {
            return false;
        }
        if (first.angle !== second.angle) {
            return false;
        }
        if (first.colorStops.length !== second.colorStops.length) {
            return false;
        }
        for (let i = 0; i < first.colorStops.length; i++) {
            const firstStop = first.colorStops[i];
            const secondStop = second.colorStops[i];
            if (firstStop.offset !== secondStop.offset) {
                return false;
            }
            if (!_color__WEBPACK_IMPORTED_MODULE_0__[/* Color */ "a"].equals(firstStop.color, secondStop.color)) {
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=linear-gradient.js.map; 
if (false ) {} 

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EditableTextBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return placeholderColorProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return keyboardTypeProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return returnKeyTypeProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return editableProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return updateTextTriggerProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return autocapitalizationTypeProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return autocorrectProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hintProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return maxLengthProperty; });
/* harmony import */ var _text_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _core_view_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
/* harmony import */ var _styling_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);






class EditableTextBase extends _text_base__WEBPACK_IMPORTED_MODULE_0__[/* TextBase */ "a"] {
    constructor() {
        super(...arguments);
        this._focusHandler = () => this._goToVisualState('focus');
        this._blurHandler = () => this._goToVisualState('blur');
    }
    _updateTextBaseFocusStateHandler(subscribe) {
        const method = subscribe ? 'on' : 'off';
        this[method]('focus', this._focusHandler);
        this[method]('blur', this._blurHandler);
    }
}
EditableTextBase.blurEvent = 'blur';
EditableTextBase.focusEvent = 'focus';
EditableTextBase.textChangeEvent = 'textChange';
__decorate([
    Object(_core_view__WEBPACK_IMPORTED_MODULE_2__[/* PseudoClassHandler */ "b"])('focus', 'blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], EditableTextBase.prototype, "_updateTextBaseFocusStateHandler", null);
// TODO: Why not name it - hintColor property??
// TODO: Or rename hintProperty to 'placeholder' and make it CSSProperty??
// https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-placeholder
const placeholderColorProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["CssProperty"]({
    name: 'placeholderColor',
    cssName: 'placeholder-color',
    equalityComparer: _color__WEBPACK_IMPORTED_MODULE_5__[/* Color */ "a"].equals,
    valueConverter: (v) => new _color__WEBPACK_IMPORTED_MODULE_5__[/* Color */ "a"](v),
});
placeholderColorProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_4__[/* Style */ "a"]);
const keyboardTypeConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_1__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_1__["makeValidator"])('datetime', 'phone', 'number', 'url', 'email', 'integer'));
const keyboardTypeProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({ name: 'keyboardType', valueConverter: keyboardTypeConverter });
keyboardTypeProperty.register(EditableTextBase);
const returnKeyTypeConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_1__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_1__["makeValidator"])('done', 'next', 'go', 'search', 'send'));
const returnKeyTypeProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({ name: 'returnKeyType', valueConverter: returnKeyTypeConverter });
returnKeyTypeProperty.register(EditableTextBase);
const editableProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({
    name: 'editable',
    defaultValue: true,
    valueConverter: _core_view_base__WEBPACK_IMPORTED_MODULE_3__["booleanConverter"],
});
editableProperty.register(EditableTextBase);
const updateTextTriggerProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({ name: 'updateTextTrigger', defaultValue: 'textChanged' });
updateTextTriggerProperty.register(EditableTextBase);
const autocapitalizationTypeConverter = Object(_core_properties__WEBPACK_IMPORTED_MODULE_1__["makeParser"])(Object(_core_properties__WEBPACK_IMPORTED_MODULE_1__["makeValidator"])('none', 'words', 'sentences', 'allcharacters'));
const autocapitalizationTypeProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({
    name: 'autocapitalizationType',
    defaultValue: 'sentences',
    valueConverter: autocapitalizationTypeConverter,
});
autocapitalizationTypeProperty.register(EditableTextBase);
const autocorrectProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({
    name: 'autocorrect',
    valueConverter: _core_view_base__WEBPACK_IMPORTED_MODULE_3__["booleanConverter"],
});
autocorrectProperty.register(EditableTextBase);
const hintProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({
    name: 'hint',
    defaultValue: '',
});
hintProperty.register(EditableTextBase);
const maxLengthProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_1__["Property"]({
    name: 'maxLength',
    defaultValue: Number.POSITIVE_INFINITY,
    valueConverter: parseInt,
});
maxLengthProperty.register(EditableTextBase);
//# sourceMappingURL=editable-text-base-common.js.map; 
if (false ) {} 

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bindingConstants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return parentsRegex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getBindingOptions; });
// regex that contains all symbols applicable for expression used to AI detect an expression.
const expressionSymbolsRegex = /[\+\-\*\/%\?:<>=!\|&\(\)^~]/;
var bindingConstants;
(function (bindingConstants) {
    bindingConstants.sourceProperty = 'sourceProperty';
    bindingConstants.targetProperty = 'targetProperty';
    bindingConstants.expression = 'expression';
    bindingConstants.twoWay = 'twoWay';
    bindingConstants.source = 'source';
    bindingConstants.bindingValueKey = '$value';
    bindingConstants.parentValueKey = '$parent';
    bindingConstants.parentsValueKey = '$parents';
    bindingConstants.newPropertyValueKey = '$newPropertyValue';
})(bindingConstants || (bindingConstants = {}));
const hasEqualSignRegex = /=+/;
const equalSignComparisionOperatorsRegex = /(==|===|>=|<=|!=|!==)/;
// this regex is used to search for all instaces of '$parents[]' within an expression
const parentsRegex = /\$parents\s*\[\s*(['"]*)\w*\1\s*\]/g;
function isNamedParam(value) {
    const equalSignIndex = value.search(hasEqualSignRegex);
    if (equalSignIndex > -1) {
        const equalSignSurround = value.substr(equalSignIndex > 0 ? equalSignIndex - 1 : 0, 3);
        if (equalSignSurround.search(equalSignComparisionOperatorsRegex) === -1) {
            return true;
        }
    }
    return false;
}
function areNamedParams(params) {
    for (let i = 0; i < params.length; i++) {
        if (isNamedParam(params[i])) {
            return true;
        }
    }
    return false;
}
const namedParamConstants = {
    propName: 'propName',
    propValue: 'propValue',
};
function getPropertyNameValuePair(param, knownOptions, callback) {
    let nameValuePair = {};
    let propertyName = param.substr(0, param.indexOf('=')).trim();
    const propertyValue = param.substr(param.indexOf('=') + 1).trim();
    if (knownOptions) {
        if (!propertyName) {
            propertyName = knownOptions.defaultProperty;
        }
        else {
            propertyName = propertyName in knownOptions ? propertyName : null;
        }
    }
    if (propertyName) {
        if (callback) {
            nameValuePair = callback(propertyName, propertyValue);
        }
        else {
            nameValuePair[namedParamConstants.propName] = propertyName;
            nameValuePair[namedParamConstants.propValue] = propertyValue;
        }
        return nameValuePair;
    }
    return null;
}
function parseNamedProperties(parameterList, knownOptions, callback) {
    const result = {};
    let nameValuePair;
    for (let i = 0; i < parameterList.length; i++) {
        nameValuePair = getPropertyNameValuePair(parameterList[i], knownOptions, callback);
        if (nameValuePair) {
            result[nameValuePair[namedParamConstants.propName]] = nameValuePair[namedParamConstants.propValue];
        }
    }
    return result;
}
function getParamsArray(value) {
    const result = [];
    let skipComma = 0;
    let indexReached = 0;
    let singleQuoteBlock = false;
    let doubleQuoteBlock = false;
    for (let i = 0; i < value.length; i++) {
        if (value[i] === '"') {
            doubleQuoteBlock = !doubleQuoteBlock;
        }
        if (value[i] === "'") {
            singleQuoteBlock = !singleQuoteBlock;
        }
        if (value[i] === '(' || value[i] === '[') {
            skipComma++;
        }
        if (value[i] === ')' || value[i] === ']') {
            skipComma--;
        }
        if (value[i] === ',' && skipComma === 0 && !(singleQuoteBlock || doubleQuoteBlock)) {
            result.push(value.substr(indexReached, i - indexReached));
            indexReached = i + 1;
        }
    }
    result.push(value.substr(indexReached));
    return result;
}
function isExpression(expression) {
    if (expression.search(expressionSymbolsRegex) > -1) {
        const parentsMatches = expression.match(parentsRegex);
        if (parentsMatches) {
            const restOfExpression = expression.substr(expression.indexOf(parentsMatches[0]) + parentsMatches[0].length);
            // no more expression regognition symbols so it is safe for sourceProperty
            if (!(restOfExpression.search(expressionSymbolsRegex) > -1)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
function getBindingOptions(name, value) {
    let namedParams = [];
    const params = getParamsArray(value);
    if (!areNamedParams(params)) {
        if (params.length === 1) {
            const trimmedValue = params[0].trim();
            let sourceProp;
            if (isExpression(trimmedValue)) {
                sourceProp = bindingConstants.bindingValueKey;
                namedParams.push(bindingConstants.expression + ' = ' + trimmedValue);
            }
            else {
                sourceProp = trimmedValue;
            }
            namedParams.push(bindingConstants.sourceProperty + ' = ' + sourceProp);
            namedParams.push(bindingConstants.twoWay + ' = true');
        }
        else {
            namedParams.push(bindingConstants.sourceProperty + ' = ' + params[0].trim());
            namedParams.push(bindingConstants.expression + ' = ' + params[1].trim());
            const twoWay = params[2] ? params[2].toLowerCase().trim() === 'true' : true;
            namedParams.push(bindingConstants.twoWay + ' = ' + twoWay);
        }
    }
    else {
        namedParams = params;
    }
    const bindingPropertyHandler = function (prop, value) {
        const result = {};
        result[namedParamConstants.propName] = prop;
        if (prop === bindingConstants.twoWay) {
            // create a real boolean value
            if (value === 'true') {
                result[namedParamConstants.propValue] = true;
            }
            else {
                result[namedParamConstants.propValue] = false;
            }
        }
        else {
            result[namedParamConstants.propValue] = value;
        }
        return result;
    };
    const bindingOptionsParameters = parseNamedProperties(namedParams, xmlBindingProperties, bindingPropertyHandler);
    const bindOptions = {
        targetProperty: name,
    };
    for (let prop in bindingOptionsParameters) {
        if (bindingOptionsParameters.hasOwnProperty(prop)) {
            bindOptions[prop] = bindingOptionsParameters[prop];
        }
    }
    if (bindOptions[bindingConstants.twoWay] === undefined) {
        bindOptions[bindingConstants.twoWay] = true;
    }
    return bindOptions;
}
const xmlBindingProperties = {
    sourceProperty: true,
    expression: true,
    twoWay: true,
    source: true,
    defaultProperty: bindingConstants.sourceProperty,
};
//# sourceMappingURL=binding-builder.js.map; 
if (false ) {} 

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeCssSelectors", function() { return mergeCssSelectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeTaggedAdditionalCSS", function() { return removeTaggedAdditionalCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTaggedAdditionalCSS", function() { return addTaggedAdditionalCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAppCSS", function() { return loadAppCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CssState", function() { return CssState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleScope", function() { return StyleScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveFileNameFromUrl", function() { return resolveFileNameFromUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyInlineStyle", function() { return applyInlineStyle; });
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(284);
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _css_parser__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_parser__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _css_css_tree_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(285);
/* harmony import */ var _css_css_tree_parser__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_css_tree_parser__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _css_selector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony import */ var _file_system__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);
/* harmony import */ var _application__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(57);
/* harmony import */ var _application__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(30);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9);
/* harmony import */ var _builder_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(37);
/* harmony import */ var _module_name_resolver__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(36);









let keyframeAnimationModule;
function ensureKeyframeAnimationModule() {
    if (!keyframeAnimationModule) {
        keyframeAnimationModule = __webpack_require__(56);
    }
}


let cssAnimationParserModule;
function ensureCssAnimationParserModule() {
    if (!cssAnimationParserModule) {
        cssAnimationParserModule = __webpack_require__(83);
    }
}
let parser = 'css-tree';
try {
    const appConfig = __webpack_require__(90);
    if (appConfig) {
        if (appConfig.cssParser === 'rework') {
            parser = 'rework';
        }
        else if (appConfig.cssParser === 'nativescript') {
            parser = 'nativescript';
        }
    }
}
catch (e) {
    //
}
/**
 * Evaluate css-variable and css-calc expressions
 */
function evaluateCssExpressions(view, property, value) {
    const newValue = Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["_evaluateCssVariableExpression"])(view, property, value);
    if (newValue === 'unset') {
        return _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
    }
    value = newValue;
    try {
        value = Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["_evaluateCssCalcExpression"])(value);
    }
    catch (e) {
        _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`Failed to evaluate css-calc for property [${property}] for expression [${value}] to ${view}. ${e.stack}`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
        return _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
    }
    return value;
}
function mergeCssSelectors() {
    applicationCssSelectors = applicationSelectors.slice();
    applicationCssSelectors.push.apply(applicationCssSelectors, applicationAdditionalSelectors);
    applicationCssSelectorVersion++;
}
let applicationCssSelectors = [];
let applicationCssSelectorVersion = 0;
let applicationSelectors = [];
const applicationAdditionalSelectors = [];
const applicationKeyframes = {};
const animationsSymbol = Symbol('animations');
const pattern = /('|")(.*?)\1/;
class CSSSource {
    constructor(_ast, _url, _file, _keyframes, _source) {
        this._ast = _ast;
        this._url = _url;
        this._file = _file;
        this._keyframes = _keyframes;
        this._source = _source;
        this._selectors = [];
        this.parse();
    }
    static fromDetect(cssOrAst, keyframes, fileName) {
        if (typeof cssOrAst === 'string') {
            // raw-loader
            return CSSSource.fromSource(cssOrAst, keyframes, fileName);
        }
        else if (typeof cssOrAst === 'object' && cssOrAst.type === 'stylesheet' && cssOrAst.stylesheet && cssOrAst.stylesheet.rules) {
            // css-loader
            return CSSSource.fromAST(cssOrAst, keyframes, fileName);
        }
        else {
            // css2json-loader
            return CSSSource.fromSource(cssOrAst.toString(), keyframes, fileName);
        }
    }
    static fromURI(uri, keyframes) {
        // webpack modules require all file paths to be relative to /app folder
        const appRelativeUri = CSSSource.pathRelativeToApp(uri);
        const sanitizedModuleName = Object(_builder_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_10__[/* sanitizeModuleName */ "a"])(appRelativeUri);
        const resolvedModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_11__[/* resolveModuleName */ "c"])(sanitizedModuleName, 'css');
        try {
            const cssOrAst = global.loadModule(resolvedModuleName, true);
            if (cssOrAst) {
                return CSSSource.fromDetect(cssOrAst, keyframes, resolvedModuleName);
            }
        }
        catch (e) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`Could not load CSS from ${uri}: ${e}`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
        }
        return CSSSource.fromFile(appRelativeUri, keyframes);
    }
    static pathRelativeToApp(uri) {
        if (!uri.startsWith('/')) {
            return uri;
        }
        const appPath = _file_system__WEBPACK_IMPORTED_MODULE_6__["knownFolders"].currentApp().path;
        if (!uri.startsWith(appPath)) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`${uri} does not start with ${appPath}`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            return uri;
        }
        const relativeUri = `.${uri.substr(appPath.length)}`;
        return relativeUri;
    }
    static fromFile(url, keyframes) {
        // .scss, .sass, etc. css files in vanilla app are usually compiled to .css so we will try to load a compiled file first.
        let cssFileUrl = url.replace(/\..\w+$/, '.css');
        if (cssFileUrl !== url) {
            const cssFile = CSSSource.resolveCSSPathFromURL(cssFileUrl);
            if (cssFile) {
                return new CSSSource(undefined, url, cssFile, keyframes, undefined);
            }
        }
        const file = CSSSource.resolveCSSPathFromURL(url);
        return new CSSSource(undefined, url, file, keyframes, undefined);
    }
    static fromFileImport(url, keyframes, importSource) {
        const file = CSSSource.resolveCSSPathFromURL(url, importSource);
        return new CSSSource(undefined, url, file, keyframes, undefined);
    }
    static resolveCSSPathFromURL(url, importSource) {
        const app = _file_system__WEBPACK_IMPORTED_MODULE_6__["knownFolders"].currentApp().path;
        const file = resolveFileNameFromUrl(url, app, _file_system__WEBPACK_IMPORTED_MODULE_6__["File"].exists, importSource);
        return file;
    }
    static fromSource(source, keyframes, url) {
        return new CSSSource(undefined, url, undefined, keyframes, source);
    }
    static fromAST(ast, keyframes, url) {
        return new CSSSource(ast, url, undefined, keyframes, undefined);
    }
    get selectors() {
        return this._selectors;
    }
    get source() {
        return this._source;
    }
    load() {
        const file = _file_system__WEBPACK_IMPORTED_MODULE_6__["File"].fromPath(this._file);
        this._source = file.readTextSync();
    }
    parse() {
        try {
            if (!this._ast) {
                if (!this._source && this._file) {
                    this.load();
                }
                // [object Object] check guards against empty app.css file
                if (this._source && this.source !== '[object Object]') {
                    this.parseCSSAst();
                }
            }
            if (this._ast) {
                this.createSelectors();
            }
            else {
                this._selectors = [];
            }
        }
        catch (e) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write('Css styling failed: ' + e, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            this._selectors = [];
        }
    }
    parseCSSAst() {
        if (this._source) {
            switch (parser) {
                case 'css-tree':
                    this._ast = Object(_css_css_tree_parser__WEBPACK_IMPORTED_MODULE_3__["cssTreeParse"])(this._source, this._file);
                    return;
                case 'nativescript':
                    const cssparser = new _css_parser__WEBPACK_IMPORTED_MODULE_2__["CSS3Parser"](this._source);
                    const stylesheet = cssparser.parseAStylesheet();
                    const cssNS = new _css_parser__WEBPACK_IMPORTED_MODULE_2__["CSSNativeScript"]();
                    this._ast = cssNS.parseStylesheet(stylesheet);
                    return;
                case 'rework':
                    this._ast = Object(_css__WEBPACK_IMPORTED_MODULE_1__["parse"])(this._source, { source: this._file });
                    return;
            }
        }
    }
    createSelectors() {
        if (this._ast) {
            this._selectors = [...this.createSelectorsFromImports(), ...this.createSelectorsFromSyntaxTree()];
        }
    }
    createSelectorsFromImports() {
        const imports = this._ast['stylesheet']['rules'].filter((r) => r.type === 'import');
        const urlFromImportObject = (importObject) => {
            const importItem = importObject['import'];
            const urlMatch = importItem && importItem.match(pattern);
            return urlMatch && urlMatch[2];
        };
        const sourceFromImportObject = (importObject) => importObject['position'] && importObject['position']['source'];
        const toUrlSourcePair = (importObject) => ({
            url: urlFromImportObject(importObject),
            source: sourceFromImportObject(importObject),
        });
        const getCssFile = ({ url, source }) => (source ? CSSSource.fromFileImport(url, this._keyframes, source) : CSSSource.fromURI(url, this._keyframes));
        const cssFiles = imports
            .map(toUrlSourcePair)
            .filter(({ url }) => !!url)
            .map(getCssFile);
        const selectors = cssFiles.map((file) => (file && file.selectors) || []);
        return selectors.reduce((acc, val) => acc.concat(val), []);
    }
    createSelectorsFromSyntaxTree() {
        const nodes = this._ast.stylesheet.rules;
        nodes.filter(isKeyframe).forEach((node) => (this._keyframes[node.name] = node));
        const rulesets = Object(_css_selector__WEBPACK_IMPORTED_MODULE_4__[/* fromAstNodes */ "d"])(nodes);
        if (rulesets && rulesets.length) {
            ensureCssAnimationParserModule();
            rulesets.forEach((rule) => {
                rule[animationsSymbol] = cssAnimationParserModule.CssAnimationParser.keyframeAnimationsFromCSSDeclarations(rule.declarations);
            });
        }
        return rulesets;
    }
    toString() {
        return this._file || this._url || '(in-memory)';
    }
}
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CSSSource.prototype, "load", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CSSSource.prototype, "parse", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CSSSource.prototype, "parseCSSAst", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CSSSource.prototype, "createSelectors", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", String)
], CSSSource, "resolveCSSPathFromURL", null);
function removeTaggedAdditionalCSS(tag) {
    let changed = false;
    for (let i = 0; i < applicationAdditionalSelectors.length; i++) {
        if (applicationAdditionalSelectors[i].tag === tag) {
            applicationAdditionalSelectors.splice(i, 1);
            i--;
            changed = true;
        }
    }
    if (changed) {
        mergeCssSelectors();
    }
    return changed;
}
function addTaggedAdditionalCSS(cssText, tag) {
    const parsed = CSSSource.fromDetect(cssText, applicationKeyframes, undefined).selectors;
    let changed = false;
    if (parsed && parsed.length) {
        changed = true;
        if (tag != null) {
            for (let i = 0; i < parsed.length; i++) {
                parsed[i].tag = tag;
            }
        }
        applicationAdditionalSelectors.push.apply(applicationAdditionalSelectors, parsed);
        mergeCssSelectors();
    }
    return changed;
}
const onCssChanged = Object(_profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"])('"style-scope".onCssChanged', (args) => {
    if (args.cssText) {
        const parsed = CSSSource.fromSource(args.cssText, applicationKeyframes, args.cssFile).selectors;
        if (parsed) {
            applicationAdditionalSelectors.push.apply(applicationAdditionalSelectors, parsed);
            mergeCssSelectors();
        }
    }
    else if (args.cssFile) {
        loadCss(args.cssFile, null, null);
    }
});
function onLiveSync(args) {
    loadCss(_application__WEBPACK_IMPORTED_MODULE_7__["getCssFileName"](), null, null);
}
const loadCss = Object(_profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"])(`"style-scope".loadCss`, (cssModule) => {
    if (!cssModule) {
        return undefined;
    }
    // safely remove "./" as global CSS should be resolved relative to app folder
    if (cssModule.startsWith('./')) {
        cssModule = cssModule.substr(2);
    }
    const result = CSSSource.fromURI(cssModule, applicationKeyframes).selectors;
    if (result.length > 0) {
        applicationSelectors = result;
        mergeCssSelectors();
    }
});
global.NativeScriptGlobals.events.on('cssChanged', onCssChanged);
global.NativeScriptGlobals.events.on('livesync', onLiveSync);
// Call to this method is injected in the application in:
//  - no-snapshot - code injected in app.ts by [bundle-config-loader](https://github.com/NativeScript/nativescript-dev-webpack/blob/9b1e34d8ef838006c9b575285c42d2304f5f02b5/bundle-config-loader.ts#L85-L92)
//  - with-snapshot - code injected in snapshot bundle by [NativeScriptSnapshotPlugin](https://github.com/NativeScript/nativescript-dev-webpack/blob/48b26f412fd70c19dc0b9c7763e08e9505a0ae11/plugins/NativeScriptSnapshotPlugin/index.js#L48-L56)
// Having the app.css loaded in snapshot provides significant boost in startup (when using the ns-theme ~150 ms). However, because app.css is resolved at build-time,
// when the snapshot is created - there is no way to use file qualifiers or change the name of on app.css
const loadAppCSS = Object(_profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"])('"style-scope".loadAppCSS', (args) => {
    loadCss(args.cssFile, null, null);
    global.NativeScriptGlobals.events.off('loadAppCss', loadAppCSS);
});
if (_application__WEBPACK_IMPORTED_MODULE_7__["hasLaunched"]()) {
    loadAppCSS({
        eventName: 'loadAppCss',
        object: _application__WEBPACK_IMPORTED_MODULE_8__,
        cssFile: _application__WEBPACK_IMPORTED_MODULE_7__["getCssFileName"](),
    }, null, null);
}
else {
    global.NativeScriptGlobals.events.on('loadAppCss', loadAppCSS);
}
class CssState {
    constructor(viewRef) {
        this.viewRef = viewRef;
        this._onDynamicStateChangeHandler = () => this.updateDynamicState();
    }
    /**
     * Called when a change had occurred that may invalidate the statically matching selectors (class, id, ancestor selectors).
     * As a result, at some point in time, the selectors matched have to be requerried from the style scope and applied to the view.
     */
    onChange() {
        const view = this.viewRef.get();
        if (view && view.isLoaded) {
            this.unsubscribeFromDynamicUpdates();
            this.updateMatch();
            this.subscribeForDynamicUpdates();
            this.updateDynamicState();
        }
        else {
            this._matchInvalid = true;
        }
    }
    isSelectorsLatestVersionApplied() {
        const view = this.viewRef.get();
        if (!view) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`isSelectorsLatestVersionApplied returns default value "false" because "this.viewRef" cleared.`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.warn);
            return false;
        }
        return this.viewRef.get()._styleScope.getSelectorsVersion() === this._appliedSelectorsVersion;
    }
    onLoaded() {
        if (this._matchInvalid) {
            this.updateMatch();
        }
        this.subscribeForDynamicUpdates();
        this.updateDynamicState();
    }
    onUnloaded() {
        this.unsubscribeFromDynamicUpdates();
    }
    updateMatch() {
        const view = this.viewRef.get();
        if (view && view._styleScope) {
            this._match = view._styleScope.matchSelectors(view);
            this._appliedSelectorsVersion = view._styleScope.getSelectorsVersion();
        }
        else {
            this._match = CssState.emptyMatch;
        }
        this._matchInvalid = false;
    }
    updateDynamicState() {
        const view = this.viewRef.get();
        if (!view) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`updateDynamicState not executed to view because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.warn);
            return;
        }
        const matchingSelectors = this._match.selectors.filter((sel) => (sel.dynamic ? sel.match(view) : true));
        view._batchUpdate(() => {
            this.stopKeyframeAnimations();
            this.setPropertyValues(matchingSelectors);
            this.playKeyframeAnimations(matchingSelectors);
        });
    }
    playKeyframeAnimations(matchingSelectors) {
        const animations = [];
        matchingSelectors.forEach((selector) => {
            let ruleAnimations = selector.ruleset[animationsSymbol];
            if (ruleAnimations) {
                ensureKeyframeAnimationModule();
                for (let animationInfo of ruleAnimations) {
                    let animation = keyframeAnimationModule.KeyframeAnimation.keyframeAnimationFromInfo(animationInfo);
                    if (animation) {
                        animations.push(animation);
                    }
                }
            }
        });
        if ((this._playsKeyframeAnimations = animations.length > 0)) {
            const view = this.viewRef.get();
            if (!view) {
                _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`KeyframeAnimations cannot play because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.warn);
                return;
            }
            animations.map((animation) => animation.play(view));
            Object.freeze(animations);
            this._appliedAnimations = animations;
        }
    }
    stopKeyframeAnimations() {
        if (!this._playsKeyframeAnimations) {
            return;
        }
        this._appliedAnimations.filter((animation) => animation.isPlaying).forEach((animation) => animation.cancel());
        this._appliedAnimations = CssState.emptyAnimationArray;
        const view = this.viewRef.get();
        if (view) {
            view.style['keyframe:rotate'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:rotateX'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:rotateY'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:scaleX'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:scaleY'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:translateX'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:translateY'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:backgroundColor'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
            view.style['keyframe:opacity'] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
        }
        else {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`KeyframeAnimations cannot be stopped because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.warn);
        }
        this._playsKeyframeAnimations = false;
    }
    /**
     * Calculate the difference between the previously applied property values,
     * and the new set of property values that have to be applied for the provided selectors.
     * Apply the values and ensure each property setter is called at most once to avoid excessive change notifications.
     * @param matchingSelectors
     */
    setPropertyValues(matchingSelectors) {
        const view = this.viewRef.get();
        if (!view) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`${matchingSelectors} not set to view's property because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.warn);
            return;
        }
        const newPropertyValues = new view.style.PropertyBag();
        matchingSelectors.forEach((selector) => selector.ruleset.declarations.forEach((declaration) => (newPropertyValues[declaration.property] = declaration.value)));
        const oldProperties = this._appliedPropertyValues;
        let isCssExpressionInUse = false;
        // Update values for the scope's css-variables
        view.style.resetScopedCssVariables();
        for (const property in newPropertyValues) {
            const value = newPropertyValues[property];
            if (Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["isCssVariable"])(property)) {
                view.style.setScopedCssVariable(property, value);
                delete newPropertyValues[property];
                continue;
            }
            isCssExpressionInUse = isCssExpressionInUse || Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["isCssVariableExpression"])(value) || Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["isCssCalcExpression"])(value);
        }
        if (isCssExpressionInUse) {
            // Evalute css-expressions to get the latest values.
            for (const property in newPropertyValues) {
                const value = evaluateCssExpressions(view, property, newPropertyValues[property]);
                if (value === _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"]) {
                    delete newPropertyValues[property];
                    continue;
                }
                newPropertyValues[property] = value;
            }
        }
        // Property values are fully updated, freeze the object to be used for next update.
        Object.freeze(newPropertyValues);
        // Unset removed values
        for (const property in oldProperties) {
            if (!(property in newPropertyValues)) {
                if (property in view.style) {
                    view.style[`css:${property}`] = _core_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"];
                }
                else {
                    // TRICKY: How do we unset local value?
                }
            }
        }
        // Set new values to the style
        for (const property in newPropertyValues) {
            if (oldProperties && property in oldProperties && oldProperties[property] === newPropertyValues[property]) {
                // Skip unchanged values
                continue;
            }
            const value = newPropertyValues[property];
            try {
                if (property in view.style) {
                    view.style[`css:${property}`] = value;
                }
                else {
                    const camelCasedProperty = property.replace(/-([a-z])/g, function (g) {
                        return g[1].toUpperCase();
                    });
                    view[camelCasedProperty] = value;
                }
            }
            catch (e) {
                _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`Failed to apply property [${property}] with value [${value}] to ${view}. ${e.stack}`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            }
        }
        this._appliedPropertyValues = newPropertyValues;
    }
    subscribeForDynamicUpdates() {
        const changeMap = this._match.changeMap;
        changeMap.forEach((changes, view) => {
            if (changes.attributes) {
                changes.attributes.forEach((attribute) => {
                    view.addEventListener(attribute + 'Change', this._onDynamicStateChangeHandler);
                });
            }
            if (changes.pseudoClasses) {
                changes.pseudoClasses.forEach((pseudoClass) => {
                    let eventName = ':' + pseudoClass;
                    view.addEventListener(':' + pseudoClass, this._onDynamicStateChangeHandler);
                    if (view[eventName]) {
                        view[eventName](+1);
                    }
                });
            }
        });
        this._appliedChangeMap = changeMap;
    }
    unsubscribeFromDynamicUpdates() {
        this._appliedChangeMap.forEach((changes, view) => {
            if (changes.attributes) {
                changes.attributes.forEach((attribute) => {
                    view.removeEventListener(attribute + 'Change', this._onDynamicStateChangeHandler);
                });
            }
            if (changes.pseudoClasses) {
                changes.pseudoClasses.forEach((pseudoClass) => {
                    let eventName = ':' + pseudoClass;
                    view.removeEventListener(eventName, this._onDynamicStateChangeHandler);
                    if (view[eventName]) {
                        view[eventName](-1);
                    }
                });
            }
        });
        this._appliedChangeMap = CssState.emptyChangeMap;
    }
    toString() {
        const view = this.viewRef.get();
        if (!view) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`toString() of CssState cannot execute correctly because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.warn);
            return '';
        }
        return `${view}._cssState`;
    }
}
CssState.emptyChangeMap = Object.freeze(new Map());
CssState.emptyPropertyBag = Object.freeze({});
CssState.emptyAnimationArray = Object.freeze([]);
CssState.emptyMatch = {
    selectors: [],
    changeMap: new Map(),
    addAttribute: () => { },
    addPseudoClass: () => { },
    properties: null,
};
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CssState.prototype, "updateMatch", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CssState.prototype, "updateDynamicState", null);
CssState.prototype._appliedChangeMap = CssState.emptyChangeMap;
CssState.prototype._appliedPropertyValues = CssState.emptyPropertyBag;
CssState.prototype._appliedAnimations = CssState.emptyAnimationArray;
CssState.prototype._matchInvalid = true;
class StyleScope {
    constructor() {
        this._css = '';
        this._localCssSelectors = [];
        this._localCssSelectorVersion = 0;
        this._localCssSelectorsAppliedVersion = 0;
        this._applicationCssSelectorsAppliedVersion = 0;
        this._keyframes = new Map();
    }
    get css() {
        return this._css;
    }
    set css(value) {
        this.setCss(value);
    }
    addCss(cssString, cssFileName) {
        this.appendCss(cssString, cssFileName);
    }
    addCssFile(cssFileName) {
        this.appendCss(null, cssFileName);
    }
    changeCssFile(cssFileName) {
        if (!cssFileName) {
            return;
        }
        const cssSelectors = CSSSource.fromURI(cssFileName, this._keyframes);
        this._css = cssSelectors.source;
        this._localCssSelectors = cssSelectors.selectors;
        this._localCssSelectorVersion++;
        this.ensureSelectors();
    }
    setCss(cssString, cssFileName) {
        this._css = cssString;
        const cssFile = CSSSource.fromSource(cssString, this._keyframes, cssFileName);
        this._localCssSelectors = cssFile.selectors;
        this._localCssSelectorVersion++;
        this.ensureSelectors();
    }
    appendCss(cssString, cssFileName) {
        if (!cssString && !cssFileName) {
            return;
        }
        let parsedCssSelectors = cssString ? CSSSource.fromSource(cssString, this._keyframes, cssFileName) : CSSSource.fromURI(cssFileName, this._keyframes);
        this._css = this._css + parsedCssSelectors.source;
        this._localCssSelectors.push.apply(this._localCssSelectors, parsedCssSelectors.selectors);
        this._localCssSelectorVersion++;
        this.ensureSelectors();
    }
    getKeyframeAnimationWithName(animationName) {
        const cssKeyframes = this._keyframes[animationName];
        if (!cssKeyframes) {
            return;
        }
        ensureKeyframeAnimationModule();
        const animation = new keyframeAnimationModule.KeyframeAnimationInfo();
        ensureCssAnimationParserModule();
        animation.keyframes = cssAnimationParserModule.CssAnimationParser.keyframesArrayFromCSS(cssKeyframes.keyframes);
        return animation;
    }
    ensureSelectors() {
        if (!this.isApplicationCssSelectorsLatestVersionApplied() || !this.isLocalCssSelectorsLatestVersionApplied() || !this._mergedCssSelectors) {
            this._createSelectors();
        }
        return this.getSelectorsVersion();
    }
    _increaseApplicationCssSelectorVersion() {
        applicationCssSelectorVersion++;
    }
    isApplicationCssSelectorsLatestVersionApplied() {
        return this._applicationCssSelectorsAppliedVersion === applicationCssSelectorVersion;
    }
    isLocalCssSelectorsLatestVersionApplied() {
        return this._localCssSelectorsAppliedVersion === this._localCssSelectorVersion;
    }
    _createSelectors() {
        let toMerge = [];
        toMerge.push(applicationCssSelectors);
        this._applicationCssSelectorsAppliedVersion = applicationCssSelectorVersion;
        toMerge.push(this._localCssSelectors);
        this._localCssSelectorsAppliedVersion = this._localCssSelectorVersion;
        for (let keyframe in applicationKeyframes) {
            this._keyframes[keyframe] = applicationKeyframes[keyframe];
        }
        if (toMerge.length > 0) {
            this._mergedCssSelectors = toMerge.reduce((merged, next) => merged.concat(next || []), []);
            this._applyKeyframesOnSelectors();
            this._selectors = new _css_selector__WEBPACK_IMPORTED_MODULE_4__[/* SelectorsMap */ "b"](this._mergedCssSelectors);
        }
    }
    // HACK: This @profile decorator creates a circular dependency
    // HACK: because the function parameter type is evaluated with 'typeof'
    matchSelectors(view) {
        // should be (view: ViewBase): SelectorsMatch<ViewBase>
        this.ensureSelectors();
        return this._selectors.query(view);
    }
    query(node) {
        this.ensureSelectors();
        return this._selectors.query(node).selectors;
    }
    getSelectorsVersion() {
        // The counters can only go up. So we can return just appVersion + localVersion
        // The 100000 * appVersion is just for easier debugging
        return 100000 * this._applicationCssSelectorsAppliedVersion + this._localCssSelectorsAppliedVersion;
    }
    _applyKeyframesOnSelectors() {
        for (let i = this._mergedCssSelectors.length - 1; i >= 0; i--) {
            let ruleset = this._mergedCssSelectors[i];
            let animations = ruleset[animationsSymbol];
            if (animations !== undefined && animations.length) {
                ensureCssAnimationParserModule();
                for (let animation of animations) {
                    const cssKeyframe = this._keyframes[animation.name];
                    if (cssKeyframe !== undefined) {
                        animation.keyframes = cssAnimationParserModule.CssAnimationParser.keyframesArrayFromCSS(cssKeyframe.keyframes);
                    }
                }
            }
        }
    }
    getAnimations(ruleset) {
        return ruleset[animationsSymbol];
    }
}
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], StyleScope.prototype, "setCss", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], StyleScope.prototype, "appendCss", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], StyleScope.prototype, "_createSelectors", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", _css_selector__WEBPACK_IMPORTED_MODULE_4__[/* SelectorsMatch */ "c"])
], StyleScope.prototype, "matchSelectors", null);
function resolveFileNameFromUrl(url, appDirectory, fileExists, importSource) {
    let fileName = typeof url === 'string' ? url.trim() : '';
    if (fileName.indexOf('~/') === 0) {
        fileName = fileName.replace('~/', '');
    }
    const isAbsolutePath = fileName.indexOf('/') === 0;
    const absolutePath = isAbsolutePath ? fileName : _file_system__WEBPACK_IMPORTED_MODULE_6__["path"].join(appDirectory, fileName);
    if (fileExists(absolutePath)) {
        return absolutePath;
    }
    if (!isAbsolutePath) {
        if (fileName[0] === '~' && fileName[1] !== '/' && fileName[1] !== '"') {
            fileName = fileName.substr(1);
        }
        if (importSource) {
            const importFile = resolveFilePathFromImport(importSource, fileName);
            if (fileExists(importFile)) {
                return importFile;
            }
        }
        const external = _file_system__WEBPACK_IMPORTED_MODULE_6__["path"].join(appDirectory, 'tns_modules', fileName);
        if (fileExists(external)) {
            return external;
        }
    }
    return null;
}
function resolveFilePathFromImport(importSource, fileName) {
    const importSourceParts = importSource.split(_file_system__WEBPACK_IMPORTED_MODULE_6__["path"].separator);
    const fileNameParts = fileName
        .split(_file_system__WEBPACK_IMPORTED_MODULE_6__["path"].separator)
        // exclude the dot-segment for current directory
        .filter((p) => !isCurrentDirectory(p));
    // remove current file name
    importSourceParts.pop();
    // remove element in case of dot-segment for parent directory or add file name
    fileNameParts.forEach((p) => (isParentDirectory(p) ? importSourceParts.pop() : importSourceParts.push(p)));
    return importSourceParts.join(_file_system__WEBPACK_IMPORTED_MODULE_6__["path"].separator);
}
const applyInlineStyle = Object(_profiling__WEBPACK_IMPORTED_MODULE_9__[/* profile */ "f"])(function applyInlineStyle(view, styleStr) {
    let localStyle = `local { ${styleStr} }`;
    let inlineRuleSet = CSSSource.fromSource(localStyle, new Map()).selectors;
    // Reset unscoped css-variables
    view.style.resetUnscopedCssVariables();
    // Set all the css-variables first, so we can be sure they are up-to-date
    inlineRuleSet[0].declarations.forEach((d) => {
        // Use the actual property name so that a local value is set.
        let property = d.property;
        if (Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["isCssVariable"])(property)) {
            view.style.setUnscopedCssVariable(property, d.value);
        }
    });
    inlineRuleSet[0].declarations.forEach((d) => {
        // Use the actual property name so that a local value is set.
        let property = d.property;
        try {
            if (Object(_core_properties__WEBPACK_IMPORTED_MODULE_0__["isCssVariable"])(property)) {
                // Skip css-variables, they have been handled
                return;
            }
            const value = evaluateCssExpressions(view, property, d.value);
            if (property in view.style) {
                view.style[property] = value;
            }
            else {
                view[property] = value;
            }
        }
        catch (e) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(`Failed to apply property [${d.property}] with value [${d.value}] to ${view}. ${e}`, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
        }
    });
    // This is needed in case of changes to css-variable or css-calc expressions.
    view._onCssStateChange();
});
function isCurrentDirectory(uriPart) {
    return uriPart === '.';
}
function isParentDirectory(uriPart) {
    return uriPart === '..';
}
function isKeyframe(node) {
    return node.type === 'keyframes';
}
//# sourceMappingURL=style-scope.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EditableTextBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _updateCharactersInRangeReplacementString; });
/* harmony import */ var _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "e", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "f", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "g", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "h", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "i", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "j", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__["j"]; });



class EditableTextBase extends _editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* EditableTextBase */ "a"] {
    dismissSoftInput() {
        this.nativeTextViewProtected.resignFirstResponder();
        this.notify({ eventName: EditableTextBase.blurEvent, object: this });
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* keyboardTypeProperty */ "f"].getDefault]() {
        let keyboardType = this.nativeTextViewProtected.keyboardType;
        switch (keyboardType) {
            case 2 /* NumbersAndPunctuation */:
                return 'number';
            case 5 /* PhonePad */:
                return 'phone';
            case 3 /* URL */:
                return 'url';
            case 7 /* EmailAddress */:
                return 'email';
            case 4 /* NumberPad */:
                return 'integer';
            default:
                return keyboardType.toString();
        }
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* keyboardTypeProperty */ "f"].setNative](value) {
        let newKeyboardType;
        switch (value) {
            case 'datetime':
                newKeyboardType = 2 /* NumbersAndPunctuation */;
                break;
            case 'phone':
                newKeyboardType = 5 /* PhonePad */;
                break;
            case 'number':
                newKeyboardType = 2 /* NumbersAndPunctuation */;
                break;
            case 'url':
                newKeyboardType = 3 /* URL */;
                break;
            case 'email':
                newKeyboardType = 7 /* EmailAddress */;
                break;
            case 'integer':
                newKeyboardType = 4 /* NumberPad */;
                break;
            default:
                let kt = +value;
                if (!isNaN(kt)) {
                    newKeyboardType = kt;
                }
                else {
                    newKeyboardType = 0 /* Default */;
                }
                break;
        }
        this.nativeTextViewProtected.keyboardType = newKeyboardType;
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* returnKeyTypeProperty */ "i"].getDefault]() {
        let returnKeyType = this.nativeTextViewProtected.returnKeyType;
        switch (returnKeyType) {
            case 9 /* Done */:
                return 'done';
            case 1 /* Go */:
                return 'go';
            case 4 /* Next */:
                return 'next';
            case 6 /* Search */:
                return 'search';
            case 7 /* Send */:
                return 'send';
            default:
                return returnKeyType.toString();
        }
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* returnKeyTypeProperty */ "i"].setNative](value) {
        let newValue;
        switch (value) {
            case 'done':
                newValue = 9 /* Done */;
                break;
            case 'go':
                newValue = 1 /* Go */;
                break;
            case 'next':
                newValue = 4 /* Next */;
                break;
            case 'search':
                newValue = 6 /* Search */;
                break;
            case 'send':
                newValue = 7 /* Send */;
                break;
            default:
                let rkt = +value;
                if (!isNaN(rkt)) {
                    newValue = rkt;
                }
                else {
                    newValue = 0 /* Default */;
                }
                break;
        }
        this.nativeTextViewProtected.returnKeyType = newValue;
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* autocapitalizationTypeProperty */ "b"].getDefault]() {
        let autocapitalizationType = this.nativeTextViewProtected.autocapitalizationType;
        switch (autocapitalizationType) {
            case 0 /* None */:
                return 'none';
            case 1 /* Words */:
                return 'words';
            case 2 /* Sentences */:
                return 'sentences';
            case 3 /* AllCharacters */:
                return 'allcharacters';
            default:
                throw new Error('Invalid autocapitalizationType value:' + autocapitalizationType);
        }
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* autocapitalizationTypeProperty */ "b"].setNative](value) {
        let newValue;
        switch (value) {
            case 'none':
                newValue = 0 /* None */;
                break;
            case 'words':
                newValue = 1 /* Words */;
                break;
            case 'sentences':
                newValue = 2 /* Sentences */;
                break;
            case 'allcharacters':
                newValue = 3 /* AllCharacters */;
                break;
            default:
                newValue = 2 /* Sentences */;
                break;
        }
        this.nativeTextViewProtected.autocapitalizationType = newValue;
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* autocorrectProperty */ "c"].getDefault]() {
        let autocorrectionType = this.nativeTextViewProtected.autocorrectionType;
        switch (autocorrectionType) {
            case 2 /* Yes */:
                return true;
            case 1 /* No */:
                return false;
            case 0 /* Default */:
                return autocorrectionType;
        }
    }
    [_editable_text_base_common__WEBPACK_IMPORTED_MODULE_0__[/* autocorrectProperty */ "c"].setNative](value) {
        let newValue;
        if (typeof value === 'number') {
            newValue = 0 /* Default */;
        }
        else if (value) {
            newValue = 2 /* Yes */;
        }
        else {
            newValue = 1 /* No */;
        }
        this.nativeTextViewProtected.autocorrectionType = newValue;
    }
}
function _updateCharactersInRangeReplacementString(formattedText, rangeLocation, rangeLength, replacementString) {
    let deletingText = !replacementString;
    let currentLocation = 0;
    for (let i = 0, length = formattedText.spans.length; i < length; i++) {
        let span = formattedText.spans.getItem(i);
        if (currentLocation <= rangeLocation && rangeLocation < currentLocation + span.text.length) {
            let newText = splice(span.text, rangeLocation - currentLocation, deletingText ? rangeLength : 0, replacementString);
            span._setTextInternal(newText);
            return;
        }
        currentLocation += span.text.length;
    }
}
/*
 * @param {String} value The string to splice.
 * @param {number} start Index at which to start changing the string.
 * @param {number} delCount An integer indicating the number of old chars to remove.
 * @param {string} newSubStr The String that is spliced in.
 * @return {string} A new string with the spliced substring.function splice(value: string, start: number, delCount: number, newSubStr: string) {
 */
function splice(value, start, delCount, newSubStr) {
    return value.slice(0, start) + newSubStr + value.slice(start + Math.abs(delCount));
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return timeConverter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return animationTimingFunctionConverter; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);

const STYLE_CURVE_MAP = Object.freeze({
    ease: _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].ease,
    linear: _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].linear,
    'ease-in': _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].easeIn,
    'ease-out': _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].easeOut,
    'ease-in-out': _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].easeInOut,
    spring: _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].spring,
});
function timeConverter(value) {
    let result = parseFloat(value);
    if (value.indexOf('ms') === -1) {
        result = result * 1000;
    }
    return Math.max(0.0, result);
}
function animationTimingFunctionConverter(value) {
    return value ? STYLE_CURVE_MAP[value] || parseCubicBezierCurve(value) : _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].ease;
}
function parseCubicBezierCurve(value) {
    const coordsString = /\((.*?)\)/.exec(value);
    const coords = coordsString && coordsString[1].split(',').map(stringToBezieCoords);
    if (value.startsWith('cubic-bezier') && coordsString && coords.length === 4) {
        const [x1, x2, y1, y2] = [...coords];
        return _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].cubicBezier(x1, x2, y1, y2);
    }
    else {
        throw new Error(`Invalid value for animation: ${value}`);
    }
}
function stringToBezieCoords(value) {
    let result = parseFloat(value);
    if (result < 0) {
        return 0;
    }
    else if (result > 1) {
        return 1;
    }
    return result;
}
//# sourceMappingURL=converters.js.map; 
if (false ) {} 

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionBarBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ActionItems; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ActionItemBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isVisible; });
/* unused harmony export titleProperty */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return traceMissingIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return iosIconRenderingModeProperty; });
/* unused harmony export textProperty */
/* unused harmony export iconProperty */
/* unused harmony export visibilityProperty */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return flatProperty; });
/* unused harmony export androidContentInsetLeftProperty */
/* unused harmony export androidContentInsetRightProperty */
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _core_view_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
/* harmony import */ var _styling_style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);







let ActionBarBase = class ActionBarBase extends _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"] {
    constructor() {
        super();
        this._actionItems = new ActionItems(this);
    }
    get navigationButton() {
        return this._navigationButton;
    }
    set navigationButton(value) {
        if (this._navigationButton !== value) {
            if (this._navigationButton) {
                this._removeView(this._navigationButton);
                this._navigationButton.actionBar = undefined;
            }
            this._navigationButton = value;
            if (this._navigationButton) {
                this._navigationButton.actionBar = this;
                this._addView(this._navigationButton);
            }
            this.update();
        }
    }
    get actionItems() {
        return this._actionItems;
    }
    set actionItems(value) {
        throw new Error('actionItems property is read-only');
    }
    get titleView() {
        return this._titleView;
    }
    set titleView(value) {
        if (this._titleView !== value) {
            if (this._titleView) {
                this._removeView(this._titleView);
                this._titleView.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["horizontalAlignmentProperty"].cssName] = _core_properties__WEBPACK_IMPORTED_MODULE_5__["unsetValue"];
                this._titleView.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["verticalAlignmentProperty"].cssName] = _core_properties__WEBPACK_IMPORTED_MODULE_5__["unsetValue"];
            }
            this._titleView = value;
            if (value) {
                // Addview will reset CSS properties so we first add it then set aligments with lowest priority.
                this._addView(value);
                const style = value.style;
                if (!_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["horizontalAlignmentProperty"].isSet(style)) {
                    style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["horizontalAlignmentProperty"].cssName] = 'center';
                }
                if (!_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["verticalAlignmentProperty"].isSet(style)) {
                    style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["verticalAlignmentProperty"].cssName] = 'middle';
                }
            }
            this.update();
        }
    }
    get androidContentInset() {
        return this.style.androidContentInset;
    }
    set androidContentInset(value) {
        this.style.androidContentInset = value;
    }
    get androidContentInsetLeft() {
        return this.style.androidContentInsetLeft;
    }
    set androidContentInsetLeft(value) {
        this.style.androidContentInsetLeft = value;
    }
    get androidContentInsetRight() {
        return this.style.androidContentInsetRight;
    }
    set androidContentInsetRight(value) {
        this.style.androidContentInsetRight = value;
    }
    // @ts-ignore
    get ios() {
        return undefined;
    }
    // @ts-ignore
    get android() {
        return undefined;
    }
    get _childrenCount() {
        let actionViewsCount = 0;
        this._actionItems.getItems().forEach((actionItem) => {
            if (actionItem.actionView) {
                actionViewsCount++;
            }
        });
        return actionViewsCount + (this.titleView ? 1 : 0);
    }
    update() {
        //
    }
    _onTitlePropertyChanged() {
        //
    }
    _addArrayFromBuilder(name, value) {
        if (name === 'actionItems') {
            this.actionItems.setItems(value);
        }
    }
    eachChildView(callback) {
        const titleView = this.titleView;
        if (titleView) {
            callback(titleView);
        }
    }
    eachChild(callback) {
        const titleView = this.titleView;
        if (titleView) {
            callback(titleView);
        }
        const navigationButton = this._navigationButton;
        if (navigationButton) {
            callback(navigationButton);
        }
        this.actionItems.getItems().forEach((actionItem) => {
            callback(actionItem);
        });
    }
    _isEmpty() {
        if (this.title || this.titleView || (this.android && this.android.icon) || this.navigationButton || this.actionItems.getItems().length > 0) {
            return false;
        }
        return true;
    }
};
ActionBarBase = __decorate([
    Object(_core_view__WEBPACK_IMPORTED_MODULE_2__[/* CSSType */ "a"])('ActionBar'),
    __metadata("design:paramtypes", [])
], ActionBarBase);

class ActionItems {
    constructor(actionBar) {
        this._items = new Array();
        this._actionBar = actionBar;
    }
    addItem(item) {
        if (!item) {
            throw new Error('Cannot add empty item');
        }
        this._items.push(item);
        item.actionBar = this._actionBar;
        this._actionBar._addView(item);
        this.invalidate();
    }
    removeItem(item) {
        if (!item) {
            throw new Error('Cannot remove empty item');
        }
        const itemIndex = this._items.indexOf(item);
        if (itemIndex < 0) {
            throw new Error('Cannot find item to remove');
        }
        this._items.splice(itemIndex, 1);
        this._actionBar._removeView(item);
        item.actionBar = undefined;
        this.invalidate();
    }
    getItems() {
        return this._items.slice();
    }
    getVisibleItems() {
        const visibleItems = [];
        this._items.forEach((item) => {
            if (isVisible(item)) {
                visibleItems.push(item);
            }
        });
        return visibleItems;
    }
    getItemAt(index) {
        if (index < 0 || index >= this._items.length) {
            return undefined;
        }
        return this._items[index];
    }
    setItems(items) {
        // Remove all existing items
        while (this._items.length > 0) {
            this.removeItem(this._items[this._items.length - 1]);
        }
        // Add new items
        for (let i = 0; i < items.length; i++) {
            this.addItem(items[i]);
        }
        this.invalidate();
    }
    invalidate() {
        if (this._actionBar) {
            this._actionBar.update();
        }
    }
}
class ActionItemBase extends _core_view_base__WEBPACK_IMPORTED_MODULE_3__["ViewBase"] {
    get actionView() {
        return this._actionView;
    }
    set actionView(value) {
        if (this._actionView !== value) {
            if (this._actionView) {
                this._actionView.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["horizontalAlignmentProperty"].cssName] = _core_properties__WEBPACK_IMPORTED_MODULE_5__["unsetValue"];
                this._actionView.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["verticalAlignmentProperty"].cssName] = _core_properties__WEBPACK_IMPORTED_MODULE_5__["unsetValue"];
                this._removeView(this._actionView);
            }
            this._actionView = value;
            if (this._actionView) {
                this._addView(this._actionView);
            }
            if (this._actionBar) {
                this._actionBar.update();
            }
        }
    }
    get actionBar() {
        return this._actionBar;
    }
    set actionBar(value) {
        if (value !== this._actionBar) {
            this._actionBar = value;
        }
    }
    onLoaded() {
        if (this._actionView) {
            this._actionView.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["horizontalAlignmentProperty"].cssName] = 'center';
            this._actionView.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["verticalAlignmentProperty"].cssName] = 'middle';
        }
        super.onLoaded();
    }
    _raiseTap() {
        this._emit(ActionItemBase.tapEvent);
    }
    _addChildFromBuilder(name, value) {
        this.actionView = value;
    }
    _onVisibilityChanged(visibility) {
        if (this.actionBar) {
            this.actionBar.update();
        }
    }
    eachChild(callback) {
        if (this._actionView) {
            callback(this._actionView);
        }
    }
}
ActionItemBase.tapEvent = 'tap';
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_0__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ActionItemBase.prototype, "onLoaded", null);
function isVisible(item) {
    return item.visibility === 'visible';
}
function onTitlePropertyChanged(actionBar, oldValue, newValue) {
    actionBar._onTitlePropertyChanged();
}
const titleProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["Property"]({
    name: 'title',
    valueChanged: onTitlePropertyChanged,
});
titleProperty.register(ActionBarBase);
function onItemChanged(item, oldValue, newValue) {
    if (item.actionBar) {
        item.actionBar.update();
    }
}
function onVisibilityChanged(item, oldValue, newValue) {
    item._onVisibilityChanged(newValue);
}
function traceMissingIcon(icon) {
    _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write('Could not load action bar icon: ' + icon, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Error, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].messageType.error);
}
function convertToContentInset(value) {
    if (typeof value === 'string' && value !== 'auto') {
        let insets = value.split(/[ ,]+/);
        return [
            [androidContentInsetLeftProperty, _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].parse(insets[0])],
            [androidContentInsetRightProperty, _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].parse(insets[1] || insets[0])],
        ];
    }
    else {
        return [
            [androidContentInsetLeftProperty, value],
            [androidContentInsetRightProperty, value],
        ];
    }
}
const iosIconRenderingModeProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["Property"]({ name: 'iosIconRenderingMode', defaultValue: 'alwaysOriginal' });
iosIconRenderingModeProperty.register(ActionBarBase);
const textProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["Property"]({
    name: 'text',
    defaultValue: '',
    valueChanged: onItemChanged,
});
textProperty.register(ActionItemBase);
const iconProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["Property"]({
    name: 'icon',
    valueChanged: onItemChanged,
});
iconProperty.register(ActionItemBase);
const visibilityProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["Property"]({
    name: 'visibility',
    defaultValue: 'visible',
    valueChanged: onVisibilityChanged,
});
visibilityProperty.register(ActionItemBase);
const flatProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["Property"]({
    name: 'flat',
    defaultValue: false,
    valueConverter: _core_view_base__WEBPACK_IMPORTED_MODULE_3__["booleanConverter"],
});
flatProperty.register(ActionBarBase);
const androidContentInsetProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["ShorthandProperty"]({
    name: 'androidContentInset',
    cssName: 'android-content-inset',
    getter: function () {
        if (_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].equals(this.androidContentInsetLeft, this.androidContentInsetRight)) {
            return this.androidContentInsetLeft;
        }
        return `${_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].convertToString(this.androidContentInsetLeft)} ${_styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].convertToString(this.androidContentInsetRight)}`;
    },
    converter: convertToContentInset,
});
androidContentInsetProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_7__[/* Style */ "a"]);
const androidContentInsetLeftProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["CssProperty"]({
    name: 'androidContentInsetLeft',
    cssName: 'android-content-inset-left',
    defaultValue: 'auto',
    equalityComparer: _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectiveContentInsetLeft = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].toDevicePixels(newValue);
        }
        else {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`${newValue} not set to view's property because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].messageType.warn);
        }
    },
    valueConverter: _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].parse,
});
androidContentInsetLeftProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_7__[/* Style */ "a"]);
const androidContentInsetRightProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_5__["CssProperty"]({
    name: 'androidContentInsetRight',
    cssName: 'android-content-inset-right',
    defaultValue: 'auto',
    equalityComparer: _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].equals,
    valueChanged: (target, oldValue, newValue) => {
        const view = target.viewRef.get();
        if (view) {
            view.effectiveContentInsetRight = _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].toDevicePixels(newValue);
        }
        else {
            _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].write(`${newValue} not set to view's property because ".viewRef" is cleared`, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].categories.Style, _trace__WEBPACK_IMPORTED_MODULE_4__[/* Trace */ "a"].messageType.warn);
        }
    },
    valueConverter: _styling_style_properties__WEBPACK_IMPORTED_MODULE_6__["Length"].parse,
});
androidContentInsetRightProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_7__[/* Style */ "a"]);
//# sourceMappingURL=action-bar-common.js.map; 
if (false ) {} 

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.CSSNativeScript = exports.CSS3Parser = exports.parseSelector = exports.parseCombinator = exports.parseSimpleSelectorSequence = exports.parseSimpleSelector = exports.parseAttributeSelector = exports.parseSimpleIdentifierSelector = exports.parseUniversalSelector = exports.parseBackground = exports.parseLinearGradient = exports.parseColorStop = exports.parseBackgroundPosition = exports.parseBackgroundSize = exports.parseAngle = exports.parsePercentageOrLength = exports.parseUnit = exports.parseRepeat = exports.parseColor = exports.parseColorKeyword = exports.colors = exports.parseHSLAColor = exports.parseHSLColor = exports.convertHSLToRGBColor = exports.parseRGBAColor = exports.parseRGBColor = exports.parseHexColor = exports.parseURL = void 0;
var urlRegEx = /\s*url\((?:('|")([^\1]*)\1|([^\)]*))\)\s*/gy;
function parseURL(text, start) {
    if (start === void 0) { start = 0; }
    urlRegEx.lastIndex = start;
    var result = urlRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = urlRegEx.lastIndex;
    var value = result[2] || result[3];
    return { start: start, end: end, value: value };
}
exports.parseURL = parseURL;
var hexColorRegEx = /\s*#((?:[0-9A-F]{8})|(?:[0-9A-F]{6})|(?:[0-9A-F]{3}))\s*/giy;
function parseHexColor(text, start) {
    if (start === void 0) { start = 0; }
    hexColorRegEx.lastIndex = start;
    var result = hexColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = hexColorRegEx.lastIndex;
    var hex = result[1];
    var argb;
    if (hex.length === 8) {
        argb = parseInt('0x' + hex);
    }
    else if (hex.length === 6) {
        argb = parseInt('0xFF' + hex);
    }
    else if (hex.length === 3) {
        argb = parseInt('0xFF' + hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]);
    }
    return { start: start, end: end, value: argb };
}
exports.parseHexColor = parseHexColor;
function rgbaToArgbNumber(r, g, b, a) {
    if (a === void 0) { a = 1; }
    if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
        return Math.round(a * 0xff) * 0x01000000 + r * 0x010000 + g * 0x000100 + b;
    }
    else {
        return null;
    }
}
var rgbColorRegEx = /\s*(rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\))/gy;
function parseRGBColor(text, start) {
    if (start === void 0) { start = 0; }
    rgbColorRegEx.lastIndex = start;
    var result = rgbColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = rgbColorRegEx.lastIndex;
    var value = result[1] && rgbaToArgbNumber(parseInt(result[2]), parseInt(result[3]), parseInt(result[4]));
    return { start: start, end: end, value: value };
}
exports.parseRGBColor = parseRGBColor;
var rgbaColorRegEx = /\s*(rgba\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*,\s*([01]?\.?\d*)\s*\))/gy;
function parseRGBAColor(text, start) {
    if (start === void 0) { start = 0; }
    rgbaColorRegEx.lastIndex = start;
    var result = rgbaColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = rgbaColorRegEx.lastIndex;
    var value = rgbaToArgbNumber(parseInt(result[2]), parseInt(result[3]), parseInt(result[4]), parseFloat(result[5]));
    return { start: start, end: end, value: value };
}
exports.parseRGBAColor = parseRGBAColor;
function convertHSLToRGBColor(hue, saturation, lightness) {
    hue /= 60;
    lightness /= 100;
    var chroma = ((1 - Math.abs(2 * lightness - 1)) * saturation) / 100, X = chroma * (1 - Math.abs((hue % 2) - 1)), _a = { m: lightness - chroma / 2 }, r = _a.m, g = _a.m, b = _a.m;
    if (0 <= hue && hue < 1) {
        r += chroma;
        g += X;
    }
    else if (hue < 2) {
        r += X;
        g += chroma;
    }
    else if (hue < 3) {
        g += chroma;
        b += X;
    }
    else if (hue < 4) {
        g += X;
        b += chroma;
    }
    else if (hue < 5) {
        r += X;
        b += chroma;
    }
    else if (hue < 6) {
        r += chroma;
        b += X;
    }
    return {
        r: Math.round(r * 0xff),
        g: Math.round(g * 0xff),
        b: Math.round(b * 0xff),
    };
}
exports.convertHSLToRGBColor = convertHSLToRGBColor;
function hslaToArgbNumber(h, s, l, a) {
    if (a === void 0) { a = 1; }
    var _a = convertHSLToRGBColor(h, s, l), r = _a.r, g = _a.g, b = _a.b;
    if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
        return Math.round(a * 0xff) * 0x01000000 + r * 0x010000 + g * 0x000100 + b;
    }
    else {
        return null;
    }
}
var hslColorRegEx = /\s*(hsl\(\s*([\d.]*)\s*,\s*([\d.]*)%\s*,\s*([\d.]*)%\s*\))/gy;
function parseHSLColor(text, start) {
    if (start === void 0) { start = 0; }
    hslColorRegEx.lastIndex = start;
    var result = hslColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = hslColorRegEx.lastIndex;
    var value = result[1] && hslaToArgbNumber(parseFloat(result[2]), parseFloat(result[3]), parseFloat(result[4]));
    return { start: start, end: end, value: value };
}
exports.parseHSLColor = parseHSLColor;
var hslaColorRegEx = /\s*(hsla\(\s*([\d.]*)\s*,\s*([\d.]*)%\s*,\s*([\d.]*)%\s*,\s*([01]?\.?\d*)\s*\))/gy;
function parseHSLAColor(text, start) {
    if (start === void 0) { start = 0; }
    hslaColorRegEx.lastIndex = start;
    var result = hslaColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = hslaColorRegEx.lastIndex;
    var value = hslaToArgbNumber(parseFloat(result[2]), parseFloat(result[3]), parseFloat(result[4]), parseFloat(result[5]));
    return { start: start, end: end, value: value };
}
exports.parseHSLAColor = parseHSLAColor;
var colors;
(function (colors) {
    colors[colors["transparent"] = 0] = "transparent";
    colors[colors["aliceblue"] = 4293982463] = "aliceblue";
    colors[colors["antiquewhite"] = 4294634455] = "antiquewhite";
    colors[colors["aqua"] = 4278255615] = "aqua";
    colors[colors["aquamarine"] = 4286578644] = "aquamarine";
    colors[colors["azure"] = 4293984255] = "azure";
    colors[colors["beige"] = 4294309340] = "beige";
    colors[colors["bisque"] = 4294960324] = "bisque";
    colors[colors["black"] = 4278190080] = "black";
    colors[colors["blanchedalmond"] = 4294962125] = "blanchedalmond";
    colors[colors["blue"] = 4278190335] = "blue";
    colors[colors["blueviolet"] = 4287245282] = "blueviolet";
    colors[colors["brown"] = 4289014314] = "brown";
    colors[colors["burlywood"] = 4292786311] = "burlywood";
    colors[colors["cadetblue"] = 4284456608] = "cadetblue";
    colors[colors["chartreuse"] = 4286578432] = "chartreuse";
    colors[colors["chocolate"] = 4291979550] = "chocolate";
    colors[colors["coral"] = 4294934352] = "coral";
    colors[colors["cornflowerblue"] = 4284782061] = "cornflowerblue";
    colors[colors["cornsilk"] = 4294965468] = "cornsilk";
    colors[colors["crimson"] = 4292613180] = "crimson";
    colors[colors["cyan"] = 4278255615] = "cyan";
    colors[colors["darkblue"] = 4278190219] = "darkblue";
    colors[colors["darkcyan"] = 4278225803] = "darkcyan";
    colors[colors["darkgoldenrod"] = 4290283019] = "darkgoldenrod";
    colors[colors["darkgray"] = 4289309097] = "darkgray";
    colors[colors["darkgreen"] = 4278215680] = "darkgreen";
    colors[colors["darkgrey"] = 4289309097] = "darkgrey";
    colors[colors["darkkhaki"] = 4290623339] = "darkkhaki";
    colors[colors["darkmagenta"] = 4287299723] = "darkmagenta";
    colors[colors["darkolivegreen"] = 4283788079] = "darkolivegreen";
    colors[colors["darkorange"] = 4294937600] = "darkorange";
    colors[colors["darkorchid"] = 4288230092] = "darkorchid";
    colors[colors["darkred"] = 4287299584] = "darkred";
    colors[colors["darksalmon"] = 4293498490] = "darksalmon";
    colors[colors["darkseagreen"] = 4287609999] = "darkseagreen";
    colors[colors["darkslateblue"] = 4282924427] = "darkslateblue";
    colors[colors["darkslategray"] = 4281290575] = "darkslategray";
    colors[colors["darkslategrey"] = 4281290575] = "darkslategrey";
    colors[colors["darkturquoise"] = 4278243025] = "darkturquoise";
    colors[colors["darkviolet"] = 4287889619] = "darkviolet";
    colors[colors["deeppink"] = 4294907027] = "deeppink";
    colors[colors["deepskyblue"] = 4278239231] = "deepskyblue";
    colors[colors["dimgray"] = 4285098345] = "dimgray";
    colors[colors["dimgrey"] = 4285098345] = "dimgrey";
    colors[colors["dodgerblue"] = 4280193279] = "dodgerblue";
    colors[colors["firebrick"] = 4289864226] = "firebrick";
    colors[colors["floralwhite"] = 4294966000] = "floralwhite";
    colors[colors["forestgreen"] = 4280453922] = "forestgreen";
    colors[colors["fuchsia"] = 4294902015] = "fuchsia";
    colors[colors["gainsboro"] = 4292664540] = "gainsboro";
    colors[colors["ghostwhite"] = 4294506751] = "ghostwhite";
    colors[colors["gold"] = 4294956800] = "gold";
    colors[colors["goldenrod"] = 4292519200] = "goldenrod";
    colors[colors["gray"] = 4286611584] = "gray";
    colors[colors["green"] = 4278222848] = "green";
    colors[colors["greenyellow"] = 4289593135] = "greenyellow";
    colors[colors["grey"] = 4286611584] = "grey";
    colors[colors["honeydew"] = 4293984240] = "honeydew";
    colors[colors["hotpink"] = 4294928820] = "hotpink";
    colors[colors["indianred"] = 4291648604] = "indianred";
    colors[colors["indigo"] = 4283105410] = "indigo";
    colors[colors["ivory"] = 4294967280] = "ivory";
    colors[colors["khaki"] = 4293977740] = "khaki";
    colors[colors["lavender"] = 4293322490] = "lavender";
    colors[colors["lavenderblush"] = 4294963445] = "lavenderblush";
    colors[colors["lawngreen"] = 4286381056] = "lawngreen";
    colors[colors["lemonchiffon"] = 4294965965] = "lemonchiffon";
    colors[colors["lightblue"] = 4289583334] = "lightblue";
    colors[colors["lightcoral"] = 4293951616] = "lightcoral";
    colors[colors["lightcyan"] = 4292935679] = "lightcyan";
    colors[colors["lightgoldenrodyellow"] = 4294638290] = "lightgoldenrodyellow";
    colors[colors["lightgray"] = 4292072403] = "lightgray";
    colors[colors["lightgreen"] = 4287688336] = "lightgreen";
    colors[colors["lightgrey"] = 4292072403] = "lightgrey";
    colors[colors["lightpink"] = 4294948545] = "lightpink";
    colors[colors["lightsalmon"] = 4294942842] = "lightsalmon";
    colors[colors["lightseagreen"] = 4280332970] = "lightseagreen";
    colors[colors["lightskyblue"] = 4287090426] = "lightskyblue";
    colors[colors["lightslategray"] = 4286023833] = "lightslategray";
    colors[colors["lightslategrey"] = 4286023833] = "lightslategrey";
    colors[colors["lightsteelblue"] = 4289774814] = "lightsteelblue";
    colors[colors["lightyellow"] = 4294967264] = "lightyellow";
    colors[colors["lime"] = 4278255360] = "lime";
    colors[colors["limegreen"] = 4281519410] = "limegreen";
    colors[colors["linen"] = 4294635750] = "linen";
    colors[colors["magenta"] = 4294902015] = "magenta";
    colors[colors["maroon"] = 4286578688] = "maroon";
    colors[colors["mediumaquamarine"] = 4284927402] = "mediumaquamarine";
    colors[colors["mediumblue"] = 4278190285] = "mediumblue";
    colors[colors["mediumorchid"] = 4290401747] = "mediumorchid";
    colors[colors["mediumpurple"] = 4287852763] = "mediumpurple";
    colors[colors["mediumseagreen"] = 4282168177] = "mediumseagreen";
    colors[colors["mediumslateblue"] = 4286277870] = "mediumslateblue";
    colors[colors["mediumspringgreen"] = 4278254234] = "mediumspringgreen";
    colors[colors["mediumturquoise"] = 4282962380] = "mediumturquoise";
    colors[colors["mediumvioletred"] = 4291237253] = "mediumvioletred";
    colors[colors["midnightblue"] = 4279834992] = "midnightblue";
    colors[colors["mintcream"] = 4294311930] = "mintcream";
    colors[colors["mistyrose"] = 4294960353] = "mistyrose";
    colors[colors["moccasin"] = 4294960309] = "moccasin";
    colors[colors["navajowhite"] = 4294958765] = "navajowhite";
    colors[colors["navy"] = 4278190208] = "navy";
    colors[colors["oldlace"] = 4294833638] = "oldlace";
    colors[colors["olive"] = 4286611456] = "olive";
    colors[colors["olivedrab"] = 4285238819] = "olivedrab";
    colors[colors["orange"] = 4294944000] = "orange";
    colors[colors["orangered"] = 4294919424] = "orangered";
    colors[colors["orchid"] = 4292505814] = "orchid";
    colors[colors["palegoldenrod"] = 4293847210] = "palegoldenrod";
    colors[colors["palegreen"] = 4288215960] = "palegreen";
    colors[colors["paleturquoise"] = 4289720046] = "paleturquoise";
    colors[colors["palevioletred"] = 4292571283] = "palevioletred";
    colors[colors["papayawhip"] = 4294963157] = "papayawhip";
    colors[colors["peachpuff"] = 4294957753] = "peachpuff";
    colors[colors["peru"] = 4291659071] = "peru";
    colors[colors["pink"] = 4294951115] = "pink";
    colors[colors["plum"] = 4292714717] = "plum";
    colors[colors["powderblue"] = 4289781990] = "powderblue";
    colors[colors["purple"] = 4286578816] = "purple";
    colors[colors["rebeccapurple"] = 4284887961] = "rebeccapurple";
    colors[colors["red"] = 4294901760] = "red";
    colors[colors["rosybrown"] = 4290547599] = "rosybrown";
    colors[colors["royalblue"] = 4282477025] = "royalblue";
    colors[colors["saddlebrown"] = 4287317267] = "saddlebrown";
    colors[colors["salmon"] = 4294606962] = "salmon";
    colors[colors["sandybrown"] = 4294222944] = "sandybrown";
    colors[colors["seagreen"] = 4281240407] = "seagreen";
    colors[colors["seashell"] = 4294964718] = "seashell";
    colors[colors["sienna"] = 4288696877] = "sienna";
    colors[colors["silver"] = 4290822336] = "silver";
    colors[colors["skyblue"] = 4287090411] = "skyblue";
    colors[colors["slateblue"] = 4285160141] = "slateblue";
    colors[colors["slategray"] = 4285563024] = "slategray";
    colors[colors["slategrey"] = 4285563024] = "slategrey";
    colors[colors["snow"] = 4294966010] = "snow";
    colors[colors["springgreen"] = 4278255487] = "springgreen";
    colors[colors["steelblue"] = 4282811060] = "steelblue";
    colors[colors["tan"] = 4291998860] = "tan";
    colors[colors["teal"] = 4278222976] = "teal";
    colors[colors["thistle"] = 4292394968] = "thistle";
    colors[colors["tomato"] = 4294927175] = "tomato";
    colors[colors["turquoise"] = 4282441936] = "turquoise";
    colors[colors["violet"] = 4293821166] = "violet";
    colors[colors["wheat"] = 4294303411] = "wheat";
    colors[colors["white"] = 4294967295] = "white";
    colors[colors["whitesmoke"] = 4294309365] = "whitesmoke";
    colors[colors["yellow"] = 4294967040] = "yellow";
    colors[colors["yellowgreen"] = 4288335154] = "yellowgreen";
})(colors = exports.colors || (exports.colors = {}));
function parseColorKeyword(value, start, keyword) {
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    if (keyword && keyword.value in colors) {
        var end = keyword.end;
        var value_1 = colors[keyword.value];
        return { start: start, end: end, value: value_1 };
    }
    return null;
}
exports.parseColorKeyword = parseColorKeyword;
function parseColor(value, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    return parseHexColor(value, start) || parseColorKeyword(value, start, keyword) || parseRGBColor(value, start) || parseRGBAColor(value, start) || parseHSLColor(value, start) || parseHSLAColor(value, start);
}
exports.parseColor = parseColor;
var keywordRegEx = /\s*([a-z][\w\-]*)\s*/giy;
function parseKeyword(text, start) {
    if (start === void 0) { start = 0; }
    keywordRegEx.lastIndex = start;
    var result = keywordRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = keywordRegEx.lastIndex;
    var value = result[1];
    return { start: start, end: end, value: value };
}
var backgroundRepeatKeywords = new Set(['repeat', 'repeat-x', 'repeat-y', 'no-repeat']);
function parseRepeat(value, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    if (keyword && backgroundRepeatKeywords.has(keyword.value)) {
        var end = keyword.end;
        var value_2 = keyword.value;
        return { start: start, end: end, value: value_2 };
    }
    return null;
}
exports.parseRepeat = parseRepeat;
var unitRegEx = /\s*([\+\-]?(?:\d+\.\d+|\d+|\.\d+)(?:[eE][\+\-]?\d+)?)([a-zA-Z]+|%)?\s*/gy;
function parseUnit(text, start) {
    if (start === void 0) { start = 0; }
    unitRegEx.lastIndex = start;
    var result = unitRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = unitRegEx.lastIndex;
    var value = parseFloat(result[1]);
    var unit = result[2] || 'dip';
    return { start: start, end: end, value: { value: value, unit: unit } };
}
exports.parseUnit = parseUnit;
function parsePercentageOrLength(text, start) {
    if (start === void 0) { start = 0; }
    var unitResult = parseUnit(text, start);
    if (unitResult) {
        var start_1 = unitResult.start, end = unitResult.end;
        var value = unitResult.value;
        if (value.unit === '%') {
            value.value /= 100;
        }
        else if (!value.unit) {
            value.unit = 'dip';
        }
        else if (value.unit === 'px' || value.unit === 'dip') {
        }
        else {
            return null;
        }
        return { start: start_1, end: end, value: value };
    }
    return null;
}
exports.parsePercentageOrLength = parsePercentageOrLength;
var angleUnitsToRadMap = {
    deg: function (start, end, deg) { return ({
        start: start,
        end: end,
        value: (deg / 180) * Math.PI,
    }); },
    rad: function (start, end, rad) { return ({
        start: start,
        end: end,
        value: rad,
    }); },
    grad: function (start, end, grad) { return ({
        start: start,
        end: end,
        value: (grad / 200) * Math.PI,
    }); },
    turn: function (start, end, turn) { return ({
        start: start,
        end: end,
        value: turn * Math.PI * 2,
    }); },
};
function parseAngle(value, start) {
    if (start === void 0) { start = 0; }
    var angleResult = parseUnit(value, start);
    if (angleResult) {
        var start_2 = angleResult.start, end = angleResult.end, value_3 = angleResult.value;
        return (angleUnitsToRadMap[value_3.unit] || (function (_, __, ___) { return null; }))(start_2, end, value_3.value);
    }
    return null;
}
exports.parseAngle = parseAngle;
var backgroundSizeKeywords = new Set(['auto', 'contain', 'cover']);
function parseBackgroundSize(value, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    var end = start;
    if (keyword && backgroundSizeKeywords.has(keyword.value)) {
        end = keyword.end;
        var value_4 = keyword.value;
        return { start: start, end: end, value: value_4 };
    }
    var firstLength = parsePercentageOrLength(value, end);
    if (firstLength) {
        end = firstLength.end;
        var secondLength = parsePercentageOrLength(value, firstLength.end);
        if (secondLength) {
            end = secondLength.end;
            return {
                start: start,
                end: end,
                value: { x: firstLength.value, y: secondLength.value },
            };
        }
        else {
            return { start: start, end: end, value: { x: firstLength.value, y: 'auto' } };
        }
    }
    return null;
}
exports.parseBackgroundSize = parseBackgroundSize;
var backgroundPositionKeywords = Object.freeze(new Set(['left', 'right', 'top', 'bottom', 'center']));
var backgroundPositionKeywordsDirection = {
    left: 'x',
    right: 'x',
    center: 'center',
    top: 'y',
    bottom: 'y',
};
function parseBackgroundPosition(text, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(text, start); }
    function formatH(align, offset) {
        if (align.value === 'center') {
            return 'center';
        }
        if (offset && offset.value.value !== 0) {
            return { align: align.value, offset: offset.value };
        }
        return align.value;
    }
    function formatV(align, offset) {
        if (align.value === 'center') {
            return 'center';
        }
        if (offset && offset.value.value !== 0) {
            return { align: align.value, offset: offset.value };
        }
        return align.value;
    }
    var end = start;
    if (keyword && backgroundPositionKeywords.has(keyword.value)) {
        end = keyword.end;
        var firstDirection = backgroundPositionKeywordsDirection[keyword.value];
        var firstLength = firstDirection !== 'center' && parsePercentageOrLength(text, end);
        if (firstLength) {
            end = firstLength.end;
        }
        var secondKeyword = parseKeyword(text, end);
        if (secondKeyword && backgroundPositionKeywords.has(secondKeyword.value)) {
            end = secondKeyword.end;
            var secondDirection = backgroundPositionKeywordsDirection[secondKeyword.end];
            if (firstDirection === secondDirection && firstDirection !== 'center') {
                return null;
            }
            var secondLength = secondDirection !== 'center' && parsePercentageOrLength(text, end);
            if (secondLength) {
                end = secondLength.end;
            }
            if ((firstDirection === secondDirection && secondDirection === 'center') || firstDirection === 'x' || secondDirection === 'y') {
                return {
                    start: start,
                    end: end,
                    value: {
                        x: formatH(keyword, firstLength),
                        y: formatV(secondKeyword, secondLength),
                    },
                };
            }
            else {
                return {
                    start: start,
                    end: end,
                    value: {
                        x: formatH(secondKeyword, secondLength),
                        y: formatV(keyword, firstLength),
                    },
                };
            }
        }
        else {
            if (firstDirection === 'center') {
                return { start: start, end: end, value: { x: 'center', y: 'center' } };
            }
            else if (firstDirection === 'x') {
                return {
                    start: start,
                    end: end,
                    value: {
                        x: formatH(keyword, firstLength),
                        y: 'center',
                    },
                };
            }
            else {
                return {
                    start: start,
                    end: end,
                    value: {
                        x: 'center',
                        y: formatV(keyword, firstLength),
                    },
                };
            }
        }
    }
    else {
        var firstLength = parsePercentageOrLength(text, end);
        if (firstLength) {
            end = firstLength.end;
            var secondLength = parsePercentageOrLength(text, end);
            if (secondLength) {
                end = secondLength.end;
                return {
                    start: start,
                    end: end,
                    value: {
                        x: { align: 'left', offset: firstLength.value },
                        y: { align: 'top', offset: secondLength.value },
                    },
                };
            }
            else {
                return {
                    start: start,
                    end: end,
                    value: {
                        x: { align: 'left', offset: firstLength.value },
                        y: 'center',
                    },
                };
            }
        }
        else {
            return null;
        }
    }
}
exports.parseBackgroundPosition = parseBackgroundPosition;
var directionRegEx = /\s*to\s*(left|right|top|bottom)\s*(left|right|top|bottom)?\s*/gy;
var sideDirections = {
    top: (Math.PI * 0) / 2,
    right: (Math.PI * 1) / 2,
    bottom: (Math.PI * 2) / 2,
    left: (Math.PI * 3) / 2,
};
var cornerDirections = {
    top: {
        right: (Math.PI * 1) / 4,
        left: (Math.PI * 7) / 4,
    },
    right: {
        top: (Math.PI * 1) / 4,
        bottom: (Math.PI * 3) / 4,
    },
    bottom: {
        right: (Math.PI * 3) / 4,
        left: (Math.PI * 5) / 4,
    },
    left: {
        top: (Math.PI * 7) / 4,
        bottom: (Math.PI * 5) / 4,
    },
};
function parseDirection(text, start) {
    if (start === void 0) { start = 0; }
    directionRegEx.lastIndex = start;
    var result = directionRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = directionRegEx.lastIndex;
    var firstDirection = result[1];
    if (result[2]) {
        var secondDirection = result[2];
        var value = cornerDirections[firstDirection][secondDirection];
        return value === undefined ? null : { start: start, end: end, value: value };
    }
    else {
        return { start: start, end: end, value: sideDirections[firstDirection] };
    }
}
var openingBracketRegEx = /\s*\(\s*/gy;
var closingBracketRegEx = /\s*\)\s*/gy;
var closingBracketOrCommaRegEx = /\s*(\)|,)\s*/gy;
function parseArgumentsList(text, start, argument) {
    openingBracketRegEx.lastIndex = start;
    var openingBracket = openingBracketRegEx.exec(text);
    if (!openingBracket) {
        return null;
    }
    var end = openingBracketRegEx.lastIndex;
    var value = [];
    closingBracketRegEx.lastIndex = end;
    var closingBracket = closingBracketRegEx.exec(text);
    if (closingBracket) {
        return { start: start, end: end, value: value };
    }
    for (var index = 0; true; index++) {
        var arg = argument(text, end, index);
        if (!arg) {
            return null;
        }
        end = arg.end;
        value.push(arg);
        closingBracketOrCommaRegEx.lastIndex = end;
        var closingBracketOrComma = closingBracketOrCommaRegEx.exec(text);
        if (closingBracketOrComma) {
            end = closingBracketOrCommaRegEx.lastIndex;
            if (closingBracketOrComma[1] === ',') {
                continue;
            }
            else if (closingBracketOrComma[1] === ')') {
                return { start: start, end: end, value: value };
            }
        }
        else {
            return null;
        }
    }
}
function parseColorStop(text, start) {
    if (start === void 0) { start = 0; }
    var color = parseColor(text, start);
    if (!color) {
        return null;
    }
    var end = color.end;
    var offset = parsePercentageOrLength(text, end);
    if (offset) {
        end = offset.end;
        return {
            start: start,
            end: end,
            value: { argb: color.value, offset: offset.value },
        };
    }
    return { start: start, end: end, value: { argb: color.value } };
}
exports.parseColorStop = parseColorStop;
var linearGradientStartRegEx = /\s*linear-gradient\s*/gy;
function parseLinearGradient(text, start) {
    if (start === void 0) { start = 0; }
    linearGradientStartRegEx.lastIndex = start;
    var lgs = linearGradientStartRegEx.exec(text);
    if (!lgs) {
        return null;
    }
    var end = linearGradientStartRegEx.lastIndex;
    var angle = Math.PI;
    var colors = [];
    var parsedArgs = parseArgumentsList(text, end, function (text, start, index) {
        if (index === 0) {
            var angleArg = parseAngle(text, start) || parseDirection(text, start);
            if (angleArg) {
                angle = angleArg.value;
                return angleArg;
            }
        }
        var colorStop = parseColorStop(text, start);
        if (colorStop) {
            colors.push(colorStop.value);
            return colorStop;
        }
        return null;
    });
    if (!parsedArgs) {
        return null;
    }
    end = parsedArgs.end;
    return { start: start, end: end, value: { angle: angle, colors: colors } };
}
exports.parseLinearGradient = parseLinearGradient;
var slashRegEx = /\s*(\/)\s*/gy;
function parseSlash(text, start) {
    slashRegEx.lastIndex = start;
    var slash = slashRegEx.exec(text);
    if (!slash) {
        return null;
    }
    var end = slashRegEx.lastIndex;
    return { start: start, end: end, value: '/' };
}
function parseBackground(text, start) {
    if (start === void 0) { start = 0; }
    var value = {};
    var end = start;
    while (end < text.length) {
        var keyword = parseKeyword(text, end);
        var color = parseColor(text, end, keyword);
        if (color) {
            value.color = color.value;
            end = color.end;
            continue;
        }
        var repeat = parseRepeat(text, end, keyword);
        if (repeat) {
            value.repeat = repeat.value;
            end = repeat.end;
            continue;
        }
        var position = parseBackgroundPosition(text, end, keyword);
        if (position) {
            position.value.text = text.substring(position.start, position.end);
            value.position = position.value;
            end = position.end;
            var slash = parseSlash(text, end);
            if (slash) {
                end = slash.end;
                var size = parseBackgroundSize(text, end);
                if (!size) {
                    return null;
                }
                value.size = size.value;
                end = size.end;
            }
            continue;
        }
        var url = parseURL(text, end);
        if (url) {
            value.image = url.value;
            end = url.end;
            continue;
        }
        var gradient = parseLinearGradient(text, end);
        if (gradient) {
            value.image = gradient.value;
            end = gradient.end;
            continue;
        }
        return null;
    }
    return { start: start, end: end, value: value };
}
exports.parseBackground = parseBackground;
var universalSelectorRegEx = /\*/gy;
function parseUniversalSelector(text, start) {
    if (start === void 0) { start = 0; }
    universalSelectorRegEx.lastIndex = start;
    var result = universalSelectorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = universalSelectorRegEx.lastIndex;
    return { start: start, end: end, value: { type: '*' } };
}
exports.parseUniversalSelector = parseUniversalSelector;
var simpleIdentifierSelectorRegEx = /(#|\.|:|\b)((?:[\w_-]|\\.)(?:[\w\d_-]|\\.)*)/guy;
var unicodeEscapeRegEx = /\\([0-9a-fA-F]{1,5}\s|[0-9a-fA-F]{6})/g;
function parseSimpleIdentifierSelector(text, start) {
    if (start === void 0) { start = 0; }
    simpleIdentifierSelectorRegEx.lastIndex = start;
    var result = simpleIdentifierSelectorRegEx.exec(text.replace(unicodeEscapeRegEx, function (_, c) { return '\\' + String.fromCodePoint(parseInt(c.trim(), 16)); }));
    if (!result) {
        return null;
    }
    var end = simpleIdentifierSelectorRegEx.lastIndex;
    var type = result[1];
    var identifier = result[2].replace(/\\/g, '');
    var value = { type: type, identifier: identifier };
    return { start: start, end: end, value: value };
}
exports.parseSimpleIdentifierSelector = parseSimpleIdentifierSelector;
var attributeSelectorRegEx = /\[\s*([_-\w][_-\w\d]*)\s*(?:(=|\^=|\$=|\*=|\~=|\|=)\s*(?:([_-\w][_-\w\d]*)|"((?:[^\\"]|\\(?:"|n|r|f|\\|0-9a-f))*)"|'((?:[^\\']|\\(?:'|n|r|f|\\|0-9a-f))*)')\s*)?\]/gy;
function parseAttributeSelector(text, start) {
    attributeSelectorRegEx.lastIndex = start;
    var result = attributeSelectorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = attributeSelectorRegEx.lastIndex;
    var property = result[1];
    if (result[2]) {
        var test_1 = result[2];
        var value = result[3] || result[4] || result[5];
        return { start: start, end: end, value: { type: '[]', property: property, test: test_1, value: value } };
    }
    return { start: start, end: end, value: { type: '[]', property: property } };
}
exports.parseAttributeSelector = parseAttributeSelector;
function parseSimpleSelector(text, start) {
    if (start === void 0) { start = 0; }
    return parseUniversalSelector(text, start) || parseSimpleIdentifierSelector(text, start) || parseAttributeSelector(text, start);
}
exports.parseSimpleSelector = parseSimpleSelector;
function parseSimpleSelectorSequence(text, start) {
    var simpleSelector = parseSimpleSelector(text, start);
    if (!simpleSelector) {
        return null;
    }
    var end = simpleSelector.end;
    var value = [];
    while (simpleSelector) {
        value.push(simpleSelector.value);
        end = simpleSelector.end;
        simpleSelector = parseSimpleSelector(text, end);
    }
    return { start: start, end: end, value: value };
}
exports.parseSimpleSelectorSequence = parseSimpleSelectorSequence;
var combinatorRegEx = /\s*(\+|~|>)?\s*/gy;
function parseCombinator(text, start) {
    if (start === void 0) { start = 0; }
    combinatorRegEx.lastIndex = start;
    var result = combinatorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = combinatorRegEx.lastIndex;
    var value = result[1] || ' ';
    return { start: start, end: end, value: value };
}
exports.parseCombinator = parseCombinator;
var whiteSpaceRegEx = /\s*/gy;
function parseSelector(text, start) {
    if (start === void 0) { start = 0; }
    var end = start;
    whiteSpaceRegEx.lastIndex = end;
    var leadingWhiteSpace = whiteSpaceRegEx.exec(text);
    if (leadingWhiteSpace) {
        end = whiteSpaceRegEx.lastIndex;
    }
    var value = [];
    var combinator;
    var expectSimpleSelector = true;
    var pair;
    do {
        var simpleSelectorSequence = parseSimpleSelectorSequence(text, end);
        if (!simpleSelectorSequence) {
            if (expectSimpleSelector) {
                return null;
            }
            else {
                break;
            }
        }
        end = simpleSelectorSequence.end;
        if (combinator) {
            pair[1] = combinator.value;
        }
        pair = [simpleSelectorSequence.value, undefined];
        value.push(pair);
        combinator = parseCombinator(text, end);
        if (combinator) {
            end = combinator.end;
        }
        expectSimpleSelector = combinator && combinator.value !== ' ';
    } while (combinator);
    return { start: start, end: end, value: value };
}
exports.parseSelector = parseSelector;
var whitespaceRegEx = /[\s\t\n\r\f]*/gmy;
var singleQuoteStringRegEx = /'((?:[^\n\r\f\']|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)(:?'|$)/gmy;
var doubleQuoteStringRegEx = /"((?:[^\n\r\f\"]|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)(:?"|$)/gmy;
var commentRegEx = /(\/\*(?:[^\*]|\*[^\/])*\*\/)/gmy;
var numberRegEx = /[\+\-]?(?:\d+\.\d+|\d+|\.\d+)(?:[eE][\+\-]?\d+)?/gmy;
var nameRegEx = /-?(?:(?:[a-zA-Z_]|[^\x00-\x7F]|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))(?:[a-zA-Z_0-9\-]*|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)/gmy;
var CSS3Parser = (function () {
    function CSS3Parser(text) {
        this.text = text;
        this.nextInputCodePointIndex = 0;
    }
    CSS3Parser.prototype.tokenize = function () {
        var tokens = [];
        var inputToken;
        do {
            inputToken = this.consumeAToken();
            tokens.push(inputToken);
        } while (inputToken);
        return tokens;
    };
    CSS3Parser.prototype.consumeAToken = function () {
        if (this.reconsumedInputToken) {
            var result = this.reconsumedInputToken;
            this.reconsumedInputToken = null;
            return result;
        }
        var char = this.text[this.nextInputCodePointIndex];
        switch (char) {
            case '"':
                return this.consumeAStringToken();
            case "'":
                return this.consumeAStringToken();
            case '(':
            case ')':
            case ',':
            case ':':
            case ';':
            case '[':
            case ']':
            case '{':
            case '}':
                this.nextInputCodePointIndex++;
                return char;
            case '#':
                return this.consumeAHashToken() || this.consumeADelimToken();
            case ' ':
            case '\t':
            case '\n':
            case '\r':
            case '\f':
                return this.consumeAWhitespace();
            case '@':
                return this.consumeAtKeyword() || this.consumeADelimToken();
            case '\\':
                return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return this.consumeANumericToken();
            case 'u':
            case 'U':
                if (this.text[this.nextInputCodePointIndex + 1] === '+') {
                    var thirdChar = this.text[this.nextInputCodePointIndex + 2];
                    if ((thirdChar >= '0' && thirdChar <= '9') || thirdChar === '?') {
                        throw new Error('Unicode tokens not supported!');
                    }
                }
                return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
            case '$':
            case '*':
            case '^':
            case '|':
            case '~':
                return this.consumeAMatchToken() || this.consumeADelimToken();
            case '-':
                return this.consumeANumericToken() || this.consumeAnIdentLikeToken() || this.consumeCDC() || this.consumeADelimToken();
            case '+':
            case '.':
                return this.consumeANumericToken() || this.consumeADelimToken();
            case '/':
                return this.consumeAComment() || this.consumeADelimToken();
            case '<':
                return this.consumeCDO() || this.consumeADelimToken();
            case undefined:
                return undefined;
            default:
                return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
        }
    };
    CSS3Parser.prototype.consumeADelimToken = function () {
        return {
            type: 2,
            text: this.text[this.nextInputCodePointIndex++],
        };
    };
    CSS3Parser.prototype.consumeAWhitespace = function () {
        whitespaceRegEx.lastIndex = this.nextInputCodePointIndex;
        whitespaceRegEx.exec(this.text);
        this.nextInputCodePointIndex = whitespaceRegEx.lastIndex;
        return ' ';
    };
    CSS3Parser.prototype.consumeAHashToken = function () {
        this.nextInputCodePointIndex++;
        var hashName = this.consumeAName();
        if (hashName) {
            return { type: 12, text: '#' + hashName.text };
        }
        this.nextInputCodePointIndex--;
        return null;
    };
    CSS3Parser.prototype.consumeCDO = function () {
        if (this.text.substr(this.nextInputCodePointIndex, 4) === '<!--') {
            this.nextInputCodePointIndex += 4;
            return '<!--';
        }
        return null;
    };
    CSS3Parser.prototype.consumeCDC = function () {
        if (this.text.substr(this.nextInputCodePointIndex, 3) === '-->') {
            this.nextInputCodePointIndex += 3;
            return '-->';
        }
        return null;
    };
    CSS3Parser.prototype.consumeAMatchToken = function () {
        if (this.text[this.nextInputCodePointIndex + 1] === '=') {
            var token = this.text.substr(this.nextInputCodePointIndex, 2);
            this.nextInputCodePointIndex += 2;
            return token;
        }
        return null;
    };
    CSS3Parser.prototype.consumeANumericToken = function () {
        numberRegEx.lastIndex = this.nextInputCodePointIndex;
        var result = numberRegEx.exec(this.text);
        if (!result) {
            return null;
        }
        this.nextInputCodePointIndex = numberRegEx.lastIndex;
        if (this.text[this.nextInputCodePointIndex] === '%') {
            return { type: 4, text: result[0] };
        }
        var name = this.consumeAName();
        if (name) {
            return {
                type: 5,
                text: result[0] + name.text,
            };
        }
        return { type: 3, text: result[0] };
    };
    CSS3Parser.prototype.consumeAnIdentLikeToken = function () {
        var name = this.consumeAName();
        if (!name) {
            return null;
        }
        if (this.text[this.nextInputCodePointIndex] === '(') {
            this.nextInputCodePointIndex++;
            if (name.text.toLowerCase() === 'url') {
                return this.consumeAURLToken();
            }
            return {
                type: 8,
                name: name.text,
                text: name.text + '(',
            };
        }
        return name;
    };
    CSS3Parser.prototype.consumeAStringToken = function () {
        var char = this.text[this.nextInputCodePointIndex];
        var result;
        if (char === "'") {
            singleQuoteStringRegEx.lastIndex = this.nextInputCodePointIndex;
            result = singleQuoteStringRegEx.exec(this.text);
            if (!result) {
                return null;
            }
            this.nextInputCodePointIndex = singleQuoteStringRegEx.lastIndex;
        }
        else if (char === '"') {
            doubleQuoteStringRegEx.lastIndex = this.nextInputCodePointIndex;
            result = doubleQuoteStringRegEx.exec(this.text);
            if (!result) {
                return null;
            }
            this.nextInputCodePointIndex = doubleQuoteStringRegEx.lastIndex;
        }
        return { type: 1, text: result[0] };
    };
    CSS3Parser.prototype.consumeAURLToken = function () {
        var start = this.nextInputCodePointIndex - 3 - 1;
        var urlToken = {
            type: 7,
            text: undefined,
        };
        this.consumeAWhitespace();
        if (this.nextInputCodePointIndex >= this.text.length) {
            return urlToken;
        }
        var nextInputCodePoint = this.text[this.nextInputCodePointIndex];
        if (nextInputCodePoint === '"' || nextInputCodePoint === "'") {
            var stringToken = this.consumeAStringToken();
            urlToken.text = stringToken.text;
            this.consumeAWhitespace();
            if (this.text[this.nextInputCodePointIndex] === ')' || this.nextInputCodePointIndex >= this.text.length) {
                this.nextInputCodePointIndex++;
                var end = this.nextInputCodePointIndex;
                urlToken.text = this.text.substring(start, end);
                return urlToken;
            }
            else {
                return null;
            }
        }
        while (this.nextInputCodePointIndex < this.text.length) {
            var char = this.text[this.nextInputCodePointIndex++];
            switch (char) {
                case ')':
                    return urlToken;
                case ' ':
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                    this.consumeAWhitespace();
                    if (this.text[this.nextInputCodePointIndex] === ')') {
                        this.nextInputCodePointIndex++;
                        return urlToken;
                    }
                    else {
                        return null;
                    }
                case '"':
                case "'":
                    return null;
                case '\\':
                    throw new Error('Escaping not yet supported!');
                default:
                    urlToken.text += char;
            }
        }
        return urlToken;
    };
    CSS3Parser.prototype.consumeAName = function () {
        nameRegEx.lastIndex = this.nextInputCodePointIndex;
        var result = nameRegEx.exec(this.text);
        if (!result) {
            return null;
        }
        this.nextInputCodePointIndex = nameRegEx.lastIndex;
        return { type: 6, text: result[0] };
    };
    CSS3Parser.prototype.consumeAtKeyword = function () {
        this.nextInputCodePointIndex++;
        var name = this.consumeAName();
        if (name) {
            return { type: 11, text: name.text };
        }
        this.nextInputCodePointIndex--;
        return null;
    };
    CSS3Parser.prototype.consumeAComment = function () {
        if (this.text[this.nextInputCodePointIndex + 1] === '*') {
            commentRegEx.lastIndex = this.nextInputCodePointIndex;
            var result = commentRegEx.exec(this.text);
            if (!result) {
                return null;
            }
            this.nextInputCodePointIndex = commentRegEx.lastIndex;
            return this.consumeAToken();
        }
        return null;
    };
    CSS3Parser.prototype.reconsumeTheCurrentInputToken = function (currentInputToken) {
        this.reconsumedInputToken = currentInputToken;
    };
    CSS3Parser.prototype.parseAStylesheet = function () {
        this.topLevelFlag = true;
        var stylesheet = {
            rules: this.consumeAListOfRules(),
        };
        return stylesheet;
    };
    CSS3Parser.prototype.consumeAListOfRules = function () {
        var rules = [];
        var inputToken;
        while ((inputToken = this.consumeAToken())) {
            switch (inputToken) {
                case ' ':
                    continue;
                case '<!--':
                case '-->':
                    if (this.topLevelFlag) {
                        continue;
                    }
                    this.reconsumeTheCurrentInputToken(inputToken);
                    var atRule = this.consumeAnAtRule();
                    if (atRule) {
                        rules.push(atRule);
                    }
                    continue;
            }
            if (inputToken.type === 11) {
                this.reconsumeTheCurrentInputToken(inputToken);
                var atRule = this.consumeAnAtRule();
                if (atRule) {
                    rules.push(atRule);
                }
                continue;
            }
            this.reconsumeTheCurrentInputToken(inputToken);
            var qualifiedRule = this.consumeAQualifiedRule();
            if (qualifiedRule) {
                rules.push(qualifiedRule);
            }
        }
        return rules;
    };
    CSS3Parser.prototype.consumeAnAtRule = function () {
        var inputToken = this.consumeAToken();
        var atRule = {
            type: 'at-rule',
            name: inputToken.text,
            prelude: [],
            block: undefined,
        };
        while ((inputToken = this.consumeAToken())) {
            if (inputToken === ';') {
                return atRule;
            }
            else if (inputToken === '{') {
                atRule.block = this.consumeASimpleBlock(inputToken);
                return atRule;
            }
            else if (inputToken.type === 9 && inputToken.associatedToken === '{') {
                atRule.block = inputToken;
                return atRule;
            }
            this.reconsumeTheCurrentInputToken(inputToken);
            var component = this.consumeAComponentValue();
            if (component) {
                atRule.prelude.push(component);
            }
        }
        return atRule;
    };
    CSS3Parser.prototype.consumeAQualifiedRule = function () {
        var qualifiedRule = {
            type: 'qualified-rule',
            prelude: [],
            block: undefined,
        };
        var inputToken;
        while ((inputToken = this.consumeAToken())) {
            if (inputToken === '{') {
                var block = this.consumeASimpleBlock(inputToken);
                qualifiedRule.block = block;
                return qualifiedRule;
            }
            else if (inputToken.type === 9) {
                var simpleBlock = inputToken;
                if (simpleBlock.associatedToken === '{') {
                    qualifiedRule.block = simpleBlock;
                    return qualifiedRule;
                }
            }
            this.reconsumeTheCurrentInputToken(inputToken);
            var componentValue = this.consumeAComponentValue();
            if (componentValue) {
                qualifiedRule.prelude.push(componentValue);
            }
        }
        return null;
    };
    CSS3Parser.prototype.consumeAComponentValue = function () {
        var inputToken = this.consumeAToken();
        switch (inputToken) {
            case '{':
            case '[':
            case '(':
                this.nextInputCodePointIndex++;
                return this.consumeASimpleBlock(inputToken);
        }
        if (typeof inputToken === 'object' && inputToken.type === 8) {
            return this.consumeAFunction(inputToken.name);
        }
        return inputToken;
    };
    CSS3Parser.prototype.consumeASimpleBlock = function (associatedToken) {
        var endianToken = {
            '[': ']',
            '{': '}',
            '(': ')',
        }[associatedToken];
        var start = this.nextInputCodePointIndex - 1;
        var block = {
            type: 9,
            text: undefined,
            associatedToken: associatedToken,
            values: [],
        };
        var nextInputToken;
        while ((nextInputToken = this.text[this.nextInputCodePointIndex])) {
            if (nextInputToken === endianToken) {
                this.nextInputCodePointIndex++;
                var end = this.nextInputCodePointIndex;
                block.text = this.text.substring(start, end);
                return block;
            }
            var value = this.consumeAComponentValue();
            if (value) {
                block.values.push(value);
            }
        }
        block.text = this.text.substring(start);
        return block;
    };
    CSS3Parser.prototype.consumeAFunction = function (name) {
        var start = this.nextInputCodePointIndex;
        var funcToken = {
            type: 14,
            name: name,
            text: undefined,
            components: [],
        };
        do {
            if (this.nextInputCodePointIndex >= this.text.length) {
                funcToken.text = name + '(' + this.text.substring(start);
                return funcToken;
            }
            var nextInputToken = this.text[this.nextInputCodePointIndex];
            switch (nextInputToken) {
                case ')':
                    this.nextInputCodePointIndex++;
                    var end = this.nextInputCodePointIndex;
                    funcToken.text = name + '(' + this.text.substring(start, end);
                    return funcToken;
                default:
                    var component = this.consumeAComponentValue();
                    if (component) {
                        funcToken.components.push(component);
                    }
            }
        } while (true);
    };
    return CSS3Parser;
}());
exports.CSS3Parser = CSS3Parser;
var CSSNativeScript = (function () {
    function CSSNativeScript() {
    }
    CSSNativeScript.prototype.parseStylesheet = function (stylesheet) {
        return {
            type: 'stylesheet',
            stylesheet: {
                rules: this.parseRules(stylesheet.rules),
            },
        };
    };
    CSSNativeScript.prototype.parseRules = function (rules) {
        var _this = this;
        return rules.map(function (rule) { return _this.parseRule(rule); });
    };
    CSSNativeScript.prototype.parseRule = function (rule) {
        if (rule.type === 'at-rule') {
            return this.parseAtRule(rule);
        }
        else if (rule.type === 'qualified-rule') {
            return this.parseQualifiedRule(rule);
        }
    };
    CSSNativeScript.prototype.parseAtRule = function (rule) {
        if (rule.name === 'import') {
            return {
                import: rule.prelude
                    .map(function (m) { return (typeof m === 'string' ? m : m.text); })
                    .join('')
                    .trim(),
                type: 'import',
            };
        }
        return;
    };
    CSSNativeScript.prototype.parseQualifiedRule = function (rule) {
        return {
            type: 'rule',
            selectors: this.preludeToSelectorsStringArray(rule.prelude),
            declarations: this.ruleBlockToDeclarations(rule.block.values),
        };
    };
    CSSNativeScript.prototype.ruleBlockToDeclarations = function (declarationsInputTokens) {
        var declarations = [];
        var property = '';
        var value = '';
        var reading = 'property';
        for (var i = 0; i < declarationsInputTokens.length; i++) {
            var inputToken = declarationsInputTokens[i];
            if (reading === 'property') {
                if (inputToken === ':') {
                    reading = 'value';
                }
                else if (typeof inputToken === 'string') {
                    property += inputToken;
                }
                else {
                    property += inputToken.text;
                }
            }
            else {
                if (inputToken === ';') {
                    property = property.trim();
                    value = value.trim();
                    declarations.push({ type: 'declaration', property: property, value: value });
                    property = '';
                    value = '';
                    reading = 'property';
                }
                else if (typeof inputToken === 'string') {
                    value += inputToken;
                }
                else {
                    value += inputToken.text;
                }
            }
        }
        property = property.trim();
        value = value.trim();
        if (property || value) {
            declarations.push({ type: 'declaration', property: property, value: value });
        }
        return declarations;
    };
    CSSNativeScript.prototype.preludeToSelectorsStringArray = function (prelude) {
        var selectors = [];
        var selector = '';
        prelude.forEach(function (inputToken) {
            if (typeof inputToken === 'string') {
                if (inputToken === ',') {
                    if (selector) {
                        selectors.push(selector.trim());
                    }
                    selector = '';
                }
                else {
                    selector += inputToken;
                }
            }
            else if (typeof inputToken === 'object') {
                selector += inputToken.text;
            }
        });
        if (selector) {
            selectors.push(selector.trim());
        }
        return selectors;
    };
    return CSSNativeScript;
}());
exports.CSSNativeScript = CSSNativeScript;
//# sourceMappingURL=parser.js.map; 
if (false ) {} 

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "HttpResponseEncoding", function() { return /* binding */ HttpResponseEncoding; });
__webpack_require__.d(__webpack_exports__, "request", function() { return /* binding */ request; });
__webpack_require__.d(__webpack_exports__, "addHeader", function() { return /* binding */ addHeader; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/types.js
var types = __webpack_require__(10);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/debugger/index.js
var core_debugger = __webpack_require__(39);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/http/http-request/http-request-common.js
function getFilenameFromUrl(url) {
    const fs = __webpack_require__(21);
    const slashPos = url.lastIndexOf('/') + 1;
    const questionMarkPos = url.lastIndexOf('?');
    let actualFileName;
    if (questionMarkPos !== -1) {
        actualFileName = url.substring(slashPos, questionMarkPos);
    }
    else {
        actualFileName = url.substring(slashPos);
    }
    const result = fs.path.join(fs.knownFolders.documents().path, actualFileName);
    return result;
}
//# sourceMappingURL=http-request-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/http/http-request/index.js



var HttpResponseEncoding;
(function (HttpResponseEncoding) {
    HttpResponseEncoding[HttpResponseEncoding["UTF8"] = 0] = "UTF8";
    HttpResponseEncoding[HttpResponseEncoding["GBK"] = 1] = "GBK";
})(HttpResponseEncoding || (HttpResponseEncoding = {}));
const currentDevice = UIDevice.currentDevice;
const device = currentDevice.userInterfaceIdiom === 0 /* Phone */ ? 'Phone' : 'Pad';
const osVersion = currentDevice.systemVersion;
const GET = 'GET';
const USER_AGENT_HEADER = 'User-Agent';
const USER_AGENT = `Mozilla/5.0 (i${device}; CPU OS ${osVersion.replace('.', '_')} like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/${osVersion} Mobile/10A5355d Safari/8536.25`;
const sessionConfig = NSURLSessionConfiguration.defaultSessionConfiguration;
const queue = NSOperationQueue.mainQueue;
function parseJSON(source) {
    const src = source.trim();
    if (src.lastIndexOf(')') === src.length - 1) {
        return JSON.parse(src.substring(src.indexOf('(') + 1, src.lastIndexOf(')')));
    }
    return JSON.parse(src);
}
var NSURLSessionTaskDelegateImpl = /** @class */ (function (_super) {
    __extends(NSURLSessionTaskDelegateImpl, _super);
    function NSURLSessionTaskDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NSURLSessionTaskDelegateImpl.prototype.URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler = function (session, task, response, request, completionHandler) {
        completionHandler(null);
    };
    NSURLSessionTaskDelegateImpl.ObjCProtocols = [NSURLSessionTaskDelegate];
    return NSURLSessionTaskDelegateImpl;
}(NSObject));
const sessionTaskDelegateInstance = NSURLSessionTaskDelegateImpl.new();
let defaultSession;
function ensureDefaultSession() {
    if (!defaultSession) {
        defaultSession = NSURLSession.sessionWithConfigurationDelegateDelegateQueue(sessionConfig, null, queue);
    }
}
let sessionNotFollowingRedirects;
function ensureSessionNotFollowingRedirects() {
    if (!sessionNotFollowingRedirects) {
        sessionNotFollowingRedirects = NSURLSession.sessionWithConfigurationDelegateDelegateQueue(sessionConfig, sessionTaskDelegateInstance, queue);
    }
}
let imageSource;
function ensureImageSource() {
    if (!imageSource) {
        imageSource = __webpack_require__(25);
    }
}
let fs;
function ensureFileSystem() {
    if (!fs) {
        fs = __webpack_require__(21);
    }
}
function request(options) {
    return new Promise((resolve, reject) => {
        if (!options.url) {
            reject(new Error('Request url was empty.'));
            return;
        }
        try {
            const network = core_debugger["c" /* getNetwork */]();
            const debugRequest = network && network.create();
            const urlRequest = NSMutableURLRequest.requestWithURL(NSURL.URLWithString(options.url));
            urlRequest.HTTPMethod = types["f" /* isDefined */](options.method) ? options.method : GET;
            urlRequest.setValueForHTTPHeaderField(USER_AGENT, USER_AGENT_HEADER);
            if (options.headers) {
                for (let header in options.headers) {
                    urlRequest.setValueForHTTPHeaderField(options.headers[header] + '', header);
                }
            }
            if (types["k" /* isString */](options.content) || options.content instanceof FormData) {
                urlRequest.HTTPBody = NSString.stringWithString(options.content.toString()).dataUsingEncoding(4);
            }
            else if (options.content instanceof ArrayBuffer) {
                const buffer = options.content;
                urlRequest.HTTPBody = NSData.dataWithData(buffer);
            }
            if (types["i" /* isNumber */](options.timeout)) {
                urlRequest.timeoutInterval = options.timeout / 1000;
            }
            let session;
            if (types["e" /* isBoolean */](options.dontFollowRedirects) && options.dontFollowRedirects) {
                ensureSessionNotFollowingRedirects();
                session = sessionNotFollowingRedirects;
            }
            else {
                ensureDefaultSession();
                session = defaultSession;
            }
            const dataTask = session.dataTaskWithRequestCompletionHandler(urlRequest, function (data, response, error) {
                if (error) {
                    reject(new Error(error.localizedDescription));
                }
                else {
                    const headers = {};
                    if (response && response.allHeaderFields) {
                        const headerFields = response.allHeaderFields;
                        headerFields.enumerateKeysAndObjectsUsingBlock((key, value, stop) => {
                            addHeader(headers, key, value);
                        });
                    }
                    if (debugRequest) {
                        debugRequest.mimeType = response.MIMEType;
                        debugRequest.data = data;
                        const debugResponse = {
                            url: options.url,
                            status: response.statusCode,
                            statusText: NSHTTPURLResponse.localizedStringForStatusCode(response.statusCode),
                            headers: headers,
                            mimeType: response.MIMEType,
                            fromDiskCache: false,
                        };
                        debugRequest.responseReceived(debugResponse);
                        debugRequest.loadingFinished();
                    }
                    resolve({
                        content: {
                            raw: data,
                            toArrayBuffer: () => interop.bufferFromData(data),
                            toString: (encoding) => {
                                const str = NSDataToString(data, encoding);
                                if (typeof str === 'string') {
                                    return str;
                                }
                                else {
                                    throw new Error('Response content may not be converted to string');
                                }
                            },
                            toJSON: (encoding) => parseJSON(NSDataToString(data, encoding)),
                            toImage: () => {
                                ensureImageSource();
                                return new Promise((resolve, reject) => {
                                    UIImage.tns_decodeImageWithDataCompletion(data, (image) => {
                                        if (image) {
                                            resolve(new imageSource.ImageSource(image));
                                        }
                                        else {
                                            reject(new Error('Response content may not be converted to an Image'));
                                        }
                                    });
                                });
                            },
                            toFile: (destinationFilePath) => {
                                ensureFileSystem();
                                if (!destinationFilePath) {
                                    destinationFilePath = getFilenameFromUrl(options.url);
                                }
                                if (data instanceof NSData) {
                                    // ensure destination path exists by creating any missing parent directories
                                    const file = fs.File.fromPath(destinationFilePath);
                                    data.writeToFileAtomically(destinationFilePath, true);
                                    return file;
                                }
                                else {
                                    reject(new Error(`Cannot save file with path: ${destinationFilePath}.`));
                                }
                            },
                        },
                        statusCode: response.statusCode,
                        headers: headers,
                    });
                }
            });
            if (options.url && debugRequest) {
                const request = {
                    url: options.url,
                    method: 'GET',
                    headers: options.headers,
                };
                debugRequest.requestWillBeSent(request);
            }
            dataTask.resume();
        }
        catch (ex) {
            reject(ex);
        }
    });
}
function NSDataToString(data, encoding) {
    let code = NSUTF8StringEncoding; // long:4
    if (encoding === HttpResponseEncoding.GBK) {
        code = 1586 /* kCFStringEncodingGB_18030_2000 */; // long:1586
    }
    let encodedString = NSString.alloc().initWithDataEncoding(data, code);
    // If UTF8 string encoding fails try with ISO-8859-1
    if (!encodedString) {
        code = NSISOLatin1StringEncoding; // long:5
        encodedString = NSString.alloc().initWithDataEncoding(data, code);
    }
    return encodedString.toString();
}
function addHeader(headers, key, value) {
    if (!headers[key]) {
        headers[key] = value;
    }
    else if (Array.isArray(headers[key])) {
        headers[key].push(value);
    }
    else {
        const values = [headers[key]];
        values.push(value);
        headers[key] = values;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Keyframes", function() { return Keyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnparsedKeyframe", function() { return UnparsedKeyframe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeDeclaration", function() { return KeyframeDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeInfo", function() { return KeyframeInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeAnimationInfo", function() { return KeyframeAnimationInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeAnimation", function() { return KeyframeAnimation; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);


// Types.



class Keyframes {
}
class UnparsedKeyframe {
}
class KeyframeDeclaration {
}
class KeyframeInfo {
    constructor() {
        this.curve = _enums__WEBPACK_IMPORTED_MODULE_0__["AnimationCurve"].ease;
    }
}
class KeyframeAnimationInfo {
    constructor() {
        this.name = '';
        this.duration = 0.3;
        this.delay = 0;
        this.iterations = 1;
        this.curve = 'ease';
        this.isForwards = false;
        this.isReverse = false;
    }
}
class KeyframeAnimation {
    constructor() {
        this.delay = 0;
        this.iterations = 1;
    }
    static keyframeAnimationFromInfo(info) {
        const length = info.keyframes.length;
        let animations = new Array();
        let startDuration = 0;
        if (info.isReverse) {
            for (let index = length - 1; index >= 0; index--) {
                let keyframe = info.keyframes[index];
                startDuration = KeyframeAnimation.parseKeyframe(info, keyframe, animations, startDuration);
            }
        }
        else {
            for (let index = 0; index < length; index++) {
                let keyframe = info.keyframes[index];
                startDuration = KeyframeAnimation.parseKeyframe(info, keyframe, animations, startDuration);
            }
            for (let index = length - 1; index > 0; index--) {
                let a1 = animations[index];
                let a2 = animations[index - 1];
                if (a2['curve'] !== undefined) {
                    a1['curve'] = a2['curve'];
                    a2['curve'] = undefined;
                }
            }
        }
        animations.map((a) => (a['curve'] ? a : Object.assign(a, { curve: info.curve })));
        const animation = new KeyframeAnimation();
        animation.delay = info.delay;
        animation.iterations = info.iterations;
        animation.animations = animations;
        animation._isForwards = info.isForwards;
        return animation;
    }
    static parseKeyframe(info, keyframe, animations, startDuration) {
        let animation = {};
        for (let declaration of keyframe.declarations) {
            animation[declaration.property] = declaration.value;
        }
        let duration = keyframe.duration;
        if (duration === 0) {
            duration = 0.01;
        }
        else {
            duration = info.duration * duration - startDuration;
            startDuration += duration;
        }
        animation.duration = info.isReverse ? info.duration - duration : duration;
        animation.curve = keyframe.curve;
        animation.forceLayer = true;
        animation.valueSource = 'keyframe';
        animations.push(animation);
        return startDuration;
    }
    get isPlaying() {
        return this._isPlaying;
    }
    cancel() {
        if (!this.isPlaying) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Keyframe animation is already playing.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
            return;
        }
        this._isPlaying = false;
        for (let i = this._nativeAnimations.length - 1; i >= 0; i--) {
            let animation = this._nativeAnimations[i];
            if (animation.isPlaying) {
                animation.cancel();
            }
        }
        if (this._nativeAnimations.length > 0) {
            let animation = this._nativeAnimations[0];
            this._resetAnimationValues(this._target, animation);
        }
        this._resetAnimations();
    }
    play(view) {
        if (this._isPlaying) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Keyframe animation is already playing.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
            return new Promise((resolve) => {
                resolve();
            });
        }
        let animationFinishedPromise = new Promise((resolve) => {
            this._resolve = resolve;
        });
        this._isPlaying = true;
        this._nativeAnimations = new Array();
        this._target = view;
        if (this.delay !== 0) {
            setTimeout(() => this.animate(view, 0, this.iterations), this.delay);
        }
        else {
            this.animate(view, 0, this.iterations);
        }
        return animationFinishedPromise;
    }
    animate(view, index, iterations) {
        if (!this._isPlaying) {
            return;
        }
        if (index === 0) {
            let animation = this.animations[0];
            if ('backgroundColor' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["backgroundColorProperty"].keyframe] = animation.backgroundColor;
            }
            if ('scale' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["scaleXProperty"].keyframe] = animation.scale.x;
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["scaleYProperty"].keyframe] = animation.scale.y;
            }
            if ('translate' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["translateXProperty"].keyframe] = animation.translate.x;
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["translateYProperty"].keyframe] = animation.translate.y;
            }
            if ('rotate' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["rotateXProperty"].keyframe] = animation.rotate.x;
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["rotateYProperty"].keyframe] = animation.rotate.y;
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["rotateProperty"].keyframe] = animation.rotate.z;
            }
            if ('opacity' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["opacityProperty"].keyframe] = animation.opacity;
            }
            if ('height' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["heightProperty"].keyframe] = animation.height;
            }
            if ('width' in animation) {
                view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["widthProperty"].keyframe] = animation.width;
            }
            setTimeout(() => this.animate(view, 1, iterations), 1);
        }
        else if (index < 0 || index >= this.animations.length) {
            iterations -= 1;
            if (iterations > 0) {
                this.animate(view, 0, iterations);
            }
            else {
                if (this._isForwards === false) {
                    let animation = this.animations[this.animations.length - 1];
                    this._resetAnimationValues(view, animation);
                }
                this._resolveAnimationFinishedPromise();
            }
        }
        else {
            let animation;
            const cachedAnimation = this._nativeAnimations[index - 1];
            if (cachedAnimation) {
                animation = cachedAnimation;
            }
            else {
                let animationDef = this.animations[index];
                animationDef.target = view;
                animation = new ___WEBPACK_IMPORTED_MODULE_3__["Animation"]([animationDef]);
                this._nativeAnimations.push(animation);
            }
            const isLastIteration = iterations - 1 <= 0;
            // Catch the animation cancel to prevent unhandled promise rejection warnings
            animation
                .play(isLastIteration)
                .then(() => {
                this.animate(view, index + 1, iterations);
            }, (error) => {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(typeof error === 'string' ? error : error.message, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
            })
                .catch((error) => {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(typeof error === 'string' ? error : error.message, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
            }); // tslint:disable-line
        }
    }
    _resolveAnimationFinishedPromise() {
        this._nativeAnimations = new Array();
        this._isPlaying = false;
        this._target = null;
        this._resolve();
    }
    _resetAnimations() {
        this._nativeAnimations = new Array();
        this._isPlaying = false;
        this._target = null;
    }
    _resetAnimationValues(view, animation) {
        if ('backgroundColor' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["backgroundColorProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
        if ('scale' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["scaleXProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["scaleYProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
        if ('translate' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["translateXProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["translateYProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
        if ('rotate' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["rotateProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
        if ('opacity' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["opacityProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
        if ('height' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["heightProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
        if ('width' in animation) {
            view.style[_styling_style_properties__WEBPACK_IMPORTED_MODULE_4__["widthProperty"].keyframe] = _core_properties__WEBPACK_IMPORTED_MODULE_2__["unsetValue"];
        }
    }
}
//# sourceMappingURL=keyframe-animation.js.map; 
if (false ) {} 

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasLaunched", function() { return hasLaunched; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "launchEvent", function() { return launchEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "suspendEvent", function() { return suspendEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "displayedEvent", function() { return displayedEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resumeEvent", function() { return resumeEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exitEvent", function() { return exitEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lowMemoryEvent", function() { return lowMemoryEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uncaughtErrorEvent", function() { return uncaughtErrorEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "discardedErrorEvent", function() { return discardedErrorEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientationChangedEvent", function() { return orientationChangedEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "systemAppearanceChangedEvent", function() { return systemAppearanceChangedEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getResources", function() { return getResources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResources", function() { return setResources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "android", function() { return android; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ios", function() { return ios; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notify", function() { return notify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasListeners", function() { return hasListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setApplication", function() { return setApplication; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "livesync", function() { return livesync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCssFileName", function() { return setCssFileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCssFileName", function() { return getCssFileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAppCss", function() { return loadAppCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientationChanged", function() { return orientationChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoSystemAppearanceChanged", function() { return autoSystemAppearanceChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAutoSystemAppearanceChanged", function() { return setAutoSystemAppearanceChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "systemAppearanceChanged", function() { return systemAppearanceChanged; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _ui_core_bindable_bindable_resources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var _css_system_classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _ui_enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
// Require globals first so that snapshot takes __extends function.





function hasLaunched() {
    return global.NativeScriptGlobals && global.NativeScriptGlobals.launched;
}
const launchEvent = 'launch';
const suspendEvent = 'suspend';
const displayedEvent = 'displayed';
const resumeEvent = 'resume';
const exitEvent = 'exit';
const lowMemoryEvent = 'lowMemory';
const uncaughtErrorEvent = 'uncaughtError';
const discardedErrorEvent = 'discardedError';
const orientationChangedEvent = 'orientationChanged';
const systemAppearanceChangedEvent = 'systemAppearanceChanged';
const ORIENTATION_CSS_CLASSES = [`${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${_ui_enums__WEBPACK_IMPORTED_MODULE_3__["Enums"].DeviceOrientation.portrait}`, `${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${_ui_enums__WEBPACK_IMPORTED_MODULE_3__["Enums"].DeviceOrientation.landscape}`, `${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${_ui_enums__WEBPACK_IMPORTED_MODULE_3__["Enums"].DeviceOrientation.unknown}`];
const SYSTEM_APPEARANCE_CSS_CLASSES = [`${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${_ui_enums__WEBPACK_IMPORTED_MODULE_3__["Enums"].SystemAppearance.light}`, `${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${_ui_enums__WEBPACK_IMPORTED_MODULE_3__["Enums"].SystemAppearance.dark}`];
let cssFile = './app.css';
function getResources() {
    return _ui_core_bindable_bindable_resources__WEBPACK_IMPORTED_MODULE_1__[/* get */ "a"]();
}
function setResources(res) {
    _ui_core_bindable_bindable_resources__WEBPACK_IMPORTED_MODULE_1__[/* set */ "b"](res);
}
let android = undefined;
let ios = undefined;
const on = global.NativeScriptGlobals.events.on.bind(global.NativeScriptGlobals.events);
const off = global.NativeScriptGlobals.events.off.bind(global.NativeScriptGlobals.events);
const notify = global.NativeScriptGlobals.events.notify.bind(global.NativeScriptGlobals.events);
const hasListeners = global.NativeScriptGlobals.events.hasListeners.bind(global.NativeScriptGlobals.events);
let app;
function setApplication(instance) {
    app = instance;
    // signal when the application instance is ready globally
    global.NativeScriptGlobals.appInstanceReady = true;
}
function livesync(rootView, context) {
    global.NativeScriptGlobals.events.notify({ eventName: 'livesync', object: app });
    const liveSyncCore = global.__onLiveSyncCore;
    let reapplyAppStyles = false;
    // ModuleContext is available only for Hot Module Replacement
    if (context && context.path) {
        const styleExtensions = ['css', 'scss'];
        const appStylesFullFileName = getCssFileName();
        const appStylesFileName = appStylesFullFileName.substring(0, appStylesFullFileName.lastIndexOf('.') + 1);
        reapplyAppStyles = styleExtensions.some((ext) => context.path === appStylesFileName.concat(ext));
    }
    // Handle application styles
    if (rootView && reapplyAppStyles) {
        rootView._onCssStateChange();
    }
    else if (liveSyncCore) {
        liveSyncCore(context);
    }
}
function setCssFileName(cssFileName) {
    cssFile = cssFileName;
    global.NativeScriptGlobals.events.notify({
        eventName: 'cssChanged',
        object: app,
        cssFile: cssFileName,
    });
}
function getCssFileName() {
    return cssFile;
}
function loadAppCss() {
    try {
        global.NativeScriptGlobals.events.notify({
            eventName: 'loadAppCss',
            object: app,
            cssFile: getCssFileName(),
        });
    }
    catch (e) {
        throw new Error(`The app CSS file ${getCssFileName()} couldn't be loaded!`);
    }
}
function addCssClass(rootView, cssClass) {
    _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].pushToSystemCssClasses(cssClass);
    rootView.cssClasses.add(cssClass);
}
function removeCssClass(rootView, cssClass) {
    _css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].removeSystemCssClass(cssClass);
    rootView.cssClasses.delete(cssClass);
}
function increaseStyleScopeApplicationCssSelectorVersion(rootView) {
    const styleScope = rootView._styleScope || (rootView.currentPage && rootView.currentPage._styleScope);
    if (styleScope) {
        styleScope._increaseApplicationCssSelectorVersion();
    }
}
function applyCssClass(rootView, cssClasses, newCssClass) {
    if (!rootView.cssClasses.has(newCssClass)) {
        cssClasses.forEach((cssClass) => removeCssClass(rootView, cssClass));
        addCssClass(rootView, newCssClass);
        increaseStyleScopeApplicationCssSelectorVersion(rootView);
        rootView._onCssStateChange();
    }
}
function orientationChanged(rootView, newOrientation) {
    if (!rootView) {
        return;
    }
    const newOrientationCssClass = `${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${newOrientation}`;
    applyCssClass(rootView, ORIENTATION_CSS_CLASSES, newOrientationCssClass);
    const rootModalViews = rootView._getRootModalViews();
    rootModalViews.forEach((rootModalView) => {
        applyCssClass(rootModalView, ORIENTATION_CSS_CLASSES, newOrientationCssClass);
    });
}
let autoSystemAppearanceChanged = true;
function setAutoSystemAppearanceChanged(value) {
    autoSystemAppearanceChanged = value;
}
function systemAppearanceChanged(rootView, newSystemAppearance) {
    if (!rootView || !autoSystemAppearanceChanged) {
        return;
    }
    const newSystemAppearanceCssClass = `${_css_system_classes__WEBPACK_IMPORTED_MODULE_2__[/* CSSUtils */ "a"].CLASS_PREFIX}${newSystemAppearance}`;
    applyCssClass(rootView, SYSTEM_APPEARANCE_CSS_CLASSES, newSystemAppearanceCssClass);
    const rootModalViews = rootView._getRootModalViews();
    rootModalViews.forEach((rootModalView) => {
        applyCssClass(rootModalView, SYSTEM_APPEARANCE_CSS_CLASSES, newSystemAppearanceCssClass);
    });
}
global.__onUncaughtError = function (error) {
    global.NativeScriptGlobals.events.notify({
        eventName: uncaughtErrorEvent,
        object: app,
        android: error,
        ios: error,
        error: error,
    });
};
global.__onDiscardedError = function (error) {
    global.NativeScriptGlobals.events.notify({
        eventName: discardedErrorEvent,
        object: app,
        error: error,
    });
};
//# sourceMappingURL=application-common.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ViewHelper; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
// Requires


class ViewHelper {
    static measureChild(parent, child, widthMeasureSpec, heightMeasureSpec) {
        let measureWidth = 0;
        let measureHeight = 0;
        if (child && !child.isCollapsed) {
            const widthSpec = parent ? parent._currentWidthMeasureSpec : widthMeasureSpec;
            const heightSpec = parent ? parent._currentHeightMeasureSpec : heightMeasureSpec;
            const width = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].getMeasureSpecSize(widthSpec);
            const widthMode = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].getMeasureSpecMode(widthSpec);
            const height = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].getMeasureSpecSize(heightSpec);
            const heightMode = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].getMeasureSpecMode(heightSpec);
            child._updateEffectiveLayoutValues(width, widthMode, height, heightMode);
            const style = child.style;
            const horizontalMargins = child.effectiveMarginLeft + child.effectiveMarginRight;
            const verticalMargins = child.effectiveMarginTop + child.effectiveMarginBottom;
            const childWidthMeasureSpec = ViewHelper.getMeasureSpec(widthMeasureSpec, horizontalMargins, child.effectiveWidth, style.horizontalAlignment === 'stretch');
            const childHeightMeasureSpec = ViewHelper.getMeasureSpec(heightMeasureSpec, verticalMargins, child.effectiveHeight, style.verticalAlignment === 'stretch');
            if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(`${child.parent} :measureChild: ${child} ${_utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].measureSpecToString(childWidthMeasureSpec)}, ${_utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].measureSpecToString(childHeightMeasureSpec)}}`, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Layout);
            }
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            measureWidth = Math.round(child.getMeasuredWidth() + horizontalMargins);
            measureHeight = Math.round(child.getMeasuredHeight() + verticalMargins);
        }
        return { measuredWidth: measureWidth, measuredHeight: measureHeight };
    }
    static layoutChild(parent, child, left, top, right, bottom, setFrame = true) {
        if (!child || child.isCollapsed) {
            return;
        }
        let childStyle = child.style;
        let childTop;
        let childLeft;
        let childWidth = child.getMeasuredWidth();
        let childHeight = child.getMeasuredHeight();
        let effectiveMarginTop = child.effectiveMarginTop;
        let effectiveMarginBottom = child.effectiveMarginBottom;
        let vAlignment;
        if (child.effectiveHeight >= 0 && childStyle.verticalAlignment === 'stretch') {
            vAlignment = 'middle';
        }
        else {
            vAlignment = childStyle.verticalAlignment;
        }
        switch (vAlignment) {
            case 'top':
                childTop = top + effectiveMarginTop;
                break;
            case 'middle':
                childTop = top + (bottom - top - childHeight + (effectiveMarginTop - effectiveMarginBottom)) / 2;
                break;
            case 'bottom':
                childTop = bottom - childHeight - effectiveMarginBottom;
                break;
            case 'stretch':
            default:
                childTop = top + effectiveMarginTop;
                childHeight = bottom - top - (effectiveMarginTop + effectiveMarginBottom);
                break;
        }
        let effectiveMarginLeft = child.effectiveMarginLeft;
        let effectiveMarginRight = child.effectiveMarginRight;
        let hAlignment;
        if (child.effectiveWidth >= 0 && childStyle.horizontalAlignment === 'stretch') {
            hAlignment = 'center';
        }
        else {
            hAlignment = childStyle.horizontalAlignment;
        }
        switch (hAlignment) {
            case 'left':
                childLeft = left + effectiveMarginLeft;
                break;
            case 'center':
                childLeft = left + (right - left - childWidth + (effectiveMarginLeft - effectiveMarginRight)) / 2;
                break;
            case 'right':
                childLeft = right - childWidth - effectiveMarginRight;
                break;
            case 'stretch':
            default:
                childLeft = left + effectiveMarginLeft;
                childWidth = right - left - (effectiveMarginLeft + effectiveMarginRight);
                break;
        }
        let childRight = Math.round(childLeft + childWidth);
        let childBottom = Math.round(childTop + childHeight);
        childLeft = Math.round(childLeft);
        childTop = Math.round(childTop);
        if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(child.parent + ' :layoutChild: ' + child + ' ' + childLeft + ', ' + childTop + ', ' + childRight + ', ' + childBottom, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Layout);
        }
        child.layout(childLeft, childTop, childRight, childBottom, setFrame);
    }
    static resolveSizeAndState(size, specSize, specMode, childMeasuredState) {
        let result = size;
        switch (specMode) {
            case _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].UNSPECIFIED:
                result = Math.ceil(size);
                break;
            case _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].AT_MOST:
                if (specSize < size) {
                    result = Math.ceil(specSize) | _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].MEASURED_STATE_TOO_SMALL;
                }
                break;
            case _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].EXACTLY:
                result = Math.ceil(specSize);
                break;
        }
        return result | (childMeasuredState & _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].MEASURED_STATE_MASK);
    }
    static combineMeasuredStates(curState, newState) {
        return curState | newState;
    }
    static getMeasureSpec(parentSpec, margins, childLength, stretched) {
        const parentLength = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].getMeasureSpecSize(parentSpec);
        const parentSpecMode = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].getMeasureSpecMode(parentSpec);
        let resultSize;
        let resultMode;
        // We want a specific size... let be it.
        if (childLength >= 0) {
            // If mode !== UNSPECIFIED we take the smaller of parentLength and childLength
            // Otherwise we will need to clip the view but this is not possible in all Android API levels.
            // TODO: remove Math.min(parentLength, childLength)
            resultSize = parentSpecMode === _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].UNSPECIFIED ? childLength : Math.min(parentLength, childLength);
            resultMode = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].EXACTLY;
        }
        else {
            switch (parentSpecMode) {
                // Parent has imposed an exact size on us
                case _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].EXACTLY:
                    resultSize = Math.max(0, parentLength - margins);
                    // if stretched - nativeView wants to be our size. So be it.
                    // else - nativeView wants to determine its own size. It can't be bigger than us.
                    resultMode = stretched ? _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].EXACTLY : _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].AT_MOST;
                    break;
                // Parent has imposed a maximum size on us
                case _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].AT_MOST:
                    resultSize = Math.max(0, parentLength - margins);
                    resultMode = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].AT_MOST;
                    break;
                // Equivalent to measure with Infinity.
                case _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].UNSPECIFIED:
                    resultSize = 0;
                    resultMode = _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].UNSPECIFIED;
                    break;
            }
        }
        return _utils__WEBPACK_IMPORTED_MODULE_0__[/* layout */ "n"].makeMeasureSpec(resultSize, resultMode);
    }
}
//# sourceMappingURL=view-helper-common.js.map; 
if (false ) {} 

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getEventOrGestureName; });
/* unused harmony export isGesture */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isEventOrGesture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Binding; });
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _weak_event_listener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);
/* harmony import */ var _builder_binding_builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _bindable_resources__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79);
/* harmony import */ var _js_libs_polymer_expressions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(103);
/* harmony import */ var _js_libs_polymer_expressions__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_js_libs_polymer_expressions__WEBPACK_IMPORTED_MODULE_8__);
// Requires








const polymerExpressions = __webpack_require__(103);

const contextKey = 'context';
// this regex is used to get parameters inside [] for example:
// from $parents['ListView'] will return 'ListView'
// from $parents[1] will return 1
const paramsRegex = /\[\s*(['"])*(\w*)\1\s*\]/;
const bc = _builder_binding_builder__WEBPACK_IMPORTED_MODULE_3__[/* bindingConstants */ "a"];
const emptyArray = [];
const propertiesCache = {};
function getProperties(property) {
    if (!property) {
        return emptyArray;
    }
    let result = propertiesCache[property];
    if (result) {
        return result;
    }
    // first replace all '$parents[..]' with a safe string
    // second removes all ] since they are not important for property access and not needed
    // then split properties either on '.' or '['
    const parentsMatches = property.match(_builder_binding_builder__WEBPACK_IMPORTED_MODULE_3__[/* parentsRegex */ "c"]);
    result = property.replace(_builder_binding_builder__WEBPACK_IMPORTED_MODULE_3__[/* parentsRegex */ "c"], 'parentsMatch').replace(/\]/g, '').split(/\.|\[/);
    let parentsMatchesCounter = 0;
    for (let i = 0, resultLength = result.length; i < resultLength; i++) {
        if (result[i] === 'parentsMatch') {
            result[i] = parentsMatches[parentsMatchesCounter++];
        }
    }
    propertiesCache[property] = result;
    return result;
}
function getEventOrGestureName(name) {
    return name.indexOf('on') === 0 ? name.substr(2, name.length - 2) : name;
}
// NOTE: method fromString from "ui/gestures";
function isGesture(eventOrGestureName) {
    let t = eventOrGestureName.trim().toLowerCase();
    return t === 'tap' || t === 'doubletap' || t === 'pinch' || t === 'pan' || t === 'swipe' || t === 'rotation' || t === 'longpress' || t === 'touch';
}
// TODO: Make this instance function so that we dont need public statc tapEvent = "tap"
// in controls. They will just override this one and provide their own event support.
function isEventOrGesture(name, view) {
    if (typeof name === 'string') {
        let eventOrGestureName = getEventOrGestureName(name);
        let evt = `${eventOrGestureName}Event`;
        return (view.constructor && evt in view.constructor) || isGesture(eventOrGestureName.toLowerCase());
    }
    return false;
}
class Binding {
    constructor(target, options) {
        this.propertyChangeListeners = new Map();
        this.target = new WeakRef(target);
        this.options = options;
        this.sourceProperties = getProperties(options.sourceProperty);
        this.targetOptions = this.resolveOptions(target, getProperties(options.targetProperty));
        if (!this.targetOptions) {
            throw new Error(`Invalid property: ${options.targetProperty} for target: ${target}`);
        }
        if (options.twoWay) {
            const target = this.targetOptions.instance.get();
            if (target instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                target.on(`${this.targetOptions.property}Change`, this.onTargetPropertyChanged, this);
            }
        }
    }
    onTargetPropertyChanged(data) {
        this.updateTwoWay(data.value);
    }
    loadedHandlerVisualTreeBinding(args) {
        let target = args.object;
        target.off('loaded', this.loadedHandlerVisualTreeBinding, this);
        const context = target.bindingContext;
        if (context !== undefined && context !== null) {
            this.update(context);
        }
    }
    clearSource() {
        this.propertyChangeListeners.forEach((observable, index, map) => {
            Object(_weak_event_listener__WEBPACK_IMPORTED_MODULE_2__[/* removeWeakEventListener */ "b"])(observable, _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"].propertyChangeEvent, this.onSourcePropertyChanged, this);
        });
        this.propertyChangeListeners.clear();
        if (this.source) {
            this.source.clear();
        }
        if (this.sourceOptions) {
            this.sourceOptions.instance.clear();
            this.sourceOptions = undefined;
        }
    }
    sourceAsObject(source) {
        /* tslint:disable */
        let objectType = typeof source;
        if (objectType === 'number') {
            source = new Number(source);
        }
        else if (objectType === 'boolean') {
            source = new Boolean(source);
        }
        else if (objectType === 'string') {
            source = new String(source);
        }
        /* tslint:enable */
        return source;
    }
    bindingContextChanged(data) {
        const target = this.targetOptions.instance.get();
        if (!target) {
            this.unbind();
            return;
        }
        const value = data.value;
        if (value !== null && value !== undefined) {
            this.update(value);
        }
        else {
            // TODO: Is this correct?
            // What should happen when bindingContext is null/undefined?
            this.clearBinding();
        }
        // TODO: if oneWay - call target.unbind();
    }
    bind(source) {
        const target = this.targetOptions.instance.get();
        if (this.sourceIsBindingContext && target instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"] && this.targetOptions.property !== 'bindingContext') {
            target.on('bindingContextChange', this.bindingContextChanged, this);
        }
        this.update(source);
    }
    update(source) {
        this.clearSource();
        source = this.sourceAsObject(source);
        if (!_utils_types__WEBPACK_IMPORTED_MODULE_6__[/* isNullOrUndefined */ "h"](source)) {
            // TODO: if oneWay - call target.unbind();
            this.source = new WeakRef(source);
            this.sourceOptions = this.resolveOptions(source, this.sourceProperties);
            let sourceValue = this.getSourcePropertyValue();
            this.updateTarget(sourceValue);
            this.addPropertyChangeListeners(this.source, this.sourceProperties);
        }
        else if (!this.sourceIsBindingContext) {
            // TODO: if oneWay - call target.unbind();
            let sourceValue = this.getSourcePropertyValue();
            this.updateTarget(sourceValue ? sourceValue : source);
        }
    }
    unbind() {
        const target = this.targetOptions.instance.get();
        if (target instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
            if (this.options.twoWay) {
                target.off(`${this.targetOptions.property}Change`, this.onTargetPropertyChanged, this);
            }
            if (this.sourceIsBindingContext && this.targetOptions.property !== 'bindingContext') {
                target.off('bindingContextChange', this.bindingContextChanged, this);
            }
        }
        if (this.targetOptions) {
            this.targetOptions = undefined;
        }
        this.sourceProperties = undefined;
        if (!this.source) {
            return;
        }
        this.clearSource();
    }
    // Consider returning single {} instead of array for performance.
    resolveObjectsAndProperties(source, properties) {
        let result = [];
        let currentObject = source;
        let currentObjectChanged = false;
        for (let i = 0, propsArrayLength = properties.length; i < propsArrayLength; i++) {
            let property = properties[i];
            if (property === bc.bindingValueKey) {
                currentObjectChanged = true;
            }
            if (property === bc.parentValueKey || property.indexOf(bc.parentsValueKey) === 0) {
                let parentView = this.getParentView(this.target.get(), property).view;
                if (parentView) {
                    currentObject = parentView.bindingContext;
                }
                else {
                    let targetInstance = this.target.get();
                    targetInstance.off('loaded', this.loadedHandlerVisualTreeBinding, this);
                    targetInstance.on('loaded', this.loadedHandlerVisualTreeBinding, this);
                }
                currentObjectChanged = true;
            }
            if (currentObject) {
                result.push({ instance: currentObject, property: property });
            }
            else {
                break;
            }
            // do not need to dive into last object property getter on binding stage will handle it
            if (!currentObjectChanged && i < propsArrayLength - 1) {
                currentObject = currentObject ? currentObject[properties[i]] : null;
            }
            currentObjectChanged = false;
        }
        return result;
    }
    addPropertyChangeListeners(source, sourceProperty, parentProperies) {
        let objectsAndProperties = this.resolveObjectsAndProperties(source.get(), sourceProperty);
        let prop = parentProperies || '';
        for (let i = 0, length = objectsAndProperties.length; i < length; i++) {
            const propName = objectsAndProperties[i].property;
            prop += '$' + propName;
            let currentObject = objectsAndProperties[i].instance;
            if (!this.propertyChangeListeners.has(prop) && currentObject instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"] && currentObject._isViewBase) {
                // Add listener for properties created with after 3.0 version
                Object(_weak_event_listener__WEBPACK_IMPORTED_MODULE_2__[/* addWeakEventListener */ "a"])(currentObject, `${propName}Change`, this.onSourcePropertyChanged, this);
                Object(_weak_event_listener__WEBPACK_IMPORTED_MODULE_2__[/* addWeakEventListener */ "a"])(currentObject, _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"].propertyChangeEvent, this.onSourcePropertyChanged, this);
                this.propertyChangeListeners.set(prop, currentObject);
            }
            else if (!this.propertyChangeListeners.has(prop) && currentObject instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                Object(_weak_event_listener__WEBPACK_IMPORTED_MODULE_2__[/* addWeakEventListener */ "a"])(currentObject, _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"].propertyChangeEvent, this.onSourcePropertyChanged, this);
                this.propertyChangeListeners.set(prop, currentObject);
            }
        }
    }
    prepareExpressionForUpdate() {
        // this regex is used to create a valid RegExp object from a string that has some special regex symbols like [,(,$ and so on.
        // Basically this method replaces all matches of 'source property' in expression with '$newPropertyValue'.
        // For example: with an expression similar to:
        // text="{{ sourceProperty = $parents['ListView'].test, expression = $parents['ListView'].test + 2}}"
        // update expression will be '$newPropertyValue + 2'
        // then on expression execution the new value will be taken and target property will be updated with the value of the expression.
        let escapedSourceProperty = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* escapeRegexSymbols */ "f"])(this.options.sourceProperty);
        let expRegex = new RegExp(escapedSourceProperty, 'g');
        let resultExp = this.options.expression.replace(expRegex, bc.newPropertyValueKey);
        return resultExp;
    }
    updateTwoWay(value) {
        if (this.updating || !this.options.twoWay) {
            return;
        }
        let newValue = value;
        if (this.options.expression) {
            let changedModel = {};
            changedModel[bc.bindingValueKey] = value;
            changedModel[bc.newPropertyValueKey] = value;
            let sourcePropertyName = '';
            if (this.sourceOptions) {
                sourcePropertyName = this.sourceOptions.property;
            }
            else if (typeof this.options.sourceProperty === 'string' && this.options.sourceProperty.indexOf('.') === -1) {
                sourcePropertyName = this.options.sourceProperty;
            }
            if (sourcePropertyName !== '') {
                changedModel[sourcePropertyName] = value;
            }
            let updateExpression = this.prepareExpressionForUpdate();
            this.prepareContextForExpression(changedModel, updateExpression, undefined);
            let expressionValue = this._getExpressionValue(updateExpression, true, changedModel);
            if (expressionValue instanceof Error) {
                _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(expressionValue.message, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Binding, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            }
            newValue = expressionValue;
        }
        this.updateSource(newValue);
    }
    _getExpressionValue(expression, isBackConvert, changedModel) {
        try {
            let exp = _js_libs_polymer_expressions__WEBPACK_IMPORTED_MODULE_8__["PolymerExpressions"].getExpression(expression);
            if (exp) {
                let context = (this.source && this.source.get && this.source.get()) || global;
                let model = {};
                let addedProps = [];
                const resources = _bindable_resources__WEBPACK_IMPORTED_MODULE_7__[/* get */ "a"]();
                for (let prop in resources) {
                    if (resources.hasOwnProperty(prop) && !context.hasOwnProperty(prop)) {
                        context[prop] = resources[prop];
                        addedProps.push(prop);
                    }
                }
                this.prepareContextForExpression(context, expression, addedProps);
                model[contextKey] = context;
                let result = exp.getValue(model, isBackConvert, changedModel ? changedModel : model);
                // clear added props
                let addedPropsLength = addedProps.length;
                for (let i = 0; i < addedPropsLength; i++) {
                    delete context[addedProps[i]];
                }
                addedProps.length = 0;
                return result;
            }
            return new Error(expression + ' is not a valid expression.');
        }
        catch (e) {
            let errorMessage = 'Run-time error occured in file: ' + e.sourceURL + ' at line: ' + e.line + ' and column: ' + e.column;
            return new Error(errorMessage);
        }
    }
    onSourcePropertyChanged(data) {
        const sourceProps = this.sourceProperties;
        const sourcePropsLength = sourceProps.length;
        let changedPropertyIndex = sourceProps.indexOf(data.propertyName);
        let parentProps = '';
        if (changedPropertyIndex > -1) {
            parentProps = '$' + sourceProps.slice(0, changedPropertyIndex + 1).join('$');
            while (this.propertyChangeListeners.get(parentProps) !== data.object) {
                changedPropertyIndex += sourceProps.slice(changedPropertyIndex + 1).indexOf(data.propertyName) + 1;
                parentProps = '$' + sourceProps.slice(0, changedPropertyIndex + 1).join('$');
            }
        }
        if (this.options.expression) {
            const expressionValue = this._getExpressionValue(this.options.expression, false, undefined);
            if (expressionValue instanceof Error) {
                _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(expressionValue.message, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Binding, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            }
            else {
                this.updateTarget(expressionValue);
            }
        }
        else {
            if (changedPropertyIndex > -1) {
                const props = sourceProps.slice(changedPropertyIndex + 1);
                const propsLength = props.length;
                if (propsLength > 0) {
                    let value = data.value;
                    for (let i = 0; i < propsLength; i++) {
                        value = value[props[i]];
                    }
                    this.updateTarget(value);
                }
                else if (data.propertyName === this.sourceOptions.property) {
                    this.updateTarget(data.value);
                }
            }
        }
        // we need to do this only if nested objects are used as source and some middle object has changed.
        if (changedPropertyIndex > -1 && changedPropertyIndex < sourcePropsLength - 1) {
            const probablyChangedObject = this.propertyChangeListeners.get(parentProps);
            if (probablyChangedObject && probablyChangedObject !== data.object[sourceProps[changedPropertyIndex]]) {
                // remove all weakevent listeners after change, because changed object replaces object that is hooked for
                // propertyChange event
                for (let i = sourcePropsLength - 1; i > changedPropertyIndex; i--) {
                    const prop = '$' + sourceProps.slice(0, i + 1).join('$');
                    if (this.propertyChangeListeners.has(prop)) {
                        Object(_weak_event_listener__WEBPACK_IMPORTED_MODULE_2__[/* removeWeakEventListener */ "b"])(this.propertyChangeListeners.get(prop), _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"].propertyChangeEvent, this.onSourcePropertyChanged, this);
                        this.propertyChangeListeners.delete(prop);
                    }
                }
                const newProps = sourceProps.slice(changedPropertyIndex + 1);
                // add new weak event listeners
                const newObject = data.object[sourceProps[changedPropertyIndex]];
                if (!_utils_types__WEBPACK_IMPORTED_MODULE_6__[/* isNullOrUndefined */ "h"](newObject) && typeof newObject === 'object') {
                    this.addPropertyChangeListeners(new WeakRef(newObject), newProps, parentProps);
                }
            }
        }
    }
    prepareContextForExpression(model, expression, newProps) {
        let parentViewAndIndex;
        let parentView;
        let addedProps = newProps || [];
        let expressionCP = expression;
        if (expressionCP.indexOf(bc.bindingValueKey) > -1) {
            model[bc.bindingValueKey] = model;
            addedProps.push(bc.bindingValueKey);
        }
        let success = true;
        let parentsArray = expressionCP.match(_builder_binding_builder__WEBPACK_IMPORTED_MODULE_3__[/* parentsRegex */ "c"]);
        if (parentsArray) {
            for (let i = 0; i < parentsArray.length; i++) {
                // This prevents later checks to mistake $parents[] for $parent
                expressionCP = expressionCP.replace(parentsArray[i], '');
                parentViewAndIndex = this.getParentView(this.target.get(), parentsArray[i]);
                if (parentViewAndIndex.view) {
                    model[bc.parentsValueKey] = model[bc.parentsValueKey] || {};
                    model[bc.parentsValueKey][parentViewAndIndex.index] = parentViewAndIndex.view.bindingContext;
                    addedProps.push(bc.parentsValueKey);
                }
                else {
                    success = false;
                }
            }
        }
        if (expressionCP.indexOf(bc.parentValueKey) > -1) {
            parentView = this.getParentView(this.target.get(), bc.parentValueKey).view;
            if (parentView) {
                model[bc.parentValueKey] = parentView.bindingContext;
                addedProps.push(bc.parentValueKey);
            }
            else {
                success = false;
            }
        }
        // For expressions, there are also cases when binding must be updated after component is loaded (e.g. ListView)
        if (!success) {
            let targetInstance = this.target.get();
            targetInstance.off('loaded', this.loadedHandlerVisualTreeBinding, this);
            targetInstance.on('loaded', this.loadedHandlerVisualTreeBinding, this);
        }
    }
    getSourcePropertyValue() {
        if (this.options.expression) {
            let changedModel = {};
            changedModel[bc.bindingValueKey] = this.source ? this.source.get() : undefined;
            let expressionValue = this._getExpressionValue(this.options.expression, false, changedModel);
            if (expressionValue instanceof Error) {
                _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write(expressionValue.message, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Binding, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            }
            else {
                return expressionValue;
            }
        }
        if (this.sourceOptions) {
            let sourceOptionsInstance = this.sourceOptions.instance.get();
            if (this.sourceOptions.property === bc.bindingValueKey) {
                return sourceOptionsInstance;
            }
            else if (sourceOptionsInstance instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"] && this.sourceOptions.property && this.sourceOptions.property !== '') {
                return sourceOptionsInstance.get(this.sourceOptions.property);
            }
            else if (sourceOptionsInstance && this.sourceOptions.property && this.sourceOptions.property !== '' && this.sourceOptions.property in sourceOptionsInstance) {
                return sourceOptionsInstance[this.sourceOptions.property];
            }
            else {
                _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write("Property: '" + this.sourceOptions.property + "' is invalid or does not exist. SourceProperty: '" + this.options.sourceProperty + "'", _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Binding, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
            }
        }
        return null;
    }
    clearBinding() {
        this.clearSource();
        this.updateTarget(_properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"]);
    }
    updateTarget(value) {
        if (this.updating) {
            return;
        }
        this.updateOptions(this.targetOptions, _utils_types__WEBPACK_IMPORTED_MODULE_6__[/* isNullOrUndefined */ "h"](value) ? _properties__WEBPACK_IMPORTED_MODULE_0__["unsetValue"] : value);
    }
    updateSource(value) {
        if (this.updating || !this.source || !this.source.get()) {
            return;
        }
        this.updateOptions(this.sourceOptions, value);
    }
    getParentView(target, property) {
        if (!target) {
            return { view: null, index: null };
        }
        let result;
        if (property === bc.parentValueKey) {
            result = target.parent;
        }
        let index = null;
        if (property.indexOf(bc.parentsValueKey) === 0) {
            result = target.parent;
            let indexParams = paramsRegex.exec(property);
            if (indexParams && indexParams.length > 1) {
                index = indexParams[2];
            }
            if (!isNaN(index)) {
                let indexAsInt = parseInt(index);
                while (indexAsInt > 0) {
                    result = result.parent;
                    indexAsInt--;
                }
            }
            else if (_utils_types__WEBPACK_IMPORTED_MODULE_6__[/* isString */ "k"](index)) {
                while (result && result.typeName !== index) {
                    result = result.parent;
                }
            }
        }
        return { view: result, index: index };
    }
    resolveOptions(obj, properties) {
        let objectsAndProperties = this.resolveObjectsAndProperties(obj, properties);
        if (objectsAndProperties.length > 0) {
            let resolvedObj = objectsAndProperties[objectsAndProperties.length - 1].instance;
            let prop = objectsAndProperties[objectsAndProperties.length - 1].property;
            return {
                instance: new WeakRef(this.sourceAsObject(resolvedObj)),
                property: prop,
            };
        }
        return null;
    }
    updateOptions(options, value) {
        let optionsInstance;
        if (options && options.instance) {
            optionsInstance = options.instance.get();
        }
        if (!optionsInstance) {
            return;
        }
        this.updating = true;
        try {
            if (isEventOrGesture(options.property, optionsInstance) && _utils_types__WEBPACK_IMPORTED_MODULE_6__[/* isFunction */ "g"](value)) {
                // calling off method with null as handler will remove all handlers for options.property event
                optionsInstance.off(options.property, null, optionsInstance.bindingContext);
                optionsInstance.on(options.property, value, optionsInstance.bindingContext);
            }
            else if (optionsInstance instanceof _data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                optionsInstance.set(options.property, value);
            }
            else {
                optionsInstance[options.property] = value;
            }
        }
        catch (ex) {
            _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].write('Binding error while setting property ' + options.property + ' of ' + optionsInstance + ': ' + ex, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].categories.Binding, _trace__WEBPACK_IMPORTED_MODULE_5__[/* Trace */ "a"].messageType.error);
        }
        this.updating = false;
    }
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContentView; });
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);


/**
 * Represents a View that has a single child - content.
 * The View itself does not have visual representation and serves as a placeholder for its content in the logical tree.
 */
class ContentView extends _core_view__WEBPACK_IMPORTED_MODULE_0__[/* CustomLayoutView */ "b"] {
    /**
     * Gets or sets the single child of the view.
     */
    get content() {
        return this._content;
    }
    set content(value) {
        let oldView = this._content;
        if (this._content) {
            this._removeView(this._content);
        }
        this._content = value;
        if (this._content) {
            this._addView(this._content);
        }
        this._onContentChanged(oldView, value);
        if ( true && oldView !== value) {
            this.requestLayout();
        }
    }
    get layoutView() {
        let result;
        if (this._content) {
            let first = true;
            this._content._eachLayoutView((child) => {
                if (first) {
                    first = false;
                    result = child;
                }
                else {
                    throw new Error('More than one layout child inside a ContentView');
                }
            });
        }
        return result;
    }
    get _childrenCount() {
        return this._content ? 1 : 0;
    }
    //@private
    /**
     * Called when the content property has changed.
     * @private
     * @param oldView The previous content.
     * @param newView The new content.
     */
    _onContentChanged(oldView, newView) {
        //
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof _core_view__WEBPACK_IMPORTED_MODULE_0__[/* View */ "c"]) {
            this.content = value;
        }
    }
    eachChildView(callback) {
        const content = this._content;
        if (content) {
            callback(content);
        }
    }
    // This method won't be called in Android because we use the native android layout.
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const result = _core_view__WEBPACK_IMPORTED_MODULE_0__[/* View */ "c"].measureChild(this, this.layoutView, widthMeasureSpec, heightMeasureSpec);
        const width = _utils__WEBPACK_IMPORTED_MODULE_1__[/* layout */ "n"].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = _utils__WEBPACK_IMPORTED_MODULE_1__[/* layout */ "n"].getMeasureSpecMode(widthMeasureSpec);
        const height = _utils__WEBPACK_IMPORTED_MODULE_1__[/* layout */ "n"].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = _utils__WEBPACK_IMPORTED_MODULE_1__[/* layout */ "n"].getMeasureSpecMode(heightMeasureSpec);
        const measureWidth = Math.max(result.measuredWidth, this.effectiveMinWidth);
        const measureHeight = Math.max(result.measuredHeight, this.effectiveMinHeight);
        const widthAndState = _core_view__WEBPACK_IMPORTED_MODULE_0__[/* View */ "c"].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = _core_view__WEBPACK_IMPORTED_MODULE_0__[/* View */ "c"].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    // This method won't be called in Android because we use the native android layout.
    onLayout(left, top, right, bottom) {
        _core_view__WEBPACK_IMPORTED_MODULE_0__[/* View */ "c"].layoutChild(this, this.layoutView, 0, 0, right - left, bottom - top);
    }
}
ContentView.prototype.recycleNativeView = 'auto';
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "TextDecoder", function() { return /* reexport */ TextDecoder; });
__webpack_require__.d(__webpack_exports__, "TextEncoder", function() { return /* reexport */ TextEncoder; });
__webpack_require__.d(__webpack_exports__, "encoding", function() { return /* binding */ encoding; });

// CONCATENATED MODULE: ../node_modules/@nativescript/core/text/text-common.js
const Object_prototype_toString = {}.toString;
const ArrayBufferString = Object_prototype_toString.call(ArrayBuffer.prototype);
function decoderReplacer(encoded) {
    var codePoint = encoded.charCodeAt(0) << 24;
    var leadingOnes = Math.clz32(~codePoint) | 0;
    var endPos = 0, stringLen = encoded.length | 0;
    var result = '';
    if (leadingOnes < 5 && stringLen >= leadingOnes) {
        codePoint = (codePoint << leadingOnes) >>> (24 + leadingOnes);
        for (endPos = 1; endPos < leadingOnes; endPos = (endPos + 1) | 0) {
            codePoint = (codePoint << 6) | (encoded.charCodeAt(endPos) & 0x3f) /*0b00111111*/;
        }
        if (codePoint <= 0xffff) {
            // BMP code point
            result += String.fromCharCode(codePoint);
        }
        else if (codePoint <= 0x10ffff) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint = (codePoint - 0x10000) | 0;
            result += String.fromCharCode(((codePoint >> 10) + 0xd800) | 0, // highSurrogate
            ((codePoint & 0x3ff) + 0xdc00) | 0 // lowSurrogate
            );
        }
        else {
            endPos = 0;
        } // to fill it in with INVALIDs
    }
    for (; endPos < stringLen; endPos = (endPos + 1) | 0) {
        result += '\ufffd';
    }
    return result;
}
function encoderReplacer(nonAsciiChars) {
    // make the UTF string into a binary UTF-8 encoded string
    var point = nonAsciiChars.charCodeAt(0) | 0;
    if (point >= 0xd800 && point <= 0xdbff) {
        var nextcode = nonAsciiChars.charCodeAt(1) | 0;
        if (nextcode !== nextcode) {
            // NaN because string is 1 code point long
            return String.fromCharCode(0xef /*11101111*/, 0xbf /*10111111*/, 0xbd /*10111101*/);
        }
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        if (nextcode >= 0xdc00 && nextcode <= 0xdfff) {
            point = (((point - 0xd800) << 10) + nextcode - 0xdc00 + 0x10000) | 0;
            if (point > 0xffff) {
                return String.fromCharCode((0x1e /*0b11110*/ << 3) | (point >>> 18), (0x2 /*0b10*/ << 6) | ((point >>> 12) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
            }
        }
        else {
            return String.fromCharCode(0xef, 0xbf, 0xbd);
        }
    }
    if (point <= 0x007f) {
        return nonAsciiChars;
    }
    else if (point <= 0x07ff) {
        return String.fromCharCode((0x6 << 5) | (point >>> 6), (0x2 << 6) | (point & 0x3f));
    }
    else {
        return String.fromCharCode((0xe /*0b1110*/ << 4) | (point >>> 12), (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
    }
}
class TextDecoder {
    constructor() {
        this[Symbol.toStringTag] = 'TextDecoder';
    }
    get encoding() {
        return 'utf-8';
    }
    decode(input) {
        const buffer = ArrayBuffer.isView(input) ? input.buffer : input;
        if (Object_prototype_toString.call(buffer) !== ArrayBufferString) {
            throw Error("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        let inputAs8 = new Uint8Array(buffer);
        let resultingString = '';
        for (let index = 0, len = inputAs8.length | 0; index < len; index = (index + 32768) | 0) {
            resultingString += String.fromCharCode.apply(0, inputAs8.slice(index, (index + 32768) | 0));
        }
        return resultingString.replace(/[\xc0-\xff][\x80-\xbf]*/g, decoderReplacer);
    }
    toString() {
        return '[object TextDecoder]';
    }
}
class TextEncoder {
    constructor() {
        this[Symbol.toStringTag] = 'TextEncoder';
    }
    get encoding() {
        return 'utf-8';
    }
    encode(input = '') {
        // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx
        // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx
        const encodedString = input === undefined ? '' : ('' + input).replace(/[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, encoderReplacer);
        const len = encodedString.length | 0, result = new Uint8Array(len);
        for (let i = 0; i < len; i = (i + 1) | 0) {
            result[i] = encodedString.charCodeAt(i);
        }
        return result;
    }
    toString() {
        return '[object TextEncoder]';
    }
}
//# sourceMappingURL=text-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/text/index.js

var encoding;
(function (encoding) {
    encoding.ISO_8859_1 = 5; //NSISOLatin1StringEncoding
    encoding.US_ASCII = 1; //NSASCIIStringEncoding
    encoding.UTF_16 = 10; //NSUnicodeStringEncoding
    encoding.UTF_16BE = 0x90000100; //NSUTF16BigEndianStringEncoding
    encoding.UTF_16LE = 0x94000100; //NSUTF16LittleEndianStringEncoding
    encoding.UTF_8 = 4; //NSUTF8StringEncoding
})(encoding || (encoding = {}));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var tokenizer = __webpack_require__(16);
var TYPE = tokenizer.TYPE;

var WhiteSpace = TYPE.WhiteSpace;
var Semicolon = TYPE.Semicolon;
var LeftCurlyBracket = TYPE.LeftCurlyBracket;
var Delim = TYPE.Delim;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function getOffsetExcludeWS() {
    if (this.scanner.tokenIndex > 0) {
        if (this.scanner.lookupType(-1) === WhiteSpace) {
            return this.scanner.tokenIndex > 1
                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
                : this.scanner.firstCharOffset;
        }
    }

    return this.scanner.tokenStart;
}

// 0, 0, false
function balanceEnd() {
    return 0;
}

// LEFTCURLYBRACKET, 0, false
function leftCurlyBracket(tokenType) {
    return tokenType === LeftCurlyBracket ? 1 : 0;
}

// LEFTCURLYBRACKET, SEMICOLON, false
function leftCurlyBracketOrSemicolon(tokenType) {
    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
}

// EXCLAMATIONMARK, SEMICOLON, false
function exclamationMarkOrSemicolon(tokenType, source, offset) {
    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
        return 1;
    }

    return tokenType === Semicolon ? 1 : 0;
}

// 0, SEMICOLON, true
function semicolonIncluded(tokenType) {
    return tokenType === Semicolon ? 2 : 0;
}

module.exports = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, mode, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(startToken, mode || balanceEnd)
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    },

    mode: {
        default: balanceEnd,
        leftCurlyBracket: leftCurlyBracket,
        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
        semicolonIncluded: semicolonIncluded
    }
};
; 
if (false ) {} 

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CacheMode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ios; });
/* harmony import */ var _linear_gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _image_source__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _css_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(106);
/* harmony import */ var _css_value__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_css_value__WEBPACK_IMPORTED_MODULE_4__);






const clearCGColor = UIColor.clearColor.CGColor;
const symbolUrl = Symbol('backgroundImageUrl');
var CacheMode;
(function (CacheMode) {
    CacheMode[CacheMode["none"] = 0] = "none";
})(CacheMode || (CacheMode = {}));
var ios;
(function (ios) {
    function createBackgroundUIColor(view, callback, flip) {
        const background = view.style.backgroundInternal;
        const nativeView = view.nativeViewProtected;
        if (nativeView.hasNonUniformBorder) {
            unsubscribeFromScrollNotifications(view);
            clearNonUniformBorders(nativeView);
        }
        clearGradient(nativeView);
        if (background.image instanceof _linear_gradient__WEBPACK_IMPORTED_MODULE_0__[/* LinearGradient */ "a"]) {
            drawGradient(nativeView, background.image);
        }
        const hasNonUniformBorderWidths = background.hasBorderWidth() && !background.hasUniformBorder();
        const hasNonUniformBorderRadiuses = background.hasBorderRadius() && !background.hasUniformBorderRadius();
        if (background.hasUniformBorderColor() && (hasNonUniformBorderWidths || hasNonUniformBorderRadiuses)) {
            drawUniformColorNonUniformBorders(nativeView, background);
            subscribeForScrollNotifications(view);
        }
        else if (background.hasUniformBorder()) {
            const layer = nativeView.layer;
            const borderColor = background.getUniformBorderColor();
            layer.borderColor = !borderColor ? undefined : borderColor.ios.CGColor;
            layer.borderWidth = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.getUniformBorderWidth());
            const renderSize = view.getActualSize() || { width: 0, height: 0 };
            const cornerRadius = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.getUniformBorderRadius());
            layer.cornerRadius = Math.min(Math.min(renderSize.width / 2, renderSize.height / 2), cornerRadius);
        }
        else {
            drawNoRadiusNonUniformBorders(nativeView, background);
            subscribeForScrollNotifications(view);
        }
        // Clip-path should be called after borders are applied.
        // It will eventually move them to different layer if uniform.
        if (background.clipPath) {
            drawClipPath(nativeView, background);
        }
        if (!background.image || background.image instanceof _linear_gradient__WEBPACK_IMPORTED_MODULE_0__[/* LinearGradient */ "a"]) {
            const uiColor = background.color ? background.color.ios : undefined;
            callback(uiColor);
        }
        else {
            setUIColorFromImage(view, nativeView, callback, flip);
        }
    }
    ios.createBackgroundUIColor = createBackgroundUIColor;
})(ios || (ios = {}));
function onScroll(args) {
    const view = args.object;
    const nativeView = view.nativeViewProtected;
    if (nativeView instanceof UIScrollView) {
        adjustLayersForScrollView(nativeView);
    }
}
function adjustLayersForScrollView(nativeView) {
    const layer = nativeView.borderLayer;
    if (layer instanceof CALayer) {
        // Compensates with transition for the background layers for scrolling in ScrollView based controls.
        CATransaction.begin();
        CATransaction.setValueForKey(kCFBooleanTrue, kCATransactionDisableActions);
        const offset = nativeView.contentOffset;
        const transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: offset.x,
            ty: offset.y,
        };
        layer.setAffineTransform(transform);
        if (nativeView.layer.mask) {
            nativeView.layer.mask.setAffineTransform(transform);
        }
        CATransaction.commit();
    }
}
function unsubscribeFromScrollNotifications(view) {
    if (view.nativeViewProtected instanceof UIScrollView) {
        view.off('scroll', onScroll);
    }
}
function subscribeForScrollNotifications(view) {
    if (view.nativeViewProtected instanceof UIScrollView) {
        view.on('scroll', onScroll);
        adjustLayersForScrollView(view.nativeViewProtected);
    }
}
function clearNonUniformBorders(nativeView) {
    if (nativeView.borderLayer) {
        nativeView.borderLayer.removeFromSuperlayer();
    }
    if (nativeView.hasBorderMask) {
        nativeView.layer.mask = nativeView.borderOriginalMask;
        nativeView.hasBorderMask = false;
        nativeView.borderOriginalMask = null;
    }
    if (nativeView.topBorderLayer) {
        nativeView.topBorderLayer.removeFromSuperlayer();
    }
    if (nativeView.rightBorderLayer) {
        nativeView.rightBorderLayer.removeFromSuperlayer();
    }
    if (nativeView.bottomBorderLayer) {
        nativeView.bottomBorderLayer.removeFromSuperlayer();
    }
    if (nativeView.leftBorderLayer) {
        nativeView.leftBorderLayer.removeFromSuperlayer();
    }
}
const pattern = /url\(('|")(.*?)\1\)/;
function setUIColorFromImage(view, nativeView, callback, flip) {
    const frame = nativeView.frame;
    const boundsWidth = view.scaleX ? frame.size.width / view.scaleX : frame.size.width;
    const boundsHeight = view.scaleY ? frame.size.height / view.scaleY : frame.size.height;
    if (!boundsWidth || !boundsHeight) {
        return undefined;
    }
    const style = view.style;
    const background = style.backgroundInternal;
    let imageUri = background.image;
    if (imageUri) {
        const match = imageUri.match(pattern);
        if (match && match[2]) {
            imageUri = match[2];
        }
    }
    let bitmap;
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[/* isDataURI */ "j"])(imageUri)) {
        const base64Data = imageUri.split(',')[1];
        if (base64Data !== undefined) {
            const imageSource = _image_source__WEBPACK_IMPORTED_MODULE_3__["ImageSource"].fromBase64Sync(base64Data);
            bitmap = imageSource && imageSource.ios;
        }
    }
    else if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[/* isFileOrResourcePath */ "k"])(imageUri)) {
        const imageSource = _image_source__WEBPACK_IMPORTED_MODULE_3__["ImageSource"].fromFileOrResourceSync(imageUri);
        bitmap = imageSource && imageSource.ios;
    }
    else if (imageUri.indexOf('http') !== -1) {
        style[symbolUrl] = imageUri;
        _image_source__WEBPACK_IMPORTED_MODULE_3__["ImageSource"].fromUrl(imageUri).then((r) => {
            if (style && style[symbolUrl] === imageUri) {
                uiColorFromImage(r.ios, view, callback, flip);
            }
        });
    }
    uiColorFromImage(bitmap, view, callback, flip);
}
function parsePosition(pos) {
    const values = Object(_css_value__WEBPACK_IMPORTED_MODULE_4__["parse"])(pos);
    if (values.length === 2) {
        return { x: values[0], y: values[1] };
    }
    if (values.length === 1) {
        const center = { type: 'ident', string: 'center' };
        if (values[0].type === 'ident') {
            const val = values[0].string.toLocaleLowerCase();
            // If you only one keyword is specified, the other value is "center"
            if (val === 'left' || val === 'right') {
                return { x: values[0], y: center };
            }
            else if (val === 'top' || val === 'bottom') {
                return { x: center, y: values[0] };
            }
            else if (val === 'center') {
                return { x: center, y: center };
            }
        }
        else if (values[0].type === 'number') {
            return { x: values[0], y: center };
        }
    }
    return null;
}
function getDrawParams(image, background, width, height) {
    if (!image) {
        return null;
    }
    const res = {
        repeatX: true,
        repeatY: true,
        posX: 0,
        posY: 0,
    };
    // repeat
    if (background.repeat) {
        switch (background.repeat.toLowerCase()) {
            case 'no-repeat':
                res.repeatX = false;
                res.repeatY = false;
                break;
            case 'repeat-x':
                res.repeatY = false;
                break;
            case 'repeat-y':
                res.repeatX = false;
                break;
        }
    }
    const imageSize = image.size;
    let imageWidth = imageSize.width;
    let imageHeight = imageSize.height;
    // size
    const size = background.size;
    if (size) {
        const values = Object(_css_value__WEBPACK_IMPORTED_MODULE_4__["parse"])(size);
        if (values.length === 2) {
            const vx = values[0];
            const vy = values[1];
            if (vx.unit === '%' && vy.unit === '%') {
                imageWidth = (width * vx.value) / 100;
                imageHeight = (height * vy.value) / 100;
                res.sizeX = imageWidth;
                res.sizeY = imageHeight;
            }
            else if (vx.type === 'number' && vy.type === 'number' && ((vx.unit === 'px' && vy.unit === 'px') || (vx.unit === '' && vy.unit === ''))) {
                imageWidth = vx.value;
                imageHeight = vy.value;
                res.sizeX = imageWidth;
                res.sizeY = imageHeight;
            }
        }
        else if (values.length === 1 && values[0].type === 'ident') {
            let scale = 0;
            if (values[0].string === 'cover') {
                scale = Math.max(width / imageWidth, height / imageHeight);
            }
            else if (values[0].string === 'contain') {
                scale = Math.min(width / imageWidth, height / imageHeight);
            }
            if (scale > 0) {
                imageWidth *= scale;
                imageHeight *= scale;
                res.sizeX = imageWidth;
                res.sizeY = imageHeight;
            }
        }
    }
    // position
    const position = background.position;
    if (position) {
        const v = parsePosition(position);
        if (v) {
            const spaceX = width - imageWidth;
            const spaceY = height - imageHeight;
            if (v.x.unit === '%' && v.y.unit === '%') {
                res.posX = (spaceX * v.x.value) / 100;
                res.posY = (spaceY * v.y.value) / 100;
            }
            else if (v.x.type === 'number' && v.y.type === 'number' && ((v.x.unit === 'px' && v.y.unit === 'px') || (v.x.unit === '' && v.y.unit === ''))) {
                res.posX = v.x.value;
                res.posY = v.y.value;
            }
            else if (v.x.type === 'ident' && v.y.type === 'ident') {
                if (v.x.string.toLowerCase() === 'center') {
                    res.posX = spaceX / 2;
                }
                else if (v.x.string.toLowerCase() === 'right') {
                    res.posX = spaceX;
                }
                if (v.y.string.toLowerCase() === 'center') {
                    res.posY = spaceY / 2;
                }
                else if (v.y.string.toLowerCase() === 'bottom') {
                    res.posY = spaceY;
                }
            }
            else if (v.x.type === 'number' && v.y.type === 'ident') {
                if (v.x.unit === '%') {
                    res.posX = (spaceX * v.x.value) / 100;
                }
                else if (v.x.unit === 'px' || v.x.unit === '') {
                    res.posX = v.x.value;
                }
                if (v.y.string.toLowerCase() === 'center') {
                    res.posY = spaceY / 2;
                }
                else if (v.y.string.toLowerCase() === 'bottom') {
                    res.posY = spaceY;
                }
            }
        }
    }
    return res;
}
function uiColorFromImage(img, view, callback, flip) {
    const background = view.style.backgroundInternal;
    if (!img) {
        callback(background.color && background.color.ios);
        return;
    }
    const nativeView = view.nativeViewProtected;
    const frame = nativeView.frame;
    const boundsWidth = view.scaleX ? frame.size.width / view.scaleX : frame.size.width;
    const boundsHeight = view.scaleY ? frame.size.height / view.scaleY : frame.size.height;
    const params = getDrawParams(img, background, boundsWidth, boundsHeight);
    if (params.sizeX > 0 && params.sizeY > 0) {
        const resizeRect = CGRectMake(0, 0, params.sizeX, params.sizeY);
        UIGraphicsBeginImageContextWithOptions(resizeRect.size, false, 0.0);
        img.drawInRect(resizeRect);
        img = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
    }
    UIGraphicsBeginImageContextWithOptions(CGSizeFromString(`{${boundsWidth},${boundsHeight}}`), false, 0.0);
    const context = UIGraphicsGetCurrentContext();
    if (background.color && background.color.ios) {
        CGContextSetFillColorWithColor(context, background.color.ios.CGColor);
        CGContextFillRect(context, CGRectMake(0, 0, boundsWidth, boundsHeight));
    }
    if (!params.repeatX && !params.repeatY) {
        img.drawAtPoint(CGPointMake(params.posX, params.posY));
    }
    else {
        const w = params.repeatX ? boundsWidth : img.size.width;
        const h = params.repeatY ? boundsHeight : img.size.height;
        CGContextSetPatternPhase(context, CGSizeMake(params.posX, params.posY));
        params.posX = params.repeatX ? 0 : params.posX;
        params.posY = params.repeatY ? 0 : params.posY;
        const patternRect = CGRectMake(params.posX, params.posY, w, h);
        img.drawAsPatternInRect(patternRect);
    }
    const bkgImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    if (flip) {
        const flippedImage = _flipImage(bkgImage);
        callback(UIColor.alloc().initWithPatternImage(flippedImage));
    }
    else {
        callback(UIColor.alloc().initWithPatternImage(bkgImage));
    }
}
// Flipping the default coordinate system
// https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html
function _flipImage(originalImage) {
    UIGraphicsBeginImageContextWithOptions(originalImage.size, false, 0.0);
    const context = UIGraphicsGetCurrentContext();
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 0.0, originalImage.size.height);
    CGContextScaleCTM(context, 1.0, -1.0);
    originalImage.drawInRect(CGRectMake(0, 0, originalImage.size.width, originalImage.size.height));
    CGContextRestoreGState(context);
    const flippedImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return flippedImage;
}
function cssValueToDeviceIndependentPixels(source, total) {
    source = source.trim();
    if (source.indexOf('px') !== -1) {
        return _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(parseFloat(source.replace('px', '')));
    }
    else if (source.indexOf('%') !== -1 && total > 0) {
        return (parseFloat(source.replace('%', '')) / 100) * total;
    }
    else {
        return parseFloat(source);
    }
}
function drawUniformColorNonUniformBorders(nativeView, background) {
    const layer = nativeView.layer;
    layer.backgroundColor = undefined;
    layer.borderColor = undefined;
    layer.borderWidth = 0;
    layer.cornerRadius = 0;
    const { width, height } = layer.bounds.size;
    const { x, y } = layer.bounds.origin;
    const left = x;
    const top = y;
    const right = x + width;
    const bottom = y + height;
    const { min, max } = Math;
    const borderTopWidth = max(0, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderTopWidth));
    const borderRightWidth = max(0, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderRightWidth));
    const borderBottomWidth = max(0, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderBottomWidth));
    const borderLeftWidth = max(0, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderLeftWidth));
    const borderVWidth = borderTopWidth + borderBottomWidth;
    const borderHWidth = borderLeftWidth + borderRightWidth;
    const cappedBorderTopWidth = borderTopWidth && borderTopWidth * min(1, height / borderVWidth);
    const cappedBorderRightWidth = borderRightWidth && borderRightWidth * min(1, width / borderHWidth);
    const cappedBorderBottomWidth = borderBottomWidth && borderBottomWidth * min(1, height / borderVWidth);
    const cappedBorderLeftWidth = borderLeftWidth && borderLeftWidth * min(1, width / borderHWidth);
    const outerTopLeftRadius = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderTopLeftRadius);
    const outerTopRightRadius = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderTopRightRadius);
    const outerBottomRightRadius = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderBottomRightRadius);
    const outerBottomLeftRadius = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderBottomLeftRadius);
    const topRadii = outerTopLeftRadius + outerTopRightRadius;
    const rightRadii = outerTopRightRadius + outerBottomRightRadius;
    const bottomRadii = outerBottomRightRadius + outerBottomLeftRadius;
    const leftRadii = outerBottomLeftRadius + outerTopLeftRadius;
    function capRadius(a, b, c) {
        return a && Math.min(a, Math.min(b, c));
    }
    const cappedOuterTopLeftRadius = capRadius(outerTopLeftRadius, (outerTopLeftRadius / topRadii) * width, (outerTopLeftRadius / leftRadii) * height);
    const cappedOuterTopRightRadius = capRadius(outerTopRightRadius, (outerTopRightRadius / topRadii) * width, (outerTopRightRadius / rightRadii) * height);
    const cappedOuterBottomRightRadius = capRadius(outerBottomRightRadius, (outerBottomRightRadius / bottomRadii) * width, (outerBottomRightRadius / rightRadii) * height);
    const cappedOuterBottomLeftRadius = capRadius(outerBottomLeftRadius, (outerBottomLeftRadius / bottomRadii) * width, (outerBottomLeftRadius / leftRadii) * height);
    // Outer contour
    const clipPath = CGPathCreateMutable();
    CGPathMoveToPoint(clipPath, null, left + cappedOuterTopLeftRadius, top);
    CGPathAddArcToPoint(clipPath, null, right, top, right, top + cappedOuterTopRightRadius, cappedOuterTopRightRadius);
    CGPathAddArcToPoint(clipPath, null, right, bottom, right - cappedOuterBottomRightRadius, bottom, cappedOuterBottomRightRadius);
    CGPathAddArcToPoint(clipPath, null, left, bottom, left, bottom - cappedOuterBottomLeftRadius, cappedOuterBottomLeftRadius);
    CGPathAddArcToPoint(clipPath, null, left, top, left + cappedOuterTopLeftRadius, top, cappedOuterTopLeftRadius);
    CGPathCloseSubpath(clipPath);
    nativeView.borderOriginalMask = layer.mask;
    const clipShapeLayer = CAShapeLayer.layer();
    clipShapeLayer.path = clipPath;
    layer.mask = clipShapeLayer;
    nativeView.hasBorderMask = true;
    if (cappedBorderLeftWidth > 0 || cappedBorderTopWidth > 0 || cappedBorderRightWidth > 0 || cappedBorderBottomWidth > 0) {
        const borderPath = CGPathCreateMutable();
        CGPathAddRect(borderPath, null, CGRectMake(left, top, width, height));
        // Inner contour
        if (cappedBorderTopWidth > 0 || cappedBorderLeftWidth > 0) {
            CGPathMoveToPoint(borderPath, null, left + cappedOuterTopLeftRadius, top + cappedBorderTopWidth);
        }
        else {
            CGPathMoveToPoint(borderPath, null, left, top);
        }
        if (cappedBorderTopWidth > 0 || cappedBorderRightWidth > 0) {
            const innerTopRightWRadius = max(0, cappedOuterTopRightRadius - cappedBorderRightWidth);
            const innerTopRightHRadius = max(0, cappedOuterTopRightRadius - cappedBorderTopWidth);
            const innerTopRightMaxRadius = max(innerTopRightWRadius, innerTopRightHRadius);
            const innerTopRightTransform = CGAffineTransformMake(innerTopRightMaxRadius && innerTopRightWRadius / innerTopRightMaxRadius, 0, 0, innerTopRightMaxRadius && innerTopRightHRadius / innerTopRightMaxRadius, right - cappedBorderRightWidth - innerTopRightWRadius, top + cappedBorderTopWidth + innerTopRightHRadius);
            CGPathAddArc(borderPath, innerTopRightTransform, 0, 0, innerTopRightMaxRadius, (Math.PI * 3) / 2, 0, false);
        }
        else {
            CGPathMoveToPoint(borderPath, null, right, top);
        }
        if (cappedBorderBottomWidth > 0 || cappedBorderRightWidth > 0) {
            const innerBottomRightWRadius = max(0, cappedOuterBottomRightRadius - cappedBorderRightWidth);
            const innerBottomRightHRadius = max(0, cappedOuterBottomRightRadius - cappedBorderBottomWidth);
            const innerBottomRightMaxRadius = max(innerBottomRightWRadius, innerBottomRightHRadius);
            const innerBottomRightTransform = CGAffineTransformMake(innerBottomRightMaxRadius && innerBottomRightWRadius / innerBottomRightMaxRadius, 0, 0, innerBottomRightMaxRadius && innerBottomRightHRadius / innerBottomRightMaxRadius, right - cappedBorderRightWidth - innerBottomRightWRadius, bottom - cappedBorderBottomWidth - innerBottomRightHRadius);
            CGPathAddArc(borderPath, innerBottomRightTransform, 0, 0, innerBottomRightMaxRadius, 0, Math.PI / 2, false);
        }
        else {
            CGPathAddLineToPoint(borderPath, null, right, bottom);
        }
        if (cappedBorderBottomWidth > 0 || cappedBorderLeftWidth > 0) {
            const innerBottomLeftWRadius = max(0, cappedOuterBottomLeftRadius - cappedBorderLeftWidth);
            const innerBottomLeftHRadius = max(0, cappedOuterBottomLeftRadius - cappedBorderBottomWidth);
            const innerBottomLeftMaxRadius = max(innerBottomLeftWRadius, innerBottomLeftHRadius);
            const innerBottomLeftTransform = CGAffineTransformMake(innerBottomLeftMaxRadius && innerBottomLeftWRadius / innerBottomLeftMaxRadius, 0, 0, innerBottomLeftMaxRadius && innerBottomLeftHRadius / innerBottomLeftMaxRadius, left + cappedBorderLeftWidth + innerBottomLeftWRadius, bottom - cappedBorderBottomWidth - innerBottomLeftHRadius);
            CGPathAddArc(borderPath, innerBottomLeftTransform, 0, 0, innerBottomLeftMaxRadius, Math.PI / 2, Math.PI, false);
        }
        else {
            CGPathAddLineToPoint(borderPath, null, left, bottom);
        }
        if (cappedBorderTopWidth > 0 || cappedBorderLeftWidth > 0) {
            const innerTopLeftWRadius = max(0, cappedOuterTopLeftRadius - cappedBorderLeftWidth);
            const innerTopLeftHRadius = max(0, cappedOuterTopLeftRadius - cappedBorderTopWidth);
            const innerTopLeftMaxRadius = max(innerTopLeftWRadius, innerTopLeftHRadius);
            const innerTopLeftTransform = CGAffineTransformMake(innerTopLeftMaxRadius && innerTopLeftWRadius / innerTopLeftMaxRadius, 0, 0, innerTopLeftMaxRadius && innerTopLeftHRadius / innerTopLeftMaxRadius, left + cappedBorderLeftWidth + innerTopLeftWRadius, top + cappedBorderTopWidth + innerTopLeftHRadius);
            CGPathAddArc(borderPath, innerTopLeftTransform, 0, 0, innerTopLeftMaxRadius, Math.PI, (Math.PI * 3) / 2, false);
        }
        else {
            CGPathAddLineToPoint(borderPath, null, left, top);
        }
        CGPathCloseSubpath(borderPath);
        const borderLayer = CAShapeLayer.layer();
        borderLayer.fillColor = (background.borderTopColor && background.borderTopColor.ios.CGColor) || UIColor.blackColor.CGColor;
        borderLayer.fillRule = kCAFillRuleEvenOdd;
        borderLayer.path = borderPath;
        layer.addSublayer(borderLayer);
        nativeView.borderLayer = borderLayer;
    }
    nativeView.hasNonUniformBorder = true;
}
function drawNoRadiusNonUniformBorders(nativeView, background) {
    const borderLayer = CALayer.layer();
    nativeView.layer.addSublayer(borderLayer);
    nativeView.borderLayer = borderLayer;
    borderLayer.borderColor = undefined;
    borderLayer.borderWidth = 0;
    borderLayer.cornerRadius = 0;
    const layerBounds = nativeView.layer.bounds;
    const layerOrigin = layerBounds.origin;
    const layerSize = layerBounds.size;
    const nativeViewLayerBounds = {
        left: layerOrigin.x,
        top: layerOrigin.y,
        bottom: layerSize.height,
        right: layerSize.width,
    };
    const top = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderTopWidth);
    const right = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderRightWidth);
    const bottom = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderBottomWidth);
    const left = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(background.borderLeftWidth);
    const lto = {
        x: nativeViewLayerBounds.left,
        y: nativeViewLayerBounds.top,
    }; // left-top-outside
    const lti = {
        x: nativeViewLayerBounds.left + left,
        y: nativeViewLayerBounds.top + top,
    }; // left-top-inside
    const rto = {
        x: nativeViewLayerBounds.right,
        y: nativeViewLayerBounds.top,
    }; // right-top-outside
    const rti = {
        x: nativeViewLayerBounds.right - right,
        y: nativeViewLayerBounds.top + top,
    }; // right-top-inside
    const rbo = {
        x: nativeViewLayerBounds.right,
        y: nativeViewLayerBounds.bottom,
    }; // right-bottom-outside
    const rbi = {
        x: nativeViewLayerBounds.right - right,
        y: nativeViewLayerBounds.bottom - bottom,
    }; // right-bottom-inside
    const lbo = {
        x: nativeViewLayerBounds.left,
        y: nativeViewLayerBounds.bottom,
    }; // left-bottom-outside
    const lbi = {
        x: nativeViewLayerBounds.left + left,
        y: nativeViewLayerBounds.bottom - bottom,
    }; // left-bottom-inside
    let hasNonUniformBorder;
    const borderTopColor = background.borderTopColor;
    if (top > 0 && borderTopColor && borderTopColor.ios) {
        const topBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(topBorderPath, null, lto.x, lto.y);
        CGPathAddLineToPoint(topBorderPath, null, rto.x, rto.y);
        CGPathAddLineToPoint(topBorderPath, null, rti.x, rti.y);
        CGPathAddLineToPoint(topBorderPath, null, lti.x, lti.y);
        CGPathAddLineToPoint(topBorderPath, null, lto.x, lto.y);
        const topBorderLayer = CAShapeLayer.layer();
        topBorderLayer.fillColor = background.borderTopColor.ios.CGColor;
        topBorderLayer.path = topBorderPath;
        borderLayer.addSublayer(topBorderLayer);
        nativeView.topBorderLayer = topBorderLayer;
        hasNonUniformBorder = true;
    }
    const borderRightColor = background.borderRightColor;
    if (right > 0 && borderRightColor && borderRightColor.ios) {
        const rightBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(rightBorderPath, null, rto.x, rto.y);
        CGPathAddLineToPoint(rightBorderPath, null, rbo.x, rbo.y);
        CGPathAddLineToPoint(rightBorderPath, null, rbi.x, rbi.y);
        CGPathAddLineToPoint(rightBorderPath, null, rti.x, rti.y);
        CGPathAddLineToPoint(rightBorderPath, null, rto.x, rto.y);
        const rightBorderLayer = CAShapeLayer.layer();
        rightBorderLayer.fillColor = background.borderRightColor.ios.CGColor;
        rightBorderLayer.path = rightBorderPath;
        borderLayer.addSublayer(rightBorderLayer);
        nativeView.rightBorderLayer = rightBorderLayer;
        hasNonUniformBorder = true;
    }
    const borderBottomColor = background.borderBottomColor;
    if (bottom > 0 && borderBottomColor && borderBottomColor.ios) {
        const bottomBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(bottomBorderPath, null, rbo.x, rbo.y);
        CGPathAddLineToPoint(bottomBorderPath, null, lbo.x, lbo.y);
        CGPathAddLineToPoint(bottomBorderPath, null, lbi.x, lbi.y);
        CGPathAddLineToPoint(bottomBorderPath, null, rbi.x, rbi.y);
        CGPathAddLineToPoint(bottomBorderPath, null, rbo.x, rbo.y);
        const bottomBorderLayer = CAShapeLayer.layer();
        bottomBorderLayer.fillColor = background.borderBottomColor.ios.CGColor;
        bottomBorderLayer.path = bottomBorderPath;
        borderLayer.addSublayer(bottomBorderLayer);
        nativeView.bottomBorderLayer = bottomBorderLayer;
        hasNonUniformBorder = true;
    }
    const borderLeftColor = background.borderLeftColor;
    if (left > 0 && borderLeftColor && borderLeftColor.ios) {
        const leftBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(leftBorderPath, null, lbo.x, lbo.y);
        CGPathAddLineToPoint(leftBorderPath, null, lto.x, lto.y);
        CGPathAddLineToPoint(leftBorderPath, null, lti.x, lti.y);
        CGPathAddLineToPoint(leftBorderPath, null, lbi.x, lbi.y);
        CGPathAddLineToPoint(leftBorderPath, null, lbo.x, lbo.y);
        const leftBorderLayer = CAShapeLayer.layer();
        leftBorderLayer.fillColor = background.borderLeftColor.ios.CGColor;
        leftBorderLayer.path = leftBorderPath;
        borderLayer.addSublayer(leftBorderLayer);
        nativeView.leftBorderLayer = leftBorderLayer;
        hasNonUniformBorder = true;
    }
    nativeView.hasNonUniformBorder = hasNonUniformBorder;
}
function drawGradient(nativeView, gradient) {
    const gradientLayer = CAGradientLayer.layer();
    gradientLayer.frame = nativeView.bounds;
    nativeView.gradientLayer = gradientLayer;
    const iosColors = NSMutableArray.alloc().initWithCapacity(gradient.colorStops.length);
    const iosStops = NSMutableArray.alloc().initWithCapacity(gradient.colorStops.length);
    let hasStops = false;
    gradient.colorStops.forEach((stop) => {
        iosColors.addObject(stop.color.ios.CGColor);
        if (stop.offset) {
            iosStops.addObject(stop.offset.value);
            hasStops = true;
        }
    });
    gradientLayer.colors = iosColors;
    if (hasStops) {
        gradientLayer.locations = iosStops;
    }
    const alpha = gradient.angle / (Math.PI * 2);
    const startX = Math.pow(Math.sin(Math.PI * (alpha + 0.75)), 2);
    const startY = Math.pow(Math.sin(Math.PI * (alpha + 0.5)), 2);
    const endX = Math.pow(Math.sin(Math.PI * (alpha + 0.25)), 2);
    const endY = Math.pow(Math.sin(Math.PI * alpha), 2);
    gradientLayer.startPoint = { x: startX, y: startY };
    gradientLayer.endPoint = { x: endX, y: endY };
    nativeView.layer.insertSublayerAtIndex(gradientLayer, 0);
}
function clearGradient(nativeView) {
    if (nativeView.gradientLayer) {
        nativeView.gradientLayer.removeFromSuperlayer();
    }
}
function drawClipPath(nativeView, background) {
    const layer = nativeView.layer;
    const layerBounds = layer.bounds;
    const layerOrigin = layerBounds.origin;
    const layerSize = layerBounds.size;
    const bounds = {
        left: layerOrigin.x,
        top: layerOrigin.y,
        bottom: layerSize.height,
        right: layerSize.width,
    };
    if (bounds.right === 0 || bounds.bottom === 0) {
        return;
    }
    let path;
    const clipPath = background.clipPath;
    const functionName = clipPath.substring(0, clipPath.indexOf('('));
    const value = clipPath.replace(`${functionName}(`, '').replace(')', '');
    switch (functionName) {
        case 'rect':
            path = rectPath(value, bounds);
            break;
        case 'inset':
            path = insetPath(value, bounds);
            break;
        case 'circle':
            path = circlePath(value, bounds);
            break;
        case 'ellipse':
            path = ellipsePath(value, bounds);
            break;
        case 'polygon':
            path = polygonPath(value, bounds);
            break;
    }
    if (path) {
        const shape = CAShapeLayer.layer();
        shape.path = path;
        layer.mask = shape;
        nativeView.clipsToBounds = true;
        const borderWidth = background.getUniformBorderWidth();
        const borderColor = background.getUniformBorderColor();
        if (borderWidth > 0 && borderColor instanceof _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"]) {
            const borderLayer = CAShapeLayer.layer();
            borderLayer.path = path;
            borderLayer.lineWidth = borderWidth * 2;
            borderLayer.strokeColor = borderColor.ios.CGColor;
            borderLayer.fillColor = clearCGColor;
            borderLayer.frame = nativeView.bounds;
            layer.borderColor = undefined;
            layer.borderWidth = 0;
            layer.addSublayer(borderLayer);
        }
    }
}
function rectPath(value, bounds) {
    const arr = value.split(/[\s]+/);
    const top = cssValueToDeviceIndependentPixels(arr[0], bounds.top);
    const right = cssValueToDeviceIndependentPixels(arr[1], bounds.right);
    const bottom = cssValueToDeviceIndependentPixels(arr[2], bounds.bottom);
    const left = cssValueToDeviceIndependentPixels(arr[3], bounds.left);
    return UIBezierPath.bezierPathWithRect(CGRectMake(left, top, right - left, bottom - top)).CGPath;
}
function insetPath(value, bounds) {
    const arr = value.split(/[\s]+/);
    let topString;
    let rightString;
    let bottomString;
    let leftString;
    if (arr.length === 1) {
        topString = rightString = bottomString = leftString = arr[0];
    }
    else if (arr.length === 2) {
        topString = bottomString = arr[0];
        rightString = leftString = arr[1];
    }
    else if (arr.length === 3) {
        topString = arr[0];
        rightString = leftString = arr[1];
        bottomString = arr[2];
    }
    else if (arr.length === 4) {
        topString = arr[0];
        rightString = arr[1];
        bottomString = arr[2];
        leftString = arr[3];
    }
    const top = cssValueToDeviceIndependentPixels(topString, bounds.bottom);
    const right = cssValueToDeviceIndependentPixels('100%', bounds.right) - cssValueToDeviceIndependentPixels(rightString, bounds.right);
    const bottom = cssValueToDeviceIndependentPixels('100%', bounds.bottom) - cssValueToDeviceIndependentPixels(bottomString, bounds.bottom);
    const left = cssValueToDeviceIndependentPixels(leftString, bounds.right);
    return UIBezierPath.bezierPathWithRect(CGRectMake(left, top, right - left, bottom - top)).CGPath;
}
function circlePath(value, bounds) {
    const arr = value.split(/[\s]+/);
    const radius = cssValueToDeviceIndependentPixels(arr[0], (bounds.right > bounds.bottom ? bounds.bottom : bounds.right) / 2);
    const y = cssValueToDeviceIndependentPixels(arr[2], bounds.bottom);
    const x = cssValueToDeviceIndependentPixels(arr[3], bounds.right);
    return UIBezierPath.bezierPathWithArcCenterRadiusStartAngleEndAngleClockwise(CGPointMake(x, y), radius, 0, 360, true).CGPath;
}
function ellipsePath(value, bounds) {
    const arr = value.split(/[\s]+/);
    const rX = cssValueToDeviceIndependentPixels(arr[0], bounds.right);
    const rY = cssValueToDeviceIndependentPixels(arr[1], bounds.bottom);
    const cX = cssValueToDeviceIndependentPixels(arr[3], bounds.right);
    const cY = cssValueToDeviceIndependentPixels(arr[4], bounds.bottom);
    const left = cX - rX;
    const top = cY - rY;
    const width = rX * 2;
    const height = rY * 2;
    return UIBezierPath.bezierPathWithOvalInRect(CGRectMake(left, top, width, height)).CGPath;
}
function polygonPath(value, bounds) {
    const path = CGPathCreateMutable();
    let firstPoint;
    const arr = value.split(/[,]+/);
    for (let i = 0; i < arr.length; i++) {
        const xy = arr[i].trim().split(/[\s]+/);
        const point = {
            x: cssValueToDeviceIndependentPixels(xy[0], bounds.right),
            y: cssValueToDeviceIndependentPixels(xy[1], bounds.bottom),
        };
        if (!firstPoint) {
            firstPoint = point;
            CGPathMoveToPoint(path, null, point.x, point.y);
        }
        CGPathAddLineToPoint(path, null, point.x, point.y);
    }
    CGPathAddLineToPoint(path, null, firstPoint.x, firstPoint.y);
    return path;
}
//# sourceMappingURL=background.ios.js.map; 
if (false ) {} 

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ActionItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return NavigationButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionBar; });
/* harmony import */ var _action_bar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _image_source__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4);







const majorVersion = _utils__WEBPACK_IMPORTED_MODULE_5__[/* iOSNativeHelper */ "a"].MajorVersion;
const UNSPECIFIED = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].makeMeasureSpec(0, _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].UNSPECIFIED);
function loadActionIcon(item) {
    let is = null;
    let img = null;
    const itemIcon = item.icon;
    const itemStyle = item.style;
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_6__[/* isFontIconURI */ "l"])(itemIcon)) {
        const fontIconCode = itemIcon.split('//')[1];
        const font = itemStyle.fontInternal;
        const color = itemStyle.color;
        is = _image_source__WEBPACK_IMPORTED_MODULE_4__["ImageSource"].fromFontIconCodeSync(fontIconCode, font, color);
    }
    else {
        is = _image_source__WEBPACK_IMPORTED_MODULE_4__["ImageSource"].fromFileOrResourceSync(itemIcon);
    }
    if (is && is.ios) {
        img = is.ios;
    }
    else {
        Object(_action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* traceMissingIcon */ "g"])(itemIcon);
    }
    return img;
}
var TapBarItemHandlerImpl = /** @class */ (function (_super) {
    __extends(TapBarItemHandlerImpl, _super);
    function TapBarItemHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TapBarItemHandlerImpl.initWithOwner = function (owner) {
        var handler = TapBarItemHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    TapBarItemHandlerImpl.prototype.tap = function (args) {
        var owner = this._owner.get();
        if (owner) {
            owner._raiseTap();
        }
    };
    TapBarItemHandlerImpl.ObjCExposedMethods = {
        tap: { returns: interop.types.void, params: [interop.types.id] },
    };
    return TapBarItemHandlerImpl;
}(NSObject));
class ActionItem extends _action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* ActionItemBase */ "b"] {
    constructor() {
        super(...arguments);
        this._ios = {
            position: 'left',
            systemIcon: undefined,
        };
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    set ios(value) {
        throw new Error('ActionItem.ios is read-only');
    }
}
class NavigationButton extends ActionItem {
    _onVisibilityChanged(visibility) {
        if (this._navigationItem) {
            const visible = visibility === 'visible';
            this._navigationItem.setHidesBackButtonAnimated(!visible, true);
        }
    }
}
class ActionBar extends _action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* ActionBarBase */ "a"] {
    get ios() {
        const page = this.page;
        if (!page || !page.parent) {
            return;
        }
        const viewController = page.ios;
        if (viewController.navigationController !== null) {
            return viewController.navigationController.navigationBar;
        }
        return null;
    }
    createNativeView() {
        return this.ios;
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof NavigationButton) {
            this.navigationButton = value;
        }
        else if (value instanceof ActionItem) {
            this.actionItems.addItem(value);
        }
        else if (value instanceof _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"]) {
            this.titleView = value;
        }
    }
    get _getActualSize() {
        const navBar = this.ios;
        if (!navBar) {
            return { width: 0, height: 0 };
        }
        const frame = navBar.frame;
        const size = frame.size;
        const width = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].toDevicePixels(size.width);
        const height = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].toDevicePixels(size.height);
        return { width, height };
    }
    layoutInternal() {
        const { width, height } = this._getActualSize;
        const widthSpec = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].makeMeasureSpec(width, _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].EXACTLY);
        const heightSpec = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].makeMeasureSpec(height, _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].EXACTLY);
        this.measure(widthSpec, heightSpec);
        this.layout(0, 0, width, height, false);
    }
    _getIconRenderingMode() {
        switch (this.iosIconRenderingMode) {
            case 'alwaysOriginal':
                return 1 /* AlwaysOriginal */;
            case 'alwaysTemplate':
                return 2 /* AlwaysTemplate */;
            case 'automatic':
            default:
                return 1 /* AlwaysOriginal */;
        }
    }
    update() {
        const page = this.page;
        // Page should be attached to frame to update the action bar.
        if (!page || !page.frame) {
            return;
        }
        const viewController = page.ios;
        const navigationItem = viewController.navigationItem;
        const navController = viewController.navigationController;
        if (!navController) {
            return;
        }
        const navigationBar = navController.navigationBar;
        let previousController;
        // Set Title
        navigationItem.title = this.title;
        const titleView = this.titleView;
        if (titleView && titleView.ios) {
            navigationItem.titleView = titleView.ios;
        }
        else {
            navigationItem.titleView = null;
        }
        // Find previous ViewController in the navigation stack
        const indexOfViewController = navController.viewControllers.indexOfObject(viewController);
        if (indexOfViewController > 0 && indexOfViewController < navController.viewControllers.count) {
            previousController = navController.viewControllers[indexOfViewController - 1];
        }
        // Set back button text
        if (previousController) {
            if (this.navigationButton) {
                let tapHandler = TapBarItemHandlerImpl.initWithOwner(new WeakRef(this.navigationButton));
                let barButtonItem = UIBarButtonItem.alloc().initWithTitleStyleTargetAction(this.navigationButton.text + '', 0 /* Plain */, tapHandler, 'tap');
                previousController.navigationItem.backBarButtonItem = barButtonItem;
            }
            else {
                previousController.navigationItem.backBarButtonItem = null;
            }
        }
        // Set back button image
        let img;
        if (this.navigationButton && Object(_action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* isVisible */ "f"])(this.navigationButton) && this.navigationButton.icon) {
            img = loadActionIcon(this.navigationButton);
        }
        // TODO: This could cause issue when canceling BackEdge gesture - we will change the backIndicator to
        // show the one from the old page but the new page will still be visible (because we canceled EdgeBackSwipe gesutre)
        // Consider moving this to new method and call it from - navigationControllerDidShowViewControllerAnimated.
        if (img) {
            let image = img.imageWithRenderingMode(1 /* AlwaysOriginal */);
            navigationBar.backIndicatorImage = image;
            navigationBar.backIndicatorTransitionMaskImage = image;
        }
        else {
            navigationBar.backIndicatorImage = null;
            navigationBar.backIndicatorTransitionMaskImage = null;
        }
        // Set back button visibility
        if (this.navigationButton) {
            this.navigationButton._navigationItem = navigationItem;
            navigationItem.setHidesBackButtonAnimated(!Object(_action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* isVisible */ "f"])(this.navigationButton), false);
        }
        // Populate action items
        this.populateMenuItems(navigationItem);
        // update colors explicitly - they may have to be cleared form a previous page
        this.updateColors(navigationBar);
        // the 'flat' property may have changed in between pages
        this.updateFlatness(navigationBar);
        if (!this.isLayoutValid) {
            this.layoutInternal();
        }
    }
    populateMenuItems(navigationItem) {
        const items = this.actionItems.getVisibleItems();
        const leftBarItems = NSMutableArray.new();
        const rightBarItems = NSMutableArray.new();
        for (let i = 0; i < items.length; i++) {
            const barButtonItem = this.createBarButtonItem(items[i]);
            if (items[i].ios.position === 'left') {
                leftBarItems.addObject(barButtonItem);
            }
            else {
                rightBarItems.insertObjectAtIndex(barButtonItem, 0);
            }
        }
        navigationItem.setLeftBarButtonItemsAnimated(leftBarItems, false);
        navigationItem.setRightBarButtonItemsAnimated(rightBarItems, false);
        if (leftBarItems.count > 0) {
            navigationItem.leftItemsSupplementBackButton = true;
        }
    }
    createBarButtonItem(item) {
        const tapHandler = TapBarItemHandlerImpl.initWithOwner(new WeakRef(item));
        // associate handler with menuItem or it will get collected by JSC.
        item.handler = tapHandler;
        let barButtonItem;
        if (item.actionView && item.actionView.ios) {
            let recognizer = UITapGestureRecognizer.alloc().initWithTargetAction(tapHandler, 'tap');
            item.actionView.ios.addGestureRecognizer(recognizer);
            barButtonItem = UIBarButtonItem.alloc().initWithCustomView(item.actionView.ios);
        }
        else if (item.ios.systemIcon !== undefined) {
            let id = item.ios.systemIcon;
            if (typeof id === 'string') {
                id = parseInt(id);
            }
            barButtonItem = UIBarButtonItem.alloc().initWithBarButtonSystemItemTargetAction(id, tapHandler, 'tap');
        }
        else if (item.icon) {
            const img = loadActionIcon(item);
            if (img) {
                const image = img.imageWithRenderingMode(this._getIconRenderingMode());
                barButtonItem = UIBarButtonItem.alloc().initWithImageStyleTargetAction(image, 0 /* Plain */, tapHandler, 'tap');
            }
        }
        else {
            barButtonItem = UIBarButtonItem.alloc().initWithTitleStyleTargetAction(item.text + '', 0 /* Plain */, tapHandler, 'tap');
        }
        if (item.text) {
            barButtonItem.isAccessibilityElement = true;
            barButtonItem.accessibilityLabel = item.text;
            barButtonItem.accessibilityTraits = UIAccessibilityTraitButton;
        }
        return barButtonItem;
    }
    updateColors(navBar) {
        const color = this.color;
        this.setColor(navBar, color);
        const bgColor = this.backgroundColor;
        navBar.barTintColor = bgColor ? bgColor.ios : null;
    }
    setColor(navBar, color) {
        if (color) {
            navBar.titleTextAttributes = {
                [NSForegroundColorAttributeName]: color.ios,
            };
            navBar.largeTitleTextAttributes = {
                [NSForegroundColorAttributeName]: color.ios,
            };
            navBar.tintColor = color.ios;
        }
        else {
            navBar.titleTextAttributes = null;
            navBar.largeTitleTextAttributes = null;
            navBar.tintColor = null;
        }
    }
    _onTitlePropertyChanged() {
        const page = this.page;
        if (!page) {
            return;
        }
        if (page.frame) {
            page.frame._updateActionBar();
        }
        let navigationItem = page.ios.navigationItem;
        navigationItem.title = this.title;
    }
    updateFlatness(navBar) {
        if (this.flat) {
            navBar.setBackgroundImageForBarMetrics(UIImage.new(), 0 /* Default */);
            navBar.shadowImage = UIImage.new();
            navBar.translucent = false;
        }
        else {
            navBar.setBackgroundImageForBarMetrics(null, null);
            navBar.shadowImage = null;
            navBar.translucent = true;
        }
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const width = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].getMeasureSpecSize(widthMeasureSpec);
        const height = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].getMeasureSpecSize(heightMeasureSpec);
        if (this.titleView) {
            _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].measureChild(this, this.titleView, UNSPECIFIED, UNSPECIFIED);
        }
        this.actionItems.getItems().forEach((actionItem) => {
            const actionView = actionItem.actionView;
            if (actionView) {
                _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].measureChild(this, actionView, UNSPECIFIED, UNSPECIFIED);
            }
        });
        // We ignore our width/height, minWidth/minHeight dimensions because it is against Apple policy to change height of NavigationBar.
        this.setMeasuredDimension(width, height);
    }
    onLayout(left, top, right, bottom) {
        const titleView = this.titleView;
        if (titleView) {
            if (majorVersion > 10) {
                // On iOS 11 titleView is wrapped in another view that is centered with constraints.
                _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].layoutChild(this, titleView, 0, 0, titleView.getMeasuredWidth(), titleView.getMeasuredHeight());
            }
            else {
                // On iOS <11 titleView is direct child of UINavigationBar so we give it full width and leave
                // the layout to center it.
                _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].layoutChild(this, titleView, 0, 0, right - left, bottom - top);
            }
        }
        this.actionItems.getItems().forEach((actionItem) => {
            const actionView = actionItem.actionView;
            if (actionView && actionView.ios) {
                const measuredWidth = actionView.getMeasuredWidth();
                const measuredHeight = actionView.getMeasuredHeight();
                _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].layoutChild(this, actionView, 0, 0, measuredWidth, measuredHeight);
            }
        });
        super.onLayout(left, top, right, bottom);
    }
    layoutNativeView(left, top, right, bottom) {
        return;
    }
    get navBar() {
        const page = this.page;
        // Page should be attached to frame to update the action bar.
        if (!page || !page.frame) {
            return undefined;
        }
        return page.frame.ios.controller.navigationBar;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["colorProperty"].getDefault]() {
        return null;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["colorProperty"].setNative](color) {
        const navBar = this.navBar;
        this.setColor(navBar, color);
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["backgroundColorProperty"].getDefault]() {
        // This getter is never called.
        // CssAnimationProperty use default value form their constructor.
        return null;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["backgroundColorProperty"].setNative](value) {
        let navBar = this.navBar;
        if (navBar) {
            let color = value instanceof _color__WEBPACK_IMPORTED_MODULE_2__[/* Color */ "a"] ? value.ios : value;
            navBar.barTintColor = color;
        }
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["backgroundInternalProperty"].setNative](value) {
        // tslint:disable-line
    }
    [_action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* flatProperty */ "d"].setNative](value) {
        // tslint:disable-line
        const navBar = this.navBar;
        if (navBar) {
            this.updateFlatness(navBar);
        }
    }
    [_action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* iosIconRenderingModeProperty */ "e"].getDefault]() {
        return 'alwaysOriginal';
    }
    [_action_bar_common__WEBPACK_IMPORTED_MODULE_0__[/* iosIconRenderingModeProperty */ "e"].setNative](value) {
        this.update();
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "StackLayoutBase", function() { return /* reexport */ stack_layout_common_StackLayoutBase; });
__webpack_require__.d(__webpack_exports__, "orientationProperty", function() { return /* reexport */ orientationProperty; });
__webpack_require__.d(__webpack_exports__, "StackLayout", function() { return /* binding */ stack_layout_StackLayout; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/layouts/layout-base.js + 1 modules
var layout_base = __webpack_require__(27);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-common.js
var view_common = __webpack_require__(31);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var properties = __webpack_require__(1);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/stack-layout/stack-layout-common.js



let stack_layout_common_StackLayoutBase = class StackLayoutBase extends layout_base["a" /* LayoutBase */] {
};
stack_layout_common_StackLayoutBase = __decorate([
    Object(view_common["a" /* CSSType */])('StackLayout')
], stack_layout_common_StackLayoutBase);

stack_layout_common_StackLayoutBase.prototype.recycleNativeView = 'auto';
const converter = Object(properties["makeParser"])(Object(properties["makeValidator"])('horizontal', 'vertical'));
const orientationProperty = new properties["Property"]({
    name: 'orientation',
    defaultValue: 'vertical',
    affectsLayout: true,
    valueConverter: converter,
});
orientationProperty.register(stack_layout_common_StackLayoutBase);
//# sourceMappingURL=stack-layout-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/index.js
var view = __webpack_require__(3);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style-properties.js + 2 modules
var style_properties = __webpack_require__(2);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/trace/index.js
var trace = __webpack_require__(0);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/stack-layout/index.js






class stack_layout_StackLayout extends stack_layout_common_StackLayoutBase {
    constructor() {
        super(...arguments);
        this._totalLength = 0;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        let measureWidth = 0;
        let measureHeight = 0;
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const isVertical = this.orientation === 'vertical';
        const horizontalPaddingsAndMargins = this.effectivePaddingLeft + this.effectivePaddingRight + this.effectiveBorderLeftWidth + this.effectiveBorderRightWidth;
        const verticalPaddingsAndMargins = this.effectivePaddingTop + this.effectivePaddingBottom + this.effectiveBorderTopWidth + this.effectiveBorderBottomWidth;
        let measureSpec;
        let mode = isVertical ? heightMode : widthMode;
        let remainingLength;
        if (mode === utils_common["n" /* layout */].UNSPECIFIED) {
            measureSpec = utils_common["n" /* layout */].UNSPECIFIED;
            remainingLength = 0;
        }
        else {
            measureSpec = utils_common["n" /* layout */].AT_MOST;
            remainingLength = isVertical ? height - verticalPaddingsAndMargins : width - horizontalPaddingsAndMargins;
        }
        let childMeasureSpec;
        if (isVertical) {
            let childWidth = widthMode === utils_common["n" /* layout */].UNSPECIFIED ? 0 : width - horizontalPaddingsAndMargins;
            childWidth = Math.max(0, childWidth);
            childMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(childWidth, widthMode);
        }
        else {
            let childHeight = heightMode === utils_common["n" /* layout */].UNSPECIFIED ? 0 : height - verticalPaddingsAndMargins;
            childHeight = Math.max(0, childHeight);
            childMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(childHeight, heightMode);
        }
        let childSize;
        this.eachLayoutChild((child, last) => {
            if (isVertical) {
                // Measuring ListView, with no height property set, with layout.AT_MOST will
                // result in total height equal to the count ot all items multiplied by DEFAULT_HEIGHT = 44 or the
                // maximum available space for the StackLayout. Any following controls will be visible only if enough space left.
                childSize = view["c" /* View */].measureChild(this, child, childMeasureSpec, utils_common["n" /* layout */].makeMeasureSpec(remainingLength, measureSpec));
                if (measureSpec === utils_common["n" /* layout */].AT_MOST && this.isUnsizedScrollableView(child)) {
                    trace["a" /* Trace */].write('Avoid using ListView or ScrollView with no explicit height set inside StackLayout. Doing so might result in poor user interface performance and poor user experience.', trace["a" /* Trace */].categories.Layout, trace["a" /* Trace */].messageType.warn);
                }
                measureWidth = Math.max(measureWidth, childSize.measuredWidth);
                let viewHeight = childSize.measuredHeight;
                measureHeight += viewHeight;
                remainingLength = Math.max(0, remainingLength - viewHeight);
            }
            else {
                childSize = view["c" /* View */].measureChild(this, child, utils_common["n" /* layout */].makeMeasureSpec(remainingLength, measureSpec), childMeasureSpec);
                measureHeight = Math.max(measureHeight, childSize.measuredHeight);
                let viewWidth = childSize.measuredWidth;
                measureWidth += viewWidth;
                remainingLength = Math.max(0, remainingLength - viewWidth);
            }
        });
        measureWidth += horizontalPaddingsAndMargins;
        measureHeight += verticalPaddingsAndMargins;
        // Check against our minimum sizes
        measureWidth = Math.max(measureWidth, this.effectiveMinWidth);
        measureHeight = Math.max(measureHeight, this.effectiveMinHeight);
        this._totalLength = isVertical ? measureHeight : measureWidth;
        const widthAndState = view["c" /* View */].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = view["c" /* View */].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        super.onLayout(left, top, right, bottom);
        const insets = this.getSafeAreaInsets();
        if (this.orientation === 'vertical') {
            this.layoutVertical(left, top, right, bottom, insets);
        }
        else {
            this.layoutHorizontal(left, top, right, bottom, insets);
        }
    }
    layoutVertical(left, top, right, bottom, insets) {
        const paddingLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
        const paddingTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
        const paddingRight = this.effectiveBorderRightWidth + this.effectivePaddingRight + insets.right;
        const paddingBottom = this.effectiveBorderBottomWidth + this.effectivePaddingBottom + insets.bottom;
        let childTop;
        let childLeft = paddingLeft;
        let childRight = right - left - paddingRight;
        switch (this.verticalAlignment) {
            case style_properties["VerticalAlignment"].MIDDLE:
                childTop = (bottom - top - this._totalLength) / 2 + paddingTop - paddingBottom;
                break;
            case style_properties["VerticalAlignment"].BOTTOM:
                childTop = bottom - top - this._totalLength + paddingTop - paddingBottom;
                break;
            case style_properties["VerticalAlignment"].TOP:
            case style_properties["VerticalAlignment"].STRETCH:
            default:
                childTop = paddingTop;
                break;
        }
        this.eachLayoutChild((child, last) => {
            const childHeight = child.getMeasuredHeight() + child.effectiveMarginTop + child.effectiveMarginBottom;
            view["c" /* View */].layoutChild(this, child, childLeft, childTop, childRight, childTop + childHeight);
            childTop += childHeight;
        });
    }
    layoutHorizontal(left, top, right, bottom, insets) {
        const paddingLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
        const paddingTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
        const paddingRight = this.effectiveBorderRightWidth + this.effectivePaddingRight + insets.right;
        const paddingBottom = this.effectiveBorderBottomWidth + this.effectivePaddingBottom + insets.bottom;
        let childTop = paddingTop;
        let childLeft;
        let childBottom = bottom - top - paddingBottom;
        switch (this.horizontalAlignment) {
            case style_properties["HorizontalAlignment"].CENTER:
                childLeft = (right - left - this._totalLength) / 2 + paddingLeft - paddingRight;
                break;
            case style_properties["HorizontalAlignment"].RIGHT:
                childLeft = right - left - this._totalLength + paddingLeft - paddingRight;
                break;
            case style_properties["HorizontalAlignment"].LEFT:
            case style_properties["HorizontalAlignment"].STRETCH:
            default:
                childLeft = paddingLeft;
                break;
        }
        this.eachLayoutChild((child, last) => {
            const childWidth = child.getMeasuredWidth() + child.effectiveMarginLeft + child.effectiveMarginRight;
            view["c" /* View */].layoutChild(this, child, childLeft, childTop, childLeft + childWidth, childBottom);
            childLeft += childWidth;
        });
    }
    isUnsizedScrollableView(child) {
        if (child.height === 'auto' && (child.ios instanceof UITableView || child.ios instanceof UIScrollView)) {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PageBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return actionBarHiddenProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return backgroundSpanUnderStatusBarProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return enableSwipeBackNavigationProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return statusBarStyleProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return androidStatusBarBackgroundProperty; });
/* harmony import */ var _content_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _core_view_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _styling_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _action_bar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(64);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);
var PageBase_1;









let PageBase = PageBase_1 = class PageBase extends _content_view__WEBPACK_IMPORTED_MODULE_0__[/* ContentView */ "a"] {
    get navigationContext() {
        return this._navigationContext;
    }
    get actionBar() {
        if (!this._actionBar) {
            this.hasActionBar = true;
            this._actionBar = new _action_bar__WEBPACK_IMPORTED_MODULE_7__[/* ActionBar */ "a"]();
            this._addView(this._actionBar);
        }
        return this._actionBar;
    }
    set actionBar(value) {
        if (!value) {
            throw new Error('ActionBar cannot be null or undefined.');
        }
        if (this._actionBar !== value) {
            if (this._actionBar) {
                this._removeView(this._actionBar);
            }
            this.hasActionBar = true;
            this._actionBar = value;
            this._addView(this._actionBar);
        }
    }
    get statusBarStyle() {
        return this.style.statusBarStyle;
    }
    set statusBarStyle(value) {
        this.style.statusBarStyle = value;
    }
    get androidStatusBarBackground() {
        return this.style.androidStatusBarBackground;
    }
    set androidStatusBarBackground(value) {
        this.style.androidStatusBarBackground = value;
    }
    get page() {
        return this;
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof _action_bar__WEBPACK_IMPORTED_MODULE_7__[/* ActionBar */ "a"]) {
            this.actionBar = value;
        }
        else {
            super._addChildFromBuilder(name, value);
        }
    }
    getKeyframeAnimationWithName(animationName) {
        return this._styleScope.getKeyframeAnimationWithName(animationName);
    }
    get frame() {
        const frame = this.parent;
        return frame instanceof _frame__WEBPACK_IMPORTED_MODULE_6__["Frame"] ? frame : undefined;
    }
    createNavigatedData(eventName, isBackNavigation) {
        return {
            eventName: eventName,
            object: this,
            context: this.navigationContext,
            isBackNavigation: isBackNavigation,
        };
    }
    onNavigatingTo(context, isBackNavigation, bindingContext) {
        this._navigationContext = context;
        if (isBackNavigation && this._styleScope) {
            this._styleScope.ensureSelectors();
            if (!this._cssState.isSelectorsLatestVersionApplied()) {
                this._onCssStateChange();
            }
        }
        //https://github.com/NativeScript/NativeScript/issues/731
        if (!isBackNavigation && bindingContext !== undefined && bindingContext !== null) {
            this.bindingContext = bindingContext;
        }
        this.notify(this.createNavigatedData(PageBase_1.navigatingToEvent, isBackNavigation));
    }
    onNavigatedTo(isBackNavigation) {
        this.notify(this.createNavigatedData(PageBase_1.navigatedToEvent, isBackNavigation));
    }
    onNavigatingFrom(isBackNavigation) {
        this.notify(this.createNavigatedData(PageBase_1.navigatingFromEvent, isBackNavigation));
    }
    onNavigatedFrom(isBackNavigation) {
        this.notify(this.createNavigatedData(PageBase_1.navigatedFromEvent, isBackNavigation));
        this._navigationContext = undefined;
    }
    eachChildView(callback) {
        super.eachChildView(callback);
        if (this.hasActionBar) {
            callback(this.actionBar);
        }
    }
    get _childrenCount() {
        return (this.content ? 1 : 0) + (this._actionBar ? 1 : 0);
    }
};
PageBase.navigatingToEvent = 'navigatingTo';
PageBase.navigatedToEvent = 'navigatedTo';
PageBase.navigatingFromEvent = 'navigatingFrom';
PageBase.navigatedFromEvent = 'navigatedFrom';
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Boolean, Object]),
    __metadata("design:returntype", void 0)
], PageBase.prototype, "onNavigatingTo", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], PageBase.prototype, "onNavigatedTo", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], PageBase.prototype, "onNavigatingFrom", null);
__decorate([
    _profiling__WEBPACK_IMPORTED_MODULE_8__[/* profile */ "f"],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], PageBase.prototype, "onNavigatedFrom", null);
PageBase = PageBase_1 = __decorate([
    Object(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* CSSType */ "a"])('Page')
], PageBase);

PageBase.prototype.recycleNativeView = 'never';
/**
 * Dependency property used to hide the Navigation Bar in iOS and the Action Bar in Android.
 */
const actionBarHiddenProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'actionBarHidden',
    affectsLayout: true,
    valueConverter: _core_view_base__WEBPACK_IMPORTED_MODULE_2__["booleanConverter"],
});
actionBarHiddenProperty.register(PageBase);
/**
 * Dependency property that specify if page background should span under status bar.
 */
const backgroundSpanUnderStatusBarProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'backgroundSpanUnderStatusBar',
    defaultValue: false,
    affectsLayout: true,
    valueConverter: _core_view_base__WEBPACK_IMPORTED_MODULE_2__["booleanConverter"],
});
backgroundSpanUnderStatusBarProperty.register(PageBase);
/**
 * Dependency property used to control if swipe back navigation in iOS is enabled.
 * This property is iOS specific. Default value: true
 */
const enableSwipeBackNavigationProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'enableSwipeBackNavigation',
    defaultValue: true,
    valueConverter: _core_view_base__WEBPACK_IMPORTED_MODULE_2__["booleanConverter"],
});
enableSwipeBackNavigationProperty.register(PageBase);
/**
 * Property backing statusBarStyle.
 */
const statusBarStyleProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["CssProperty"]({
    name: 'statusBarStyle',
    cssName: 'status-bar-style',
});
statusBarStyleProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_4__[/* Style */ "a"]);
/**
 * Property backing androidStatusBarBackground.
 */
const androidStatusBarBackgroundProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["CssProperty"]({
    name: 'androidStatusBarBackground',
    cssName: 'android-status-bar-background',
    equalityComparer: _color__WEBPACK_IMPORTED_MODULE_5__[/* Color */ "a"].equals,
    valueConverter: (v) => new _color__WEBPACK_IMPORTED_MODULE_5__[/* Color */ "a"](v),
});
androidStatusBarBackgroundProperty.register(_styling_style__WEBPACK_IMPORTED_MODULE_4__[/* Style */ "a"]);
//# sourceMappingURL=page-common.js.map; 
if (false ) {} 

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

//
//                              list
//                            ┌──────┐
//             ┌──────────────┼─head │
//             │              │ tail─┼──────────────┐
//             │              └──────┘              │
//             ▼                                    ▼
//            item        item        item        item
//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
//          │ data │    │ data │    │ data │    │ data │
//          └──────┘    └──────┘    └──────┘    └──────┘
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

var cursors = null;
var List = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List.createItem = createItem;
List.prototype.createItem = createItem;

List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List.prototype.toJSON = List.prototype.toArray;

List.prototype.isEmpty = function() {
    return this.head === null;
};

List.prototype.first = function() {
    return this.head && this.head.data;
};

List.prototype.last = function() {
    return this.tail && this.tail.data;
};

List.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEach = List.prototype.each;

List.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEachRight = List.prototype.eachRight;

List.prototype.reduce = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);
    var acc = initialValue;

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List.prototype.reduceRight = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);
    var acc = initialValue;

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List.prototype.map = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.filter = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
        }
        cursor = cursor.next;
    }

    return result;
};

List.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List.prototype.copy = function() {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List.prototype.append = function(item) {
    return this.insert(item);
};

List.prototype.appendData = function(data) {
    return this.insert(createItem(data));
};

List.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item);

        // insert to the ending of the list
        if (this.tail !== null) {
            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no tail, then it also has no head
            // in this case head points to new item
            this.head = item;
        }

        // tail always points to new item
        this.tail = item;
    }

    return this;
};

List.prototype.insertData = function(data, before) {
    return this.insert(createItem(data), before);
};

List.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List.prototype.push = function(data) {
    this.insert(createItem(data));
};

List.prototype.pop = function() {
    if (this.tail !== null) {
        return this.remove(this.tail);
    }
};

List.prototype.unshift = function(data) {
    this.prepend(createItem(data));
};

List.prototype.shift = function() {
    if (this.head !== null) {
        return this.remove(this.head);
    }
};

List.prototype.prependList = function(list) {
    return this.insertList(list, this.head);
};

List.prototype.appendList = function(list) {
    return this.insertList(list);
};

List.prototype.insertList = function(list, before) {
    // ignore empty lists
    if (list.head === null) {
        return this;
    }

    if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
    } else {
        this.updateCursors(this.tail, list.tail, null, list.head);

        // insert to end of the list
        if (this.tail !== null) {
            // if destination list has a tail, then it also has a head,
            // but head doesn't change

            // dest tail -> source head
            this.tail.next = list.head;

            // dest tail <- source head
            list.head.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = list.head;
        }

        // tail always start point to new item
        this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;

    return this;
};

List.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
};

module.exports = List;
; 
if (false ) {} 

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_resolveAnimationCurve", function() { return _resolveAnimationCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getTransformMismatchErrorMessage", function() { return _getTransformMismatchErrorMessage; });
/* harmony import */ var _animation_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _utils_native_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Properties", function() { return _animation_common__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubicBezierAnimationCurve", function() { return _animation_common__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationBase", function() { return _animation_common__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _keyframe_animation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyframeAnimation", function() { return _keyframe_animation__WEBPACK_IMPORTED_MODULE_5__["KeyframeAnimation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyframeAnimationInfo", function() { return _keyframe_animation__WEBPACK_IMPORTED_MODULE_5__["KeyframeAnimationInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyframeDeclaration", function() { return _keyframe_animation__WEBPACK_IMPORTED_MODULE_5__["KeyframeDeclaration"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyframeInfo", function() { return _keyframe_animation__WEBPACK_IMPORTED_MODULE_5__["KeyframeInfo"]; });

// Requires







let _transform = '_transform';
let _skip = '_skip';
let FLT_MAX = 340282346638528859811704183484516925440.0;
class AnimationInfo {
}
var AnimationDelegateImpl = /** @class */ (function (_super) {
    __extends(AnimationDelegateImpl, _super);
    function AnimationDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationDelegateImpl.initWithFinishedCallback = function (finishedCallback, propertyAnimation, valueSource) {
        var delegate = AnimationDelegateImpl.new();
        delegate._finishedCallback = finishedCallback;
        delegate._propertyAnimation = propertyAnimation;
        delegate._valueSource = valueSource;
        return delegate;
    };
    AnimationDelegateImpl.prototype.animationDidStart = function (anim) {
        var value = this._propertyAnimation.value;
        var setLocal = this._valueSource === 'animation';
        var targetStyle = this._propertyAnimation.target.style;
        this._propertyAnimation.target._suspendPresentationLayerUpdates();
        switch (this._propertyAnimation.property) {
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].backgroundColor:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["backgroundColorProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["backgroundColorProperty"].keyframe] = value;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].opacity:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["opacityProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["opacityProperty"].keyframe] = value;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].keyframe] = value.x;
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].keyframe] = value.y;
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].keyframe] = value.z;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].keyframe] = value.x;
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].keyframe] = value.y;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].height:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["heightProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["heightProperty"].keyframe] = value;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].width:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["widthProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["widthProperty"].keyframe] = value;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale:
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].keyframe] = value.x === 0 ? 0.001 : value.x;
                targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].keyframe] = value.y === 0 ? 0.001 : value.y;
                break;
            case _transform:
                if (value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate] !== undefined) {
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].keyframe] = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate].x;
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].keyframe] = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate].y;
                }
                if (value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate] !== undefined) {
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].keyframe] = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate].x;
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].keyframe] = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate].y;
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].keyframe] = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate].z;
                }
                if (value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale] !== undefined) {
                    var x = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale].x;
                    var y = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale].y;
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].keyframe] = x === 0 ? 0.001 : x;
                    targetStyle[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].keyframe] = y === 0 ? 0.001 : y;
                }
                break;
        }
        this._propertyAnimation.target._resumePresentationLayerUpdates();
    };
    AnimationDelegateImpl.prototype.animationDidStopFinished = function (anim, finished) {
        if (this._finishedCallback) {
            this._finishedCallback(!finished);
        }
        if (finished && this.nextAnimation) {
            this.nextAnimation();
        }
    };
    // The CAAnimationDelegate protocol has been introduced in the iOS 10 SDK
    AnimationDelegateImpl.ObjCProtocols = global.CAAnimationDelegate ? [global.CAAnimationDelegate] : [];
    return AnimationDelegateImpl;
}(NSObject));
function _resolveAnimationCurve(curve) {
    switch (curve) {
        case 'easeIn':
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseIn);
        case 'easeOut':
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseOut);
        case 'easeInOut':
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseInEaseOut);
        case 'linear':
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionLinear);
        case 'spring':
            return curve;
        case 'ease':
            return CAMediaTimingFunction.functionWithControlPoints(0.25, 0.1, 0.25, 1.0);
        default:
            if (curve instanceof CAMediaTimingFunction) {
                return curve;
            }
            else if (curve instanceof _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* CubicBezierAnimationCurve */ "b"]) {
                let animationCurve = curve;
                return CAMediaTimingFunction.functionWithControlPoints(animationCurve.x1, animationCurve.y1, animationCurve.x2, animationCurve.y2);
            }
            else {
                throw new Error(`Invalid animation curve: ${curve}`);
            }
    }
}
class Animation extends _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* AnimationBase */ "a"] {
    constructor(animationDefinitions, playSequentially) {
        super(animationDefinitions, playSequentially);
        this._valueSource = 'animation';
        if (animationDefinitions.length > 0 && animationDefinitions[0].valueSource !== undefined) {
            this._valueSource = animationDefinitions[0].valueSource;
        }
        if (!playSequentially) {
            if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Non-merged Property Animations: ' + this._propertyAnimations.length, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
            }
            this._mergedPropertyAnimations = Animation._mergeAffineTransformAnimations(this._propertyAnimations);
            if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Merged Property Animations: ' + this._mergedPropertyAnimations.length, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
            }
        }
        else {
            this._mergedPropertyAnimations = this._propertyAnimations;
        }
        let that = this;
        let animationFinishedCallback = (cancelled) => {
            if (that._playSequentially) {
                // This function will be called by the last animation when done or by another animation if the user cancels them halfway through.
                if (cancelled) {
                    that._rejectAnimationFinishedPromise();
                }
                else {
                    that._resolveAnimationFinishedPromise();
                }
            }
            else {
                // This callback will be called by each INDIVIDUAL animation when it finishes or is cancelled.
                if (cancelled) {
                    that._cancelledAnimations++;
                }
                else {
                    that._finishedAnimations++;
                }
                if (that._cancelledAnimations > 0 && that._cancelledAnimations + that._finishedAnimations === that._mergedPropertyAnimations.length) {
                    if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                        _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(that._cancelledAnimations + ' animations cancelled.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
                    }
                    that._rejectAnimationFinishedPromise();
                }
                else if (that._finishedAnimations === that._mergedPropertyAnimations.length) {
                    if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                        _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write(that._finishedAnimations + ' animations finished.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
                    }
                    that._resolveAnimationFinishedPromise();
                }
            }
        };
        this._iOSAnimationFunction = Animation._createiOSAnimationFunction(this._mergedPropertyAnimations, 0, this._playSequentially, this._valueSource, animationFinishedCallback);
    }
    play() {
        if (this.isPlaying) {
            return this._rejectAlreadyPlaying();
        }
        let animationFinishedPromise = super.play();
        this._finishedAnimations = 0;
        this._cancelledAnimations = 0;
        this._iOSAnimationFunction();
        return animationFinishedPromise;
    }
    cancel() {
        if (!this.isPlaying) {
            _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Animation is not currently playing.', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].messageType.warn);
            return;
        }
        let i = 0;
        let length = this._mergedPropertyAnimations.length;
        for (; i < length; i++) {
            let propertyAnimation = this._mergedPropertyAnimations[i];
            propertyAnimation.target.nativeViewProtected.layer.removeAllAnimations();
            if (propertyAnimation._propertyResetCallback) {
                propertyAnimation._propertyResetCallback(propertyAnimation._originalValue, this._valueSource);
            }
        }
    }
    _resolveAnimationCurve(curve) {
        return _resolveAnimationCurve(curve);
    }
    static _createiOSAnimationFunction(propertyAnimations, index, playSequentially, valueSource, finishedCallback) {
        return (cancelled) => {
            if (cancelled && finishedCallback) {
                if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                    _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Animation ' + (index - 1).toString() + ' was cancelled. Will skip the rest of animations and call finishedCallback(true).', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
                }
                finishedCallback(cancelled);
                return;
            }
            let animation = propertyAnimations[index];
            let args = Animation._getNativeAnimationArguments(animation, valueSource);
            if (animation.curve === 'spring') {
                Animation._createNativeSpringAnimation(propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback);
            }
            else {
                Animation._createNativeAnimation(propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback);
            }
        };
    }
    static _getNativeAnimationArguments(animation, valueSource) {
        const view = animation.target;
        const style = view.style;
        const nativeView = view.nativeViewProtected;
        const parent = view.parent;
        let propertyNameToAnimate = animation.property;
        let subPropertyNameToAnimate;
        let toValue = animation.value;
        let fromValue;
        let setLocal = valueSource === 'animation';
        switch (animation.property) {
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].backgroundColor:
                animation._originalValue = view.backgroundColor;
                animation._propertyResetCallback = (value, valueSource) => {
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["backgroundColorProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["backgroundColorProperty"].keyframe] = value;
                };
                fromValue = nativeView.layer.backgroundColor;
                if (nativeView instanceof UILabel) {
                    nativeView.setValueForKey(UIColor.clearColor, 'backgroundColor');
                }
                toValue = toValue.CGColor;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].opacity:
                animation._originalValue = view.opacity;
                animation._propertyResetCallback = (value, valueSource) => {
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["opacityProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["opacityProperty"].keyframe] = value;
                };
                fromValue = nativeView.layer.opacity;
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate:
                animation._originalValue = {
                    x: view.rotateX,
                    y: view.rotateY,
                    z: view.rotate,
                };
                animation._propertyResetCallback = (value, valueSource) => {
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].keyframe] = value.z;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].keyframe] = value.x;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].keyframe] = value.y;
                };
                propertyNameToAnimate = 'transform.rotation';
                subPropertyNameToAnimate = ['x', 'y', 'z'];
                fromValue = {
                    x: nativeView.layer.valueForKeyPath('transform.rotation.x'),
                    y: nativeView.layer.valueForKeyPath('transform.rotation.y'),
                    z: nativeView.layer.valueForKeyPath('transform.rotation.z'),
                };
                if (animation.target.rotateX !== undefined && animation.target.rotateX !== 0 && Math.floor(toValue / 360) - toValue / 360 === 0) {
                    fromValue.x = (animation.target.rotateX * Math.PI) / 180;
                }
                if (animation.target.rotateY !== undefined && animation.target.rotateY !== 0 && Math.floor(toValue / 360) - toValue / 360 === 0) {
                    fromValue.y = (animation.target.rotateY * Math.PI) / 180;
                }
                if (animation.target.rotate !== undefined && animation.target.rotate !== 0 && Math.floor(toValue / 360) - toValue / 360 === 0) {
                    fromValue.z = (animation.target.rotate * Math.PI) / 180;
                }
                // Respect only value.z for back-compat until 3D rotations are implemented
                toValue = {
                    x: (toValue.x * Math.PI) / 180,
                    y: (toValue.y * Math.PI) / 180,
                    z: (toValue.z * Math.PI) / 180,
                };
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate:
                animation._originalValue = {
                    x: view.translateX,
                    y: view.translateY,
                };
                animation._propertyResetCallback = (value, valueSource) => {
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].keyframe] = value.x;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].keyframe] = value.y;
                };
                propertyNameToAnimate = 'transform';
                fromValue = NSValue.valueWithCATransform3D(nativeView.layer.transform);
                toValue = NSValue.valueWithCATransform3D(CATransform3DTranslate(nativeView.layer.transform, toValue.x, toValue.y, 0));
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale:
                if (toValue.x === 0) {
                    toValue.x = 0.001;
                }
                if (toValue.y === 0) {
                    toValue.y = 0.001;
                }
                animation._originalValue = { x: view.scaleX, y: view.scaleY };
                animation._propertyResetCallback = (value, valueSource) => {
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].keyframe] = value.x;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].keyframe] = value.y;
                };
                propertyNameToAnimate = 'transform';
                fromValue = NSValue.valueWithCATransform3D(nativeView.layer.transform);
                toValue = NSValue.valueWithCATransform3D(CATransform3DScale(nativeView.layer.transform, toValue.x, toValue.y, 1));
                break;
            case _transform:
                fromValue = NSValue.valueWithCATransform3D(nativeView.layer.transform);
                animation._originalValue = {
                    xs: view.scaleX,
                    ys: view.scaleY,
                    xt: view.translateX,
                    yt: view.translateY,
                    rx: view.rotateX,
                    ry: view.rotateY,
                    rz: view.rotate,
                };
                animation._propertyResetCallback = (value, valueSource) => {
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateXProperty"].keyframe] = value.xt;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["translateYProperty"].keyframe] = value.yt;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleXProperty"].keyframe] = value.xs;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["scaleYProperty"].keyframe] = value.ys;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateXProperty"].keyframe] = value.rx;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateYProperty"].keyframe] = value.ry;
                    style[setLocal ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].name : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["rotateProperty"].keyframe] = value.rz;
                };
                propertyNameToAnimate = 'transform';
                toValue = NSValue.valueWithCATransform3D(Animation._createNativeAffineTransform(animation));
                break;
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].width:
            case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].height:
                const direction = animation.property;
                const isHeight = direction === 'height';
                propertyNameToAnimate = 'bounds';
                if (!parent) {
                    throw new Error(`cannot animate ${direction} on root view`);
                }
                const parentExtent = isHeight ? parent.getMeasuredHeight() : parent.getMeasuredWidth();
                const asNumber = _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["PercentLength"].toDevicePixels(_styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["PercentLength"].parse(toValue), parentExtent, parentExtent) / _platform__WEBPACK_IMPORTED_MODULE_4__["Screen"].mainScreen.scale;
                let currentBounds = nativeView.layer.bounds;
                let extentX = isHeight ? currentBounds.size.width : asNumber;
                let extentY = isHeight ? asNumber : currentBounds.size.height;
                fromValue = NSValue.valueWithCGRect(currentBounds);
                toValue = NSValue.valueWithCGRect(CGRectMake(currentBounds.origin.x, currentBounds.origin.y, extentX, extentY));
                animation._originalValue = view.height;
                animation._propertyResetCallback = (value, valueSource) => {
                    const prop = isHeight ? _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["heightProperty"] : _styling_style_properties__WEBPACK_IMPORTED_MODULE_2__["widthProperty"];
                    style[setLocal ? prop.name : prop.keyframe] = value;
                };
                break;
            default:
                throw new Error(`Animating property '${animation.property}' is unsupported`);
        }
        let duration = 0.3;
        if (animation.duration !== undefined) {
            duration = animation.duration / 1000.0;
        }
        let delay = undefined;
        if (animation.delay) {
            delay = animation.delay / 1000.0;
        }
        let repeatCount = undefined;
        if (animation.iterations !== undefined) {
            if (animation.iterations === Number.POSITIVE_INFINITY) {
                repeatCount = FLT_MAX;
            }
            else {
                repeatCount = animation.iterations;
            }
        }
        return {
            propertyNameToAnimate: propertyNameToAnimate,
            fromValue: fromValue,
            subPropertiesToAnimate: subPropertyNameToAnimate,
            toValue: toValue,
            duration: duration,
            repeatCount: repeatCount,
            delay: delay,
        };
    }
    static _createNativeAnimation(propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback) {
        let nativeView = animation.target.nativeViewProtected;
        let nativeAnimation;
        if (args.subPropertiesToAnimate) {
            nativeAnimation = this._createGroupAnimation(args, animation);
        }
        else {
            nativeAnimation = this._createBasicAnimation(args, animation);
        }
        let animationDelegate = AnimationDelegateImpl.initWithFinishedCallback(finishedCallback, animation, valueSource);
        nativeAnimation.setValueForKey(animationDelegate, 'delegate');
        nativeView.layer.addAnimationForKey(nativeAnimation, args.propertyNameToAnimate);
        let callback = undefined;
        if (index + 1 < propertyAnimations.length) {
            callback = Animation._createiOSAnimationFunction(propertyAnimations, index + 1, playSequentially, valueSource, finishedCallback);
            if (!playSequentially) {
                callback();
            }
            else {
                animationDelegate.nextAnimation = callback;
            }
        }
    }
    static _createGroupAnimation(args, animation) {
        let groupAnimation = CAAnimationGroup.new();
        groupAnimation.duration = args.duration;
        const animations = NSMutableArray.alloc().initWithCapacity(3);
        args.subPropertiesToAnimate.forEach((property) => {
            const basicAnimationArgs = Object.assign({}, args);
            basicAnimationArgs.propertyNameToAnimate = `${args.propertyNameToAnimate}.${property}`;
            basicAnimationArgs.fromValue = args.fromValue[property];
            basicAnimationArgs.toValue = args.toValue[property];
            const basicAnimation = this._createBasicAnimation(basicAnimationArgs, animation);
            animations.addObject(basicAnimation);
        });
        groupAnimation.animations = animations;
        return groupAnimation;
    }
    static _createBasicAnimation(args, animation) {
        let basicAnimation = CABasicAnimation.animationWithKeyPath(args.propertyNameToAnimate);
        basicAnimation.fromValue = args.fromValue;
        basicAnimation.toValue = args.toValue;
        basicAnimation.duration = args.duration;
        if (args.repeatCount !== undefined) {
            basicAnimation.repeatCount = args.repeatCount;
        }
        if (args.delay !== undefined) {
            basicAnimation.beginTime = CACurrentMediaTime() + args.delay;
        }
        if (animation.curve !== undefined) {
            basicAnimation.timingFunction = animation.curve;
        }
        return basicAnimation;
    }
    static _createNativeSpringAnimation(propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback) {
        let nativeView = animation.target.nativeViewProtected;
        let callback = undefined;
        let nextAnimation;
        if (index + 1 < propertyAnimations.length) {
            callback = Animation._createiOSAnimationFunction(propertyAnimations, index + 1, playSequentially, valueSource, finishedCallback);
            if (!playSequentially) {
                callback();
            }
            else {
                nextAnimation = callback;
            }
        }
        let delay = 0;
        if (args.delay) {
            delay = args.delay;
        }
        UIView.animateWithDurationDelayUsingSpringWithDampingInitialSpringVelocityOptionsAnimationsCompletion(args.duration, delay, 0.2, 0, 196608 /* CurveLinear */, () => {
            if (args.repeatCount !== undefined) {
                UIView.setAnimationRepeatCount(args.repeatCount);
            }
            switch (animation.property) {
                case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].backgroundColor:
                    animation.target.backgroundColor = args.toValue;
                    break;
                case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].opacity:
                    animation.target.opacity = args.toValue;
                    break;
                case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].height:
                case _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].width:
                    animation._originalValue = animation.target[animation.property];
                    nativeView.layer.setValueForKey(args.toValue, args.propertyNameToAnimate);
                    animation._propertyResetCallback = function (value) {
                        animation.target[animation.property] = value;
                    };
                    break;
                case _transform:
                    animation._originalValue = nativeView.layer.transform;
                    nativeView.layer.setValueForKey(args.toValue, args.propertyNameToAnimate);
                    animation._propertyResetCallback = function (value) {
                        nativeView.layer.transform = value;
                    };
                    break;
            }
        }, function (animationDidFinish) {
            if (animationDidFinish) {
                if (animation.property === _transform) {
                    if (animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate] !== undefined) {
                        animation.target.translateX = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate].x;
                        animation.target.translateY = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate].y;
                    }
                    if (animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate] !== undefined) {
                        animation.target.rotateX = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate].x;
                        animation.target.rotateY = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate].y;
                        animation.target.rotate = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].rotate].z;
                    }
                    if (animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale] !== undefined) {
                        animation.target.scaleX = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale].x;
                        animation.target.scaleY = animation.value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale].y;
                    }
                }
            }
            else {
                if (animation._propertyResetCallback) {
                    animation._propertyResetCallback(animation._originalValue);
                }
            }
            if (finishedCallback) {
                let cancelled = !animationDidFinish;
                finishedCallback(cancelled);
            }
            if (animationDidFinish && nextAnimation) {
                nextAnimation();
            }
        });
    }
    static _createNativeAffineTransform(animation) {
        let value = animation.value;
        let result = CATransform3DIdentity;
        if (value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate] !== undefined) {
            let x = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate].x;
            let y = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate].y;
            result = CATransform3DTranslate(result, x, y, 0);
        }
        if (value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale] !== undefined) {
            let x = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale].x;
            let y = value[_animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale].y;
            result = CATransform3DScale(result, x === 0 ? 0.001 : x, y === 0 ? 0.001 : y, 1);
        }
        return result;
    }
    static _isAffineTransform(property) {
        return property === _transform || property === _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].translate || property === _animation_common__WEBPACK_IMPORTED_MODULE_0__[/* Properties */ "c"].scale;
    }
    static _canBeMerged(animation1, animation2) {
        let result = Animation._isAffineTransform(animation1.property) && Animation._isAffineTransform(animation2.property) && animation1.target === animation2.target && animation1.duration === animation2.duration && animation1.delay === animation2.delay && animation1.iterations === animation2.iterations && animation1.curve === animation2.curve;
        return result;
    }
    static _mergeAffineTransformAnimations(propertyAnimations) {
        let result = new Array();
        let i = 0;
        let j;
        let length = propertyAnimations.length;
        for (; i < length; i++) {
            if (propertyAnimations[i][_skip]) {
                continue;
            }
            if (!Animation._isAffineTransform(propertyAnimations[i].property)) {
                // This is not an affine transform animation, so there is nothing to merge.
                result.push(propertyAnimations[i]);
            }
            else {
                // This animation has not been merged anywhere. Create a new transform animation.
                // The value becomes a JSON object combining all affine transforms together like this:
                // {
                //    translate: {x: 100, y: 100 },
                //    rotate: 90,
                //    scale: {x: 2, y: 2 }
                // }
                let newTransformAnimation = {
                    target: propertyAnimations[i].target,
                    property: _transform,
                    value: {},
                    duration: propertyAnimations[i].duration,
                    delay: propertyAnimations[i].delay,
                    iterations: propertyAnimations[i].iterations,
                    curve: propertyAnimations[i].curve,
                };
                if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                    _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Curve: ' + propertyAnimations[i].curve, _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
                }
                newTransformAnimation.value[propertyAnimations[i].property] = propertyAnimations[i].value;
                if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                    _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Created new transform animation: ' + Animation._getAnimationInfo(newTransformAnimation), _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
                }
                // Merge all compatible affine transform animations to the right into this new animation.
                j = i + 1;
                if (j < length) {
                    for (; j < length; j++) {
                        if (Animation._canBeMerged(propertyAnimations[i], propertyAnimations[j])) {
                            if (_trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].isEnabled()) {
                                _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].write('Merging animations: ' + Animation._getAnimationInfo(newTransformAnimation) + ' + ' + Animation._getAnimationInfo(propertyAnimations[j]) + ';', _trace__WEBPACK_IMPORTED_MODULE_1__[/* Trace */ "a"].categories.Animation);
                            }
                            newTransformAnimation.value[propertyAnimations[j].property] = propertyAnimations[j].value;
                            // Mark that it has been merged so we can skip it on our outer loop.
                            propertyAnimations[j][_skip] = true;
                        }
                    }
                }
                result.push(newTransformAnimation);
            }
        }
        return result;
    }
}
function _getTransformMismatchErrorMessage(view) {
    const expectedTransform = calculateTransform(view);
    const expectedTransformString = getCATransform3DString(expectedTransform);
    const actualTransformString = getCATransform3DString(view.nativeViewProtected.layer.transform);
    if (actualTransformString !== expectedTransformString) {
        return 'View and Native transforms do not match.\nActual: ' + actualTransformString + ';\nExpected: ' + expectedTransformString;
    }
    return undefined;
}
function calculateTransform(view) {
    const scaleX = view.scaleX || 1e-6;
    const scaleY = view.scaleY || 1e-6;
    const perspective = view.perspective || 300;
    // Order is important: translate, rotate, scale
    let expectedTransform = new CATransform3D(CATransform3DIdentity);
    // Only set perspective if there is 3D rotation
    if (view.rotateX || view.rotateY) {
        expectedTransform.m34 = -1 / perspective;
    }
    expectedTransform = CATransform3DTranslate(expectedTransform, view.translateX, view.translateY, 0);
    expectedTransform = _utils_native_helper__WEBPACK_IMPORTED_MODULE_3__[/* iOSNativeHelper */ "a"].applyRotateTransform(expectedTransform, view.rotateX, view.rotateY, view.rotate);
    expectedTransform = CATransform3DScale(expectedTransform, scaleX, scaleY, 1);
    return expectedTransform;
}
function getCATransform3DString(t) {
    return `[
    ${t.m11}, ${t.m12}, ${t.m13}, ${t.m14},
    ${t.m21}, ${t.m22}, ${t.m23}, ${t.m24},
    ${t.m31}, ${t.m32}, ${t.m33}, ${t.m34},
    ${t.m41}, ${t.m42}, ${t.m43}, ${t.m44}]`;
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observe", function() { return observe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GesturesObserver", function() { return GesturesObserver; });
/* harmony import */ var _gestures_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GestureTypes", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GestureStateTypes", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SwipeDirection", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TouchAction", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GesturesObserverBase", function() { return _gestures_common__WEBPACK_IMPORTED_MODULE_0__["c"]; });

// Definitions.
// Types.

// Import layout from utils directly to avoid circular references


function observe(target, type, callback, context) {
    const observer = new GesturesObserver(target, callback, context);
    observer.observe(type);
    return observer;
}
var UIGestureRecognizerDelegateImpl = /** @class */ (function (_super) {
    __extends(UIGestureRecognizerDelegateImpl, _super);
    function UIGestureRecognizerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIGestureRecognizerDelegateImpl.prototype.gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer = function (gestureRecognizer, otherGestureRecognizer) {
        return true;
    };
    UIGestureRecognizerDelegateImpl.prototype.gestureRecognizerShouldRequireFailureOfGestureRecognizer = function (gestureRecognizer, otherGestureRecognizer) {
        // If both gesture recognizers are of type UITapGestureRecognizer & one of them is a doubleTap,
        // we must require a failure.
        if (gestureRecognizer instanceof UITapGestureRecognizer && otherGestureRecognizer instanceof UITapGestureRecognizer && otherGestureRecognizer.numberOfTapsRequired === 2) {
            return true;
        }
        return false;
    };
    UIGestureRecognizerDelegateImpl.ObjCProtocols = [UIGestureRecognizerDelegate];
    return UIGestureRecognizerDelegateImpl;
}(NSObject));
let recognizerDelegateInstance = UIGestureRecognizerDelegateImpl.new();
var UIGestureRecognizerImpl = /** @class */ (function (_super) {
    __extends(UIGestureRecognizerImpl, _super);
    function UIGestureRecognizerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIGestureRecognizerImpl.initWithOwnerTypeCallback = function (owner, type, callback, thisArg) {
        var handler = UIGestureRecognizerImpl.new();
        handler._owner = owner;
        handler._type = type;
        if (callback) {
            handler._callback = callback;
        }
        if (thisArg) {
            handler._context = thisArg;
        }
        return handler;
    };
    UIGestureRecognizerImpl.prototype.recognize = function (recognizer) {
        var owner = this._owner.get();
        var callback = this._callback ? this._callback : owner ? owner.callback : null;
        var typeParam = this._type;
        var target = owner ? owner.target : undefined;
        var args = {
            type: typeParam,
            view: target,
            ios: recognizer,
            android: undefined,
            object: target,
            eventName: Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(typeParam),
        };
        if (callback) {
            callback.call(this._context, args);
        }
    };
    UIGestureRecognizerImpl.ObjCExposedMethods = {
        recognize: {
            returns: interop.types.void,
            params: [UIGestureRecognizer],
        },
    };
    return UIGestureRecognizerImpl;
}(NSObject));
class GesturesObserver extends _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GesturesObserverBase */ "c"] {
    constructor(target, callback, context) {
        super(target, callback, context);
        this._recognizers = {};
    }
    androidOnTouchEvent(motionEvent) {
        //
    }
    observe(type) {
        if (this.target) {
            this.type = type;
            this._onTargetLoaded = (args) => {
                this._attach(this.target, type);
            };
            this._onTargetUnloaded = (args) => {
                this._detach();
            };
            this.target.on('loaded', this._onTargetLoaded);
            this.target.on('unloaded', this._onTargetUnloaded);
            if (this.target.isLoaded) {
                this._attach(this.target, type);
            }
        }
    }
    _attach(target, type) {
        this._detach();
        if (target && target.nativeViewProtected && target.nativeViewProtected.addGestureRecognizer) {
            const nativeView = target.nativeViewProtected;
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].tap) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].tap, (args) => {
                    if (args.view) {
                        this._executeCallback(_getTapData(args));
                    }
                }));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].doubleTap) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].doubleTap, (args) => {
                    if (args.view) {
                        this._executeCallback(_getTapData(args));
                    }
                }));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].pinch) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].pinch, (args) => {
                    if (args.view) {
                        this._executeCallback(_getPinchData(args));
                    }
                }));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].pan) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].pan, (args) => {
                    if (args.view) {
                        this._executeCallback(_getPanData(args, target.nativeViewProtected));
                    }
                }));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe, (args) => {
                    if (args.view) {
                        this._executeCallback(_getSwipeData(args));
                    }
                }, 8 /* Down */));
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe, (args) => {
                    if (args.view) {
                        this._executeCallback(_getSwipeData(args));
                    }
                }, 2 /* Left */));
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe, (args) => {
                    if (args.view) {
                        this._executeCallback(_getSwipeData(args));
                    }
                }, 1 /* Right */));
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe, (args) => {
                    if (args.view) {
                        this._executeCallback(_getSwipeData(args));
                    }
                }, 4 /* Up */));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].rotation) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].rotation, (args) => {
                    if (args.view) {
                        this._executeCallback(_getRotationData(args));
                    }
                }));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].longPress) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].longPress, (args) => {
                    if (args.view) {
                        this._executeCallback(_getLongPressData(args));
                    }
                }));
            }
            if (type & _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].touch) {
                nativeView.addGestureRecognizer(this._createRecognizer(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].touch));
            }
        }
    }
    _detach() {
        if (this.target && this.target.nativeViewProtected) {
            for (let name in this._recognizers) {
                if (this._recognizers.hasOwnProperty(name)) {
                    let item = this._recognizers[name];
                    this.target.nativeViewProtected.removeGestureRecognizer(item.recognizer);
                    item.recognizer = null;
                    item.target = null;
                }
            }
            this._recognizers = {};
        }
    }
    disconnect() {
        this._detach();
        if (this.target) {
            this.target.off('loaded', this._onTargetLoaded);
            this.target.off('unloaded', this._onTargetUnloaded);
            this._onTargetLoaded = null;
            this._onTargetUnloaded = null;
        }
        // clears target, context and callback references
        super.disconnect();
    }
    _executeCallback(args) {
        if (this.callback) {
            this.callback.call(this.context, args);
        }
    }
    _createRecognizer(type, callback, swipeDirection) {
        let recognizer;
        let name = Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(type);
        const target = _createUIGestureRecognizerTarget(this, type, callback, this.context);
        const recognizerType = _getUIGestureRecognizerType(type);
        if (recognizerType) {
            recognizer = recognizerType.alloc().initWithTargetAction(target, 'recognize');
            if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe && swipeDirection) {
                name = name + swipeDirection.toString();
                recognizer.direction = swipeDirection;
            }
            else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].touch) {
                recognizer.observer = this;
            }
            else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].doubleTap) {
                recognizer.numberOfTapsRequired = 2;
            }
            if (recognizer) {
                recognizer.delegate = recognizerDelegateInstance;
                this._recognizers[name] = {
                    recognizer: recognizer,
                    target: target,
                };
            }
        }
        return recognizer;
    }
}
function _createUIGestureRecognizerTarget(owner, type, callback, context) {
    return UIGestureRecognizerImpl.initWithOwnerTypeCallback(new WeakRef(owner), type, callback, context);
}
function _getUIGestureRecognizerType(type) {
    let nativeType = null;
    if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].tap) {
        nativeType = UITapGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].doubleTap) {
        nativeType = UITapGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].pinch) {
        nativeType = UIPinchGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].pan) {
        nativeType = UIPanGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].swipe) {
        nativeType = UISwipeGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].rotation) {
        nativeType = UIRotationGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].longPress) {
        nativeType = UILongPressGestureRecognizer;
    }
    else if (type === _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].touch) {
        nativeType = TouchGestureRecognizer;
    }
    return nativeType;
}
function getState(recognizer) {
    if (recognizer.state === 1 /* Began */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureStateTypes */ "a"].began;
    }
    else if (recognizer.state === 4 /* Cancelled */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureStateTypes */ "a"].cancelled;
    }
    else if (recognizer.state === 2 /* Changed */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureStateTypes */ "a"].changed;
    }
    else if (recognizer.state === 3 /* Ended */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureStateTypes */ "a"].ended;
    }
}
function _getSwipeDirection(direction) {
    if (direction === 8 /* Down */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* SwipeDirection */ "d"].down;
    }
    else if (direction === 2 /* Left */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* SwipeDirection */ "d"].left;
    }
    else if (direction === 1 /* Right */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* SwipeDirection */ "d"].right;
    }
    else if (direction === 4 /* Up */) {
        return _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* SwipeDirection */ "d"].up;
    }
}
function _getTapData(args) {
    const recognizer = args.ios;
    const center = recognizer.locationInView(args.view.nativeViewProtected);
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        eventName: args.eventName,
        object: args.object,
        getPointerCount: () => recognizer.numberOfTouches,
        getX: () => _utils__WEBPACK_IMPORTED_MODULE_1__[/* layout */ "n"].toDeviceIndependentPixels(center.x),
        getY: () => _utils__WEBPACK_IMPORTED_MODULE_1__[/* layout */ "n"].toDeviceIndependentPixels(center.y),
    };
}
function _getPinchData(args) {
    const recognizer = args.ios;
    const center = recognizer.locationInView(args.view.nativeViewProtected);
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        scale: recognizer.scale,
        getFocusX: () => center.x,
        getFocusY: () => center.y,
        object: args.view,
        eventName: Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(args.type),
        state: getState(recognizer),
    };
}
function _getSwipeData(args) {
    const recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        direction: _getSwipeDirection(recognizer.direction),
        object: args.view,
        eventName: Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(args.type),
    };
}
function _getPanData(args, view) {
    const recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        deltaX: recognizer.translationInView(view).x,
        deltaY: recognizer.translationInView(view).y,
        object: args.view,
        eventName: Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(args.type),
        state: getState(recognizer),
    };
}
function _getRotationData(args) {
    const recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        rotation: recognizer.rotation * (180.0 / Math.PI),
        object: args.view,
        eventName: Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(args.type),
        state: getState(recognizer),
    };
}
function _getLongPressData(args) {
    const recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        object: args.view,
        eventName: Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(args.type),
        state: getState(recognizer),
    };
}
var TouchGestureRecognizer = /** @class */ (function (_super) {
    __extends(TouchGestureRecognizer, _super);
    function TouchGestureRecognizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TouchGestureRecognizer.prototype.touchesBeganWithEvent = function (touches, event) {
        this.executeCallback(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* TouchAction */ "e"].down, touches, event);
        if (this.view) {
            this.view.touchesBeganWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.touchesMovedWithEvent = function (touches, event) {
        this.executeCallback(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* TouchAction */ "e"].move, touches, event);
        if (this.view) {
            this.view.touchesMovedWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.touchesEndedWithEvent = function (touches, event) {
        this.executeCallback(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* TouchAction */ "e"].up, touches, event);
        if (this.view) {
            this.view.touchesEndedWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.touchesCancelledWithEvent = function (touches, event) {
        this.executeCallback(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* TouchAction */ "e"].cancel, touches, event);
        if (this.view) {
            this.view.touchesCancelledWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.executeCallback = function (action, touches, event) {
        if (!this._eventData) {
            this._eventData = new TouchGestureEventData();
        }
        this._eventData.prepare(this.observer.target, action, touches, event);
        this.observer._executeCallback(this._eventData);
    };
    return TouchGestureRecognizer;
}(UIGestureRecognizer));
class Pointer {
    constructor(touch, targetView) {
        this.android = undefined;
        this.ios = undefined;
        this.ios = touch;
        this._view = targetView;
    }
    get location() {
        if (!this._location) {
            this._location = this.ios.locationInView(this._view.nativeViewProtected);
        }
        return this._location;
    }
    getX() {
        return this.location.x;
    }
    getY() {
        return this.location.y;
    }
}
class TouchGestureEventData {
    constructor() {
        this.eventName = Object(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "g"])(_gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].touch);
        this.type = _gestures_common__WEBPACK_IMPORTED_MODULE_0__[/* GestureTypes */ "b"].touch;
        this.android = undefined;
    }
    prepare(view, action, touches, event) {
        this.action = action;
        this.view = view;
        this.object = view;
        this.ios = {
            touches: touches,
            event: event,
        };
        this._mainPointer = undefined;
        this._activePointers = undefined;
        this._allPointers = undefined;
    }
    getPointerCount() {
        return this.ios.event.allTouches.count;
    }
    getMainPointer() {
        if (this._mainPointer === undefined) {
            this._mainPointer = this.ios.touches.anyObject();
        }
        return this._mainPointer;
    }
    getActivePointers() {
        if (!this._activePointers) {
            this._activePointers = [];
            for (let i = 0, nsArr = this.ios.touches.allObjects; i < nsArr.count; i++) {
                this._activePointers.push(new Pointer(nsArr.objectAtIndex(i), this.view));
            }
        }
        return this._activePointers;
    }
    getAllPointers() {
        if (!this._allPointers) {
            this._allPointers = [];
            let nsArr = this.ios.event.allTouches.allObjects;
            for (let i = 0; i < nsArr.count; i++) {
                this._allPointers.push(new Pointer(nsArr.objectAtIndex(i), this.view));
            }
        }
        return this._allPointers;
    }
    getX() {
        return this.getMainPointer().locationInView(this.view.nativeViewProtected).x;
    }
    getY() {
        return this.getMainPointer().locationInView(this.view.nativeViewProtected).y;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Transition; });
let transitionId = 0;
class Transition {
    constructor(duration, curve = 0 /* EaseInOut */) {
        this._duration = duration ? duration / 1000 : 0.35;
        this._curve = curve;
        this._id = transitionId++;
    }
    getDuration() {
        return this._duration;
    }
    getCurve() {
        return this._curve;
    }
    animateIOSTransition(containerView, fromView, toView, operation, completion) {
        throw new Error('Abstract method call');
    }
    createAndroidAnimator(transitionType) {
        throw new Error('Abstract method call');
    }
    toString() {
        return `Transition@${this._id}`;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Span; });
/* harmony import */ var _core_view_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);


class Span extends _core_view_base__WEBPACK_IMPORTED_MODULE_0__["ViewBase"] {
    constructor() {
        super(...arguments);
        this._tappable = false;
    }
    get fontFamily() {
        return this.style.fontFamily;
    }
    set fontFamily(value) {
        this.style.fontFamily = value;
    }
    get fontSize() {
        return this.style.fontSize;
    }
    set fontSize(value) {
        this.style.fontSize = value;
    }
    // Italic
    get fontStyle() {
        return this.style.fontStyle;
    }
    set fontStyle(value) {
        this.style.fontStyle = value;
    }
    // Bold
    get fontWeight() {
        return this.style.fontWeight;
    }
    set fontWeight(value) {
        this.style.fontWeight = value;
    }
    get textDecoration() {
        return this.style.textDecoration;
    }
    set textDecoration(value) {
        this.style.textDecoration = value;
    }
    get color() {
        return this.style.color;
    }
    set color(value) {
        this.style.color = value;
    }
    get backgroundColor() {
        return this.style.backgroundColor;
    }
    set backgroundColor(value) {
        this.style.backgroundColor = value;
    }
    get text() {
        return this._text;
    }
    set text(value) {
        if (this._text !== value) {
            if (Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isNullOrUndefined */ "h"])(value)) {
                this._text = '';
            }
            else {
                // value can be a number
                this._text = Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"])(value) ? `${value}`.replace('\\n', '\n').replace('\\t', '\t') : `${value}`;
            }
            this.notifyPropertyChange('text', this._text);
        }
    }
    get tappable() {
        return this._tappable;
    }
    addEventListener(arg, callback, thisArg) {
        super.addEventListener(arg, callback, thisArg);
        this._setTappable(this.hasListeners(Span.linkTapEvent));
    }
    removeEventListener(arg, callback, thisArg) {
        super.removeEventListener(arg, callback, thisArg);
        this._setTappable(this.hasListeners(Span.linkTapEvent));
    }
    _setTextInternal(value) {
        this._text = value;
    }
    _setTappable(value) {
        if (this._tappable !== value) {
            this._tappable = value;
            this.notifyPropertyChange('tappable', value);
        }
    }
}
Span.linkTapEvent = 'linkTap';
//# sourceMappingURL=span.js.map; 
if (false ) {} 

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SelectorCore */
/* unused harmony export SimpleSelector */
/* unused harmony export InvalidSelector */
/* unused harmony export UniversalSelector */
/* unused harmony export IdSelector */
/* unused harmony export TypeSelector */
/* unused harmony export ClassSelector */
/* unused harmony export AttributeSelector */
/* unused harmony export PseudoClassSelector */
/* unused harmony export SimpleSelectorSequence */
/* unused harmony export Selector */
/* unused harmony export RuleSet */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return fromAstNodes; });
/* unused harmony export createSelector */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SelectorsMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SelectorsMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CSSHelper; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _css_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _css_parser__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_parser__WEBPACK_IMPORTED_MODULE_2__);



var Match;
(function (Match) {
    /**
     * Depends on attributes or pseudoclasses state;
     */
    Match.Dynamic = true;
    /**
     * Depends only on the tree structure.
     */
    Match.Static = false;
})(Match || (Match = {}));
function getNodeDirectSibling(node) {
    if (!node.parent || !node.parent.getChildIndex || !node.parent.getChildAt) {
        return null;
    }
    const nodeIndex = node.parent.getChildIndex(node);
    if (nodeIndex === 0) {
        return null;
    }
    return node.parent.getChildAt(nodeIndex - 1);
}
function SelectorProperties(specificity, rarity, dynamic = false) {
    return (cls) => {
        cls.prototype.specificity = specificity;
        cls.prototype.rarity = rarity;
        cls.prototype.combinator = undefined;
        cls.prototype.dynamic = dynamic;
        return cls;
    };
}
let SelectorCore = class SelectorCore {
    lookupSort(sorter, base) {
        sorter.sortAsUniversal(base || this);
    }
};
SelectorCore = __decorate([
    SelectorProperties(0 /* Universal */, 0 /* Universal */, Match.Static)
], SelectorCore);

class SimpleSelector extends SelectorCore {
    accumulateChanges(node, map) {
        if (!this.dynamic) {
            return this.match(node);
        }
        else if (this.mayMatch(node)) {
            this.trackChanges(node, map);
            return true;
        }
        return false;
    }
    mayMatch(node) {
        return this.match(node);
    }
    trackChanges(node, map) {
        // No-op, silence the tslint 'block is empty'.
        // Some derived classes (dynamic) will actually fill the map with stuff here, some (static) won't do anything.
    }
}
function wrap(text) {
    return text ? ` ${text} ` : '';
}
let InvalidSelector = class InvalidSelector extends SimpleSelector {
    constructor(e) {
        super();
        this.e = e;
    }
    toString() {
        return `<error: ${this.e}>`;
    }
    match(node) {
        return false;
    }
    lookupSort(sorter, base) {
        // No-op, silence the tslint 'block is empty'.
        // It feels like tslint has problems with simple polymorphism...
        // This selector is invalid and will never match so we won't bother sorting it to further appear in queries.
    }
};
InvalidSelector = __decorate([
    SelectorProperties(0 /* Invalid */, 4 /* Invalid */, Match.Static),
    __metadata("design:paramtypes", [Error])
], InvalidSelector);

let UniversalSelector = class UniversalSelector extends SimpleSelector {
    toString() {
        return `*${wrap(this.combinator)}`;
    }
    match(node) {
        return true;
    }
};
UniversalSelector = __decorate([
    SelectorProperties(0 /* Universal */, 0 /* Universal */, Match.Static)
], UniversalSelector);

let IdSelector = class IdSelector extends SimpleSelector {
    constructor(id) {
        super();
        this.id = id;
    }
    toString() {
        return `#${this.id}${wrap(this.combinator)}`;
    }
    match(node) {
        return node.id === this.id;
    }
    lookupSort(sorter, base) {
        sorter.sortById(this.id, base || this);
    }
};
IdSelector = __decorate([
    SelectorProperties(100 /* Id */, 3 /* Id */, Match.Static),
    __metadata("design:paramtypes", [String])
], IdSelector);

let TypeSelector = class TypeSelector extends SimpleSelector {
    constructor(cssType) {
        super();
        this.cssType = cssType;
    }
    toString() {
        return `${this.cssType}${wrap(this.combinator)}`;
    }
    match(node) {
        return node.cssType === this.cssType;
    }
    lookupSort(sorter, base) {
        sorter.sortByType(this.cssType, base || this);
    }
};
TypeSelector = __decorate([
    SelectorProperties(1 /* Type */, 1 /* Type */, Match.Static),
    __metadata("design:paramtypes", [String])
], TypeSelector);

let ClassSelector = class ClassSelector extends SimpleSelector {
    constructor(cssClass) {
        super();
        this.cssClass = cssClass;
    }
    toString() {
        return `.${this.cssClass}${wrap(this.combinator)}`;
    }
    match(node) {
        return node.cssClasses && node.cssClasses.has(this.cssClass);
    }
    lookupSort(sorter, base) {
        sorter.sortByClass(this.cssClass, base || this);
    }
};
ClassSelector = __decorate([
    SelectorProperties(10 /* Class */, 2 /* Class */, Match.Static),
    __metadata("design:paramtypes", [String])
], ClassSelector);

let AttributeSelector = class AttributeSelector extends SimpleSelector {
    constructor(attribute, test, value) {
        super();
        this.attribute = attribute;
        this.test = test;
        this.value = value;
        if (!test) {
            // HasAttribute
            this.match = (node) => !Object(_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isNullOrUndefined */ "h"])(node[attribute]);
            return;
        }
        if (!value) {
            this.match = (node) => false;
        }
        this.match = (node) => {
            const attr = node[attribute] + '';
            if (test === '=') {
                // Equals
                return attr === value;
            }
            if (test === '^=') {
                // PrefixMatch
                return attr.startsWith(value);
            }
            if (test === '$=') {
                // SuffixMatch
                return attr.endsWith(value);
            }
            if (test === '*=') {
                // SubstringMatch
                return attr.indexOf(value) !== -1;
            }
            if (test === '~=') {
                // Includes
                const words = attr.split(' ');
                return words && words.indexOf(value) !== -1;
            }
            if (test === '|=') {
                // DashMatch
                return attr === value || attr.startsWith(value + '-');
            }
        };
    }
    toString() {
        return `[${this.attribute}${wrap(this.test)}${(this.test && this.value) || ''}]${wrap(this.combinator)}`;
    }
    match(node) {
        return false;
    }
    mayMatch(node) {
        return true;
    }
    trackChanges(node, map) {
        map.addAttribute(node, this.attribute);
    }
};
AttributeSelector = __decorate([
    SelectorProperties(10 /* Attribute */, 0 /* Attribute */, Match.Dynamic),
    __metadata("design:paramtypes", [String, String, String])
], AttributeSelector);

let PseudoClassSelector = class PseudoClassSelector extends SimpleSelector {
    constructor(cssPseudoClass) {
        super();
        this.cssPseudoClass = cssPseudoClass;
    }
    toString() {
        return `:${this.cssPseudoClass}${wrap(this.combinator)}`;
    }
    match(node) {
        return node.cssPseudoClasses && node.cssPseudoClasses.has(this.cssPseudoClass);
    }
    mayMatch(node) {
        return true;
    }
    trackChanges(node, map) {
        map.addPseudoClass(node, this.cssPseudoClass);
    }
};
PseudoClassSelector = __decorate([
    SelectorProperties(10 /* PseudoClass */, 0 /* PseudoClass */, Match.Dynamic),
    __metadata("design:paramtypes", [String])
], PseudoClassSelector);

class SimpleSelectorSequence extends SimpleSelector {
    constructor(selectors) {
        super();
        this.selectors = selectors;
        this.specificity = selectors.reduce((sum, sel) => sel.specificity + sum, 0);
        this.head = this.selectors.reduce((prev, curr) => (!prev || curr.rarity > prev.rarity ? curr : prev), null);
        this.dynamic = selectors.some((sel) => sel.dynamic);
    }
    toString() {
        return `${this.selectors.join('')}${wrap(this.combinator)}`;
    }
    match(node) {
        return this.selectors.every((sel) => sel.match(node));
    }
    mayMatch(node) {
        return this.selectors.every((sel) => sel.mayMatch(node));
    }
    trackChanges(node, map) {
        this.selectors.forEach((sel) => sel.trackChanges(node, map));
    }
    lookupSort(sorter, base) {
        this.head.lookupSort(sorter, base || this);
    }
}
class Selector extends SelectorCore {
    constructor(selectors) {
        super();
        this.selectors = selectors;
        const supportedCombinator = [undefined, ' ', '>', '+'];
        let siblingGroup;
        let lastGroup;
        let groups = [];
        this.specificity = 0;
        this.dynamic = false;
        for (let i = selectors.length - 1; i > -1; i--) {
            const sel = selectors[i];
            if (supportedCombinator.indexOf(sel.combinator) === -1) {
                throw new Error(`Unsupported combinator "${sel.combinator}".`);
            }
            if (sel.combinator === undefined || sel.combinator === ' ') {
                groups.push((lastGroup = [(siblingGroup = [])]));
            }
            if (sel.combinator === '>') {
                lastGroup.push((siblingGroup = []));
            }
            this.specificity += sel.specificity;
            if (sel.dynamic) {
                this.dynamic = true;
            }
            siblingGroup.push(sel);
        }
        this.groups = groups.map((g) => new Selector.ChildGroup(g.map((sg) => new Selector.SiblingGroup(sg))));
        this.last = selectors[selectors.length - 1];
    }
    toString() {
        return this.selectors.join('');
    }
    match(node) {
        return this.groups.every((group, i) => {
            if (i === 0) {
                node = group.match(node);
                return !!node;
            }
            else {
                let ancestor = node;
                while ((ancestor = ancestor.parent)) {
                    if ((node = group.match(ancestor))) {
                        return true;
                    }
                }
                return false;
            }
        });
    }
    lookupSort(sorter, base) {
        this.last.lookupSort(sorter, this);
    }
    accumulateChanges(node, map) {
        if (!this.dynamic) {
            return this.match(node);
        }
        let bounds = [];
        let mayMatch = this.groups.every((group, i) => {
            if (i === 0) {
                let nextNode = group.mayMatch(node);
                bounds.push({ left: node, right: node });
                node = nextNode;
                return !!node;
            }
            else {
                let ancestor = node;
                while ((ancestor = ancestor.parent)) {
                    let nextNode = group.mayMatch(ancestor);
                    if (nextNode) {
                        bounds.push({ left: ancestor, right: null });
                        node = nextNode;
                        return true;
                    }
                }
                return false;
            }
        });
        // Calculating the right bounds for each selectors won't save much
        if (!mayMatch) {
            return false;
        }
        if (!map) {
            return mayMatch;
        }
        for (let i = 0; i < this.groups.length; i++) {
            let group = this.groups[i];
            if (!group.dynamic) {
                continue;
            }
            let bound = bounds[i];
            let node = bound.left;
            do {
                if (group.mayMatch(node)) {
                    group.trackChanges(node, map);
                }
            } while (node !== bound.right && (node = node.parent));
        }
        return mayMatch;
    }
}
(function (Selector) {
    // Non-spec. Selector sequences are grouped by ancestor then by child combinators for easier backtracking.
    class ChildGroup {
        constructor(selectors) {
            this.selectors = selectors;
            this.dynamic = selectors.some((sel) => sel.dynamic);
        }
        match(node) {
            return this.selectors.every((sel, i) => (node = i === 0 ? node : node.parent) && sel.match(node)) ? node : null;
        }
        mayMatch(node) {
            return this.selectors.every((sel, i) => (node = i === 0 ? node : node.parent) && sel.mayMatch(node)) ? node : null;
        }
        trackChanges(node, map) {
            this.selectors.forEach((sel, i) => (node = i === 0 ? node : node.parent) && sel.trackChanges(node, map));
        }
    }
    Selector.ChildGroup = ChildGroup;
    class SiblingGroup {
        constructor(selectors) {
            this.selectors = selectors;
            this.dynamic = selectors.some((sel) => sel.dynamic);
        }
        match(node) {
            return this.selectors.every((sel, i) => (node = i === 0 ? node : getNodeDirectSibling(node)) && sel.match(node)) ? node : null;
        }
        mayMatch(node) {
            return this.selectors.every((sel, i) => (node = i === 0 ? node : getNodeDirectSibling(node)) && sel.mayMatch(node)) ? node : null;
        }
        trackChanges(node, map) {
            this.selectors.forEach((sel, i) => (node = i === 0 ? node : getNodeDirectSibling(node)) && sel.trackChanges(node, map));
        }
    }
    Selector.SiblingGroup = SiblingGroup;
})(Selector || (Selector = {}));
class RuleSet {
    constructor(selectors, declarations) {
        this.selectors = selectors;
        this.declarations = declarations;
        this.selectors.forEach((sel) => (sel.ruleset = this));
    }
    toString() {
        return `${this.selectors.join(', ')} {${this.declarations.map((d, i) => `${i === 0 ? ' ' : ''}${d.property}: ${d.value}`).join('; ')} }`;
    }
    lookupSort(sorter) {
        this.selectors.forEach((sel) => sel.lookupSort(sorter));
    }
}
function fromAstNodes(astRules) {
    return astRules.filter(isRule).map((rule) => {
        let declarations = rule.declarations.filter(isDeclaration).map(createDeclaration);
        let selectors = rule.selectors.map(createSelector);
        return new RuleSet(selectors, declarations);
    });
}
function createDeclaration(decl) {
    return { property: decl.property.toLowerCase(), value: decl.value };
}
function createSimpleSelectorFromAst(ast) {
    if (ast.type === '.') {
        return new ClassSelector(ast.identifier);
    }
    if (ast.type === '') {
        return new TypeSelector(ast.identifier.replace('-', '').toLowerCase());
    }
    if (ast.type === '#') {
        return new IdSelector(ast.identifier);
    }
    if (ast.type === '[]') {
        return new AttributeSelector(ast.property, ast.test, ast.test && ast.value);
    }
    if (ast.type === ':') {
        return new PseudoClassSelector(ast.identifier);
    }
    if (ast.type === '*') {
        return new UniversalSelector();
    }
}
function createSimpleSelectorSequenceFromAst(ast) {
    if (ast.length === 0) {
        return new InvalidSelector(new Error('Empty simple selector sequence.'));
    }
    else if (ast.length === 1) {
        return createSimpleSelectorFromAst(ast[0]);
    }
    else {
        return new SimpleSelectorSequence(ast.map(createSimpleSelectorFromAst));
    }
}
function createSelectorFromAst(ast) {
    if (ast.length === 0) {
        return new InvalidSelector(new Error('Empty selector.'));
    }
    else if (ast.length === 1) {
        return createSimpleSelectorSequenceFromAst(ast[0][0]);
    }
    else {
        let simpleSelectorSequences = [];
        let simpleSelectorSequence;
        let combinator;
        for (let i = 0; i < ast.length; i++) {
            simpleSelectorSequence = createSimpleSelectorSequenceFromAst(ast[i][0]);
            combinator = ast[i][1];
            if (combinator) {
                simpleSelectorSequence.combinator = combinator;
            }
            simpleSelectorSequences.push(simpleSelectorSequence);
        }
        return new Selector(simpleSelectorSequences);
    }
}
function createSelector(sel) {
    try {
        let parsedSelector = _css_parser__WEBPACK_IMPORTED_MODULE_2__["parseSelector"](sel);
        if (!parsedSelector) {
            return new InvalidSelector(new Error('Empty selector'));
        }
        return createSelectorFromAst(parsedSelector.value);
    }
    catch (e) {
        return new InvalidSelector(e);
    }
}
function isRule(node) {
    return node.type === 'rule';
}
function isDeclaration(node) {
    return node.type === 'declaration';
}
class SelectorsMap {
    constructor(rulesets) {
        this.id = {};
        this.class = {};
        this.type = {};
        this.universal = [];
        this.position = 0;
        rulesets.forEach((rule) => rule.lookupSort(this));
    }
    query(node) {
        const selectorsMatch = new SelectorsMatch();
        const { cssClasses, id, cssType } = node;
        const selectorClasses = [this.universal, this.id[id], this.type[cssType]];
        if (cssClasses && cssClasses.size) {
            cssClasses.forEach((c) => selectorClasses.push(this.class[c]));
        }
        const selectors = selectorClasses.reduce((cur, next) => cur.concat(next || []), []);
        selectorsMatch.selectors = selectors.filter((sel) => sel.accumulateChanges(node, selectorsMatch)).sort((a, b) => a.specificity - b.specificity || a.pos - b.pos);
        return selectorsMatch;
    }
    sortById(id, sel) {
        this.addToMap(this.id, id, sel);
    }
    sortByClass(cssClass, sel) {
        this.addToMap(this.class, cssClass, sel);
    }
    sortByType(cssType, sel) {
        this.addToMap(this.type, cssType, sel);
    }
    sortAsUniversal(sel) {
        this.universal.push(this.makeDocSelector(sel));
    }
    addToMap(map, head, sel) {
        if (!map[head]) {
            map[head] = [];
        }
        map[head].push(this.makeDocSelector(sel));
    }
    makeDocSelector(sel) {
        sel.pos = this.position++;
        return sel;
    }
}
class SelectorsMatch {
    constructor() {
        this.changeMap = new Map();
    }
    addAttribute(node, attribute) {
        let deps = this.properties(node);
        if (!deps.attributes) {
            deps.attributes = new Set();
        }
        deps.attributes.add(attribute);
    }
    addPseudoClass(node, pseudoClass) {
        let deps = this.properties(node);
        if (!deps.pseudoClasses) {
            deps.pseudoClasses = new Set();
        }
        deps.pseudoClasses.add(pseudoClass);
    }
    properties(node) {
        let set = this.changeMap.get(node);
        if (!set) {
            this.changeMap.set(node, (set = {}));
        }
        return set;
    }
}
const CSSHelper = {
    createSelector,
    SelectorCore,
    SimpleSelector,
    InvalidSelector,
    UniversalSelector,
    TypeSelector,
    ClassSelector,
    AttributeSelector,
    PseudoClassSelector,
    SimpleSelectorSequence,
    Selector,
    RuleSet,
    SelectorsMap,
    fromAstNodes,
    SelectorsMatch,
};
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ItemSpec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GridLayoutBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return columnProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return columnSpanProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return rowProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return rowSpanProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GridUnitType; });
/* harmony import */ var _layout_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
var GridLayoutBase_1;




function validateArgs(element) {
    if (!element) {
        throw new Error('element cannot be null or undefined.');
    }
    return element;
}
_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].prototype.row = 0;
_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].prototype.col = 0;
_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].prototype.rowSpan = 1;
_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].prototype.colSpan = 1;
Object.defineProperty(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].prototype, 'column', {
    get() {
        return this.col;
    },
    set(value) {
        this.col = value;
    },
    enumerable: true,
    configurable: true,
});
Object.defineProperty(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].prototype, 'columnSpan', {
    get() {
        return this.colSpan;
    },
    set(value) {
        this.colSpan = value;
    },
    enumerable: true,
    configurable: true,
});
function validateItemSpec(itemSpec) {
    if (!itemSpec) {
        throw new Error('Value cannot be undefined.');
    }
    if (itemSpec.owner) {
        throw new Error('itemSpec is already added to GridLayout.');
    }
}
function convertGridLength(value) {
    if (value === GridUnitType.AUTO) {
        return ItemSpec.create(1, GridUnitType.AUTO);
    }
    else if (value.indexOf('*') !== -1) {
        const starCount = parseInt(value.replace('*', '') || '1');
        return ItemSpec.create(starCount, GridUnitType.STAR);
    }
    else if (!isNaN(parseInt(value))) {
        return ItemSpec.create(parseInt(value), GridUnitType.PIXEL);
    }
    else {
        throw new Error(`Cannot parse item spec from string: ${value}`);
    }
}
function parseAndAddItemSpecs(value, func) {
    // ensure value is a string since view bindings could be parsed as number/int's here
    const arr = `${value}`.split(/[\s,]+/);
    for (let i = 0, length = arr.length; i < length; i++) {
        const str = arr[i].trim();
        if (str.length > 0) {
            func(convertGridLength(arr[i].trim()));
        }
    }
}
class ItemSpec extends _data_observable__WEBPACK_IMPORTED_MODULE_4__["Observable"] {
    constructor() {
        super();
        this._actualLength = 0;
        if (arguments.length === 0) {
            this._value = 1;
            this._unitType = GridUnitType.STAR;
        }
        else if (arguments.length === 2) {
            const value = arguments[0];
            const type = arguments[1];
            if (typeof value === 'number' && typeof type === 'string') {
                if (value < 0 || isNaN(value) || !isFinite(value)) {
                    throw new Error(`Value should not be negative, NaN or Infinity: ${value}`);
                }
                this._value = value;
                this._unitType = GridUnitType.parse(type);
            }
            else {
                throw new Error('First argument should be number, second argument should be string.');
            }
        }
        else {
            throw new Error('ItemSpec expects 0 or 2 arguments');
        }
        this.index = -1;
    }
    static create(value, type) {
        let spec = new ItemSpec();
        spec._value = value;
        spec._unitType = type;
        return spec;
    }
    get actualLength() {
        return this._actualLength;
    }
    static equals(value1, value2) {
        return value1.gridUnitType === value2.gridUnitType && value1.value === value2.value && value1.owner === value2.owner && value1.index === value2.index;
    }
    get gridUnitType() {
        return this._unitType;
    }
    get isAbsolute() {
        return this._unitType === GridUnitType.PIXEL;
    }
    get isAuto() {
        return this._unitType === GridUnitType.AUTO;
    }
    get isStar() {
        return this._unitType === GridUnitType.STAR;
    }
    get value() {
        return this._value;
    }
}
let GridLayoutBase = GridLayoutBase_1 = class GridLayoutBase extends _layout_base__WEBPACK_IMPORTED_MODULE_0__[/* LayoutBase */ "a"] {
    constructor() {
        super(...arguments);
        this._rows = new Array();
        this._cols = new Array();
    }
    static getColumn(element) {
        return validateArgs(element).col;
    }
    static setColumn(element, value) {
        validateArgs(element).col = value;
    }
    static getColumnSpan(element) {
        return validateArgs(element).colSpan;
    }
    static setColumnSpan(element, value) {
        validateArgs(element).colSpan = value;
    }
    static getRow(element) {
        return validateArgs(element).row;
    }
    static setRow(element, value) {
        validateArgs(element).row = value;
    }
    static getRowSpan(element) {
        return validateArgs(element).rowSpan;
    }
    static setRowSpan(element, value) {
        validateArgs(element).rowSpan = value;
    }
    addRow(itemSpec) {
        validateItemSpec(itemSpec);
        itemSpec.owner = this;
        this._rows.push(itemSpec);
        this._onRowAdded(itemSpec);
        this.invalidate();
    }
    addColumn(itemSpec) {
        validateItemSpec(itemSpec);
        itemSpec.owner = this;
        this._cols.push(itemSpec);
        this._onColumnAdded(itemSpec);
        this.invalidate();
    }
    addChildAtCell(view, row, column, rowSpan, columnSpan) {
        this.addChild(view);
        GridLayoutBase_1.setRow(view, row);
        GridLayoutBase_1.setColumn(view, column);
        if (rowSpan) {
            GridLayoutBase_1.setRowSpan(view, rowSpan);
        }
        if (columnSpan) {
            GridLayoutBase_1.setColumnSpan(view, columnSpan);
        }
    }
    removeRow(itemSpec) {
        if (!itemSpec) {
            throw new Error('Value is null.');
        }
        const index = this._rows.indexOf(itemSpec);
        if (itemSpec.owner !== this || index < 0) {
            throw new Error('Row is not child of this GridLayout');
        }
        itemSpec.index = -1;
        this._rows.splice(index, 1);
        this._onRowRemoved(itemSpec, index);
        this.invalidate();
    }
    removeColumn(itemSpec) {
        if (!itemSpec) {
            throw new Error('Value is null.');
        }
        const index = this._cols.indexOf(itemSpec);
        if (itemSpec.owner !== this || index < 0) {
            throw new Error('Column is not child of this GridLayout');
        }
        itemSpec.index = -1;
        this._cols.splice(index, 1);
        this._onColumnRemoved(itemSpec, index);
        this.invalidate();
    }
    removeColumns() {
        for (let i = this._cols.length - 1; i >= 0; i--) {
            const colSpec = this._cols[i];
            this._onColumnRemoved(colSpec, i);
            colSpec.index = -1;
        }
        this._cols.length = 0;
        this.invalidate();
    }
    removeRows() {
        for (let i = this._rows.length - 1; i >= 0; i--) {
            const rowSpec = this._rows[i];
            this._onRowRemoved(rowSpec, i);
            rowSpec.index = -1;
        }
        this._rows.length = 0;
        this.invalidate();
    }
    onRowChanged(element, oldValue, newValue) {
        this.invalidate();
    }
    onRowSpanChanged(element, oldValue, newValue) {
        this.invalidate();
    }
    onColumnChanged(element, oldValue, newValue) {
        this.invalidate();
    }
    onColumnSpanChanged(element, oldValue, newValue) {
        this.invalidate();
    }
    _onRowAdded(itemSpec) {
        //
    }
    _onColumnAdded(itemSpec) {
        //
    }
    _onRowRemoved(itemSpec, index) {
        //
    }
    _onColumnRemoved(itemSpec, index) {
        //
    }
    getColumns() {
        return this._cols.slice();
    }
    getRows() {
        return this._rows.slice();
    }
    get columnsInternal() {
        return this._cols;
    }
    get rowsInternal() {
        return this._rows;
    }
    invalidate() {
        // handled natively in android and overridden in ios.
    }
    set rows(value) {
        this.removeRows();
        parseAndAddItemSpecs(value, (spec) => this.addRow(spec));
    }
    set columns(value) {
        this.removeColumns();
        parseAndAddItemSpecs(value, (spec) => this.addColumn(spec));
    }
};
GridLayoutBase = GridLayoutBase_1 = __decorate([
    Object(_core_view__WEBPACK_IMPORTED_MODULE_2__[/* CSSType */ "a"])('GridLayout')
], GridLayoutBase);

GridLayoutBase.prototype.recycleNativeView = 'auto';
const columnProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'col',
    defaultValue: 0,
    valueChanged: (target, oldValue, newValue) => {
        const grid = target.parent;
        if (grid instanceof GridLayoutBase) {
            grid.onColumnChanged(target, oldValue, newValue);
        }
    },
    valueConverter: (v) => Math.max(0, parseInt(v)),
});
columnProperty.register(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"]);
const columnSpanProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'colSpan',
    defaultValue: 1,
    valueChanged: (target, oldValue, newValue) => {
        const grid = target.parent;
        if (grid instanceof GridLayoutBase) {
            grid.onColumnSpanChanged(target, oldValue, newValue);
        }
    },
    valueConverter: (v) => Math.max(1, parseInt(v)),
});
columnSpanProperty.register(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"]);
const rowProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'row',
    defaultValue: 0,
    valueChanged: (target, oldValue, newValue) => {
        const grid = target.parent;
        if (grid instanceof GridLayoutBase) {
            grid.onRowChanged(target, oldValue, newValue);
        }
    },
    valueConverter: (v) => Math.max(0, parseInt(v)),
});
rowProperty.register(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"]);
const rowSpanProperty = new _core_properties__WEBPACK_IMPORTED_MODULE_3__["Property"]({
    name: 'rowSpan',
    defaultValue: 1,
    valueChanged: (target, oldValue, newValue) => {
        const grid = target.parent;
        if (grid instanceof GridLayoutBase) {
            grid.onRowSpanChanged(target, oldValue, newValue);
        }
    },
    valueConverter: (v) => Math.max(1, parseInt(v)),
});
rowSpanProperty.register(_core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"]);
var GridUnitType;
(function (GridUnitType) {
    GridUnitType.PIXEL = 'pixel';
    GridUnitType.STAR = 'star';
    GridUnitType.AUTO = 'auto';
    GridUnitType.isValid = Object(_core_properties__WEBPACK_IMPORTED_MODULE_3__["makeValidator"])(GridUnitType.PIXEL, GridUnitType.STAR, GridUnitType.AUTO);
    GridUnitType.parse = Object(_core_properties__WEBPACK_IMPORTED_MODULE_3__["makeParser"])(GridUnitType.isValid);
})(GridUnitType || (GridUnitType = {}));
//# sourceMappingURL=grid-layout-common.js.map; 
if (false ) {} 

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTimeout", function() { return setTimeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearTimeout", function() { return clearTimeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setInterval", function() { return setInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearInterval", function() { return clearInterval; });
//iOS specific timer functions implementation.
const timeoutCallbacks = new Map();
let timerId = 0;
var TimerTargetImpl = /** @class */ (function (_super) {
    __extends(TimerTargetImpl, _super);
    function TimerTargetImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimerTargetImpl.initWithCallback = function (callback, id, shouldRepeat) {
        var handler = TimerTargetImpl.new();
        handler.callback = callback;
        handler.id = id;
        handler.shouldRepeat = shouldRepeat;
        return handler;
    };
    TimerTargetImpl.prototype.tick = function (timer) {
        if (!this.disposed) {
            this.callback();
        }
        if (!this.shouldRepeat) {
            this.unregister();
        }
    };
    TimerTargetImpl.prototype.unregister = function () {
        if (!this.disposed) {
            this.disposed = true;
            var timer = timeoutCallbacks.get(this.id).k;
            timer.invalidate();
            timeoutCallbacks.delete(this.id);
        }
    };
    TimerTargetImpl.ObjCExposedMethods = {
        tick: { returns: interop.types.void, params: [NSTimer] },
    };
    return TimerTargetImpl;
}(NSObject));
function createTimerAndGetId(callback, milliseconds, shouldRepeat) {
    // Cast to Number
    milliseconds += 0;
    timerId++;
    let id = timerId;
    let timerTarget = TimerTargetImpl.initWithCallback(callback, id, shouldRepeat);
    let timer = NSTimer.scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(milliseconds / 1000, timerTarget, 'tick', null, shouldRepeat);
    // https://github.com/NativeScript/NativeScript/issues/2116
    NSRunLoop.currentRunLoop.addTimerForMode(timer, NSRunLoopCommonModes);
    let pair = {
        k: timer,
        v: timerTarget,
    };
    timeoutCallbacks.set(id, pair);
    return id;
}
function setTimeout(callback, milliseconds = 0, ...args) {
    let invoke = () => callback(...args);
    return createTimerAndGetId(zonedCallback(invoke), milliseconds, false);
}
function clearTimeout(id) {
    let pair = timeoutCallbacks.get(id);
    if (pair) {
        pair.v.unregister();
    }
}
function setInterval(callback, milliseconds = 0, ...args) {
    let invoke = () => callback(...args);
    return createTimerAndGetId(zonedCallback(invoke), milliseconds, true);
}
const clearInterval = clearTimeout;
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export NativeScriptGlobalState */
/* unused harmony export installPolyfills */
/* unused harmony export initGlobal */
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
const tslib = __webpack_require__(295);


function registerOnGlobalContext(moduleName, exportName) {
    Object.defineProperty(global, exportName, {
        get: function () {
            // We do not need to cache require() call since it is already cached in the runtime.
            let m = global.loadModule(moduleName);
            // Redefine the property to make sure the above code is executed only once.
            let resolvedValue = m[exportName];
            Object.defineProperty(global, exportName, {
                value: resolvedValue,
                configurable: true,
                writable: true,
            });
            return resolvedValue;
        },
        configurable: true,
    });
}
/**
 * Manages internal framework global state
 */
class NativeScriptGlobalState {
    constructor() {
        this.launched = false;
        this._appInstanceReady = false;
        // console.log('creating NativeScriptGlobals...')
        this.events = new _data_observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]();
        this._setLaunched = this._setLaunchedFn.bind(this);
        this.events.on('launch', this._setLaunched);
        if (Object(_profiling__WEBPACK_IMPORTED_MODULE_1__[/* level */ "e"])() > 0) {
            this.events.on('displayed', () => {
                const duration = Object(_profiling__WEBPACK_IMPORTED_MODULE_1__[/* uptime */ "n"])();
                const end = Object(_profiling__WEBPACK_IMPORTED_MODULE_1__[/* time */ "l"])();
                const start = end - duration;
                Object(_profiling__WEBPACK_IMPORTED_MODULE_1__[/* trace */ "m"])(`Displayed in ${duration.toFixed(2)}ms`, start, end);
            });
        }
    }
    get appInstanceReady() {
        return this._appInstanceReady;
    }
    set appInstanceReady(value) {
        this._appInstanceReady = value;
        // app instance ready, wire up any app events waiting in startup queue
        if (this.appEventWiring && this.appEventWiring.length) {
            for (const callback of this.appEventWiring) {
                callback();
            }
            // cleanup
            this.appEventWiring = null;
        }
    }
    /**
     * Ability for classes to initialize app event handling early even before the app instance is ready during boot cycle avoiding boot race conditions
     * @param callback wire up any global event handling inside the callback
     */
    addEventWiring(callback) {
        if (this._appInstanceReady) {
            callback();
        }
        else {
            if (!this.appEventWiring) {
                this.appEventWiring = [];
            }
            this.appEventWiring.push(callback);
        }
    }
    _setLaunchedFn() {
        // console.log('NativeScriptGlobals launch fired!');
        this.launched = true;
        this.events.off('launch', this._setLaunched);
        this._setLaunched = null;
    }
}
function installPolyfills(moduleName, exportNames) {
    if (global.__snapshot) {
        const loadedModule = global.loadModule(moduleName);
        exportNames.forEach((exportName) => (global[exportName] = loadedModule[exportName]));
    }
    else {
        exportNames.forEach((exportName) => registerOnGlobalContext(moduleName, exportName));
    }
}
function initGlobal() {
    if (!global.NativeScriptHasInitGlobal) {
        global.NativeScriptHasInitGlobal = true;
        // init global state handler
        global.NativeScriptGlobals = new NativeScriptGlobalState();
        // ts-helpers
        // Required by V8 snapshot generator
        if (!global.__extends) {
            global.__extends = function (d, b) {
                for (let p in b) {
                    if (b.hasOwnProperty(p)) {
                        d[p] = b[p];
                    }
                }
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
            };
        }
        // Bind the tslib helpers to global scope.
        // This is needed when we don't use importHelpers, which
        // breaks extending native-classes
        for (const fnName of Object.keys(tslib)) {
            if (typeof tslib[fnName] !== 'function') {
                continue;
            }
            if (fnName in global) {
                // Don't override globals that are already defined (ex. __extends)
                continue;
            }
            global[fnName] = tslib[fnName];
        }
        // module helpers
        const modules = new Map();
        const modulesLoadedForUI = new Set();
        const defaultExtensionMap = {
            '.js': '.js',
            '.ts': '.js',
            '.kt': '.js',
            '.css': '.css',
            '.scss': '.css',
            '.less': '.css',
            '.sass': '.css',
            '.xml': '.xml',
        };
        // Cast to <any> because moduleResolvers is read-only in definitions
        global.moduleResolvers = [global.require];
        global.registerModule = function (name, loader) {
            modules.set(name, { loader, moduleId: name });
        };
        global._unregisterModule = function _unregisterModule(name) {
            modules.delete(name);
        };
        global._isModuleLoadedForUI = function _isModuleLoadedForUI(moduleName) {
            return modulesLoadedForUI.has(moduleName);
        };
        global.registerWebpackModules = function registerWebpackModules(context, extensionMap = {}) {
            context.keys().forEach((moduleId) => {
                const extDotIndex = moduleId.lastIndexOf('.');
                const base = moduleId.substr(0, extDotIndex);
                const originalExt = moduleId.substr(extDotIndex);
                const registerExt = extensionMap[originalExt] || defaultExtensionMap[originalExt] || originalExt;
                // We prefer source files for webpack scenarios before compilation leftovers,
                // e. g. if we get a .js and .ts for the same module, the .js is probably the compiled version of the .ts file,
                // so we register the .ts with higher priority, similar is the case with us preferring the .scss to .css
                const isSourceFile = originalExt !== registerExt;
                const registerName = base + registerExt;
                const registerWithName = (nickName) => {
                    modules.set(nickName, {
                        moduleId,
                        loader: () => {
                            return context(moduleId);
                        },
                    });
                };
                if (registerName.startsWith('./') && registerName.endsWith('.js')) {
                    const jsNickNames = [
                        // This is extremely short version like "main-page" that was promoted to be used with global.registerModule("module-name", loaderFunc);
                        registerName.substr(2, registerName.length - 5),
                        // This is for supporting module names like "./main/main-page"
                        registerName.substr(0, registerName.length - 3),
                        // This is for supporting module names like "main/main-page.js"
                        registerName.substr(2),
                    ];
                    jsNickNames.forEach((jsNickName) => {
                        if (isSourceFile || !global.moduleExists(jsNickName)) {
                            registerWithName(jsNickName);
                        }
                    });
                }
                else if (registerName.startsWith('./')) {
                    const moduleNickNames = [
                        // This is for supporting module names like "main/main-page.xml"
                        registerName.substr(2),
                    ];
                    moduleNickNames.forEach((moduleNickName) => {
                        if (!global.moduleExists(moduleNickName)) {
                            registerWithName(moduleNickName);
                        }
                    });
                }
                if (isSourceFile || !global.moduleExists(registerName)) {
                    registerWithName(registerName);
                }
            });
        };
        global.moduleExists = function moduleExists(name) {
            return modules.has(name);
        };
        global.loadModule = function loadModule(name, isUIModule = false) {
            const moduleInfo = modules.get(name);
            if (moduleInfo) {
                if (isUIModule) {
                    modulesLoadedForUI.add(moduleInfo.moduleId);
                }
                const result = moduleInfo.loader(name);
                if (result.enableAutoAccept) {
                    result.enableAutoAccept();
                }
                return result;
            }
            for (let resolver of global.moduleResolvers) {
                const result = resolver(name);
                if (result) {
                    modules.set(name, { moduleId: name, loader: () => result });
                    return result;
                }
            }
        };
        global.getRegisteredModules = function getRegisteredModules() {
            return Array.from(modules.keys());
        };
        /**
         * Polyfills
         */
        // This method iterates all the keys in the source exports object and copies them to the destination exports one.
        // Note: the method will not check for naming collisions and will override any already existing entries in the destination exports.
        global.moduleMerge = function (sourceExports, destExports) {
            for (let key in sourceExports) {
                destExports[key] = sourceExports[key];
            }
        };
        global.zonedCallback = function (callback) {
            if (global.zone) {
                // Zone v0.5.* style callback wrapping
                return global.zone.bind(callback);
            }
            if (global.Zone) {
                // Zone v0.6.* style callback wrapping
                return global.Zone.current.wrap(callback);
            }
            else {
                return callback;
            }
        };
        global.System = {
            import(path) {
                return new Promise((resolve, reject) => {
                    try {
                        resolve(global.require(path));
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            },
        };
        // DOM api polyfills
        global.registerModule('timer', () => __webpack_require__(74));
        installPolyfills('timer', ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']);
        global.registerModule('animation', () => __webpack_require__(419));
        installPolyfills('animation', ['requestAnimationFrame', 'cancelAnimationFrame']);
        global.registerModule('ui-dialogs', () => __webpack_require__(8));
        installPolyfills('ui-dialogs', ['alert', 'confirm', 'prompt', 'login', 'action']);
        global.registerModule('text', () => __webpack_require__(61));
        installPolyfills('text', ['TextDecoder', 'TextEncoder']);
        global.registerModule('xhr', () => __webpack_require__(407));
        installPolyfills('xhr', ['XMLHttpRequest', 'FormData', 'Blob', 'File', 'FileReader']);
        global.registerModule('fetch', () => __webpack_require__(408));
        installPolyfills('fetch', ['fetch', 'Headers', 'Request', 'Response']);
        // Custom decorators
        global.Deprecated = function (target, key, descriptor) {
            if (descriptor) {
                const originalMethod = descriptor.value;
                descriptor.value = function (...args) {
                    console.log(`${key.toString()} is deprecated`);
                    return originalMethod.apply(this, args);
                };
                return descriptor;
            }
            else {
                console.log(`${(target && target.name) || target} is deprecated`);
                return target;
            }
        };
        global.Experimental = function (target, key, descriptor) {
            if (descriptor) {
                const originalMethod = descriptor.value;
                descriptor.value = function (...args) {
                    console.log(`${key.toString()} is experimental`);
                    return originalMethod.apply(this, args);
                };
                return descriptor;
            }
            else {
                console.log(`${(target && target.name) || target} is experimental`);
                return target;
            }
        };
    }
}
if (!global.NativeScriptHasInitGlobal) {
    initGlobal();
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var charCodeDef = __webpack_require__(110);
var isDigit = charCodeDef.isDigit;
var isHexDigit = charCodeDef.isHexDigit;
var isUppercaseLetter = charCodeDef.isUppercaseLetter;
var isName = charCodeDef.isName;
var isWhiteSpace = charCodeDef.isWhiteSpace;
var isValidEscape = charCodeDef.isValidEscape;

function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i - start);

        // testCode.toLowerCase() for A..Z
        if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isDigit(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

// § 4.3.7. Consume an escaped code point
function consumeEscaped(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (isHexDigit(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        var code = getCharCode(source, offset);
        if (isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
        }
    }

    return offset;
}

// §4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // name code point
        if (isName(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = consumeEscaped(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// §4.3.12. Consume a number
function consumeNumber(source, offset) {
    var code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        code = source.charCodeAt(offset += 2);

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar(source, offset, 101 /* e */)) {
        var sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (isDigit(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

// § 4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped(source, offset);
        }
    }

    return offset;
}

module.exports = {
    consumeEscaped: consumeEscaped,
    consumeName: consumeName,
    consumeNumber: consumeNumber,
    consumeBadUrlRemnants: consumeBadUrlRemnants,

    cmpChar: cmpChar,
    cmpStr: cmpStr,

    getNewlineLength: getNewlineLength,
    findWhiteSpaceStart: findWhiteSpaceStart,
    findWhiteSpaceEnd: findWhiteSpaceEnd
};
; 
if (false ) {} 

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dispatchToMainThread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isMainThread; });
function dispatchToMainThread(func) {
    NSOperationQueue.mainQueue.addOperationWithBlock(func);
}
function isMainThread() {
    return NSThread.isMainThread;
}
//# sourceMappingURL=mainthread-helper.ios.js.map; 
if (false ) {} 

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerInspectorEvents", function() { return registerInspectorEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodeById", function() { return getNodeById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMNode", function() { return DOMNode; });
const registeredDomNodes = {};
const ELEMENT_NODE_TYPE = 1;
const ROOT_NODE_TYPE = 9;
const propertyBlacklist = ['effectivePaddingLeft', 'effectivePaddingBottom', 'effectivePaddingRight', 'effectivePaddingTop', 'effectiveBorderTopWidth', 'effectiveBorderRightWidth', 'effectiveBorderBottomWidth', 'effectiveBorderLeftWidth', 'effectiveMinWidth', 'effectiveMinHeight', 'effectiveWidth', 'effectiveHeight', 'effectiveMarginLeft', 'effectiveMarginTop', 'effectiveMarginRight', 'effectiveMarginBottom', 'nodeName', 'nodeType', 'decodeWidth', 'decodeHeight', 'ng-reflect-items', 'domNode', 'touchListenerIsSet', 'bindingContext', 'nativeView'];
function lazy(action) {
    let _value;
    return () => _value || (_value = action());
}
const percentLengthToStringLazy = lazy(() => __webpack_require__(2).PercentLength.convertToString);
const getSetPropertiesLazy = lazy(() => __webpack_require__(1).getSetProperties);
const getComputedCssValuesLazy = lazy(() => __webpack_require__(1).getComputedCssValues);
function registerInspectorEvents(inspector) {
    inspectorFrontendInstance = inspector;
}
let inspectorFrontendInstance;
function notifyInspector(callback) {
    if (inspectorFrontendInstance) {
        callback(inspectorFrontendInstance);
    }
}
function valueToString(value) {
    if (typeof value === 'undefined' || value === null) {
        return '';
    }
    else if (typeof value === 'object' && value.unit) {
        return percentLengthToStringLazy()(value);
    }
    else {
        return value + '';
    }
}
function propertyFilter([name, value]) {
    if (name[0] === '_') {
        return false;
    }
    if (value !== null && typeof value === 'object') {
        return false;
    }
    if (propertyBlacklist.indexOf(name) >= 0) {
        return false;
    }
    return true;
}
function registerNode(domNode) {
    registeredDomNodes[domNode.nodeId] = domNode;
}
function unregisterNode(domNode) {
    delete registeredDomNodes[domNode.nodeId];
}
function getNodeById(id) {
    return registeredDomNodes[id];
}
class DOMNode {
    constructor(view) {
        this.nodeValue = '';
        this.attributes = [];
        this.viewRef = new WeakRef(view);
        this.nodeType = view.typeName === 'Frame' ? ROOT_NODE_TYPE : ELEMENT_NODE_TYPE;
        this.nodeId = view._domId;
        this.nodeName = view.typeName;
        this.localName = this.nodeName;
        // Load all attributes
        this.loadAttributes();
        registerNode(this);
    }
    loadAttributes() {
        this.attributes = [];
        getSetPropertiesLazy()(this.viewRef.get())
            .filter(propertyFilter)
            .forEach((pair) => this.attributes.push(pair[0], pair[1] + ''));
    }
    get children() {
        const view = this.viewRef.get();
        if (!view) {
            return [];
        }
        const res = [];
        view.eachChild((child) => {
            child.ensureDomNode();
            res.push(child.domNode);
            return true;
        });
        return res;
    }
    onChildAdded(childView) {
        notifyInspector((ins) => {
            const view = this.viewRef.get();
            let previousChild;
            view.eachChild((child) => {
                if (child === childView) {
                    return false;
                }
                previousChild = child;
                return true;
            });
            const index = !!previousChild ? previousChild._domId : 0;
            childView.ensureDomNode();
            ins.childNodeInserted(this.nodeId, index, childView.domNode);
        });
    }
    onChildRemoved(view) {
        notifyInspector((ins) => {
            ins.childNodeRemoved(this.nodeId, view._domId);
        });
    }
    attributeModified(name, value) {
        notifyInspector((ins) => {
            if (propertyBlacklist.indexOf(name) < 0) {
                ins.attributeModified(this.nodeId, name, valueToString(value));
            }
        });
    }
    attributeRemoved(name) {
        notifyInspector((ins) => {
            ins.attributeRemoved(this.nodeId, name);
        });
    }
    getComputedProperties() {
        const view = this.viewRef.get();
        if (!view) {
            return [];
        }
        const result = getComputedCssValuesLazy()(view)
            .filter((pair) => pair[0][0] !== '_')
            .map((pair) => {
            return {
                name: pair[0],
                value: valueToString(pair[1]),
            };
        });
        return result;
    }
    dispose() {
        unregisterNode(this);
        this.viewRef.clear();
    }
    toObject() {
        return {
            nodeId: this.nodeId,
            nodeType: this.nodeType,
            nodeName: this.nodeName,
            localName: this.localName,
            nodeValue: this.nodeValue,
            children: this.children.map((c) => c.toObject()),
            attributes: this.attributes,
            backendNodeId: 0,
        };
    }
}
//# sourceMappingURL=dom-node.js.map; 
if (false ) {} 

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return set; });
let resources = {};
function get() {
    return resources;
}
function set(res) {
    resources = res;
}
//# sourceMappingURL=bindable-resources.js.map; 
if (false ) {} 

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ attachDOMInspectorEventCallbacks; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ attachDOMInspectorCommandCallbacks; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ attachCSSInspectorCommandCallbacks; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/debugger/dom-node.js
var dom_node = __webpack_require__(78);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/debugger/devtools-elements.common.js
//Requires


// Use lazy requires for core modules
const getAppRootView = () => __webpack_require__(30).getRootView();
let unsetValue;
function unsetViewValue(view, name) {
    if (!unsetValue) {
        unsetValue = __webpack_require__(1).unsetValue;
    }
    view[name] = unsetValue;
}
function getViewById(nodeId) {
    const node = Object(dom_node["getNodeById"])(nodeId);
    let view;
    if (node) {
        view = node.viewRef.get();
    }
    return view;
}
function getDocument() {
    const appRoot = getAppRootView();
    if (!appRoot) {
        return undefined;
    }
    try {
        appRoot.ensureDomNode();
    }
    catch (e) {
        console.log('ERROR in getDocument(): ' + e);
    }
    return appRoot.domNode.toObject();
}
function getComputedStylesForNode(nodeId) {
    const view = getViewById(nodeId);
    if (view) {
        return view.domNode.getComputedProperties();
    }
    return [];
}
const removeNode = Object(utils_common["o" /* mainThreadify */])(function removeNode(nodeId) {
    const view = getViewById(nodeId);
    if (view) {
        // Avoid importing layout and content view
        let parent = view.parent;
        if (parent.removeChild) {
            parent.removeChild(view);
        }
        else if (parent.content === view) {
            parent.content = null;
        }
        else {
            console.log("Can't remove child from " + parent);
        }
    }
});
const setAttributeAsText = Object(utils_common["o" /* mainThreadify */])(function setAttributeAsText(nodeId, text, name) {
    const view = getViewById(nodeId);
    if (view) {
        // attribute is registered for the view instance
        let hasOriginalAttribute = !!name.trim();
        if (text) {
            let textParts = text.split('=');
            if (textParts.length === 2) {
                let attrName = textParts[0];
                let attrValue = textParts[1].replace(/['"]+/g, '');
                // if attr name is being replaced with another
                if (name !== attrName && hasOriginalAttribute) {
                    unsetViewValue(view, name);
                    view[attrName] = attrValue;
                }
                else {
                    view[hasOriginalAttribute ? name : attrName] = attrValue;
                }
            }
        }
        else {
            // delete attribute
            unsetViewValue(view, name);
        }
        view.domNode.loadAttributes();
    }
});
//# sourceMappingURL=devtools-elements.common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/debugger/devtools-elements.js
// Requires



function attachDOMInspectorEventCallbacks(DOMDomainFrontend) {
    Object(dom_node["registerInspectorEvents"])(DOMDomainFrontend);
    const originalChildNodeInserted = DOMDomainFrontend.childNodeInserted;
    DOMDomainFrontend.childNodeInserted = (parentId, lastId, node) => {
        originalChildNodeInserted(parentId, lastId, node.toObject());
    };
}
function attachDOMInspectorCommandCallbacks(DOMDomainBackend) {
    DOMDomainBackend.getDocument = getDocument;
    DOMDomainBackend.removeNode = removeNode;
    DOMDomainBackend.setAttributeAsText = setAttributeAsText;
}
function attachCSSInspectorCommandCallbacks(CSSDomainBackend) {
    CSSDomainBackend.getComputedStylesForNode = getComputedStylesForNode;
}
//# sourceMappingURL=devtools-elements.ios.js.map; 
if (false ) {} 

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(82);
var TYPE = constants.TYPE;
var NAME = constants.NAME;

var utils = __webpack_require__(76);
var cmpStr = utils.cmpStr;

var EOF = TYPE.EOF;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

var TokenStream = function() {
    this.offsetAndType = null;
    this.balance = null;

    this.reset();
};

TokenStream.prototype = {
    reset: function() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    },

    lookupType: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return EOF;
    },
    lookupOffset: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }

        return this.source.length;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    },

    // TODO: -> skipUntilBalanced
    getRawLength: function(startToken, mode) {
        var cursor = startToken;
        var balanceEnd;
        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
        var type;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

            // check token is stop type
            switch (mode(type, this.source, offset)) {
                case 1:
                    break loop;

                case 2:
                    cursor++;
                    break loop;

                default:
                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }
        }

        return cursor - this.tokenIndex;
    },
    isBalanceEdge: function(pos) {
        return this.balance[this.tokenIndex] < pos;
    },
    isDelim: function(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === TYPE.Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === TYPE.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    getTokenLength: function() {
        return this.tokenEnd - this.tokenStart;
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    forEachToken(fn) {
        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            var start = offset;
            var item = this.offsetAndType[i];
            var end = item & OFFSET_MASK;
            var type = item >> TYPE_SHIFT;

            offset = end;

            fn(type, start, end, i);
        }
    },

    dump() {
        var tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: NAME[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
};

module.exports = TokenStream;
; 
if (false ) {} 

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
var TYPE = {
    EOF: 0,                 // <EOF-token>
    Ident: 1,               // <ident-token>
    Function: 2,            // <function-token>
    AtKeyword: 3,           // <at-keyword-token>
    Hash: 4,                // <hash-token>
    String: 5,              // <string-token>
    BadString: 6,           // <bad-string-token>
    Url: 7,                 // <url-token>
    BadUrl: 8,              // <bad-url-token>
    Delim: 9,               // <delim-token>
    Number: 10,             // <number-token>
    Percentage: 11,         // <percentage-token>
    Dimension: 12,          // <dimension-token>
    WhiteSpace: 13,         // <whitespace-token>
    CDO: 14,                // <CDO-token>
    CDC: 15,                // <CDC-token>
    Colon: 16,              // <colon-token>     :
    Semicolon: 17,          // <semicolon-token> ;
    Comma: 18,              // <comma-token>     ,
    LeftSquareBracket: 19,  // <[-token>
    RightSquareBracket: 20, // <]-token>
    LeftParenthesis: 21,    // <(-token>
    RightParenthesis: 22,   // <)-token>
    LeftCurlyBracket: 23,   // <{-token>
    RightCurlyBracket: 24,  // <}-token>
    Comment: 25
};

var NAME = Object.keys(TYPE).reduce(function(result, key) {
    result[TYPE[key]] = key;
    return result;
}, {});

module.exports = {
    TYPE: TYPE,
    NAME: NAME
};
; 
if (false ) {} 

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CssAnimationParser", function() { return CssAnimationParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseKeyframeDeclarations", function() { return parseKeyframeDeclarations; });
/* harmony import */ var _core_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _animation_keyframe_animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _styling_converters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _styling_style_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);




const ANIMATION_PROPERTY_HANDLERS = Object.freeze({
    'animation-name': (info, value) => (info.name = value),
    'animation-duration': (info, value) => (info.duration = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* timeConverter */ "b"])(value)),
    'animation-delay': (info, value) => (info.delay = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* timeConverter */ "b"])(value)),
    'animation-timing-function': (info, value) => (info.curve = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* animationTimingFunctionConverter */ "a"])(value)),
    'animation-iteration-count': (info, value) => (info.iterations = value === 'infinite' ? Number.MAX_VALUE : parseFloat(value)),
    'animation-direction': (info, value) => (info.isReverse = value === 'reverse'),
    'animation-fill-mode': (info, value) => (info.isForwards = value === 'forwards'),
});
class CssAnimationParser {
    static keyframeAnimationsFromCSSDeclarations(declarations) {
        if (declarations === null || declarations === undefined) {
            return undefined;
        }
        let animations = new Array();
        let animationInfo = undefined;
        declarations.forEach(({ property, value }) => {
            if (property === 'animation') {
                keyframeAnimationsFromCSSProperty(value, animations);
            }
            else {
                const propertyHandler = ANIMATION_PROPERTY_HANDLERS[property];
                if (propertyHandler) {
                    if (animationInfo === undefined) {
                        animationInfo = new _animation_keyframe_animation__WEBPACK_IMPORTED_MODULE_1__["KeyframeAnimationInfo"]();
                        animations.push(animationInfo);
                    }
                    propertyHandler(animationInfo, value);
                }
            }
        });
        return animations.length === 0 ? undefined : animations;
    }
    static keyframesArrayFromCSS(keyframes) {
        let parsedKeyframes = new Array();
        for (let keyframe of keyframes) {
            let declarations = parseKeyframeDeclarations(keyframe.declarations);
            for (let time of keyframe.values) {
                if (time === 'from') {
                    time = 0;
                }
                else if (time === 'to') {
                    time = 1;
                }
                else {
                    time = parseFloat(time) / 100;
                    if (time < 0) {
                        time = 0;
                    }
                    if (time > 100) {
                        time = 100;
                    }
                }
                let current = parsedKeyframes[time];
                if (current === undefined) {
                    current = {};
                    current.duration = time;
                    parsedKeyframes[time] = current;
                }
                for (let declaration of keyframe.declarations) {
                    if (declaration.property === 'animation-timing-function') {
                        current.curve = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* animationTimingFunctionConverter */ "a"])(declaration.value);
                    }
                }
                current.declarations = declarations;
            }
        }
        let array = new Array();
        for (let parsedKeyframe in parsedKeyframes) {
            array.push(parsedKeyframes[parsedKeyframe]);
        }
        array.sort(function (a, b) {
            return a.duration - b.duration;
        });
        return array;
    }
}
function keyframeAnimationsFromCSSProperty(value, animations) {
    if (typeof value === 'string') {
        let values = value.split(/[,]+/);
        for (let parsedValue of values) {
            let animationInfo = new _animation_keyframe_animation__WEBPACK_IMPORTED_MODULE_1__["KeyframeAnimationInfo"]();
            let arr = parsedValue.trim().split(/[ ]+/);
            if (arr.length > 0) {
                animationInfo.name = arr[0];
            }
            if (arr.length > 1) {
                animationInfo.duration = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* timeConverter */ "b"])(arr[1]);
            }
            if (arr.length > 2) {
                animationInfo.curve = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* animationTimingFunctionConverter */ "a"])(arr[2]);
            }
            if (arr.length > 3) {
                animationInfo.delay = Object(_styling_converters__WEBPACK_IMPORTED_MODULE_2__[/* timeConverter */ "b"])(arr[3]);
            }
            if (arr.length > 4) {
                animationInfo.iterations = parseInt(arr[4]);
            }
            if (arr.length > 5) {
                animationInfo.isReverse = arr[4] === 'reverse';
            }
            if (arr.length > 6) {
                animationInfo.isForwards = arr[5] === 'forwards';
            }
            if (arr.length > 7) {
                throw new Error('Invalid value for animation: ' + value);
            }
            animations.push(animationInfo);
        }
    }
}
function parseKeyframeDeclarations(unparsedKeyframeDeclarations) {
    const declarations = unparsedKeyframeDeclarations.reduce((declarations, { property: unparsedProperty, value: unparsedValue }) => {
        const property = _core_properties__WEBPACK_IMPORTED_MODULE_0__["CssAnimationProperty"]._getByCssName(unparsedProperty);
        if (typeof unparsedProperty === 'string' && property && property._valueConverter) {
            declarations[property.name] = property._valueConverter(unparsedValue);
        }
        else if (typeof unparsedValue === 'string' && unparsedProperty === 'transform') {
            const transformations = Object(_styling_style_properties__WEBPACK_IMPORTED_MODULE_3__["transformConverter"])(unparsedValue);
            Object.assign(declarations, transformations);
        }
        return declarations;
    }, {});
    return Object.keys(declarations).map((property) => ({
        property,
        value: declarations[property],
    }));
}
//# sourceMappingURL=css-animation-parser.js.map; 
if (false ) {} 

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Page", function() { return Page; });
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _page_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PageBase", function() { return _page_common__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "actionBarHiddenProperty", function() { return _page_common__WEBPACK_IMPORTED_MODULE_3__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "backgroundSpanUnderStatusBarProperty", function() { return _page_common__WEBPACK_IMPORTED_MODULE_3__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableSwipeBackNavigationProperty", function() { return _page_common__WEBPACK_IMPORTED_MODULE_3__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "statusBarStyleProperty", function() { return _page_common__WEBPACK_IMPORTED_MODULE_3__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "androidStatusBarBackgroundProperty", function() { return _page_common__WEBPACK_IMPORTED_MODULE_3__["c"]; });

// Definitions.

// Types.





const ENTRY = '_entry';
const DELEGATE = '_delegate';
const TRANSITION = '_transition';
const NON_ANIMATED_TRANSITION = 'non-animated';
const majorVersion = _utils__WEBPACK_IMPORTED_MODULE_5__[/* iOSNativeHelper */ "a"].MajorVersion;
function isBackNavigationTo(page, entry) {
    const frame = page.frame;
    if (!frame) {
        return false;
    }
    // if executing context is null here this most probably means back navigation through iOS back button
    const navigationContext = frame._executingContext || {
        navigationType: _frame__WEBPACK_IMPORTED_MODULE_0__[/* NavigationType */ "a"].back,
    };
    const isReplace = navigationContext.navigationType === _frame__WEBPACK_IMPORTED_MODULE_0__[/* NavigationType */ "a"].replace;
    if (isReplace) {
        return false;
    }
    if (frame.navigationQueueIsEmpty()) {
        return true;
    }
    const navigationQueue = frame._navigationQueue;
    for (let i = 0; i < navigationQueue.length; i++) {
        if (navigationQueue[i].entry === entry) {
            return navigationQueue[i].navigationType === _frame__WEBPACK_IMPORTED_MODULE_0__[/* NavigationType */ "a"].back;
        }
    }
    return false;
}
function isBackNavigationFrom(controller, page) {
    if (!page.frame) {
        return false;
    }
    // Controller is cleared or backstack skipped
    if (controller.isBackstackCleared || controller.isBackstackSkipped) {
        return false;
    }
    if (controller.navigationController && controller.navigationController.viewControllers.containsObject(controller)) {
        return false;
    }
    return true;
}
var UIViewControllerImpl = /** @class */ (function (_super) {
    __extends(UIViewControllerImpl, _super);
    function UIViewControllerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIViewControllerImpl.initWithOwner = function (owner) {
        var controller = UIViewControllerImpl.new();
        controller._owner = owner;
        return controller;
    };
    UIViewControllerImpl.prototype.viewDidLoad = function () {
        _super.prototype.viewDidLoad.call(this);
        // Unify translucent and opaque bars layout
        // this.edgesForExtendedLayout = UIRectEdgeBottom;
        this.extendedLayoutIncludesOpaqueBars = true;
    };
    UIViewControllerImpl.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        var frame = this.navigationController ? this.navigationController.owner : null;
        var newEntry = this[ENTRY];
        // Don't raise event if currentPage was showing modal page.
        if (!owner._presentedViewController && newEntry && (!frame || frame.currentPage !== owner)) {
            var isBack = isBackNavigationTo(owner, newEntry);
            owner.onNavigatingTo(newEntry.entry.context, isBack, newEntry.entry.bindingContext);
        }
        if (frame) {
            if (!owner.parent) {
                owner._frame = frame;
                if (!frame._styleScope) {
                    // Make sure page will have styleScope even if frame don't.
                    owner._updateStyleScope();
                }
                frame._addView(owner);
            }
            else if (owner.parent !== frame) {
                throw new Error('Page is already shown on another frame.');
            }
            frame._updateActionBar(owner);
        }
        // Set autoAdjustScrollInsets in will appear - as early as possible
        _core_view__WEBPACK_IMPORTED_MODULE_1__[/* IOSHelper */ "a"].updateAutoAdjustScrollInsets(this, owner);
        // Pages in backstack are unloaded so raise loaded here.
        if (!owner.isLoaded) {
            owner.callLoaded();
        }
        else {
            // Note: Handle the case of canceled backstack navigation. (https://github.com/NativeScript/NativeScript/issues/7430)
            // In this case viewWillAppear will be executed for the previous page and it will change the ActionBar
            // because changes happen in an interactive transition - IOS will animate between the the states.
            // If canceled - viewWillAppear will be called for the current page(which is already loaded) and we need to
            // update the action bar explicitly, so that it is not left styles as the previous page.
            owner.actionBar.update();
        }
    };
    UIViewControllerImpl.prototype.viewDidAppear = function (animated) {
        _super.prototype.viewDidAppear.call(this, animated);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        var navigationController = this.navigationController;
        var frame = navigationController ? navigationController.owner : null;
        // Skip navigation events if modal page is shown.
        if (!owner._presentedViewController && frame) {
            var newEntry = this[ENTRY];
            // frame.setCurrent(...) will reset executing context so retrieve it here
            // if executing context is null here this most probably means back navigation through iOS back button
            var navigationContext = frame._executingContext || {
                navigationType: _frame__WEBPACK_IMPORTED_MODULE_0__[/* NavigationType */ "a"].back,
            };
            var isReplace = navigationContext.navigationType === _frame__WEBPACK_IMPORTED_MODULE_0__[/* NavigationType */ "a"].replace;
            frame.setCurrent(newEntry, navigationContext.navigationType);
            if (isReplace) {
                var controller = newEntry.resolvedPage.ios;
                if (controller) {
                    var animated_1 = frame._getIsAnimatedNavigation(newEntry.entry);
                    if (animated_1) {
                        controller[TRANSITION] = frame._getNavigationTransition(newEntry.entry);
                    }
                    else {
                        controller[TRANSITION] = {
                            name: NON_ANIMATED_TRANSITION,
                        };
                    }
                }
            }
            // If page was shown with custom animation - we need to set the navigationController.delegate to the animatedDelegate.
            frame.ios.controller.delegate = this[DELEGATE];
            frame._processNavigationQueue(owner);
            // _processNavigationQueue will shift navigationQueue. Check canGoBack after that.
            // Workaround for disabled backswipe on second custom native transition
            if (frame.canGoBack()) {
                navigationController.interactivePopGestureRecognizer.delegate = navigationController;
                navigationController.interactivePopGestureRecognizer.enabled = owner.enableSwipeBackNavigation;
            }
            else {
                navigationController.interactivePopGestureRecognizer.enabled = false;
            }
        }
        if (!this.presentedViewController) {
            // clear presented viewController here only if no presented controller.
            // this is needed because in iOS9 the order of events could be - willAppear, willDisappear, didAppear.
            // If we clean it when we have viewController then once presented VC is dismissed then
            owner._presentedViewController = null;
        }
    };
    UIViewControllerImpl.prototype.viewWillDisappear = function (animated) {
        _super.prototype.viewWillDisappear.call(this, animated);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        // Cache presentedViewController if any. We don't want to raise
        // navigation events in case of presenting view controller.
        if (!owner._presentedViewController) {
            owner._presentedViewController = this.presentedViewController;
        }
        var frame = owner.frame;
        // Skip navigation events if we are hiding because we are about to show a modal page,
        // or because we are closing a modal page,
        // or because we are in tab and another controller is selected.
        var tab = this.tabBarController;
        if (owner.onNavigatingFrom && !owner._presentedViewController && !this.presentingViewController && frame && frame.currentPage === owner) {
            var willSelectViewController = tab && tab._willSelectViewController;
            if (!willSelectViewController || willSelectViewController === tab.selectedViewController) {
                var isBack = isBackNavigationFrom(this, owner);
                owner.onNavigatingFrom(isBack);
            }
        }
    };
    UIViewControllerImpl.prototype.viewDidDisappear = function (animated) {
        _super.prototype.viewDidDisappear.call(this, animated);
        var page = this._owner.get();
        // Exit if no page or page is hiding because it shows another page modally.
        if (!page || page.modal || page._presentedViewController) {
            return;
        }
        // Forward navigation does not remove page from frame so we raise unloaded manually.
        if (page.isLoaded) {
            page.callUnloaded();
        }
    };
    UIViewControllerImpl.prototype.viewWillLayoutSubviews = function () {
        _super.prototype.viewWillLayoutSubviews.call(this);
        var owner = this._owner.get();
        if (owner) {
            _core_view__WEBPACK_IMPORTED_MODULE_1__[/* IOSHelper */ "a"].updateConstraints(this, owner);
        }
    };
    UIViewControllerImpl.prototype.viewDidLayoutSubviews = function () {
        _super.prototype.viewDidLayoutSubviews.call(this);
        var owner = this._owner.get();
        if (owner) {
            // layout(owner.actionBar)
            // layout(owner.content)
            if (majorVersion >= 11) {
                // Handle nested Page safe area insets application.
                // A Page is nested if its Frame has a parent.
                // If the Page is nested, cross check safe area insets on top and bottom with Frame parent.
                var frame = owner.parent;
                // There is a legacy scenario where Page is not in a Frame - the root of a Modal View, so it has no parent.
                var frameParent = frame && frame.parent;
                // Handle Angular scenario where TabView is in a ProxyViewContainer
                // It is possible to wrap components in ProxyViewContainers indefinitely
                // Not using instanceof ProxyViewContainer to avoid circular dependency
                // TODO: Try moving UIViewControllerImpl out of page module
                while (frameParent && !frameParent.nativeViewProtected) {
                    frameParent = frameParent.parent;
                }
                if (frameParent) {
                    var parentPageInsetsTop = frameParent.nativeViewProtected.safeAreaInsets.top;
                    var currentInsetsTop = this.view.safeAreaInsets.top;
                    var additionalInsetsTop = Math.max(parentPageInsetsTop - currentInsetsTop, 0);
                    var parentPageInsetsBottom = frameParent.nativeViewProtected.safeAreaInsets.bottom;
                    var currentInsetsBottom = this.view.safeAreaInsets.bottom;
                    var additionalInsetsBottom = Math.max(parentPageInsetsBottom - currentInsetsBottom, 0);
                    if (additionalInsetsTop > 0 || additionalInsetsBottom > 0) {
                        var additionalInsets = new UIEdgeInsets({
                            top: additionalInsetsTop,
                            left: 0,
                            bottom: additionalInsetsBottom,
                            right: 0,
                        });
                        this.additionalSafeAreaInsets = additionalInsets;
                    }
                }
            }
            _core_view__WEBPACK_IMPORTED_MODULE_1__[/* IOSHelper */ "a"].layoutView(this, owner);
        }
    };
    // Mind implementation for other controllerss
    UIViewControllerImpl.prototype.traitCollectionDidChange = function (previousTraitCollection) {
        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
        if (majorVersion >= 13) {
            var owner = this._owner.get();
            if (owner && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection(previousTraitCollection)) {
                owner.notify({
                    eventName: _core_view__WEBPACK_IMPORTED_MODULE_1__[/* IOSHelper */ "a"].traitCollectionColorAppearanceChangedEvent,
                    object: owner,
                });
            }
        }
    };
    Object.defineProperty(UIViewControllerImpl.prototype, "preferredStatusBarStyle", {
        // @ts-ignore
        get: function () {
            var owner = this._owner.get();
            if (owner) {
                return owner.statusBarStyle === 'dark' ? UIStatusBarStyle.LightContent : UIStatusBarStyle.Default;
            }
            else {
                return UIStatusBarStyle.Default;
            }
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        _profiling__WEBPACK_IMPORTED_MODULE_4__[/* profile */ "f"]
    ], UIViewControllerImpl.prototype, "viewDidAppear", null);
    __decorate([
        _profiling__WEBPACK_IMPORTED_MODULE_4__[/* profile */ "f"]
    ], UIViewControllerImpl.prototype, "viewWillDisappear", null);
    __decorate([
        _profiling__WEBPACK_IMPORTED_MODULE_4__[/* profile */ "f"]
    ], UIViewControllerImpl.prototype, "viewDidDisappear", null);
    return UIViewControllerImpl;
}(UIViewController));
class Page extends _page_common__WEBPACK_IMPORTED_MODULE_3__[/* PageBase */ "a"] {
    constructor() {
        super();
        this._backgroundColor = majorVersion <= 12 && !UIColor.systemBackgroundColor ? UIColor.whiteColor : UIColor.systemBackgroundColor;
        const controller = UIViewControllerImpl.initWithOwner(new WeakRef(this));
        this.viewController = this._ios = controller;
        // Make transitions look good
        controller.view.backgroundColor = this._backgroundColor;
    }
    createNativeView() {
        return this.viewController.view;
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    get frame() {
        return this._frame;
    }
    layoutNativeView(left, top, right, bottom) {
        //
    }
    _setNativeViewFrame(nativeView, frame) {
        //
    }
    _shouldDelayLayout() {
        return this._frame && this._frame._animationInProgress;
    }
    onLoaded() {
        super.onLoaded();
        if (this.hasActionBar) {
            this.actionBar.update();
        }
    }
    updateStatusBar() {
        this._updateStatusBarStyle(this.statusBarStyle);
    }
    _updateStatusBarStyle(value) {
        const frame = this.frame;
        if (this.frame && value) {
            const navigationController = frame.ios.controller;
            const navigationBar = navigationController.navigationBar;
            navigationBar.barStyle = value === 'dark' ? 1 /* Black */ : 0 /* Default */;
        }
    }
    _updateEnableSwipeBackNavigation(enabled) {
        const navController = this._ios.navigationController;
        if (this.frame && navController && navController.interactivePopGestureRecognizer) {
            // Make sure we don't set true if cannot go back
            enabled = enabled && this.frame.canGoBack();
            navController.interactivePopGestureRecognizer.enabled = enabled;
        }
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const width = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].getMeasureSpecMode(widthMeasureSpec);
        const height = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].getMeasureSpecMode(heightMeasureSpec);
        if (this.frame && this.frame._getNavBarVisible(this)) {
            const { width, height } = this.actionBar._getActualSize;
            const widthSpec = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].makeMeasureSpec(width, _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].EXACTLY);
            const heightSpec = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].makeMeasureSpec(height, _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].EXACTLY);
            _core_view__WEBPACK_IMPORTED_MODULE_2__[/* View */ "c"].measureChild(this, this.actionBar, widthSpec, heightSpec);
        }
        const result = _core_view__WEBPACK_IMPORTED_MODULE_2__[/* View */ "c"].measureChild(this, this.layoutView, widthMeasureSpec, heightMeasureSpec);
        const measureWidth = Math.max(result.measuredWidth, this.effectiveMinWidth);
        const measureHeight = Math.max(result.measuredHeight, this.effectiveMinHeight);
        const widthAndState = _core_view__WEBPACK_IMPORTED_MODULE_2__[/* View */ "c"].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = _core_view__WEBPACK_IMPORTED_MODULE_2__[/* View */ "c"].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        const { width: actionBarWidth, height: actionBarHeight } = this.actionBar._getActualSize;
        _core_view__WEBPACK_IMPORTED_MODULE_2__[/* View */ "c"].layoutChild(this, this.actionBar, 0, 0, actionBarWidth, actionBarHeight);
        const insets = this.getSafeAreaInsets();
        if (majorVersion <= 10) {
            // iOS 10 and below don't have safe area insets API,
            // there we need only the top inset on the Page
            insets.top = _utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_6__[/* layout */ "n"].toDevicePixels(this.viewController.view.safeAreaLayoutGuide.layoutFrame.origin.y));
        }
        const childLeft = 0 + insets.left;
        const childTop = 0 + insets.top;
        const childRight = right - insets.right;
        let childBottom = bottom - insets.bottom;
        _core_view__WEBPACK_IMPORTED_MODULE_2__[/* View */ "c"].layoutChild(this, this.layoutView, childLeft, childTop, childRight, childBottom);
    }
    _addViewToNativeVisualTree(child, atIndex) {
        // ActionBar is handled by the UINavigationController
        if (child === this.actionBar) {
            return true;
        }
        const nativeParent = this.nativeViewProtected;
        const nativeChild = child.nativeViewProtected;
        const viewController = child.ios instanceof UIViewController ? child.ios : child.viewController;
        if (viewController) {
            // Adding modal controllers to as child will make app freeze.
            if (this.viewController.presentedViewController === viewController) {
                return true;
            }
            this.viewController.addChildViewController(viewController);
        }
        if (nativeParent && nativeChild) {
            if (typeof atIndex !== 'number' || atIndex >= nativeParent.subviews.count) {
                nativeParent.addSubview(nativeChild);
            }
            else {
                nativeParent.insertSubviewAtIndex(nativeChild, atIndex);
            }
            return true;
        }
        return false;
    }
    _removeViewFromNativeVisualTree(child) {
        // ActionBar is handled by the UINavigationController
        if (child === this.actionBar) {
            return;
        }
        const viewController = child.ios instanceof UIViewController ? child.ios : child.viewController;
        if (viewController) {
            viewController.removeFromParentViewController();
        }
        super._removeViewFromNativeVisualTree(child);
    }
    [_page_common__WEBPACK_IMPORTED_MODULE_3__[/* actionBarHiddenProperty */ "b"].setNative](value) {
        this._updateEnableSwipeBackNavigation(value);
        // Invalidate all inner controller.
        invalidateTopmostController(this.viewController);
        const frame = this.frame;
        if (frame) {
            // Update nav-bar visibility with disabled animations
            frame._updateActionBar(this, true);
        }
    }
    [_page_common__WEBPACK_IMPORTED_MODULE_3__[/* statusBarStyleProperty */ "f"].getDefault]() {
        return 0 /* Default */;
    }
    [_page_common__WEBPACK_IMPORTED_MODULE_3__[/* statusBarStyleProperty */ "f"].setNative](value) {
        const frame = this.frame;
        if (frame) {
            const navigationBar = frame.ios.controller.navigationBar;
            if (typeof value === 'string') {
                navigationBar.barStyle = value === 'dark' ? 1 /* Black */ : 0 /* Default */;
            }
            else {
                navigationBar.barStyle = value;
            }
        }
    }
}
function invalidateTopmostController(controller) {
    if (!controller) {
        return;
    }
    controller.view.setNeedsLayout();
    const presentedViewController = controller.presentedViewController;
    if (presentedViewController) {
        return invalidateTopmostController(presentedViewController);
    }
    const childControllers = controller.childViewControllers;
    let size = controller.childViewControllers.count;
    while (size > 0) {
        const childController = childControllers[--size];
        if (childController instanceof UITabBarController) {
            invalidateTopmostController(childController.selectedViewController);
        }
        else if (childController instanceof UINavigationController) {
            invalidateTopmostController(childController.topViewController);
        }
        else if (childController instanceof UISplitViewController) {
            invalidateTopmostController(childController.viewControllers.lastObject);
        }
        else {
            invalidateTopmostController(childController);
        }
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormattedString; });
/* harmony import */ var _span__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _data_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _data_observable_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var _core_view_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);




class FormattedString extends _core_view_base__WEBPACK_IMPORTED_MODULE_3__["ViewBase"] {
    constructor() {
        super();
        this._spans = new _data_observable_array__WEBPACK_IMPORTED_MODULE_2__["ObservableArray"]();
        this._spans.addEventListener(_data_observable_array__WEBPACK_IMPORTED_MODULE_2__["ObservableArray"].changeEvent, this.onSpansCollectionChanged, this);
    }
    get fontFamily() {
        return this.style.fontFamily;
    }
    set fontFamily(value) {
        this.style.fontFamily = value;
    }
    get fontSize() {
        return this.style.fontSize;
    }
    set fontSize(value) {
        this.style.fontSize = value;
    }
    get fontStyle() {
        return this.style.fontStyle;
    }
    set fontStyle(value) {
        this.style.fontStyle = value;
    }
    get fontWeight() {
        return this.style.fontWeight;
    }
    set fontWeight(value) {
        this.style.fontWeight = value;
    }
    get textDecoration() {
        return this.style.textDecoration;
    }
    set textDecoration(value) {
        this.style.textDecoration = value;
    }
    get color() {
        return this.style.color;
    }
    set color(value) {
        this.style.color = value;
    }
    get backgroundColor() {
        return this.style.backgroundColor;
    }
    set backgroundColor(value) {
        this.style.backgroundColor = value;
    }
    get spans() {
        if (!this._spans) {
            this._spans = new _data_observable_array__WEBPACK_IMPORTED_MODULE_2__["ObservableArray"]();
        }
        return this._spans;
    }
    toString() {
        let result = '';
        for (let i = 0, length = this._spans.length; i < length; i++) {
            result += this._spans.getItem(i).text;
        }
        return result;
    }
    _addArrayFromBuilder(name, value) {
        if (name === 'spans') {
            this.spans.push(value);
        }
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof _span__WEBPACK_IMPORTED_MODULE_0__[/* Span */ "a"]) {
            this.spans.push(value);
        }
    }
    onSpansCollectionChanged(eventData) {
        if (eventData.addedCount > 0) {
            for (let i = 0; i < eventData.addedCount; i++) {
                const span = eventData.object.getItem(eventData.index + i);
                // First add to logical tree so that inherited properties are set.
                this._addView(span);
                // Then attach handlers - we skip the first notification because
                // we raise change for the whole instance.
                this.addPropertyChangeHandler(span);
            }
        }
        if (eventData.removed && eventData.removed.length > 0) {
            for (let p = 0; p < eventData.removed.length; p++) {
                const span = eventData.removed[p];
                // First remove handlers so that we don't listen for changes
                // on inherited properties.
                this.removePropertyChangeHandler(span);
                // Then remove the element.
                this._removeView(span);
            }
        }
        this.notifyPropertyChange('.', this);
    }
    addPropertyChangeHandler(span) {
        const style = span.style;
        span.on(_data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"].propertyChangeEvent, this.onPropertyChange, this);
        style.on('fontFamilyChange', this.onPropertyChange, this);
        style.on('fontSizeChange', this.onPropertyChange, this);
        style.on('fontStyleChange', this.onPropertyChange, this);
        style.on('fontWeightChange', this.onPropertyChange, this);
        style.on('textDecorationChange', this.onPropertyChange, this);
        style.on('colorChange', this.onPropertyChange, this);
        style.on('backgroundColorChange', this.onPropertyChange, this);
    }
    removePropertyChangeHandler(span) {
        const style = span.style;
        span.off(_data_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"].propertyChangeEvent, this.onPropertyChange, this);
        style.off('fontFamilyChange', this.onPropertyChange, this);
        style.off('fontSizeChange', this.onPropertyChange, this);
        style.off('fontStyleChange', this.onPropertyChange, this);
        style.off('fontWeightChange', this.onPropertyChange, this);
        style.off('textDecorationChange', this.onPropertyChange, this);
        style.off('colorChange', this.onPropertyChange, this);
        style.off('backgroundColorChange', this.onPropertyChange, this);
    }
    onPropertyChange(data) {
        this.notifyPropertyChange(data.propertyName, this);
    }
    eachChild(callback) {
        this.spans.forEach((v, i, arr) => callback(v));
    }
}
//# sourceMappingURL=formatted-string.js.map; 
if (false ) {} 

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ControlStateChangeListener; });
var ObserverClass = /** @class */ (function (_super) {
    __extends(ObserverClass, _super);
    function ObserverClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // NOTE: Refactor this - use Typescript property instead of strings....
    ObserverClass.prototype.observeValueForKeyPathOfObjectChangeContext = function (path) {
        if (path === 'selected') {
            this['_owner']._onSelectedChanged();
        }
        else if (path === 'enabled') {
            this['_owner']._onEnabledChanged();
        }
        else if (path === 'highlighted') {
            this['_owner']._onHighlightedChanged();
        }
    };
    return ObserverClass;
}(NSObject));
class ControlStateChangeListener {
    constructor(control, callback) {
        this._observing = false;
        this._observer = ObserverClass.alloc().init();
        this._observer['_owner'] = this;
        this._control = control;
        this._callback = callback;
    }
    start() {
        if (!this._observing) {
            this._control.addObserverForKeyPathOptionsContext(this._observer, 'highlighted', 1 /* New */, null);
            this._observing = true;
            this._updateState();
        }
    }
    stop() {
        if (this._observing) {
            this._observing = false;
            this._control.removeObserverForKeyPath(this._observer, 'highlighted');
        }
    }
    //@ts-ignore
    _onEnabledChanged() {
        this._updateState();
    }
    //@ts-ignore
    _onSelectedChanged() {
        this._updateState();
    }
    //@ts-ignore
    _onHighlightedChanged() {
        this._updateState();
    }
    _updateState() {
        let state = 'normal';
        if (this._control.highlighted) {
            state = 'highlighted';
        }
        this._callback(state);
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "ActionBar", function() { return /* reexport */ action_bar["a" /* ActionBar */]; });
__webpack_require__.d(__webpack_exports__, "ActionItem", function() { return /* reexport */ action_bar["b" /* ActionItem */]; });
__webpack_require__.d(__webpack_exports__, "ActionItems", function() { return /* reexport */ action_bar_common["c" /* ActionItems */]; });
__webpack_require__.d(__webpack_exports__, "NavigationButton", function() { return /* reexport */ action_bar["c" /* NavigationButton */]; });
__webpack_require__.d(__webpack_exports__, "ActivityIndicator", function() { return /* reexport */ activity_indicator_ActivityIndicator; });
__webpack_require__.d(__webpack_exports__, "Animation", function() { return /* reexport */ animation["Animation"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeAnimation", function() { return /* reexport */ keyframe_animation["KeyframeAnimation"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeAnimationInfo", function() { return /* reexport */ keyframe_animation["KeyframeAnimationInfo"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeDeclaration", function() { return /* reexport */ keyframe_animation["KeyframeDeclaration"]; });
__webpack_require__.d(__webpack_exports__, "KeyframeInfo", function() { return /* reexport */ keyframe_animation["KeyframeInfo"]; });
__webpack_require__.d(__webpack_exports__, "BottomNavigation", function() { return /* reexport */ bottom_navigation_BottomNavigation; });
__webpack_require__.d(__webpack_exports__, "Builder", function() { return /* reexport */ builder["a" /* Builder */]; });
__webpack_require__.d(__webpack_exports__, "sanitizeModuleName", function() { return /* reexport */ module_name_sanitizer["a" /* sanitizeModuleName */]; });
__webpack_require__.d(__webpack_exports__, "Button", function() { return /* reexport */ ui_button["Button"]; });
__webpack_require__.d(__webpack_exports__, "ContentView", function() { return /* reexport */ content_view["a" /* ContentView */]; });
__webpack_require__.d(__webpack_exports__, "Binding", function() { return /* reexport */ bindable["a" /* Binding */]; });
__webpack_require__.d(__webpack_exports__, "ControlStateChangeListener", function() { return /* reexport */ control_state_change["a" /* ControlStateChangeListener */]; });
__webpack_require__.d(__webpack_exports__, "ViewBase", function() { return /* reexport */ view_base["ViewBase"]; });
__webpack_require__.d(__webpack_exports__, "eachDescendant", function() { return /* reexport */ view_base["eachDescendant"]; });
__webpack_require__.d(__webpack_exports__, "getAncestor", function() { return /* reexport */ view_base["getAncestor"]; });
__webpack_require__.d(__webpack_exports__, "getViewById", function() { return /* reexport */ view_base["getViewById"]; });
__webpack_require__.d(__webpack_exports__, "booleanConverter", function() { return /* reexport */ view_base["booleanConverter"]; });
__webpack_require__.d(__webpack_exports__, "View", function() { return /* reexport */ core_view["c" /* View */]; });
__webpack_require__.d(__webpack_exports__, "CSSType", function() { return /* reexport */ view_common["a" /* CSSType */]; });
__webpack_require__.d(__webpack_exports__, "ContainerView", function() { return /* reexport */ core_view["a" /* ContainerView */]; });
__webpack_require__.d(__webpack_exports__, "ViewHelper", function() { return /* reexport */ view_helper_common["a" /* ViewHelper */]; });
__webpack_require__.d(__webpack_exports__, "IOSHelper", function() { return /* reexport */ view_helper["a" /* IOSHelper */]; });
__webpack_require__.d(__webpack_exports__, "isUserInteractionEnabledProperty", function() { return /* reexport */ view_common["f" /* isUserInteractionEnabledProperty */]; });
__webpack_require__.d(__webpack_exports__, "PseudoClassHandler", function() { return /* reexport */ view_common["b" /* PseudoClassHandler */]; });
__webpack_require__.d(__webpack_exports__, "Property", function() { return /* reexport */ core_properties["Property"]; });
__webpack_require__.d(__webpack_exports__, "CoercibleProperty", function() { return /* reexport */ core_properties["CoercibleProperty"]; });
__webpack_require__.d(__webpack_exports__, "InheritedProperty", function() { return /* reexport */ core_properties["InheritedProperty"]; });
__webpack_require__.d(__webpack_exports__, "CssProperty", function() { return /* reexport */ core_properties["CssProperty"]; });
__webpack_require__.d(__webpack_exports__, "InheritedCssProperty", function() { return /* reexport */ core_properties["InheritedCssProperty"]; });
__webpack_require__.d(__webpack_exports__, "ShorthandProperty", function() { return /* reexport */ core_properties["ShorthandProperty"]; });
__webpack_require__.d(__webpack_exports__, "CssAnimationProperty", function() { return /* reexport */ core_properties["CssAnimationProperty"]; });
__webpack_require__.d(__webpack_exports__, "unsetValue", function() { return /* reexport */ core_properties["unsetValue"]; });
__webpack_require__.d(__webpack_exports__, "makeParser", function() { return /* reexport */ core_properties["makeParser"]; });
__webpack_require__.d(__webpack_exports__, "makeValidator", function() { return /* reexport */ core_properties["makeValidator"]; });
__webpack_require__.d(__webpack_exports__, "addWeakEventListener", function() { return /* reexport */ weak_event_listener["a" /* addWeakEventListener */]; });
__webpack_require__.d(__webpack_exports__, "removeWeakEventListener", function() { return /* reexport */ weak_event_listener["b" /* removeWeakEventListener */]; });
__webpack_require__.d(__webpack_exports__, "DatePicker", function() { return /* reexport */ date_picker_DatePicker; });
__webpack_require__.d(__webpack_exports__, "DialogStrings", function() { return /* reexport */ dialogs_common["a" /* DialogStrings */]; });
__webpack_require__.d(__webpack_exports__, "action", function() { return /* reexport */ dialogs["action"]; });
__webpack_require__.d(__webpack_exports__, "alert", function() { return /* reexport */ dialogs["alert"]; });
__webpack_require__.d(__webpack_exports__, "confirm", function() { return /* reexport */ dialogs["confirm"]; });
__webpack_require__.d(__webpack_exports__, "login", function() { return /* reexport */ dialogs["login"]; });
__webpack_require__.d(__webpack_exports__, "prompt", function() { return /* reexport */ dialogs["prompt"]; });
__webpack_require__.d(__webpack_exports__, "getCurrentPage", function() { return /* reexport */ dialogs_common["d" /* getCurrentPage */]; });
__webpack_require__.d(__webpack_exports__, "Dialogs", function() { return /* reexport */ dialogs["Dialogs"]; });
__webpack_require__.d(__webpack_exports__, "inputType", function() { return /* reexport */ dialogs_common["g" /* inputType */]; });
__webpack_require__.d(__webpack_exports__, "capitalizationType", function() { return /* reexport */ dialogs_common["b" /* capitalizationType */]; });
__webpack_require__.d(__webpack_exports__, "placeholderColorProperty", function() { return /* reexport */ editable_text_base["i" /* placeholderColorProperty */]; });
__webpack_require__.d(__webpack_exports__, "keyboardTypeProperty", function() { return /* reexport */ editable_text_base["g" /* keyboardTypeProperty */]; });
__webpack_require__.d(__webpack_exports__, "returnKeyTypeProperty", function() { return /* reexport */ editable_text_base["j" /* returnKeyTypeProperty */]; });
__webpack_require__.d(__webpack_exports__, "editableProperty", function() { return /* reexport */ editable_text_base["e" /* editableProperty */]; });
__webpack_require__.d(__webpack_exports__, "updateTextTriggerProperty", function() { return /* reexport */ editable_text_base["k" /* updateTextTriggerProperty */]; });
__webpack_require__.d(__webpack_exports__, "autocapitalizationTypeProperty", function() { return /* reexport */ editable_text_base["c" /* autocapitalizationTypeProperty */]; });
__webpack_require__.d(__webpack_exports__, "autocorrectProperty", function() { return /* reexport */ editable_text_base["d" /* autocorrectProperty */]; });
__webpack_require__.d(__webpack_exports__, "hintProperty", function() { return /* reexport */ editable_text_base["f" /* hintProperty */]; });
__webpack_require__.d(__webpack_exports__, "maxLengthProperty", function() { return /* reexport */ editable_text_base["h" /* maxLengthProperty */]; });
__webpack_require__.d(__webpack_exports__, "EditableTextBase", function() { return /* reexport */ editable_text_base["a" /* EditableTextBase */]; });
__webpack_require__.d(__webpack_exports__, "_updateCharactersInRangeReplacementString", function() { return /* reexport */ editable_text_base["b" /* _updateCharactersInRangeReplacementString */]; });
__webpack_require__.d(__webpack_exports__, "Enums", function() { return /* reexport */ enums["Enums"]; });
__webpack_require__.d(__webpack_exports__, "Frame", function() { return /* reexport */ ui_frame["Frame"]; });
__webpack_require__.d(__webpack_exports__, "setActivityCallbacks", function() { return /* reexport */ ui_frame["setActivityCallbacks"]; });
__webpack_require__.d(__webpack_exports__, "GesturesObserver", function() { return /* reexport */ gestures["GesturesObserver"]; });
__webpack_require__.d(__webpack_exports__, "TouchAction", function() { return /* reexport */ gestures_common["e" /* TouchAction */]; });
__webpack_require__.d(__webpack_exports__, "GestureTypes", function() { return /* reexport */ gestures_common["b" /* GestureTypes */]; });
__webpack_require__.d(__webpack_exports__, "GestureStateTypes", function() { return /* reexport */ gestures_common["a" /* GestureStateTypes */]; });
__webpack_require__.d(__webpack_exports__, "SwipeDirection", function() { return /* reexport */ gestures_common["d" /* SwipeDirection */]; });
__webpack_require__.d(__webpack_exports__, "HtmlView", function() { return /* reexport */ html_view_HtmlView; });
__webpack_require__.d(__webpack_exports__, "Image", function() { return /* reexport */ image_Image; });
__webpack_require__.d(__webpack_exports__, "ImageCache", function() { return /* reexport */ image_cache_Cache; });
__webpack_require__.d(__webpack_exports__, "Label", function() { return /* reexport */ ui_label["Label"]; });
__webpack_require__.d(__webpack_exports__, "AbsoluteLayout", function() { return /* reexport */ absolute_layout_AbsoluteLayout; });
__webpack_require__.d(__webpack_exports__, "DockLayout", function() { return /* reexport */ dock_layout_DockLayout; });
__webpack_require__.d(__webpack_exports__, "FlexboxLayout", function() { return /* reexport */ flexbox_layout_FlexboxLayout; });
__webpack_require__.d(__webpack_exports__, "GridLayout", function() { return /* reexport */ grid_layout["GridLayout"]; });
__webpack_require__.d(__webpack_exports__, "GridUnitType", function() { return /* reexport */ grid_layout_common["b" /* GridUnitType */]; });
__webpack_require__.d(__webpack_exports__, "ItemSpec", function() { return /* reexport */ grid_layout_common["c" /* ItemSpec */]; });
__webpack_require__.d(__webpack_exports__, "StackLayout", function() { return /* reexport */ stack_layout["StackLayout"]; });
__webpack_require__.d(__webpack_exports__, "WrapLayout", function() { return /* reexport */ wrap_layout_WrapLayout; });
__webpack_require__.d(__webpack_exports__, "LayoutBase", function() { return /* reexport */ layout_base["a" /* LayoutBase */]; });
__webpack_require__.d(__webpack_exports__, "ListPicker", function() { return /* reexport */ list_picker_ListPicker; });
__webpack_require__.d(__webpack_exports__, "ListView", function() { return /* reexport */ list_view_ListView; });
__webpack_require__.d(__webpack_exports__, "Page", function() { return /* reexport */ ui_page["Page"]; });
__webpack_require__.d(__webpack_exports__, "PageBase", function() { return /* reexport */ page_common["a" /* PageBase */]; });
__webpack_require__.d(__webpack_exports__, "Placeholder", function() { return /* reexport */ placeholder_Placeholder; });
__webpack_require__.d(__webpack_exports__, "Progress", function() { return /* reexport */ progress_Progress; });
__webpack_require__.d(__webpack_exports__, "ProxyViewContainer", function() { return /* reexport */ proxy_view_container_ProxyViewContainer; });
__webpack_require__.d(__webpack_exports__, "Repeater", function() { return /* reexport */ repeater_Repeater; });
__webpack_require__.d(__webpack_exports__, "ScrollView", function() { return /* reexport */ scroll_view_ScrollView; });
__webpack_require__.d(__webpack_exports__, "SearchBar", function() { return /* reexport */ search_bar_SearchBar; });
__webpack_require__.d(__webpack_exports__, "SegmentedBar", function() { return /* reexport */ segmented_bar_SegmentedBar; });
__webpack_require__.d(__webpack_exports__, "SegmentedBarItem", function() { return /* reexport */ segmented_bar_SegmentedBarItem; });
__webpack_require__.d(__webpack_exports__, "Slider", function() { return /* reexport */ slider_Slider; });
__webpack_require__.d(__webpack_exports__, "addTaggedAdditionalCSS", function() { return /* reexport */ style_scope["addTaggedAdditionalCSS"]; });
__webpack_require__.d(__webpack_exports__, "removeTaggedAdditionalCSS", function() { return /* reexport */ style_scope["removeTaggedAdditionalCSS"]; });
__webpack_require__.d(__webpack_exports__, "resolveFileNameFromUrl", function() { return /* reexport */ style_scope["resolveFileNameFromUrl"]; });
__webpack_require__.d(__webpack_exports__, "Background", function() { return /* reexport */ background_common["a" /* Background */]; });
__webpack_require__.d(__webpack_exports__, "animationTimingFunctionConverter", function() { return /* reexport */ converters["a" /* animationTimingFunctionConverter */]; });
__webpack_require__.d(__webpack_exports__, "timeConverter", function() { return /* reexport */ converters["b" /* timeConverter */]; });
__webpack_require__.d(__webpack_exports__, "Font", function() { return /* reexport */ styling_font["a" /* Font */]; });
__webpack_require__.d(__webpack_exports__, "Style", function() { return /* reexport */ style["a" /* Style */]; });
__webpack_require__.d(__webpack_exports__, "PercentLength", function() { return /* reexport */ style_properties["PercentLength"]; });
__webpack_require__.d(__webpack_exports__, "Length", function() { return /* reexport */ style_properties["Length"]; });
__webpack_require__.d(__webpack_exports__, "zeroLength", function() { return /* reexport */ style_properties["zeroLength"]; });
__webpack_require__.d(__webpack_exports__, "minWidthProperty", function() { return /* reexport */ style_properties["minWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "minHeightProperty", function() { return /* reexport */ style_properties["minHeightProperty"]; });
__webpack_require__.d(__webpack_exports__, "widthProperty", function() { return /* reexport */ style_properties["widthProperty"]; });
__webpack_require__.d(__webpack_exports__, "heightProperty", function() { return /* reexport */ style_properties["heightProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginLeftProperty", function() { return /* reexport */ style_properties["marginLeftProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginRightProperty", function() { return /* reexport */ style_properties["marginRightProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginTopProperty", function() { return /* reexport */ style_properties["marginTopProperty"]; });
__webpack_require__.d(__webpack_exports__, "marginBottomProperty", function() { return /* reexport */ style_properties["marginBottomProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingLeftProperty", function() { return /* reexport */ style_properties["paddingLeftProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingRightProperty", function() { return /* reexport */ style_properties["paddingRightProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingTopProperty", function() { return /* reexport */ style_properties["paddingTopProperty"]; });
__webpack_require__.d(__webpack_exports__, "paddingBottomProperty", function() { return /* reexport */ style_properties["paddingBottomProperty"]; });
__webpack_require__.d(__webpack_exports__, "HorizontalAlignment", function() { return /* reexport */ style_properties["HorizontalAlignment"]; });
__webpack_require__.d(__webpack_exports__, "horizontalAlignmentProperty", function() { return /* reexport */ style_properties["horizontalAlignmentProperty"]; });
__webpack_require__.d(__webpack_exports__, "VerticalAlignment", function() { return /* reexport */ style_properties["VerticalAlignment"]; });
__webpack_require__.d(__webpack_exports__, "verticalAlignmentProperty", function() { return /* reexport */ style_properties["verticalAlignmentProperty"]; });
__webpack_require__.d(__webpack_exports__, "rotateProperty", function() { return /* reexport */ style_properties["rotateProperty"]; });
__webpack_require__.d(__webpack_exports__, "rotateXProperty", function() { return /* reexport */ style_properties["rotateXProperty"]; });
__webpack_require__.d(__webpack_exports__, "rotateYProperty", function() { return /* reexport */ style_properties["rotateYProperty"]; });
__webpack_require__.d(__webpack_exports__, "perspectiveProperty", function() { return /* reexport */ style_properties["perspectiveProperty"]; });
__webpack_require__.d(__webpack_exports__, "scaleXProperty", function() { return /* reexport */ style_properties["scaleXProperty"]; });
__webpack_require__.d(__webpack_exports__, "scaleYProperty", function() { return /* reexport */ style_properties["scaleYProperty"]; });
__webpack_require__.d(__webpack_exports__, "translateXProperty", function() { return /* reexport */ style_properties["translateXProperty"]; });
__webpack_require__.d(__webpack_exports__, "translateYProperty", function() { return /* reexport */ style_properties["translateYProperty"]; });
__webpack_require__.d(__webpack_exports__, "transformConverter", function() { return /* reexport */ style_properties["transformConverter"]; });
__webpack_require__.d(__webpack_exports__, "backgroundInternalProperty", function() { return /* reexport */ style_properties["backgroundInternalProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundImageProperty", function() { return /* reexport */ style_properties["backgroundImageProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundColorProperty", function() { return /* reexport */ style_properties["backgroundColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "BackgroundRepeat", function() { return /* reexport */ style_properties["BackgroundRepeat"]; });
__webpack_require__.d(__webpack_exports__, "backgroundRepeatProperty", function() { return /* reexport */ style_properties["backgroundRepeatProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundSizeProperty", function() { return /* reexport */ style_properties["backgroundSizeProperty"]; });
__webpack_require__.d(__webpack_exports__, "backgroundPositionProperty", function() { return /* reexport */ style_properties["backgroundPositionProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopColorProperty", function() { return /* reexport */ style_properties["borderTopColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderRightColorProperty", function() { return /* reexport */ style_properties["borderRightColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomColorProperty", function() { return /* reexport */ style_properties["borderBottomColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderLeftColorProperty", function() { return /* reexport */ style_properties["borderLeftColorProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopWidthProperty", function() { return /* reexport */ style_properties["borderTopWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderRightWidthProperty", function() { return /* reexport */ style_properties["borderRightWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomWidthProperty", function() { return /* reexport */ style_properties["borderBottomWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderLeftWidthProperty", function() { return /* reexport */ style_properties["borderLeftWidthProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopLeftRadiusProperty", function() { return /* reexport */ style_properties["borderTopLeftRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderTopRightRadiusProperty", function() { return /* reexport */ style_properties["borderTopRightRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomRightRadiusProperty", function() { return /* reexport */ style_properties["borderBottomRightRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "borderBottomLeftRadiusProperty", function() { return /* reexport */ style_properties["borderBottomLeftRadiusProperty"]; });
__webpack_require__.d(__webpack_exports__, "clipPathProperty", function() { return /* reexport */ style_properties["clipPathProperty"]; });
__webpack_require__.d(__webpack_exports__, "zIndexProperty", function() { return /* reexport */ style_properties["zIndexProperty"]; });
__webpack_require__.d(__webpack_exports__, "opacityProperty", function() { return /* reexport */ style_properties["opacityProperty"]; });
__webpack_require__.d(__webpack_exports__, "colorProperty", function() { return /* reexport */ style_properties["colorProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontInternalProperty", function() { return /* reexport */ style_properties["fontInternalProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontFamilyProperty", function() { return /* reexport */ style_properties["fontFamilyProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontSizeProperty", function() { return /* reexport */ style_properties["fontSizeProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontStyleProperty", function() { return /* reexport */ style_properties["fontStyleProperty"]; });
__webpack_require__.d(__webpack_exports__, "fontWeightProperty", function() { return /* reexport */ style_properties["fontWeightProperty"]; });
__webpack_require__.d(__webpack_exports__, "Visibility", function() { return /* reexport */ style_properties["Visibility"]; });
__webpack_require__.d(__webpack_exports__, "visibilityProperty", function() { return /* reexport */ style_properties["visibilityProperty"]; });
__webpack_require__.d(__webpack_exports__, "androidElevationProperty", function() { return /* reexport */ style_properties["androidElevationProperty"]; });
__webpack_require__.d(__webpack_exports__, "androidDynamicElevationOffsetProperty", function() { return /* reexport */ style_properties["androidDynamicElevationOffsetProperty"]; });
__webpack_require__.d(__webpack_exports__, "CssAnimationParser", function() { return /* reexport */ css_animation_parser["CssAnimationParser"]; });
__webpack_require__.d(__webpack_exports__, "parseKeyframeDeclarations", function() { return /* reexport */ css_animation_parser["parseKeyframeDeclarations"]; });
__webpack_require__.d(__webpack_exports__, "CSSHelper", function() { return /* reexport */ css_selector["a" /* CSSHelper */]; });
__webpack_require__.d(__webpack_exports__, "Switch", function() { return /* reexport */ switch_Switch; });
__webpack_require__.d(__webpack_exports__, "TabContentItem", function() { return /* reexport */ tab_content_item_TabContentItem; });
__webpack_require__.d(__webpack_exports__, "TabNavigationBase", function() { return /* reexport */ tab_navigation_base_TabNavigationBase; });
__webpack_require__.d(__webpack_exports__, "getIconSpecSize", function() { return /* reexport */ getIconSpecSize; });
__webpack_require__.d(__webpack_exports__, "tabStripProperty", function() { return /* reexport */ tabStripProperty; });
__webpack_require__.d(__webpack_exports__, "TabStrip", function() { return /* reexport */ tab_strip_TabStrip; });
__webpack_require__.d(__webpack_exports__, "TabStripItem", function() { return /* reexport */ tab_strip_item_TabStripItem; });
__webpack_require__.d(__webpack_exports__, "TabView", function() { return /* reexport */ tab_view_TabView; });
__webpack_require__.d(__webpack_exports__, "TabViewItem", function() { return /* reexport */ tab_view_TabViewItem; });
__webpack_require__.d(__webpack_exports__, "Tabs", function() { return /* reexport */ tabs_Tabs; });
__webpack_require__.d(__webpack_exports__, "TextBase", function() { return /* reexport */ text_base["a" /* TextBase */]; });
__webpack_require__.d(__webpack_exports__, "getTransformedText", function() { return /* reexport */ text_base["b" /* getTransformedText */]; });
__webpack_require__.d(__webpack_exports__, "letterSpacingProperty", function() { return /* reexport */ text_base_common["d" /* letterSpacingProperty */]; });
__webpack_require__.d(__webpack_exports__, "textAlignmentProperty", function() { return /* reexport */ text_base_common["g" /* textAlignmentProperty */]; });
__webpack_require__.d(__webpack_exports__, "textDecorationProperty", function() { return /* reexport */ text_base_common["h" /* textDecorationProperty */]; });
__webpack_require__.d(__webpack_exports__, "textTransformProperty", function() { return /* reexport */ text_base_common["j" /* textTransformProperty */]; });
__webpack_require__.d(__webpack_exports__, "whiteSpaceProperty", function() { return /* reexport */ text_base_common["k" /* whiteSpaceProperty */]; });
__webpack_require__.d(__webpack_exports__, "lineHeightProperty", function() { return /* reexport */ text_base_common["e" /* lineHeightProperty */]; });
__webpack_require__.d(__webpack_exports__, "FormattedString", function() { return /* reexport */ formatted_string["a" /* FormattedString */]; });
__webpack_require__.d(__webpack_exports__, "Span", function() { return /* reexport */ span["a" /* Span */]; });
__webpack_require__.d(__webpack_exports__, "TextField", function() { return /* reexport */ text_field["TextField"]; });
__webpack_require__.d(__webpack_exports__, "TextView", function() { return /* reexport */ text_view_TextView; });
__webpack_require__.d(__webpack_exports__, "TimePicker", function() { return /* reexport */ time_picker_TimePicker; });
__webpack_require__.d(__webpack_exports__, "Transition", function() { return /* reexport */ transition["a" /* Transition */]; });
__webpack_require__.d(__webpack_exports__, "WebView", function() { return /* reexport */ web_view_WebView; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/action-bar/index.js
var action_bar = __webpack_require__(64);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/action-bar/action-bar-common.js
var action_bar_common = __webpack_require__(53);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/index.js
var core_view = __webpack_require__(3);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-common.js
var view_common = __webpack_require__(31);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view-base/index.js
var view_base = __webpack_require__(15);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var core_properties = __webpack_require__(1);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/activity-indicator/activity-indicator-common.js



let activity_indicator_common_ActivityIndicatorBase = class ActivityIndicatorBase extends core_view["c" /* View */] {
};
activity_indicator_common_ActivityIndicatorBase = __decorate([
    Object(view_common["a" /* CSSType */])('ActivityIndicator')
], activity_indicator_common_ActivityIndicatorBase);

activity_indicator_common_ActivityIndicatorBase.prototype.recycleNativeView = 'auto';
const busyProperty = new core_properties["Property"]({
    name: 'busy',
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
});
busyProperty.register(activity_indicator_common_ActivityIndicatorBase);
//# sourceMappingURL=activity-indicator-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style-properties.js + 2 modules
var style_properties = __webpack_require__(2);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/color/index.js + 2 modules
var core_color = __webpack_require__(6);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/native-helper.js
var native_helper = __webpack_require__(38);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/activity-indicator/index.js





const majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
class activity_indicator_ActivityIndicator extends activity_indicator_common_ActivityIndicatorBase {
    constructor() {
        super(...arguments);
        this._activityIndicatorViewStyle = majorVersion <= 12 || !100 /* Medium */ ? 2 /* Gray */ : 100 /* Medium */;
    }
    createNativeView() {
        const viewStyle = this._activityIndicatorViewStyle;
        const view = UIActivityIndicatorView.alloc().initWithActivityIndicatorStyle(viewStyle);
        view.hidesWhenStopped = true;
        return view;
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    [busyProperty.getDefault]() {
        if (this.nativeViewProtected.isAnimating) {
            return this.nativeViewProtected.isAnimating();
        }
        else {
            return this.nativeViewProtected.animating;
        }
    }
    [busyProperty.setNative](value) {
        let nativeView = this.nativeViewProtected;
        if (value) {
            nativeView.startAnimating();
        }
        else {
            nativeView.stopAnimating();
        }
        if (nativeView.hidesWhenStopped) {
            this.requestLayout();
        }
    }
    [style_properties["colorProperty"].getDefault]() {
        return this.nativeViewProtected.color;
    }
    [style_properties["colorProperty"].setNative](value) {
        this.nativeViewProtected.color = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/animation/index.js
var animation = __webpack_require__(68);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/animation/keyframe-animation.js
var keyframe_animation = __webpack_require__(56);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/image-asset/index.js + 1 modules
var image_asset = __webpack_require__(88);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/image-source/index.js + 1 modules
var image_source = __webpack_require__(25);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style/index.js
var style = __webpack_require__(7);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/trace/index.js
var trace = __webpack_require__(0);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/image/image-common.js










let image_common_ImageBase = class ImageBase extends core_view["c" /* View */] {
    get tintColor() {
        return this.style.tintColor;
    }
    set tintColor(value) {
        this.style.tintColor = value;
    }
    /**
     * @internal
     */
    _createImageSourceFromSrc(value) {
        const originalValue = value;
        const sync = this.loadMode === 'sync';
        if (typeof value === 'string' || value instanceof String) {
            value = value.trim();
            this.imageSource = null;
            this['_url'] = value;
            this.isLoading = true;
            const imageLoaded = (source) => {
                let currentValue = this.src;
                if (currentValue !== originalValue) {
                    return;
                }
                this.imageSource = source;
                this.isLoading = false;
            };
            if (Object(utils_common["l" /* isFontIconURI */])(value)) {
                const fontIconCode = value.split('//')[1];
                if (fontIconCode !== undefined) {
                    // support sync mode only
                    const font = this.style.fontInternal;
                    const color = this.style.color;
                    imageLoaded(image_source["ImageSource"].fromFontIconCodeSync(fontIconCode, font, color));
                }
            }
            else if (Object(utils_common["j" /* isDataURI */])(value)) {
                const base64Data = value.split(',')[1];
                if (base64Data !== undefined) {
                    if (sync) {
                        imageLoaded(image_source["ImageSource"].fromBase64Sync(base64Data));
                    }
                    else {
                        image_source["ImageSource"].fromBase64(base64Data).then(imageLoaded);
                    }
                }
            }
            else if (Object(utils_common["k" /* isFileOrResourcePath */])(value)) {
                if (value.indexOf(utils_common["b" /* RESOURCE_PREFIX */]) === 0) {
                    const resPath = value.substr(utils_common["b" /* RESOURCE_PREFIX */].length);
                    if (sync) {
                        imageLoaded(image_source["ImageSource"].fromResourceSync(resPath));
                    }
                    else {
                        this.imageSource = null;
                        image_source["ImageSource"].fromResource(resPath).then(imageLoaded);
                    }
                }
                else {
                    if (sync) {
                        imageLoaded(image_source["ImageSource"].fromFileSync(value));
                    }
                    else {
                        this.imageSource = null;
                        image_source["ImageSource"].fromFile(value).then(imageLoaded);
                    }
                }
            }
            else {
                this.imageSource = null;
                image_source["ImageSource"].fromUrl(value).then((r) => {
                    if (this['_url'] === value) {
                        this.imageSource = r;
                        this.isLoading = false;
                    }
                }, (err) => {
                    // catch: Response content may not be converted to an Image
                    this.isLoading = false;
                    if (trace["a" /* Trace */].isEnabled()) {
                        if (typeof err === 'object' && err.message) {
                            err = err.message;
                        }
                        trace["a" /* Trace */].write(err, trace["a" /* Trace */].categories.Debug);
                    }
                });
            }
        }
        else if (value instanceof image_source["ImageSource"]) {
            // Support binding the imageSource trough the src property
            this.imageSource = value;
            this.isLoading = false;
        }
        else if (value instanceof image_asset["a" /* ImageAsset */]) {
            image_source["ImageSource"].fromAsset(value).then((result) => {
                this.imageSource = result;
                this.isLoading = false;
            });
        }
        else {
            this.imageSource = new image_source["ImageSource"](value);
            this.isLoading = false;
        }
    }
};
image_common_ImageBase = __decorate([
    Object(view_common["a" /* CSSType */])('Image')
], image_common_ImageBase);

image_common_ImageBase.prototype.recycleNativeView = 'auto';
const imageSourceProperty = new core_properties["Property"]({
    name: 'imageSource',
});
imageSourceProperty.register(image_common_ImageBase);
const srcProperty = new core_properties["Property"]({ name: 'src' });
srcProperty.register(image_common_ImageBase);
const loadModeProperty = new core_properties["Property"]({
    name: 'loadMode',
    defaultValue: 'sync',
});
loadModeProperty.register(image_common_ImageBase);
const isLoadingProperty = new core_properties["Property"]({
    name: 'isLoading',
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
});
isLoadingProperty.register(image_common_ImageBase);
const stretchProperty = new core_properties["Property"]({
    name: 'stretch',
    defaultValue: 'aspectFit',
    affectsLayout: true,
});
stretchProperty.register(image_common_ImageBase);
const tintColorProperty = new core_properties["InheritedCssProperty"]({
    name: 'tintColor',
    cssName: 'tint-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (value) => new core_color["a" /* Color */](value),
});
tintColorProperty.register(style["a" /* Style */]);
const decodeHeightProperty = new core_properties["Property"]({
    name: 'decodeHeight',
    defaultValue: { value: 0, unit: 'dip' },
    valueConverter: style_properties["Length"].parse,
});
decodeHeightProperty.register(image_common_ImageBase);
const decodeWidthProperty = new core_properties["Property"]({
    name: 'decodeWidth',
    defaultValue: { value: 0, unit: 'dip' },
    valueConverter: style_properties["Length"].parse,
});
decodeWidthProperty.register(image_common_ImageBase);
//# sourceMappingURL=image-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/image/index.js




class image_Image extends image_common_ImageBase {
    constructor() {
        super(...arguments);
        this._imageSourceAffectsLayout = true;
    }
    createNativeView() {
        const imageView = UIImageView.new();
        imageView.contentMode = 1 /* ScaleAspectFit */;
        imageView.userInteractionEnabled = true;
        return imageView;
    }
    initNativeView() {
        super.initNativeView();
        this._setNativeClipToBounds();
    }
    setTintColor(value) {
        if (value && this.nativeViewProtected.image && !this._templateImageWasCreated) {
            this.nativeViewProtected.image = this.nativeViewProtected.image.imageWithRenderingMode(2 /* AlwaysTemplate */);
            this._templateImageWasCreated = true;
        }
        else if (!value && this.nativeViewProtected.image && this._templateImageWasCreated) {
            this._templateImageWasCreated = false;
            this.nativeViewProtected.image = this.nativeViewProtected.image.imageWithRenderingMode(0 /* Automatic */);
        }
        this.nativeViewProtected.tintColor = value ? value.ios : null;
    }
    _setNativeImage(nativeImage) {
        this.nativeViewProtected.image = nativeImage;
        this._templateImageWasCreated = false;
        this.setTintColor(this.style.tintColor);
        if (this._imageSourceAffectsLayout) {
            this.requestLayout();
        }
    }
    _setNativeClipToBounds() {
        // Always set clipsToBounds for images
        this.nativeViewProtected.clipsToBounds = true;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        // We don't call super because we measure native view with specific size.
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const nativeWidth = this.imageSource ? utils_common["n" /* layout */].toDevicePixels(this.imageSource.width) : 0;
        const nativeHeight = this.imageSource ? utils_common["n" /* layout */].toDevicePixels(this.imageSource.height) : 0;
        let measureWidth = Math.max(nativeWidth, this.effectiveMinWidth);
        let measureHeight = Math.max(nativeHeight, this.effectiveMinHeight);
        const finiteWidth = widthMode !== utils_common["n" /* layout */].UNSPECIFIED;
        const finiteHeight = heightMode !== utils_common["n" /* layout */].UNSPECIFIED;
        this._imageSourceAffectsLayout = widthMode !== utils_common["n" /* layout */].EXACTLY || heightMode !== utils_common["n" /* layout */].EXACTLY;
        if (nativeWidth !== 0 && nativeHeight !== 0 && (finiteWidth || finiteHeight)) {
            const scale = image_Image.computeScaleFactor(width, height, finiteWidth, finiteHeight, nativeWidth, nativeHeight, this.stretch);
            const resultW = Math.round(nativeWidth * scale.width);
            const resultH = Math.round(nativeHeight * scale.height);
            measureWidth = finiteWidth ? Math.min(resultW, width) : resultW;
            measureHeight = finiteHeight ? Math.min(resultH, height) : resultH;
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write('Image stretch: ' + this.stretch + ', nativeWidth: ' + nativeWidth + ', nativeHeight: ' + nativeHeight, trace["a" /* Trace */].categories.Layout);
            }
        }
        const widthAndState = image_Image.resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = image_Image.resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    static computeScaleFactor(measureWidth, measureHeight, widthIsFinite, heightIsFinite, nativeWidth, nativeHeight, imageStretch) {
        let scaleW = 1;
        let scaleH = 1;
        if ((imageStretch === 'aspectFill' || imageStretch === 'aspectFit' || imageStretch === 'fill') && (widthIsFinite || heightIsFinite)) {
            scaleW = nativeWidth > 0 ? measureWidth / nativeWidth : 0;
            scaleH = nativeHeight > 0 ? measureHeight / nativeHeight : 0;
            if (!widthIsFinite) {
                scaleW = scaleH;
            }
            else if (!heightIsFinite) {
                scaleH = scaleW;
            }
            else {
                // No infinite dimensions.
                switch (imageStretch) {
                    case 'aspectFit':
                        scaleH = scaleW < scaleH ? scaleW : scaleH;
                        scaleW = scaleH;
                        break;
                    case 'aspectFill':
                        scaleH = scaleW > scaleH ? scaleW : scaleH;
                        scaleW = scaleH;
                        break;
                }
            }
        }
        return { width: scaleW, height: scaleH };
    }
    [stretchProperty.setNative](value) {
        switch (value) {
            case 'aspectFit':
                this.nativeViewProtected.contentMode = 1 /* ScaleAspectFit */;
                break;
            case 'aspectFill':
                this.nativeViewProtected.contentMode = 2 /* ScaleAspectFill */;
                break;
            case 'fill':
                this.nativeViewProtected.contentMode = 0 /* ScaleToFill */;
                break;
            case 'none':
            default:
                this.nativeViewProtected.contentMode = 9 /* TopLeft */;
                break;
        }
    }
    [tintColorProperty.setNative](value) {
        this.setTintColor(value);
    }
    [imageSourceProperty.setNative](value) {
        this._setNativeImage(value ? value.ios : null);
    }
    [srcProperty.setNative](value) {
        this._createImageSourceFromSrc(value);
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/label/index.js
var ui_label = __webpack_require__(46);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/text-base-common.js
var text_base_common = __webpack_require__(35);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-navigation-base/tab-strip-item/index.js
var TabStripItem_1;

// Requires





let tab_strip_item_TabStripItem = TabStripItem_1 = class TabStripItem extends core_view["c" /* View */] {
    get title() {
        if (this.isLoaded) {
            return this.label.text;
        }
        return this._title;
    }
    set title(value) {
        this._title = value;
        if (this.isLoaded) {
            this.label.text = value;
        }
    }
    get iconClass() {
        if (this.isLoaded) {
            return this.image.className;
        }
        return this._iconClass;
    }
    set iconClass(value) {
        this._iconClass = value;
        if (this.isLoaded) {
            this.image.className = value;
        }
    }
    get iconSource() {
        if (this.isLoaded) {
            return this.image.src;
        }
        return this._iconSource;
    }
    set iconSource(value) {
        this._iconSource = value;
        if (this.isLoaded) {
            this.image.src = value;
        }
    }
    onLoaded() {
        if (!this.image) {
            const image = new image_Image();
            image.src = this.iconSource;
            image.className = this.iconClass;
            this.image = image;
            this._addView(this.image);
        }
        if (!this.label) {
            const label = new ui_label["Label"]();
            label.text = this.title;
            this.label = label;
            this._addView(this.label);
        }
        super.onLoaded();
        this._labelColorHandler =
            this._labelColorHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarItemColor(this, args.value);
                });
        this.label.style.on('colorChange', this._labelColorHandler);
        this._labelFontHandler =
            this._labelFontHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarItemFontInternal(this, args.value);
                });
        this.label.style.on('fontInternalChange', this._labelFontHandler);
        this._labelTextTransformHandler =
            this._labelTextTransformHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarItemTextTransform(this, args.value);
                });
        this.label.style.on('textTransformChange', this._labelTextTransformHandler);
        this._labelTextHandler =
            this._labelTextHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarItemTitle(this, args.value);
                });
        this.label.on('textChange', this._labelTextHandler);
        this._imageColorHandler =
            this._imageColorHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarIconColor(this, args.value);
                });
        this.image.style.on('colorChange', this._imageColorHandler);
        this._imageFontHandler =
            this._imageFontHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarIconColor(this, args.value);
                });
        this.image.style.on('fontInternalChange', this._imageFontHandler);
        this._imageSrcHandler =
            this._imageSrcHandler ||
                ((args) => {
                    const parent = this.parent;
                    const tabStripParent = parent && parent.parent;
                    return tabStripParent && tabStripParent.setTabBarIconSource(this, args.value);
                });
        this.image.on('srcChange', this._imageSrcHandler);
    }
    onUnloaded() {
        super.onUnloaded();
        this.label.style.off('colorChange', this._labelColorHandler);
        this.label.style.off('fontInternalChange', this._labelFontHandler);
        this.label.style.off('textTransformChange', this._labelTextTransformHandler);
        this.label.style.off('textChange', this._labelTextHandler);
        this.image.style.off('colorChange', this._imageColorHandler);
        this.image.style.off('fontInternalChange', this._imageFontHandler);
        this.image.style.off('srcChange', this._imageSrcHandler);
    }
    eachChild(callback) {
        if (this.label) {
            callback(this.label);
        }
        if (this.image) {
            callback(this.image);
        }
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof image_Image) {
            this.image = value;
            this.iconSource = value.src;
            this.iconClass = value.className;
            this._addView(value);
            // selectedIndexProperty.coerce(this);
        }
        if (value instanceof ui_label["Label"]) {
            this.label = value;
            this.title = value.text;
            this._addView(value);
            // selectedIndexProperty.coerce(this);
        }
    }
    requestLayout() {
        // Default implementation for non View instances (like TabViewItem).
        const parent = this.parent;
        if (parent) {
            parent.requestLayout();
        }
    }
    _updateTabStateChangeHandler(subscribe) {
        if (subscribe) {
            this._highlightedHandler =
                this._highlightedHandler ||
                    (() => {
                        this._goToVisualState('highlighted');
                    });
            this._normalHandler =
                this._normalHandler ||
                    (() => {
                        this._goToVisualState('normal');
                    });
            this.on(TabStripItem_1.selectEvent, this._highlightedHandler);
            this.on(TabStripItem_1.unselectEvent, this._normalHandler);
            const parent = this.parent;
            const tabStripParent = parent && parent.parent;
            if (this._index === tabStripParent.selectedIndex && !( true && tabStripParent.cssType.toLowerCase() === 'tabs')) {
                // HACK: tabStripParent instanceof Tabs creates a circular dependency
                // HACK: tabStripParent.cssType === "Tabs" is a hacky workaround
                this._goToVisualState('highlighted');
            }
        }
        else {
            this.off(TabStripItem_1.selectEvent, this._highlightedHandler);
            this.off(TabStripItem_1.unselectEvent, this._normalHandler);
        }
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        const parent = this.parent;
        const tabStripParent = parent && parent.parent;
        return tabStripParent && tabStripParent.getTabBarBackgroundColor();
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        const parent = this.parent;
        const tabStripParent = parent && parent.parent;
        return tabStripParent && tabStripParent.setTabBarItemBackgroundColor(this, value);
    }
    [text_base_common["j" /* textTransformProperty */].getDefault]() {
        const parent = this.parent;
        const tabStripParent = parent && parent.parent;
        return tabStripParent && tabStripParent.getTabBarItemTextTransform(this);
    }
    [text_base_common["j" /* textTransformProperty */].setNative](value) {
        const parent = this.parent;
        const tabStripParent = parent && parent.parent;
        return tabStripParent && tabStripParent.setTabBarItemTextTransform(this, value);
    }
    [style_properties["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["backgroundInternalProperty"].setNative](value) {
        // disable the background CSS properties
    }
};
tab_strip_item_TabStripItem.tapEvent = 'tap';
tab_strip_item_TabStripItem.selectEvent = 'select';
tab_strip_item_TabStripItem.unselectEvent = 'unselect';
__decorate([
    Object(view_common["b" /* PseudoClassHandler */])('normal', 'highlighted', 'pressed', 'active'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], tab_strip_item_TabStripItem.prototype, "_updateTabStateChangeHandler", null);
tab_strip_item_TabStripItem = TabStripItem_1 = __decorate([
    Object(view_common["a" /* CSSType */])('TabStripItem')
], tab_strip_item_TabStripItem);

//# sourceMappingURL=index.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-navigation-base/tab-strip/index.js
// Types

// Requires






const traceCategory = 'TabView';
// Place this on top because the webpack ts-loader doesn't work when export
// is after reference
const highlightColorProperty = new core_properties["Property"]({
    name: 'highlightColor',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
const selectedItemColorProperty = new core_properties["Property"]({
    name: 'selectedItemColor',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
const unSelectedItemColorProperty = new core_properties["Property"]({
    name: 'unSelectedItemColor',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
let tab_strip_TabStrip = class TabStrip extends core_view["c" /* View */] {
    eachChild(callback) {
        const items = this.items;
        if (items) {
            items.forEach((item, i) => {
                callback(item);
            });
        }
    }
    _addArrayFromBuilder(name, value) {
        if (name === 'items') {
            this.items = value;
        }
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof tab_strip_item_TabStripItem) {
            if (!this.items) {
                this.items = new Array();
            }
            this.items.push(value);
            this._addView(value);
            // selectedIndexProperty.coerce(this);
        }
    }
    onItemsChanged(oldItems, newItems) {
        if (oldItems) {
            oldItems.forEach((item) => this._removeView(item));
        }
        if (newItems) {
            newItems.forEach((item) => {
                this._addView(item);
            });
        }
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarBackgroundColor();
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarBackgroundColor(value);
    }
    [style_properties["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["backgroundInternalProperty"].setNative](value) {
        // disable the background CSS properties
    }
    [style_properties["colorProperty"].getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarColor();
    }
    [style_properties["colorProperty"].setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarColor(value);
    }
    [style_properties["fontInternalProperty"].getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarFontInternal();
    }
    [style_properties["fontInternalProperty"].setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarFontInternal(value);
    }
    [text_base_common["j" /* textTransformProperty */].getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarTextTransform();
    }
    [text_base_common["j" /* textTransformProperty */].setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarTextTransform(value);
    }
    [highlightColorProperty.getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarHighlightColor();
    }
    [highlightColorProperty.setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarHighlightColor(value);
    }
    [selectedItemColorProperty.getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarSelectedItemColor();
    }
    [selectedItemColorProperty.setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarSelectedItemColor(value);
    }
    [unSelectedItemColorProperty.getDefault]() {
        const parent = this.parent;
        return parent && parent.getTabBarUnSelectedItemColor();
    }
    [unSelectedItemColorProperty.setNative](value) {
        const parent = this.parent;
        return parent && parent.setTabBarUnSelectedItemColor(value);
    }
};
tab_strip_TabStrip.itemTapEvent = 'itemTap';
tab_strip_TabStrip = __decorate([
    Object(view_common["a" /* CSSType */])('TabStrip')
], tab_strip_TabStrip);

const itemsProperty = new core_properties["Property"]({
    name: 'items',
    valueChanged: (target, oldValue, newValue) => {
        target.onItemsChanged(oldValue, newValue);
    },
});
itemsProperty.register(tab_strip_TabStrip);
const iosIconRenderingModeProperty = new core_properties["Property"]({ name: 'iosIconRenderingMode', defaultValue: 'automatic' });
iosIconRenderingModeProperty.register(tab_strip_TabStrip);
const isIconSizeFixedProperty = new core_properties["Property"]({
    name: 'isIconSizeFixed',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
isIconSizeFixedProperty.register(tab_strip_TabStrip);
highlightColorProperty.register(tab_strip_TabStrip);
selectedItemColorProperty.register(tab_strip_TabStrip);
unSelectedItemColorProperty.register(tab_strip_TabStrip);
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/index.js
var text_base = __webpack_require__(34);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/platform/index.js
var platform = __webpack_require__(13);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-helper/index.js
var view_helper = __webpack_require__(28);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/frame/index.js + 5 modules
var ui_frame = __webpack_require__(12);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/font.js
var styling_font = __webpack_require__(22);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/content-view/index.js
var content_view = __webpack_require__(60);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-navigation-base/tab-content-item/tab-content-item-common.js
// Requires


const tab_content_item_common_traceCategory = 'TabView';
let tab_content_item_common_TabContentItemBase = class TabContentItemBase extends content_view["a" /* ContentView */] {
    eachChild(callback) {
        if (this.content) {
            callback(this.content);
        }
    }
    loadView(view) {
        const tabView = this.parent;
        if (tabView && tabView.items) {
            // Don't load items until their fragments are instantiated.
            if (this.canBeLoaded) {
                super.loadView(view);
            }
        }
    }
};
tab_content_item_common_TabContentItemBase = __decorate([
    Object(view_common["a" /* CSSType */])('TabContentItem')
], tab_content_item_common_TabContentItemBase);

//# sourceMappingURL=tab-content-item-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-navigation-base/tab-content-item/index.js
// Requires


class tab_content_item_TabContentItem extends tab_content_item_common_TabContentItemBase {
    setViewController(controller, nativeView) {
        this.__controller = controller;
        this.setNativeView(nativeView);
    }
    disposeNativeView() {
        this.__controller = undefined;
        this.setNativeView(undefined);
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-navigation-base/tab-navigation-base/index.js




class tab_navigation_base_TabNavigationBase extends core_view["c" /* View */] {
    _addArrayFromBuilder(name, value) {
        if (name === 'items') {
            this.items = value;
        }
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof tab_content_item_TabContentItem) {
            if (!this.items) {
                this.items = new Array();
            }
            this.items.push(value);
            this._addView(value);
            // selectedIndexProperty.coerce(this);
        }
        else if (value instanceof tab_strip_TabStrip) {
            // Setting tabStrip will trigger onTabStripChanged
            this.tabStrip = value;
        }
    }
    get _selectedView() {
        const selectedIndex = this.selectedIndex;
        return selectedIndex > -1 ? this.items[selectedIndex].content : null;
    }
    get _childrenCount() {
        const items = this.items;
        return items ? items.length : 0;
    }
    eachChild(callback) {
        const items = this.items;
        if (items) {
            items.forEach((item, i) => {
                callback(item);
            });
        }
        const tabStrip = this.tabStrip;
        if (tabStrip) {
            callback(tabStrip);
        }
    }
    eachChildView(callback) {
        const items = this.items;
        if (items) {
            items.forEach((item, i) => {
                callback(item.content);
            });
        }
    }
    onItemsChanged(oldItems, newItems) {
        if (oldItems) {
            oldItems.forEach((item) => this._removeView(item));
        }
        if (newItems) {
            newItems.forEach((item) => {
                if (!item.content) {
                    throw new Error(`TabContentItem must have a content (view).`);
                }
                this._addView(item);
            });
        }
    }
    onTabStripChanged(oldTabStrip, newTabStrip) {
        if (oldTabStrip && oldTabStrip.parent) {
            this._removeView(oldTabStrip);
        }
        if (newTabStrip) {
            this._addView(newTabStrip);
        }
    }
    onSelectedIndexChanged(oldIndex, newIndex) {
        // to be overridden in platform specific files
        this.notify({
            eventName: tab_navigation_base_TabNavigationBase.selectedIndexChangedEvent,
            object: this,
            oldIndex,
            newIndex,
        });
    }
    getTabBarBackgroundColor() {
        // overridden by inheritors
        return null;
    }
    getTabBarBackgroundArgbColor() {
        // This method is implemented only for Android
        const colorDrawable = this.getTabBarBackgroundColor();
        return colorDrawable && colorDrawable.getColor && colorDrawable.getColor();
    }
    setTabBarBackgroundColor(value) {
        // overridden by inheritors
    }
    getTabBarFontInternal() {
        // overridden by inheritors
        return null;
    }
    setTabBarFontInternal(value) {
        // overridden by inheritors
    }
    getTabBarTextTransform() {
        // overridden by inheritors
        return null;
    }
    setTabBarTextTransform(value) {
        // overridden by inheritors
    }
    getTabBarHighlightColor() {
        // overridden by inheritors
    }
    setTabBarHighlightColor(value) {
        // overridden by inheritors
    }
    getTabBarSelectedItemColor() {
        // overridden by inheritors
        return null;
    }
    setTabBarSelectedItemColor(value) {
        // overridden by inheritors
    }
    getTabBarUnSelectedItemColor() {
        // overridden by inheritors
        return null;
    }
    setTabBarUnSelectedItemColor(value) {
        // overridden by inheritors
    }
    getTabBarColor() {
        // overridden by inheritors
        return null;
    }
    setTabBarColor(value) {
        // overridden by inheritors
    }
    setTabBarItemTitle(tabStripItem, value) {
        // overridden by inheritors
    }
    getTabBarItemBackgroundColor(tabStripItem) {
        // overridden by inheritors
        return null;
    }
    setTabBarItemBackgroundColor(tabStripItem, value) {
        // overridden by inheritors
    }
    getTabBarItemColor(tabStripItem) {
        // overridden by inheritors
        return null;
    }
    setTabBarItemColor(tabStripItem, value) {
        // overridden by inheritors
    }
    setTabBarIconColor(tabStripItem, value) {
        // overridden by inheritors
    }
    setTabBarIconSource(tabStripItem, value) {
        // overridden by inheritors
    }
    getTabBarItemFontSize(tabStripItem) {
        // overridden by inheritors
        return null;
    }
    setTabBarItemFontSize(tabStripItem, value) {
        // overridden by inheritors
    }
    getTabBarItemFontInternal(tabStripItem) {
        // overridden by inheritors
        return null;
    }
    setTabBarItemFontInternal(tabStripItem, value) {
        // overridden by inheritors
    }
    getTabBarItemTextTransform(tabStripItem) {
        // overridden by inheritors
        return null;
    }
    setTabBarItemTextTransform(tabStripItem, value) {
        // overridden by inheritors
    }
}
tab_navigation_base_TabNavigationBase.selectedIndexChangedEvent = 'selectedIndexChanged';
const MIN_ICON_SIZE = 24;
const MAX_ICON_WIDTH = 31;
const MAX_ICON_HEIGHT = 28;
function getIconSpecSize(size) {
    const inWidth = size.width;
    const inHeight = size.height;
    let outWidth = 0;
    let outHeight = 0;
    if (inWidth < inHeight) {
        outWidth = MIN_ICON_SIZE;
        outHeight = (inHeight * MIN_ICON_SIZE) / inWidth;
        if (outHeight > MAX_ICON_HEIGHT) {
            outHeight = MAX_ICON_HEIGHT;
            outWidth = (inWidth * MAX_ICON_HEIGHT) / inHeight;
        }
    }
    else {
        outHeight = MIN_ICON_SIZE;
        outWidth = (inWidth * MIN_ICON_SIZE) / inHeight;
        if (outWidth > MAX_ICON_WIDTH) {
            outWidth = MAX_ICON_WIDTH;
            outHeight = (inHeight * MAX_ICON_WIDTH) / inWidth;
        }
    }
    return { width: outWidth, height: outHeight };
}
const selectedIndexProperty = new core_properties["CoercibleProperty"]({
    name: 'selectedIndex',
    defaultValue: -1,
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        target.onSelectedIndexChanged(oldValue, newValue);
    },
    coerceValue: (target, value) => {
        const items = target.items;
        if (items) {
            const max = items.length - 1;
            if (value < 0) {
                value = 0;
            }
            if (value > max) {
                value = max;
            }
        }
        else {
            value = -1;
        }
        return value;
    },
    valueConverter: (v) => parseInt(v),
});
selectedIndexProperty.register(tab_navigation_base_TabNavigationBase);
const _tabs = new Array();
const tab_navigation_base_itemsProperty = new core_properties["Property"]({
    name: 'items',
    valueChanged: (target, oldValue, newValue) => {
        target.onItemsChanged(oldValue, newValue);
    },
});
tab_navigation_base_itemsProperty.register(tab_navigation_base_TabNavigationBase);
const tabStripProperty = new core_properties["Property"]({
    name: 'tabStrip',
    valueChanged: (target, oldValue, newValue) => {
        target.onTabStripChanged(oldValue, newValue);
    },
});
tabStripProperty.register(tab_navigation_base_TabNavigationBase);
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/bottom-navigation/index.js



// Requires








// TODO:
// import { profile } from "../../profiling";
const maxTabsCount = 5;
const bottom_navigation_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
const isPhone = platform["Device"].deviceType === 'Phone';
var bottom_navigation_UITabBarControllerImpl = /** @class */ (function (_super) {
    __extends(UITabBarControllerImpl, _super);
    function UITabBarControllerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITabBarControllerImpl.initWithOwner = function (owner) {
        var handler = UITabBarControllerImpl.new();
        handler._owner = owner;
        return handler;
    };
    // TODO
    // @profile
    UITabBarControllerImpl.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        // Unify translucent and opaque bars layout
        this.extendedLayoutIncludesOpaqueBars = true;
        view_helper["a" /* IOSHelper */].updateAutoAdjustScrollInsets(this, owner);
        if (!owner.parent) {
            owner.callLoaded();
        }
    };
    // TODO
    // @profile
    UITabBarControllerImpl.prototype.viewDidDisappear = function (animated) {
        _super.prototype.viewDidDisappear.call(this, animated);
        var owner = this._owner.get();
        if (owner && !owner.parent && owner.isLoaded && !this.presentedViewController) {
            owner.callUnloaded();
        }
    };
    UITabBarControllerImpl.prototype.viewWillTransitionToSizeWithTransitionCoordinator = function (size, coordinator) {
        var _this = this;
        _super.prototype.viewWillTransitionToSizeWithTransitionCoordinator.call(this, size, coordinator);
        coordinator.animateAlongsideTransitionCompletion(function () {
            var owner = _this._owner.get();
            if (owner && owner.tabStrip && owner.tabStrip.items) {
                var tabStrip_1 = owner.tabStrip;
                tabStrip_1.items.forEach(function (tabStripItem) {
                    updateBackgroundPositions(tabStrip_1, tabStripItem);
                    var index = tabStripItem._index;
                    var tabBarItemController = _this.viewControllers[index];
                    updateTitleAndIconPositions(tabStripItem, tabBarItemController.tabBarItem, tabBarItemController);
                });
            }
        }, null);
    };
    // Mind implementation for other controllers
    UITabBarControllerImpl.prototype.traitCollectionDidChange = function (previousTraitCollection) {
        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
        if (bottom_navigation_majorVersion >= 13) {
            var owner = this._owner.get();
            if (owner && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection(previousTraitCollection)) {
                owner.notify({
                    eventName: view_helper["a" /* IOSHelper */].traitCollectionColorAppearanceChangedEvent,
                    object: owner,
                });
            }
        }
    };
    return UITabBarControllerImpl;
}(UITabBarController));
var bottom_navigation_UITabBarControllerDelegateImpl = /** @class */ (function (_super) {
    __extends(UITabBarControllerDelegateImpl, _super);
    function UITabBarControllerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITabBarControllerDelegateImpl.initWithOwner = function (owner) {
        var delegate = UITabBarControllerDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UITabBarControllerDelegateImpl.prototype.tabBarControllerShouldSelectViewController = function (tabBarController, viewController) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.delegate.SHOULD_select(" + tabBarController + ", " + viewController + ");", Trace.categories.Debug);
        // }
        var owner = this._owner.get();
        if (owner) {
            // "< More" cannot be visible after clicking on the main tab bar buttons.
            var backToMoreWillBeVisible = false;
            owner._handleTwoNavigationBars(backToMoreWillBeVisible);
            if (tabBarController.viewControllers) {
                var position = tabBarController.viewControllers.indexOfObject(viewController);
                if (position !== NSNotFound) {
                    var tabStrip = owner.tabStrip;
                    var tabStripItems = tabStrip && tabStrip.items;
                    if (tabStripItems && tabStripItems[position]) {
                        tabStripItems[position]._emit(tab_strip_item_TabStripItem.tapEvent);
                        tabStrip.notify({
                            eventName: tab_strip_TabStrip.itemTapEvent,
                            object: tabStrip,
                            index: position,
                        });
                    }
                }
            }
        }
        if (tabBarController.selectedViewController === viewController) {
            return false;
        }
        tabBarController._willSelectViewController = viewController;
        return true;
    };
    UITabBarControllerDelegateImpl.prototype.tabBarControllerDidSelectViewController = function (tabBarController, viewController) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.delegate.DID_select(" + tabBarController + ", " + viewController + ");", Trace.categories.Debug);
        // }
        var owner = this._owner.get();
        if (owner) {
            owner._onViewControllerShown(viewController);
        }
        tabBarController._willSelectViewController = undefined;
    };
    UITabBarControllerDelegateImpl.ObjCProtocols = [UITabBarControllerDelegate];
    return UITabBarControllerDelegateImpl;
}(NSObject));
var UINavigationControllerDelegateImpl = /** @class */ (function (_super) {
    __extends(UINavigationControllerDelegateImpl, _super);
    function UINavigationControllerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UINavigationControllerDelegateImpl.initWithOwner = function (owner) {
        var delegate = UINavigationControllerDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UINavigationControllerDelegateImpl.prototype.navigationControllerWillShowViewControllerAnimated = function (navigationController, viewController, animated) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.moreNavigationController.WILL_show(" + navigationController + ", " + viewController + ", " + animated + ");", Trace.categories.Debug);
        // }
        var owner = this._owner.get();
        if (owner) {
            // If viewController is one of our tab item controllers, then "< More" will be visible shortly.
            // Otherwise viewController is the UIMoreListController which shows the list of all tabs beyond the 4th tab.
            var backToMoreWillBeVisible = owner._ios.viewControllers.containsObject(viewController);
            owner._handleTwoNavigationBars(backToMoreWillBeVisible);
        }
    };
    UINavigationControllerDelegateImpl.prototype.navigationControllerDidShowViewControllerAnimated = function (navigationController, viewController, animated) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.moreNavigationController.DID_show(" + navigationController + ", " + viewController + ", " + animated + ");", Trace.categories.Debug);
        // }
        // We don't need Edit button in More screen.
        navigationController.navigationBar.topItem.rightBarButtonItem = null;
        var owner = this._owner.get();
        if (owner) {
            owner._onViewControllerShown(viewController);
        }
    };
    UINavigationControllerDelegateImpl.ObjCProtocols = [UINavigationControllerDelegate];
    return UINavigationControllerDelegateImpl;
}(NSObject));
function updateBackgroundPositions(tabStrip, tabStripItem) {
    let bgView = tabStripItem.bgView;
    const index = tabStripItem._index;
    const width = tabStrip.nativeView.frame.size.width / tabStrip.items.length;
    const frame = CGRectMake(width * index, 0, width, tabStrip.nativeView.frame.size.width);
    if (!bgView) {
        bgView = UIView.alloc().initWithFrame(frame);
        tabStrip.nativeView.insertSubviewAtIndex(bgView, 0);
        tabStripItem.bgView = bgView;
    }
    else {
        bgView.frame = frame;
    }
    const backgroundColor = tabStripItem.style.backgroundColor;
    bgView.backgroundColor = backgroundColor instanceof core_color["a" /* Color */] ? backgroundColor.ios : backgroundColor;
}
function updateTitleAndIconPositions(tabStripItem, tabBarItem, controller) {
    if (!tabStripItem || !tabBarItem) {
        return;
    }
    // For iOS <11 icon is *always* above the text.
    // For iOS 11 icon is above the text *only* on phones in portrait mode.
    const orientation = controller.interfaceOrientation;
    const isPortrait = orientation !== 4 /* LandscapeLeft */ && orientation !== 3 /* LandscapeRight */;
    const isIconAboveTitle = bottom_navigation_majorVersion < 11 || (isPhone && isPortrait);
    if (!tabStripItem.iconSource) {
        if (isIconAboveTitle) {
            tabBarItem.titlePositionAdjustment = {
                horizontal: 0,
                vertical: -20,
            };
        }
        else {
            tabBarItem.titlePositionAdjustment = { horizontal: 0, vertical: 0 };
        }
    }
    if (!tabStripItem.title) {
        if (isIconAboveTitle) {
            tabBarItem.imageInsets = new UIEdgeInsets({
                top: 6,
                left: 0,
                bottom: -6,
                right: 0,
            });
        }
        else {
            tabBarItem.imageInsets = new UIEdgeInsets({
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
            });
        }
    }
}
let bottom_navigation_BottomNavigation = class BottomNavigation extends tab_navigation_base_TabNavigationBase {
    constructor() {
        super();
        this._iconsCache = {};
        this.viewController = this._ios = bottom_navigation_UITabBarControllerImpl.initWithOwner(new WeakRef(this));
        this.nativeViewProtected = this._ios.view;
    }
    initNativeView() {
        super.initNativeView();
        this._delegate = bottom_navigation_UITabBarControllerDelegateImpl.initWithOwner(new WeakRef(this));
        this._moreNavigationControllerDelegate = UINavigationControllerDelegateImpl.initWithOwner(new WeakRef(this));
        if (!this.tabStrip) {
            this.viewController.tabBar.hidden = true;
        }
    }
    disposeNativeView() {
        this._delegate = null;
        this._moreNavigationControllerDelegate = null;
        super.disposeNativeView();
    }
    // TODO
    // @profile
    onLoaded() {
        super.onLoaded();
        this.setViewControllers(this.items);
        const selectedIndex = this.selectedIndex;
        const selectedView = this.items && this.items[selectedIndex] && this.items[selectedIndex].content;
        if (selectedView instanceof ui_frame["Frame"]) {
            selectedView._pushInFrameStackRecursive();
        }
        this._ios.delegate = this._delegate;
    }
    onUnloaded() {
        this._ios.delegate = null;
        this._ios.moreNavigationController.delegate = null;
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    layoutNativeView(left, top, right, bottom) {
        //
    }
    _setNativeViewFrame(nativeView, frame) {
        //
    }
    onSelectedIndexChanged(oldIndex, newIndex) {
        const items = this.items;
        if (!items) {
            return;
        }
        const oldItem = items[oldIndex];
        if (oldItem) {
            oldItem.canBeLoaded = false;
            oldItem.unloadView(oldItem.content);
        }
        const newItem = items[newIndex];
        if (newItem && this.isLoaded) {
            const selectedView = items[newIndex].content;
            if (selectedView instanceof ui_frame["Frame"]) {
                selectedView._pushInFrameStackRecursive();
            }
            newItem.canBeLoaded = true;
            newItem.loadView(newItem.content);
        }
        const tabStripItems = this.tabStrip && this.tabStrip.items;
        if (tabStripItems) {
            if (tabStripItems[newIndex]) {
                tabStripItems[newIndex]._emit(tab_strip_item_TabStripItem.selectEvent);
            }
            if (tabStripItems[oldIndex]) {
                tabStripItems[oldIndex]._emit(tab_strip_item_TabStripItem.unselectEvent);
            }
        }
        super.onSelectedIndexChanged(oldIndex, newIndex);
    }
    getTabBarBackgroundColor() {
        return this._ios.tabBar.barTintColor;
    }
    setTabBarBackgroundColor(value) {
        this._ios.tabBar.barTintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.updateAllItemsColors();
    }
    setTabBarItemTitle(tabStripItem, value) {
        tabStripItem.nativeView.title = value;
    }
    setTabBarItemBackgroundColor(tabStripItem, value) {
        if (!this.tabStrip || !tabStripItem) {
            return;
        }
        updateBackgroundPositions(this.tabStrip, tabStripItem);
    }
    setTabBarItemColor(tabStripItem, value) {
        this.setViewAttributes(tabStripItem.nativeView, tabStripItem.label);
    }
    setItemColors() {
        if (this._selectedItemColor) {
            this.viewController.tabBar.selectedImageTintColor = this._selectedItemColor.ios;
        }
        if (this._unSelectedItemColor) {
            this.viewController.tabBar.unselectedItemTintColor = this._unSelectedItemColor.ios;
        }
    }
    setIconColor(tabStripItem, forceReload = false) {
        if (forceReload || (!this._unSelectedItemColor && !this._selectedItemColor)) {
            // if selectedItemColor or unSelectedItemColor is set we don't respect the color from the style
            const tabStripColor = this.selectedIndex === tabStripItem._index ? this._selectedItemColor : this._unSelectedItemColor;
            const image = this.getIcon(tabStripItem, tabStripColor);
            tabStripItem.nativeView.image = image;
            tabStripItem.nativeView.selectedImage = image;
        }
    }
    setTabBarIconColor(tabStripItem, value) {
        this.setIconColor(tabStripItem);
    }
    setTabBarIconSource(tabStripItem, value) {
        this.updateItemColors(tabStripItem);
    }
    setTabBarItemFontInternal(tabStripItem, value) {
        this.setViewAttributes(tabStripItem.nativeView, tabStripItem.label);
    }
    setTabBarItemTextTransform(tabStripItem, value) {
        tabStripItem.nativeView.title = Object(text_base["b" /* getTransformedText */])(tabStripItem.label.text, value);
    }
    getTabBarHighlightColor() {
        return this._ios.tabBar.tintColor;
    }
    setTabBarHighlightColor(value) {
        this._ios.tabBar.tintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    getTabBarSelectedItemColor() {
        return this._selectedItemColor;
    }
    setTabBarSelectedItemColor(value) {
        this._selectedItemColor = value;
        this.updateAllItemsColors();
    }
    getTabBarUnSelectedItemColor() {
        return this._unSelectedItemColor;
    }
    setTabBarUnSelectedItemColor(value) {
        this._unSelectedItemColor = value;
        this.updateAllItemsColors();
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(width, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(height, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    _onViewControllerShown(viewController) {
        // This method could be called with the moreNavigationController or its list controller, so we have to check.
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView._onViewControllerShown(" + viewController + ");", Trace.categories.Debug);
        // }
        if (this._ios.viewControllers && this._ios.viewControllers.containsObject(viewController)) {
            this.selectedIndex = this._ios.viewControllers.indexOfObject(viewController);
        }
        else {
            // TODO
            // if (Trace.isEnabled()) {
            //     Trace.write("TabView._onViewControllerShown: viewController is not one of our viewControllers", Trace.categories.Debug);
            // }
        }
    }
    _handleTwoNavigationBars(backToMoreWillBeVisible) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write(`TabView._handleTwoNavigationBars(backToMoreWillBeVisible: ${backToMoreWillBeVisible})`, Trace.categories.Debug);
        // }
        // The "< Back" and "< More" navigation bars should not be visible simultaneously.
        const page = this.page || this._selectedView.page || this._selectedView.currentPage;
        if (!page || !page.frame) {
            return;
        }
        const actionBarVisible = page.frame._getNavBarVisible(page);
        if (backToMoreWillBeVisible && actionBarVisible) {
            page.frame.ios._disableNavBarAnimation = true;
            page.actionBarHidden = true;
            page.frame.ios._disableNavBarAnimation = false;
            this._actionBarHiddenByTabView = true;
            // TODO
            // if (Trace.isEnabled()) {
            //     Trace.write(`TabView hid action bar`, Trace.categories.Debug);
            // }
            return;
        }
        if (!backToMoreWillBeVisible && this._actionBarHiddenByTabView) {
            page.frame.ios._disableNavBarAnimation = true;
            page.actionBarHidden = false;
            page.frame.ios._disableNavBarAnimation = false;
            this._actionBarHiddenByTabView = undefined;
            // TODO
            // if (Trace.isEnabled()) {
            //     Trace.write(`TabView restored action bar`, Trace.categories.Debug);
            // }
            return;
        }
    }
    getViewController(item) {
        let newController = item.content ? item.content.viewController : null;
        if (newController) {
            item.setViewController(newController, newController.view);
            return newController;
        }
        if (item.content.ios instanceof UIViewController) {
            newController = item.content.ios;
            item.setViewController(newController, newController.view);
        }
        else if (item.content.ios && item.content.ios.controller instanceof UIViewController) {
            newController = item.content.ios.controller;
            item.setViewController(newController, newController.view);
        }
        else {
            newController = view_helper["a" /* IOSHelper */].UILayoutViewController.initWithOwner(new WeakRef(item.content));
            newController.view.addSubview(item.content.nativeViewProtected);
            item.content.viewController = newController;
            item.setViewController(newController, item.content.nativeViewProtected);
        }
        return newController;
    }
    setViewControllers(items) {
        const length = items ? items.length : 0;
        if (length === 0) {
            this._ios.viewControllers = null;
            return;
        }
        // Limit both tabContentItems and tabStripItems to 5 in order to prevent iOS 'more' button
        items = items.slice(0, maxTabsCount);
        const controllers = NSMutableArray.alloc().initWithCapacity(length);
        if (this.tabStrip) {
            this.tabStrip.setNativeView(this._ios.tabBar);
        }
        items.forEach((item, i) => {
            const controller = this.getViewController(item);
            if (this.tabStrip && this.tabStrip.items && this.tabStrip.items[i]) {
                const tabStripItem = this.tabStrip.items[i];
                const tabBarItem = this.createTabBarItem(tabStripItem, i);
                updateTitleAndIconPositions(tabStripItem, tabBarItem, controller);
                this.setViewAttributes(tabBarItem, tabStripItem.label);
                controller.tabBarItem = tabBarItem;
                tabStripItem._index = i;
                tabStripItem.setNativeView(tabBarItem);
            }
            controllers.addObject(controller);
        });
        this.setItemImages();
        this._ios.viewControllers = controllers;
        this._ios.customizableViewControllers = null;
        // When we set this._ios.viewControllers, someone is clearing the moreNavigationController.delegate, so we have to reassign it each time here.
        this._ios.moreNavigationController.delegate = this._moreNavigationControllerDelegate;
    }
    setItemImages() {
        if (this._selectedItemColor || this._unSelectedItemColor) {
            if (this.tabStrip && this.tabStrip.items) {
                this.tabStrip.items.forEach((item) => {
                    if (this._unSelectedItemColor && item.nativeView) {
                        item.nativeView.image = this.getIcon(item, this._unSelectedItemColor);
                        item.nativeView.tintColor = this._unSelectedItemColor;
                    }
                    if (this._selectedItemColor && item.nativeView) {
                        item.nativeView.selectedImage = this.getIcon(item, this._selectedItemColor);
                        item.nativeView.tintColor = this._selectedItemColor;
                    }
                });
            }
        }
    }
    updateAllItemsColors() {
        this.setItemColors();
        if (this.tabStrip && this.tabStrip.items) {
            this.tabStrip.items.forEach((tabStripItem) => {
                this.updateItemColors(tabStripItem);
            });
        }
    }
    updateItemColors(tabStripItem) {
        updateBackgroundPositions(this.tabStrip, tabStripItem);
        this.setIconColor(tabStripItem, true);
    }
    createTabBarItem(item, index) {
        let image;
        let title;
        if (item.isLoaded) {
            image = this.getIcon(item);
            title = item.label.text;
            const textTransform = item.label.style.textTransform;
            if (textTransform) {
                title = Object(text_base["b" /* getTransformedText */])(title, textTransform);
            }
        }
        return UITabBarItem.alloc().initWithTitleImageTag(title, image, index);
    }
    getIconRenderingMode() {
        switch (this.tabStrip && this.tabStrip.iosIconRenderingMode) {
            case 'alwaysOriginal':
                return 1 /* AlwaysOriginal */;
            case 'alwaysTemplate':
                return 2 /* AlwaysTemplate */;
            case 'automatic':
            default:
                return 0 /* Automatic */;
        }
    }
    getIcon(tabStripItem, color) {
        // Image and Label children of TabStripItem
        // take priority over its `iconSource` and `title` properties
        const iconSource = tabStripItem.image && tabStripItem.image.src;
        if (!iconSource) {
            return null;
        }
        const target = tabStripItem.image;
        const font = target.style.fontInternal || styling_font["a" /* Font */].default;
        if (!color) {
            color = target.style.color;
        }
        const iconTag = [iconSource, font.fontStyle, font.fontWeight, font.fontSize, font.fontFamily, color].join(';');
        let isFontIcon = false;
        let image = this._iconsCache[iconTag];
        if (!image) {
            let is;
            if (Object(utils_common["l" /* isFontIconURI */])(iconSource)) {
                isFontIcon = true;
                const fontIconCode = iconSource.split('//')[1];
                is = image_source["ImageSource"].fromFontIconCodeSync(fontIconCode, font, color);
            }
            else {
                is = image_source["ImageSource"].fromFileOrResourceSync(iconSource);
            }
            if (is && is.ios) {
                image = is.ios;
                if (this.tabStrip && this.tabStrip.isIconSizeFixed) {
                    image = this.getFixedSizeIcon(image);
                }
                let renderingMode = 1 /* AlwaysOriginal */;
                if (!isFontIcon) {
                    renderingMode = this.getIconRenderingMode();
                }
                const originalRenderedImage = image.imageWithRenderingMode(renderingMode);
                this._iconsCache[iconTag] = originalRenderedImage;
                image = originalRenderedImage;
            }
            else {
                // TODO
                // traceMissingIcon(iconSource);
            }
        }
        return image;
    }
    getFixedSizeIcon(image) {
        const inWidth = image.size.width;
        const inHeight = image.size.height;
        const iconSpecSize = getIconSpecSize({
            width: inWidth,
            height: inHeight,
        });
        const widthPts = iconSpecSize.width;
        const heightPts = iconSpecSize.height;
        UIGraphicsBeginImageContextWithOptions({ width: widthPts, height: heightPts }, false, utils_common["n" /* layout */].getDisplayDensity());
        image.drawInRect(CGRectMake(0, 0, widthPts, heightPts));
        const resultImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return resultImage;
    }
    // private _updateIOSTabBarColorsAndFonts(): void {
    //     if (!this.tabStrip || !this.tabStrip.items || !this.tabStrip.items.length) {
    //         return;
    //     }
    //     const tabBar = <UITabBar>this.ios.tabBar;
    //     const states = getTitleAttributesForStates(this);
    //     for (let i = 0; i < tabBar.items.count; i++) {
    //         applyStatesToItem(tabBar.items[i], states);
    //     }
    // }
    // TODO: Move this to TabStripItem
    // [fontInternalProperty.getDefault](): Font {
    //     return null;
    // }
    // [fontInternalProperty.setNative](value: Font) {
    //     this._updateIOSTabBarColorsAndFonts();
    // }
    [selectedIndexProperty.setNative](value) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView._onSelectedIndexPropertyChangedSetNativeValue(" + value + ")", Trace.categories.Debug);
        // }
        if (value > -1) {
            this._ios._willSelectViewController = this._ios.viewControllers[value];
            this._ios.selectedIndex = value;
        }
    }
    [tab_navigation_base_itemsProperty.getDefault]() {
        return null;
    }
    [tab_navigation_base_itemsProperty.setNative](value) {
        if (value) {
            value.forEach((item, i) => {
                item.index = i;
            });
        }
        this.setViewControllers(value);
        selectedIndexProperty.coerce(this);
    }
    [tabStripProperty.getDefault]() {
        return null;
    }
    [tabStripProperty.setNative](value) {
        this.setViewControllers(this.items);
        selectedIndexProperty.coerce(this);
    }
    setViewAttributes(item, view) {
        if (!view) {
            return null;
        }
        const defaultTabItemFontSize = 10;
        const tabItemFontSize = view.style.fontSize || defaultTabItemFontSize;
        const font = (view.style.fontInternal || styling_font["a" /* Font */].default).getUIFont(UIFont.systemFontOfSize(tabItemFontSize));
        const tabItemTextColor = view.style.color;
        const textColor = tabItemTextColor instanceof core_color["a" /* Color */] ? tabItemTextColor.ios : null;
        const attributes = { [NSFontAttributeName]: font };
        // if selectedItemColor or unSelectedItemColor is set we don't respect the color from the style
        if (!this._selectedItemColor && !this._unSelectedItemColor) {
            if (textColor) {
                attributes[UITextAttributeTextColor] = textColor;
                attributes[NSForegroundColorAttributeName] = textColor;
            }
        }
        else {
            this.viewController.tabBar.unselectedItemTintColor = this._unSelectedItemColor && this._unSelectedItemColor.ios;
            this.viewController.tabBar.selectedImageTintColor = this._selectedItemColor && this._selectedItemColor.ios;
        }
        item.setTitleTextAttributesForState(attributes, 4 /* Selected */);
        item.setTitleTextAttributesForState(attributes, 0 /* Normal */);
        // there's a bug when setting the item color on ios 13 if there's no background set to the tabstrip
        // https://books.google.bg/books?id=99_BDwAAQBAJ&q=tabBar.unselectedItemTintColor
        // to fix the above issue we are applying the selected fix only for the case, when there is no background set
        // in that case we have the following known issue:
        // // we will set the color to all unselected items, so you won't be able to set different colors for the different not selected items
        if (!this.viewController.tabBar.barTintColor && attributes[UITextAttributeTextColor] && bottom_navigation_majorVersion > 9) {
            this.viewController.tabBar.unselectedItemTintColor = attributes[UITextAttributeTextColor];
        }
    }
};
bottom_navigation_BottomNavigation = __decorate([
    Object(view_common["a" /* CSSType */])('BottomNavigation'),
    __metadata("design:paramtypes", [])
], bottom_navigation_BottomNavigation);

//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/builder/index.js
var builder = __webpack_require__(42);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/builder/module-name-sanitizer.js
var module_name_sanitizer = __webpack_require__(37);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/button/index.js + 1 modules
var ui_button = __webpack_require__(100);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/bindable/index.js
var bindable = __webpack_require__(59);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/control-state-change/index.js
var control_state_change = __webpack_require__(86);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-helper/view-helper-common.js
var view_helper_common = __webpack_require__(58);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/weak-event-listener/index.js
var weak_event_listener = __webpack_require__(43);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/date-picker/date-picker-common.js


const defaultDate = new Date();
const dateComparer = (x, y) => x <= y && x >= y;
let date_picker_common_DatePickerBase = class DatePickerBase extends core_view["c" /* View */] {
};
date_picker_common_DatePickerBase = __decorate([
    Object(view_common["a" /* CSSType */])('DatePicker')
], date_picker_common_DatePickerBase);

date_picker_common_DatePickerBase.prototype.recycleNativeView = 'auto';
const yearProperty = new core_properties["Property"]({
    name: 'year',
    defaultValue: defaultDate.getFullYear(),
    valueConverter: (v) => parseInt(v),
});
yearProperty.register(date_picker_common_DatePickerBase);
const monthProperty = new core_properties["Property"]({
    name: 'month',
    defaultValue: defaultDate.getMonth() + 1,
    valueConverter: (v) => parseInt(v),
});
monthProperty.register(date_picker_common_DatePickerBase);
const dayProperty = new core_properties["Property"]({
    name: 'day',
    defaultValue: defaultDate.getDate(),
    valueConverter: (v) => parseInt(v),
});
dayProperty.register(date_picker_common_DatePickerBase);
// TODO: Make CoercibleProperties
const maxDateProperty = new core_properties["Property"]({
    name: 'maxDate',
    equalityComparer: dateComparer,
    valueConverter: (v) => new Date(v),
});
maxDateProperty.register(date_picker_common_DatePickerBase);
const minDateProperty = new core_properties["Property"]({
    name: 'minDate',
    equalityComparer: dateComparer,
    valueConverter: (v) => new Date(v),
});
minDateProperty.register(date_picker_common_DatePickerBase);
const dateProperty = new core_properties["Property"]({
    name: 'date',
    defaultValue: defaultDate,
    equalityComparer: dateComparer,
    valueConverter: (v) => new Date(v),
});
dateProperty.register(date_picker_common_DatePickerBase);
const iosPreferredDatePickerStyleProperty = new core_properties["Property"]({
    name: 'iosPreferredDatePickerStyle',
    defaultValue: 0,
    valueConverter: (v) => parseInt(v),
});
iosPreferredDatePickerStyleProperty.register(date_picker_common_DatePickerBase);
//# sourceMappingURL=date-picker-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/date-picker/index.js





const SUPPORT_DATE_PICKER_STYLE = parseFloat(platform["Device"].osVersion) >= 13.4;
const SUPPORT_TEXT_COLOR = parseFloat(platform["Device"].osVersion) < 14.0;
class date_picker_DatePicker extends date_picker_common_DatePickerBase {
    createNativeView() {
        const picker = UIDatePicker.new();
        picker.datePickerMode = 1 /* Date */;
        if (SUPPORT_DATE_PICKER_STYLE) {
            picker.preferredDatePickerStyle = this.iosPreferredDatePickerStyle;
        }
        return picker;
    }
    initNativeView() {
        super.initNativeView();
        const nativeView = this.nativeViewProtected;
        this._changeHandler = date_picker_UIDatePickerChangeHandlerImpl.initWithOwner(new WeakRef(this));
        nativeView.addTargetActionForControlEvents(this._changeHandler, 'valueChanged', 4096 /* ValueChanged */);
    }
    disposeNativeView() {
        this._changeHandler = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    [yearProperty.setNative](value) {
        this.date = new Date(value, this.month - 1, this.day);
    }
    [monthProperty.setNative](value) {
        this.date = new Date(this.year, value - 1, this.day);
    }
    [dayProperty.setNative](value) {
        this.date = new Date(this.year, this.month - 1, value);
    }
    [dateProperty.setNative](value) {
        const picker = this.nativeViewProtected;
        const comps = NSCalendar.currentCalendar.componentsFromDate(4 /* CalendarUnitYear */ | 8 /* CalendarUnitMonth */ | 16 /* CalendarUnitDay */, picker.date);
        comps.year = value.getFullYear();
        comps.month = value.getMonth() + 1;
        comps.day = value.getDate();
        this.year = comps.year;
        this.month = comps.month;
        this.day = comps.day;
        picker.setDateAnimated(NSCalendar.currentCalendar.dateFromComponents(comps), false);
    }
    [maxDateProperty.getDefault]() {
        return this.nativeViewProtected.maximumDate;
    }
    [maxDateProperty.setNative](value) {
        const picker = this.nativeViewProtected;
        const nsDate = NSDate.dateWithTimeIntervalSince1970(value.getTime() / 1000);
        picker.maximumDate = nsDate;
    }
    [minDateProperty.getDefault]() {
        return this.nativeViewProtected.minimumDate;
    }
    [minDateProperty.setNative](value) {
        const picker = this.nativeViewProtected;
        const nsDate = NSDate.dateWithTimeIntervalSince1970(value.getTime() / 1000);
        picker.minimumDate = nsDate;
    }
    [style_properties["colorProperty"].getDefault]() {
        return SUPPORT_TEXT_COLOR ? this.nativeViewProtected.valueForKey('textColor') : UIColor.new();
    }
    [style_properties["colorProperty"].setNative](value) {
        if (SUPPORT_TEXT_COLOR) {
            const picker = this.nativeViewProtected;
            picker.setValueForKey(value instanceof core_color["a" /* Color */] ? value.ios : value, 'textColor');
        }
    }
}
var date_picker_UIDatePickerChangeHandlerImpl = /** @class */ (function (_super) {
    __extends(UIDatePickerChangeHandlerImpl, _super);
    function UIDatePickerChangeHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIDatePickerChangeHandlerImpl.initWithOwner = function (owner) {
        var impl = UIDatePickerChangeHandlerImpl.new();
        impl._owner = owner;
        return impl;
    };
    UIDatePickerChangeHandlerImpl.prototype.valueChanged = function (sender) {
        var comps = NSCalendar.currentCalendar.componentsFromDate(NSCalendarUnit.CalendarUnitYear | NSCalendarUnit.CalendarUnitMonth | NSCalendarUnit.CalendarUnitDay, sender.date);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        var dateChanged = false;
        if (comps.year !== owner.year) {
            yearProperty.nativeValueChange(owner, comps.year);
            dateChanged = true;
        }
        if (comps.month !== owner.month) {
            monthProperty.nativeValueChange(owner, comps.month);
            dateChanged = true;
        }
        if (comps.day !== owner.day) {
            dayProperty.nativeValueChange(owner, comps.day);
            dateChanged = true;
        }
        if (dateChanged) {
            dateProperty.nativeValueChange(owner, new Date(comps.year, comps.month - 1, comps.day));
        }
    };
    UIDatePickerChangeHandlerImpl.ObjCExposedMethods = {
        valueChanged: { returns: interop.types.void, params: [UIDatePicker] },
    };
    return UIDatePickerChangeHandlerImpl;
}(NSObject));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/dialogs/dialogs-common.js
var dialogs_common = __webpack_require__(26);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/dialogs/index.js
var dialogs = __webpack_require__(8);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/editable-text-base/index.js
var editable_text_base = __webpack_require__(51);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/enums/index.js
var enums = __webpack_require__(32);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/gestures/index.js
var gestures = __webpack_require__(69);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/gestures/gestures-common.js
var gestures_common = __webpack_require__(17);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/html-view/html-view-common.js





let html_view_common_HtmlViewBase = class HtmlViewBase extends core_view["c" /* View */] {
};
html_view_common_HtmlViewBase = __decorate([
    Object(view_common["a" /* CSSType */])('HtmlView')
], html_view_common_HtmlViewBase);

html_view_common_HtmlViewBase.prototype.recycleNativeView = 'auto';
// TODO: Can we use Label.ios optimization for affectsLayout???
const htmlProperty = new core_properties["Property"]({
    name: 'html',
    defaultValue: '',
    affectsLayout: true,
});
htmlProperty.register(html_view_common_HtmlViewBase);
const linkColorProperty = new core_properties["CssProperty"]({
    name: 'linkColor',
    cssName: 'link-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (value) => new core_color["a" /* Color */](value),
});
linkColorProperty.register(style["a" /* Style */]);
//# sourceMappingURL=html-view-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/html-view/index.js







const html_view_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
class html_view_HtmlView extends html_view_common_HtmlViewBase {
    createNativeView() {
        const view = UITextView.new();
        view.scrollEnabled = false;
        view.editable = false;
        view.selectable = true;
        view.userInteractionEnabled = true;
        view.dataDetectorTypes = -1 /* All */;
        return view;
    }
    initNativeView() {
        super.initNativeView();
        // Remove extra padding
        this.nativeViewProtected.textContainer.lineFragmentPadding = 0;
        this.nativeViewProtected.textContainerInset = UIEdgeInsets.zero;
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const nativeView = this.nativeViewProtected;
        if (nativeView) {
            const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
            const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
            const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
            const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
            const desiredSize = utils_common["n" /* layout */].measureNativeView(nativeView, width, widthMode, height, heightMode);
            const labelWidth = widthMode === utils_common["n" /* layout */].AT_MOST ? Math.min(desiredSize.width, width) : desiredSize.width;
            const measureWidth = Math.max(labelWidth, this.effectiveMinWidth);
            const measureHeight = Math.max(desiredSize.height, this.effectiveMinHeight);
            const widthAndState = core_view["c" /* View */].resolveSizeAndState(measureWidth, width, widthMode, 0);
            const heightAndState = core_view["c" /* View */].resolveSizeAndState(measureHeight, height, heightMode, 0);
            this.setMeasuredDimension(widthAndState, heightAndState);
        }
    }
    [htmlProperty.getDefault]() {
        return '';
    }
    renderWithStyles() {
        let html = this.currentHtml;
        const styles = [];
        if (this.nativeViewProtected.font) {
            styles.push(`font-family: '${this.nativeViewProtected.font.fontName}';`);
            styles.push(`font-size: ${this.nativeViewProtected.font.pointSize}px;`);
        }
        if (this.nativeViewProtected.textColor) {
            const textColor = core_color["a" /* Color */].fromIosColor(this.nativeViewProtected.textColor);
            styles.push(`color: ${textColor.hex};`);
        }
        if (styles.length > 0) {
            html += `<style>body {${styles.join('')}}</style>`;
        }
        const htmlString = NSString.stringWithString(html + '');
        const nsData = htmlString.dataUsingEncoding(NSUnicodeStringEncoding);
        this.nativeViewProtected.attributedText = NSAttributedString.alloc().initWithDataOptionsDocumentAttributesError(nsData, { [NSDocumentTypeDocumentAttribute]: NSHTMLTextDocumentType }, null);
        if (html_view_majorVersion >= 13 && UIColor.labelColor) {
            this.nativeViewProtected.textColor = UIColor.labelColor;
        }
    }
    [htmlProperty.setNative](value) {
        this.currentHtml = value;
        this.renderWithStyles();
    }
    [style_properties["colorProperty"].getDefault]() {
        return this.nativeViewProtected.textColor;
    }
    [style_properties["colorProperty"].setNative](value) {
        const color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.nativeViewProtected.textColor = color;
        this.renderWithStyles();
    }
    [linkColorProperty.getDefault]() {
        return this.nativeViewProtected.linkTextAttributes[NSForegroundColorAttributeName];
    }
    [linkColorProperty.setNative](value) {
        const color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        const linkTextAttributes = NSDictionary.dictionaryWithObjectForKey(color, NSForegroundColorAttributeName);
        this.nativeViewProtected.linkTextAttributes = linkTextAttributes;
    }
    [style_properties["fontInternalProperty"].getDefault]() {
        return this.nativeViewProtected.font;
    }
    [style_properties["fontInternalProperty"].setNative](value) {
        const font = value instanceof styling_font["a" /* Font */] ? value.getUIFont(this.nativeViewProtected.font) : value;
        this.nativeViewProtected.font = font;
        this.renderWithStyles();
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable/index.js
var observable = __webpack_require__(5);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/image-cache/image-cache-common.js

class image_cache_common_Cache extends observable["Observable"] {
    constructor() {
        super(...arguments);
        this.maxRequests = 5;
        this._enabled = true;
        this._pendingDownloads = {};
        this._queue = [];
        this._currentDownloads = 0;
    }
    enableDownload() {
        if (this._enabled) {
            return;
        }
        // schedule all pending downloads
        this._enabled = true;
        let request;
        while (this._queue.length > 0 && this._currentDownloads < this.maxRequests) {
            request = this._queue.pop();
            if (!(request.key in this._pendingDownloads)) {
                this._download(request);
            }
        }
    }
    disableDownload() {
        if (!this._enabled) {
            return;
        }
        this._enabled = false;
    }
    push(request) {
        this._addRequest(request, true);
    }
    enqueue(request) {
        this._addRequest(request, false);
    }
    _addRequest(request, onTop) {
        if (request.key in this._pendingDownloads) {
            const existingRequest = this._pendingDownloads[request.key];
            this._mergeRequests(existingRequest, request);
        }
        else {
            // TODO: Potential performance bottleneck - traversing the whole queue on each download request.
            let queueRequest;
            for (let i = 0; i < this._queue.length; i++) {
                if (this._queue[i].key === request.key) {
                    queueRequest = this._queue[i];
                    break;
                }
            }
            if (queueRequest) {
                this._mergeRequests(queueRequest, request);
            }
            else {
                if (this._shouldDownload(request, onTop)) {
                    this._download(request);
                }
            }
        }
    }
    _mergeRequests(existingRequest, newRequest) {
        if (existingRequest.completed) {
            if (newRequest.completed) {
                const existingCompleted = existingRequest.completed;
                const stackCompleted = function (result, key) {
                    existingCompleted(result, key);
                    newRequest.completed(result, key);
                };
                existingRequest.completed = stackCompleted;
            }
        }
        else {
            existingRequest.completed = newRequest.completed;
        }
        if (existingRequest.error) {
            if (newRequest.error) {
                const existingError = existingRequest.error;
                const stackError = function (key) {
                    existingError(key);
                    newRequest.error(key);
                };
                existingRequest.error = stackError;
            }
        }
        else {
            existingRequest.error = newRequest.error;
        }
    }
    get(key) {
        // This method is intended to be overridden by the android and ios implementations
        throw new Error('Abstract');
    }
    set(key, image) {
        // This method is intended to be overridden by the android and ios implementations
        throw new Error('Abstract');
    }
    remove(key) {
        // This method is intended to be overridden by the android and ios implementations
        throw new Error('Abstract');
    }
    clear() {
        // This method is intended to be overridden by the android and ios implementations
        throw new Error('Abstract');
    }
    /* tslint:disable:no-unused-variable */
    _downloadCore(request) {
        // This method is intended to be overridden by the android and ios implementations
        throw new Error('Abstract');
    }
    /* tslint:enable:no-unused-variable */
    _onDownloadCompleted(key, image) {
        const request = this._pendingDownloads[key];
        this.set(request.key, image);
        this._currentDownloads--;
        if (request.completed) {
            request.completed(image, request.key);
        }
        if (this.hasListeners(image_cache_common_Cache.downloadedEvent)) {
            this.notify({
                eventName: image_cache_common_Cache.downloadedEvent,
                object: this,
                key: key,
                image: image,
            });
        }
        delete this._pendingDownloads[request.key];
        this._updateQueue();
    }
    _onDownloadError(key, err) {
        const request = this._pendingDownloads[key];
        this._currentDownloads--;
        if (request.error) {
            request.error(request.key);
        }
        if (this.hasListeners(image_cache_common_Cache.downloadErrorEvent)) {
            this.notify({
                eventName: image_cache_common_Cache.downloadErrorEvent,
                object: this,
                key: key,
                error: err,
            });
        }
        delete this._pendingDownloads[request.key];
        this._updateQueue();
    }
    _shouldDownload(request, onTop) {
        if (this.get(request.key) || request.key in this._pendingDownloads) {
            return false;
        }
        if (this._currentDownloads >= this.maxRequests || !this._enabled) {
            if (onTop) {
                this._queue.push(request);
            }
            else {
                this._queue.unshift(request);
            }
            return false;
        }
        return true;
    }
    _download(request) {
        this._currentDownloads++;
        this._pendingDownloads[request.key] = request;
        this._downloadCore(request);
    }
    _updateQueue() {
        if (!this._enabled || this._queue.length === 0 || this._currentDownloads === this.maxRequests) {
            return;
        }
        const request = this._queue.pop();
        this._download(request);
    }
}
image_cache_common_Cache.downloadedEvent = 'downloaded';
image_cache_common_Cache.downloadErrorEvent = 'downloadError';
//# sourceMappingURL=image-cache-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/index.js
var utils = __webpack_require__(19);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/image-cache/index.js



let httpRequest;
function ensureHttpRequest() {
    if (!httpRequest) {
        httpRequest = __webpack_require__(55);
    }
}
var image_cache_MemmoryWarningHandler = /** @class */ (function (_super) {
    __extends(MemmoryWarningHandler, _super);
    function MemmoryWarningHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MemmoryWarningHandler.new = function () {
        return _super.new.call(this);
    };
    MemmoryWarningHandler.prototype.initWithCache = function (cache) {
        this._cache = cache;
        NSNotificationCenter.defaultCenter.addObserverSelectorNameObject(this, 'clearCache', 'UIApplicationDidReceiveMemoryWarningNotification', null);
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('[MemmoryWarningHandler] Added low memory observer.', trace["a" /* Trace */].categories.Debug);
        }
        return this;
    };
    MemmoryWarningHandler.prototype.dealloc = function () {
        NSNotificationCenter.defaultCenter.removeObserverNameObject(this, 'UIApplicationDidReceiveMemoryWarningNotification', null);
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('[MemmoryWarningHandler] Removed low memory observer.', trace["a" /* Trace */].categories.Debug);
        }
        _super.prototype.dealloc.call(this);
    };
    MemmoryWarningHandler.prototype.clearCache = function () {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('[MemmoryWarningHandler] Clearing Image Cache.', trace["a" /* Trace */].categories.Debug);
        }
        this._cache.removeAllObjects();
        utils["b" /* GC */]();
    };
    MemmoryWarningHandler.ObjCExposedMethods = {
        clearCache: { returns: interop.types.void, params: [] },
    };
    return MemmoryWarningHandler;
}(NSObject));
class image_cache_Cache extends image_cache_common_Cache {
    constructor() {
        super();
        this._cache = new NSCache();
        this._memoryWarningHandler = image_cache_MemmoryWarningHandler.new().initWithCache(this._cache);
    }
    _downloadCore(request) {
        ensureHttpRequest();
        httpRequest.request({ url: request.url, method: 'GET' }).then((response) => {
            try {
                const image = UIImage.alloc().initWithData(response.content.raw);
                if (image) {
                    this._onDownloadCompleted(request.key, image);
                }
                else {
                    this._onDownloadError(request.key, new Error('No result for provided url'));
                }
            }
            catch (err) {
                this._onDownloadError(request.key, err);
            }
        }, (err) => {
            this._onDownloadError(request.key, err);
        });
    }
    get(key) {
        return this._cache.objectForKey(key);
    }
    set(key, image) {
        this._cache.setObjectForKey(image, key);
    }
    remove(key) {
        this._cache.removeObjectForKey(key);
    }
    clear() {
        this._cache.removeAllObjects();
        utils["b" /* GC */]();
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/layouts/layout-base.js + 1 modules
var layout_base = __webpack_require__(27);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/absolute-layout/absolute-layout-common.js





core_view["c" /* View */].prototype.effectiveLeft = 0;
core_view["c" /* View */].prototype.effectiveTop = 0;
function validateArgs(element) {
    if (!element) {
        throw new Error('element cannot be null or undefinied.');
    }
    return element;
}
let absolute_layout_common_AbsoluteLayoutBase = class AbsoluteLayoutBase extends layout_base["a" /* LayoutBase */] {
    // TODO: Do we still need this? it can be get like view.left
    static getLeft(element) {
        return validateArgs(element).left;
    }
    // TODO: Do we still need this? it can be set like view.left=value
    static setLeft(element, value) {
        validateArgs(element).left = value;
    }
    // TODO: Do we still need this? it can be get like view.top
    static getTop(element) {
        return validateArgs(element).top;
    }
    // TODO: Do we still need this? it can be set like view.top=value
    static setTop(element, value) {
        validateArgs(element).top = value;
    }
    onLeftChanged(view, oldValue, newValue) {
        //
    }
    onTopChanged(view, oldValue, newValue) {
        //
    }
};
absolute_layout_common_AbsoluteLayoutBase = __decorate([
    Object(view_common["a" /* CSSType */])('AbsoluteLayout')
], absolute_layout_common_AbsoluteLayoutBase);

absolute_layout_common_AbsoluteLayoutBase.prototype.recycleNativeView = 'auto';
const leftProperty = new core_properties["Property"]({
    name: 'left',
    defaultValue: style_properties["zeroLength"],
    valueChanged: (target, oldValue, newValue) => {
        target.effectiveLeft = style_properties["Length"].toDevicePixels(newValue, 0);
        const layout = target.parent;
        if (layout instanceof absolute_layout_common_AbsoluteLayoutBase) {
            layout.onLeftChanged(target, oldValue, newValue);
        }
    },
    valueConverter: (v) => style_properties["Length"].parse(v),
});
leftProperty.register(core_view["c" /* View */]);
const topProperty = new core_properties["Property"]({
    name: 'top',
    defaultValue: style_properties["zeroLength"],
    valueChanged: (target, oldValue, newValue) => {
        target.effectiveTop = style_properties["Length"].toDevicePixels(newValue, 0);
        const layout = target.parent;
        if (layout instanceof absolute_layout_common_AbsoluteLayoutBase) {
            layout.onTopChanged(target, oldValue, newValue);
        }
    },
    valueConverter: (v) => style_properties["Length"].parse(v),
});
topProperty.register(core_view["c" /* View */]);
//# sourceMappingURL=absolute-layout-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/absolute-layout/index.js




class absolute_layout_AbsoluteLayout extends absolute_layout_common_AbsoluteLayoutBase {
    onLeftChanged(view, oldValue, newValue) {
        this.requestLayout();
    }
    onTopChanged(view, oldValue, newValue) {
        this.requestLayout();
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        let measureWidth = 0;
        let measureHeight = 0;
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const childMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(0, utils_common["n" /* layout */].UNSPECIFIED);
        this.eachLayoutChild((child, last) => {
            let childSize = core_view["c" /* View */].measureChild(this, child, childMeasureSpec, childMeasureSpec);
            measureWidth = Math.max(measureWidth, child.effectiveLeft + childSize.measuredWidth);
            measureHeight = Math.max(measureHeight, child.effectiveTop + childSize.measuredHeight);
        });
        measureWidth += this.effectiveBorderLeftWidth + this.effectivePaddingLeft + this.effectivePaddingRight + this.effectiveBorderRightWidth;
        measureHeight += this.effectiveBorderTopWidth + this.effectivePaddingTop + this.effectivePaddingBottom + this.effectiveBorderBottomWidth;
        measureWidth = Math.max(measureWidth, this.effectiveMinWidth);
        measureHeight = Math.max(measureHeight, this.effectiveMinHeight);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        super.onLayout(left, top, right, bottom);
        const insets = this.getSafeAreaInsets();
        this.eachLayoutChild((child, last) => {
            const childWidth = child.getMeasuredWidth();
            const childHeight = child.getMeasuredHeight();
            const childLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + child.effectiveLeft + insets.left;
            const childTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + child.effectiveTop + insets.top;
            const childRight = childLeft + childWidth + child.effectiveMarginLeft + child.effectiveMarginRight;
            const childBottom = childTop + childHeight + child.effectiveMarginTop + child.effectiveMarginBottom;
            core_view["c" /* View */].layoutChild(this, child, childLeft, childTop, childRight, childBottom);
        });
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/dock-layout/dock-layout-common.js




function dock_layout_common_validateArgs(element) {
    if (!element) {
        throw new Error('element cannot be null or undefinied.');
    }
    return element;
}

let dock_layout_common_DockLayoutBase = class DockLayoutBase extends layout_base["a" /* LayoutBase */] {
    static getDock(element) {
        return dock_layout_common_validateArgs(element).dock;
    }
    static setDock(element, value) {
        dock_layout_common_validateArgs(element).dock = value;
    }
    onDockChanged(view, oldValue, newValue) {
        //
    }
};
dock_layout_common_DockLayoutBase = __decorate([
    Object(view_common["a" /* CSSType */])('DockLayout')
], dock_layout_common_DockLayoutBase);

dock_layout_common_DockLayoutBase.prototype.recycleNativeView = 'auto';
const dockConverter = Object(core_properties["makeParser"])(Object(core_properties["makeValidator"])('left', 'top', 'right', 'bottom'));
const dockProperty = new core_properties["Property"]({
    name: 'dock',
    defaultValue: 'left',
    valueChanged: (target, oldValue, newValue) => {
        if (target instanceof core_view["c" /* View */]) {
            const layout = target.parent;
            if (layout instanceof dock_layout_common_DockLayoutBase) {
                layout.onDockChanged(target, oldValue, newValue);
            }
        }
    },
    valueConverter: dockConverter,
});
dockProperty.register(core_view["c" /* View */]);
const stretchLastChildProperty = new core_properties["Property"]({
    name: 'stretchLastChild',
    defaultValue: true,
    affectsLayout: true,
    valueConverter: view_base["booleanConverter"],
});
stretchLastChildProperty.register(dock_layout_common_DockLayoutBase);
//# sourceMappingURL=dock-layout-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/dock-layout/index.js




class dock_layout_DockLayout extends dock_layout_common_DockLayoutBase {
    onDockChanged(view, oldValue, newValue) {
        this.requestLayout();
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        let measureWidth = 0;
        let measureHeight = 0;
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const horizontalPaddingsAndMargins = this.effectivePaddingLeft + this.effectivePaddingRight + this.effectiveBorderLeftWidth + this.effectiveBorderRightWidth;
        const verticalPaddingsAndMargins = this.effectivePaddingTop + this.effectivePaddingBottom + this.effectiveBorderTopWidth + this.effectiveBorderBottomWidth;
        let remainingWidth = widthMode === utils_common["n" /* layout */].UNSPECIFIED ? Number.MAX_VALUE : width - horizontalPaddingsAndMargins;
        let remainingHeight = heightMode === utils_common["n" /* layout */].UNSPECIFIED ? Number.MAX_VALUE : height - verticalPaddingsAndMargins;
        let tempHeight = 0;
        let tempWidth = 0;
        let childWidthMeasureSpec;
        let childHeightMeasureSpec;
        this.eachLayoutChild((child, last) => {
            if (this.stretchLastChild && last) {
                childWidthMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(remainingWidth, widthMode);
                childHeightMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(remainingHeight, heightMode);
            }
            else {
                // Measure children with AT_MOST even if our mode is EXACT
                childWidthMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(remainingWidth, widthMode === utils_common["n" /* layout */].EXACTLY ? utils_common["n" /* layout */].AT_MOST : widthMode);
                childHeightMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec(remainingHeight, heightMode === utils_common["n" /* layout */].EXACTLY ? utils_common["n" /* layout */].AT_MOST : heightMode);
            }
            let childSize = core_view["c" /* View */].measureChild(this, child, childWidthMeasureSpec, childHeightMeasureSpec);
            switch (child.dock) {
                case 'top':
                case 'bottom':
                    remainingHeight = Math.max(0, remainingHeight - childSize.measuredHeight);
                    tempHeight += childSize.measuredHeight;
                    measureWidth = Math.max(measureWidth, tempWidth + childSize.measuredWidth);
                    measureHeight = Math.max(measureHeight, tempHeight);
                    break;
                case 'left':
                case 'right':
                default:
                    remainingWidth = Math.max(0, remainingWidth - childSize.measuredWidth);
                    tempWidth += childSize.measuredWidth;
                    measureWidth = Math.max(measureWidth, tempWidth);
                    measureHeight = Math.max(measureHeight, tempHeight + childSize.measuredHeight);
                    break;
            }
        });
        measureWidth += horizontalPaddingsAndMargins;
        measureHeight += verticalPaddingsAndMargins;
        measureWidth = Math.max(measureWidth, this.effectiveMinWidth);
        measureHeight = Math.max(measureHeight, this.effectiveMinHeight);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        super.onLayout(left, top, right, bottom);
        const insets = this.getSafeAreaInsets();
        const horizontalPaddingsAndMargins = this.effectivePaddingLeft + this.effectivePaddingRight + this.effectiveBorderLeftWidth + this.effectiveBorderRightWidth + insets.left + insets.right;
        const verticalPaddingsAndMargins = this.effectivePaddingTop + this.effectivePaddingBottom + this.effectiveBorderTopWidth + this.effectiveBorderBottomWidth + insets.top + insets.bottom;
        let childLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
        let childTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
        let x = childLeft;
        let y = childTop;
        let remainingWidth = Math.max(0, right - left - horizontalPaddingsAndMargins);
        let remainingHeight = Math.max(0, bottom - top - verticalPaddingsAndMargins);
        this.eachLayoutChild((child, last) => {
            let childWidth = child.getMeasuredWidth() + child.effectiveMarginLeft + child.effectiveMarginRight;
            let childHeight = child.getMeasuredHeight() + child.effectiveMarginTop + child.effectiveMarginBottom;
            if (last && this.stretchLastChild) {
                // Last child with stretch - give it all the space and return;
                core_view["c" /* View */].layoutChild(this, child, x, y, x + remainingWidth, y + remainingHeight);
                return;
            }
            let dock = dock_layout_DockLayout.getDock(child);
            switch (dock) {
                case 'top':
                    childLeft = x;
                    childTop = y;
                    childWidth = remainingWidth;
                    y += childHeight;
                    remainingHeight = Math.max(0, remainingHeight - childHeight);
                    break;
                case 'bottom':
                    childLeft = x;
                    childTop = y + remainingHeight - childHeight;
                    childWidth = remainingWidth;
                    remainingHeight = Math.max(0, remainingHeight - childHeight);
                    break;
                case 'right':
                    childLeft = x + remainingWidth - childWidth;
                    childTop = y;
                    childHeight = remainingHeight;
                    remainingWidth = Math.max(0, remainingWidth - childWidth);
                    break;
                case 'left':
                default:
                    childLeft = x;
                    childTop = y;
                    childHeight = remainingHeight;
                    x += childWidth;
                    remainingWidth = Math.max(0, remainingWidth - childWidth);
                    break;
            }
            core_view["c" /* View */].layoutChild(this, child, childLeft, childTop, childLeft + childWidth, childTop + childHeight);
        });
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/flexbox-layout/flexbox-layout-common.js




const ORDER_DEFAULT = 1;
const FLEX_GROW_DEFAULT = 0.0;
const FLEX_SHRINK_DEFAULT = 1.0;
var flexbox_layout_common_FlexDirection;
(function (FlexDirection) {
    FlexDirection.ROW = 'row';
    FlexDirection.ROW_REVERSE = 'row-reverse';
    FlexDirection.COLUMN = 'column';
    FlexDirection.COLUMN_REVERSE = 'column-reverse';
    FlexDirection.isValid = Object(core_properties["makeValidator"])(FlexDirection.ROW, FlexDirection.ROW_REVERSE, FlexDirection.COLUMN, FlexDirection.COLUMN_REVERSE);
    FlexDirection.parse = Object(core_properties["makeParser"])(FlexDirection.isValid);
})(flexbox_layout_common_FlexDirection || (flexbox_layout_common_FlexDirection = {}));
var flexbox_layout_common_FlexWrap;
(function (FlexWrap) {
    FlexWrap.NOWRAP = 'nowrap';
    FlexWrap.WRAP = 'wrap';
    FlexWrap.WRAP_REVERSE = 'wrap-reverse';
    FlexWrap.isValid = Object(core_properties["makeValidator"])(FlexWrap.NOWRAP, FlexWrap.WRAP, FlexWrap.WRAP_REVERSE);
    FlexWrap.parse = Object(core_properties["makeParser"])(FlexWrap.isValid);
})(flexbox_layout_common_FlexWrap || (flexbox_layout_common_FlexWrap = {}));
var flexbox_layout_common_JustifyContent;
(function (JustifyContent) {
    JustifyContent.FLEX_START = 'flex-start';
    JustifyContent.FLEX_END = 'flex-end';
    JustifyContent.CENTER = 'center';
    JustifyContent.SPACE_BETWEEN = 'space-between';
    JustifyContent.SPACE_AROUND = 'space-around';
    JustifyContent.isValid = Object(core_properties["makeValidator"])(JustifyContent.FLEX_START, JustifyContent.FLEX_END, JustifyContent.CENTER, JustifyContent.SPACE_BETWEEN, JustifyContent.SPACE_AROUND);
    JustifyContent.parse = Object(core_properties["makeParser"])(JustifyContent.isValid);
})(flexbox_layout_common_JustifyContent || (flexbox_layout_common_JustifyContent = {}));
var FlexBasisPercent;
(function (FlexBasisPercent) {
    FlexBasisPercent.DEFAULT = -1;
})(FlexBasisPercent || (FlexBasisPercent = {}));
var flexbox_layout_common_AlignItems;
(function (AlignItems) {
    AlignItems.FLEX_START = 'flex-start';
    AlignItems.FLEX_END = 'flex-end';
    AlignItems.CENTER = 'center';
    AlignItems.BASELINE = 'baseline';
    AlignItems.STRETCH = 'stretch';
    AlignItems.isValid = Object(core_properties["makeValidator"])(AlignItems.FLEX_START, AlignItems.FLEX_END, AlignItems.CENTER, AlignItems.BASELINE, AlignItems.STRETCH);
    AlignItems.parse = Object(core_properties["makeParser"])(AlignItems.isValid);
})(flexbox_layout_common_AlignItems || (flexbox_layout_common_AlignItems = {}));
var flexbox_layout_common_AlignContent;
(function (AlignContent) {
    AlignContent.FLEX_START = 'flex-start';
    AlignContent.FLEX_END = 'flex-end';
    AlignContent.CENTER = 'center';
    AlignContent.SPACE_BETWEEN = 'space-between';
    AlignContent.SPACE_AROUND = 'space-around';
    AlignContent.STRETCH = 'stretch';
    AlignContent.isValid = Object(core_properties["makeValidator"])(AlignContent.FLEX_START, AlignContent.FLEX_END, AlignContent.CENTER, AlignContent.SPACE_BETWEEN, AlignContent.SPACE_AROUND, AlignContent.STRETCH);
    AlignContent.parse = Object(core_properties["makeParser"])(AlignContent.isValid);
})(flexbox_layout_common_AlignContent || (flexbox_layout_common_AlignContent = {}));
var Order;
(function (Order) {
    function isValid(value) {
        return isFinite(parseInt(value));
    }
    Order.isValid = isValid;
    Order.parse = parseInt;
})(Order || (Order = {}));
var FlexGrow;
(function (FlexGrow) {
    function isValid(value) {
        const parsed = parseInt(value);
        return isFinite(parsed) && value >= 0;
    }
    FlexGrow.isValid = isValid;
    FlexGrow.parse = parseFloat;
})(FlexGrow || (FlexGrow = {}));
var FlexShrink;
(function (FlexShrink) {
    function isValid(value) {
        const parsed = parseInt(value);
        return isFinite(parsed) && value >= 0;
    }
    FlexShrink.isValid = isValid;
    FlexShrink.parse = parseFloat;
})(FlexShrink || (FlexShrink = {}));
var FlexWrapBefore;
(function (FlexWrapBefore) {
    function isValid(value) {
        if (typeof value === 'boolean') {
            return true;
        }
        if (typeof value === 'string') {
            const str = value.trim().toLowerCase();
            return str === 'true' || str === 'false';
        }
        return false;
    }
    FlexWrapBefore.isValid = isValid;
    function parse(value) {
        return value && value.toString().trim().toLowerCase() === 'true';
    }
    FlexWrapBefore.parse = parse;
})(FlexWrapBefore || (FlexWrapBefore = {}));
var flexbox_layout_common_AlignSelf;
(function (AlignSelf) {
    AlignSelf.AUTO = 'auto';
    AlignSelf.FLEX_START = 'flex-start';
    AlignSelf.FLEX_END = 'flex-end';
    AlignSelf.CENTER = 'center';
    AlignSelf.BASELINE = 'baseline';
    AlignSelf.STRETCH = 'stretch';
    AlignSelf.isValid = Object(core_properties["makeValidator"])(AlignSelf.AUTO, AlignSelf.FLEX_START, AlignSelf.FLEX_END, AlignSelf.CENTER, AlignSelf.BASELINE, AlignSelf.STRETCH);
    AlignSelf.parse = Object(core_properties["makeParser"])(AlignSelf.isValid);
})(flexbox_layout_common_AlignSelf || (flexbox_layout_common_AlignSelf = {}));
function flexbox_layout_common_validateArgs(element) {
    if (!element) {
        throw new Error('element cannot be null or undefinied.');
    }
    return element;
}
/**
 * A common base class for all cross platform flexbox layout implementations.
 */
let flexbox_layout_common_FlexboxLayoutBase = class FlexboxLayoutBase extends layout_base["a" /* LayoutBase */] {
    get flexDirection() {
        return this.style.flexDirection;
    }
    set flexDirection(value) {
        this.style.flexDirection = value;
    }
    get flexWrap() {
        return this.style.flexWrap;
    }
    set flexWrap(value) {
        this.style.flexWrap = value;
    }
    get justifyContent() {
        return this.style.justifyContent;
    }
    set justifyContent(value) {
        this.style.justifyContent = value;
    }
    get alignItems() {
        return this.style.alignItems;
    }
    set alignItems(value) {
        this.style.alignItems = value;
    }
    get alignContent() {
        return this.style.alignContent;
    }
    set alignContent(value) {
        this.style.alignContent = value;
    }
    static setOrder(view, order) {
        flexbox_layout_common_validateArgs(view).style.order = order;
    }
    static getOrder(view) {
        return flexbox_layout_common_validateArgs(view).style.order;
    }
    static setFlexGrow(view, grow) {
        flexbox_layout_common_validateArgs(view).style.flexGrow = grow;
    }
    static getFlexGrow(view) {
        return flexbox_layout_common_validateArgs(view).style.flexGrow;
    }
    static setFlexShrink(view, shrink) {
        flexbox_layout_common_validateArgs(view).style.flexShrink = shrink;
    }
    static getFlexShrink(view) {
        return flexbox_layout_common_validateArgs(view).style.flexShrink;
    }
    static setAlignSelf(view, align) {
        flexbox_layout_common_validateArgs(view).style.alignSelf = align;
    }
    static getAlignSelf(view) {
        return flexbox_layout_common_validateArgs(view).style.alignSelf;
    }
    static setFlexWrapBefore(view, wrap) {
        flexbox_layout_common_validateArgs(view).style.flexWrapBefore = wrap;
    }
    static getFlexWrapBefore(view) {
        return flexbox_layout_common_validateArgs(view).style.flexWrapBefore;
    }
};
flexbox_layout_common_FlexboxLayoutBase = __decorate([
    Object(view_common["a" /* CSSType */])('FlexboxLayout')
], flexbox_layout_common_FlexboxLayoutBase);

flexbox_layout_common_FlexboxLayoutBase.prototype.recycleNativeView = 'auto';
const flexDirectionProperty = new core_properties["CssProperty"]({
    name: 'flexDirection',
    cssName: 'flex-direction',
    defaultValue: flexbox_layout_common_FlexDirection.ROW,
    affectsLayout: true,
    valueConverter: flexbox_layout_common_FlexDirection.parse,
});
flexDirectionProperty.register(style["a" /* Style */]);
const flexWrapProperty = new core_properties["CssProperty"]({
    name: 'flexWrap',
    cssName: 'flex-wrap',
    defaultValue: 'nowrap',
    affectsLayout: true,
    valueConverter: flexbox_layout_common_FlexWrap.parse,
});
flexWrapProperty.register(style["a" /* Style */]);
const justifyContentProperty = new core_properties["CssProperty"]({
    name: 'justifyContent',
    cssName: 'justify-content',
    defaultValue: flexbox_layout_common_JustifyContent.FLEX_START,
    affectsLayout: true,
    valueConverter: flexbox_layout_common_JustifyContent.parse,
});
justifyContentProperty.register(style["a" /* Style */]);
const alignItemsProperty = new core_properties["CssProperty"]({
    name: 'alignItems',
    cssName: 'align-items',
    defaultValue: flexbox_layout_common_AlignItems.STRETCH,
    affectsLayout: true,
    valueConverter: flexbox_layout_common_AlignItems.parse,
});
alignItemsProperty.register(style["a" /* Style */]);
const alignContentProperty = new core_properties["CssProperty"]({
    name: 'alignContent',
    cssName: 'align-content',
    defaultValue: flexbox_layout_common_AlignContent.STRETCH,
    affectsLayout: true,
    valueConverter: flexbox_layout_common_AlignContent.parse,
});
alignContentProperty.register(style["a" /* Style */]);
const orderProperty = new core_properties["CssProperty"]({
    name: 'order',
    cssName: 'order',
    defaultValue: ORDER_DEFAULT,
    valueConverter: Order.parse,
});
orderProperty.register(style["a" /* Style */]);
Object.defineProperty(core_view["c" /* View */].prototype, 'order', {
    get() {
        return this.style.order;
    },
    set(value) {
        this.style.order = value;
    },
    enumerable: true,
    configurable: true,
});
const flexGrowProperty = new core_properties["CssProperty"]({
    name: 'flexGrow',
    cssName: 'flex-grow',
    defaultValue: FLEX_GROW_DEFAULT,
    valueConverter: FlexGrow.parse,
});
flexGrowProperty.register(style["a" /* Style */]);
Object.defineProperty(core_view["c" /* View */].prototype, 'flexGrow', {
    get() {
        return this.style.flexGrow;
    },
    set(value) {
        this.style.flexGrow = value;
    },
    enumerable: true,
    configurable: true,
});
const flexShrinkProperty = new core_properties["CssProperty"]({
    name: 'flexShrink',
    cssName: 'flex-shrink',
    defaultValue: FLEX_SHRINK_DEFAULT,
    valueConverter: FlexShrink.parse,
});
flexShrinkProperty.register(style["a" /* Style */]);
Object.defineProperty(core_view["c" /* View */].prototype, 'flexShrink', {
    get() {
        return this.style.flexShrink;
    },
    set(value) {
        this.style.flexShrink = value;
    },
    enumerable: true,
    configurable: true,
});
const flexWrapBeforeProperty = new core_properties["CssProperty"]({
    name: 'flexWrapBefore',
    cssName: 'flex-wrap-before',
    defaultValue: false,
    valueConverter: FlexWrapBefore.parse,
});
flexWrapBeforeProperty.register(style["a" /* Style */]);
Object.defineProperty(core_view["c" /* View */].prototype, 'flexWrapBefore', {
    get() {
        return this.style.flexWrapBefore;
    },
    set(value) {
        this.style.flexWrapBefore = value;
    },
    enumerable: true,
    configurable: true,
});
const alignSelfProperty = new core_properties["CssProperty"]({
    name: 'alignSelf',
    cssName: 'align-self',
    defaultValue: flexbox_layout_common_AlignSelf.AUTO,
    valueConverter: flexbox_layout_common_AlignSelf.parse,
});
alignSelfProperty.register(style["a" /* Style */]);
Object.defineProperty(core_view["c" /* View */].prototype, 'alignSelf', {
    get() {
        return this.style.alignSelf;
    },
    set(value) {
        this.style.alignSelf = value;
    },
    enumerable: true,
    configurable: true,
});
// flex-flow: <flex-direction> || <flex-wrap>
const flexFlowProperty = new core_properties["ShorthandProperty"]({
    name: 'flexFlow',
    cssName: 'flex-flow',
    getter: function () {
        return `${this.flexDirection} ${this.flexWrap}`;
    },
    converter: function (value) {
        const properties = [];
        if (value === core_properties["unsetValue"]) {
            properties.push([flexDirectionProperty, value]);
            properties.push([flexWrapProperty, value]);
        }
        else {
            const trimmed = value && value.trim();
            if (trimmed) {
                const values = trimmed.split(/\s+/);
                if (values.length >= 1 && flexbox_layout_common_FlexDirection.isValid(values[0])) {
                    properties.push([flexDirectionProperty, flexbox_layout_common_FlexDirection.parse(values[0])]);
                }
                if (value.length >= 2 && flexbox_layout_common_FlexWrap.isValid(values[1])) {
                    properties.push([flexWrapProperty, flexbox_layout_common_FlexWrap.parse(values[1])]);
                }
            }
        }
        return properties;
    },
});
flexFlowProperty.register(style["a" /* Style */]);
// flex: inital | auto | none | <flex-grow> <flex-shrink> || <flex-basis>
const flexProperty = new core_properties["ShorthandProperty"]({
    name: 'flex',
    cssName: 'flex',
    getter: function () {
        return `${this.flexGrow} ${this.flexShrink}`;
    },
    converter: function (value) {
        const properties = [];
        if (value === core_properties["unsetValue"]) {
            properties.push([flexGrowProperty, value]);
            properties.push([flexShrinkProperty, value]);
        }
        else {
            const trimmed = value && value.trim();
            if (trimmed) {
                const values = trimmed.split(/\s+/);
                if (values.length === 1) {
                    switch (values[0]) {
                        case 'inital':
                            properties.push([flexGrowProperty, 0]);
                            properties.push([flexShrinkProperty, 1]);
                            // properties.push([flexBasisProperty, FlexBasis.AUTO])
                            break;
                        case 'auto':
                            properties.push([flexGrowProperty, 1]);
                            properties.push([flexShrinkProperty, 1]);
                            // properties.push([flexBasisProperty, FlexBasis.AUTO])
                            break;
                        case 'none':
                            properties.push([flexGrowProperty, 0]);
                            properties.push([flexShrinkProperty, 0]);
                            // properties.push([flexBasisProperty, FlexBasis.AUTO])
                            break;
                        default:
                            if (FlexGrow.isValid(values[0])) {
                                properties.push([flexGrowProperty, FlexGrow.parse(values[0])]);
                                properties.push([flexShrinkProperty, 1]);
                                // properties.push([flexBasisProperty, 0])
                            }
                    }
                }
                if (values.length >= 2) {
                    if (FlexGrow.isValid(values[0]) && FlexShrink.isValid(values[1])) {
                        properties.push([flexGrowProperty, FlexGrow.parse(values[0])]);
                        properties.push([flexShrinkProperty, FlexShrink.parse(values[1])]);
                    }
                }
                // if (value.length >= 3) {
                //     properties.push({ property: flexBasisProperty, value: FlexBasis.parse(values[2])})
                // }
            }
        }
        return properties;
    },
});
flexProperty.register(style["a" /* Style */]);
//# sourceMappingURL=flexbox-layout-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/flexbox-layout/index.js




var EXACTLY = utils_common["n" /* layout */].EXACTLY;
var AT_MOST = utils_common["n" /* layout */].AT_MOST;
var UNSPECIFIED = utils_common["n" /* layout */].UNSPECIFIED;
var MEASURED_SIZE_MASK = utils_common["n" /* layout */].MEASURED_SIZE_MASK;
var MEASURED_STATE_TOO_SMALL = utils_common["n" /* layout */].MEASURED_STATE_TOO_SMALL;
function requestFlexboxLayout(value) {
    let flexbox = this.parent;
    if (flexbox instanceof flexbox_layout_common_FlexboxLayoutBase) {
        flexbox.requestLayout();
    }
}
core_view["c" /* View */].prototype[orderProperty.setNative] = requestFlexboxLayout;
core_view["c" /* View */].prototype[flexGrowProperty.setNative] = requestFlexboxLayout;
core_view["c" /* View */].prototype[flexShrinkProperty.setNative] = requestFlexboxLayout;
core_view["c" /* View */].prototype[flexWrapBeforeProperty.setNative] = requestFlexboxLayout;
core_view["c" /* View */].prototype[alignSelfProperty.setNative] = requestFlexboxLayout;
const MATCH_PARENT = -1;
const WRAP_CONTENT = -2;
const View_sUseZeroUnspecifiedMeasureSpec = true; // NOTE: android version < M
// Long ints may not be safe in JavaScript
const MAX_SIZE = 0x00ffffff & MEASURED_SIZE_MASK;
var makeMeasureSpec = utils_common["n" /* layout */].makeMeasureSpec;
var getMeasureSpecMode = utils_common["n" /* layout */].getMeasureSpecMode;
var getMeasureSpecSize = utils_common["n" /* layout */].getMeasureSpecSize;
// `eachLayoutChild` iterates over children, and we need more - indexed access.
// This class tries to accomodate that by collecting all children in an
// array no more than once per measure.
class MeasureContext {
    constructor(owner) {
        this.owner = owner;
        this.children = [];
        this.owner.eachLayoutChild((child) => {
            this.children.push(child);
        });
    }
    get childrenCount() {
        return this.children.length;
    }
    childAt(index) {
        return this.children[index];
    }
}
class FlexLine {
    constructor() {
        this._left = Number.MAX_VALUE;
        this._top = Number.MAX_VALUE;
        this._right = Number.MAX_VALUE;
        this._bottom = Number.MAX_VALUE;
        this._mainSize = 0;
        this._dividerLengthInMainSize = 0;
        this._crossSize = 0;
        this._itemCount = 0;
        this._totalFlexGrow = 0;
        this._totalFlexShrink = 0;
        this._maxBaseline = 0;
        this._indicesAlignSelfStretch = [];
    }
    get left() {
        return this._left;
    }
    get top() {
        return this._top;
    }
    get right() {
        return this._right;
    }
    get bottom() {
        return this._bottom;
    }
    get mainSize() {
        return this._mainSize;
    }
    get crossSize() {
        return this._crossSize;
    }
    get itemCount() {
        return this._itemCount;
    }
    get totalFlexGrow() {
        return this._totalFlexGrow;
    }
    get totalFlexShrink() {
        return this._totalFlexShrink;
    }
}
class flexbox_layout_Order {
    compareTo(another) {
        if (this.order !== another.order) {
            return this.order - another.order;
        }
        return this.index - another.index;
    }
}
class flexbox_layout_FlexboxLayout extends flexbox_layout_common_FlexboxLayoutBase {
    constructor() {
        // Omit divider
        super(...arguments);
        this._flexLines = [];
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        this.measureContext = new MeasureContext(this);
        // Omit: super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        if (this._isOrderChangedFromLastMeasurement) {
            this._reorderedIndices = this._createReorderedIndices();
        }
        if (!this._childrenFrozen || this._childrenFrozen.length < this.measureContext.childrenCount) {
            this._childrenFrozen = new Array(this.measureContext.childrenCount);
        }
        switch (this.flexDirection) {
            case flexbox_layout_common_FlexDirection.ROW:
            case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                this._measureHorizontal(widthMeasureSpec, heightMeasureSpec);
                break;
            case flexbox_layout_common_FlexDirection.COLUMN:
            case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                this._measureVertical(widthMeasureSpec, heightMeasureSpec);
                break;
            default:
                throw new Error('Invalid value for the flex direction is set: ' + this.flexDirection);
        }
        this._childrenFrozen.length = 0;
    }
    _getReorderedChildAt(index) {
        let child;
        if (index < 0 || index >= this._reorderedIndices.length) {
            child = null;
        }
        else {
            let reorderedIndex = this._reorderedIndices[index];
            child = this.measureContext.childAt(reorderedIndex);
        }
        return child;
    }
    _createReorderedIndices() {
        let childCount = this.measureContext.childrenCount;
        let orders = this._createOrders(childCount);
        return this._sortOrdersIntoReorderedIndices(childCount, orders);
    }
    _sortOrdersIntoReorderedIndices(childCount, orders) {
        orders.sort((a, b) => a.compareTo(b));
        if (!this._orderCache) {
            this._orderCache = [];
        }
        this._orderCache.length = 0;
        let reorderedIndices = [];
        orders.forEach((order, i) => {
            reorderedIndices[i] = order.index;
            this._orderCache[i] = order.order;
        });
        return reorderedIndices;
    }
    _createOrders(childCount) {
        let orders = [];
        for (let i = 0; i < childCount; i++) {
            let child = this.measureContext.childAt(i);
            let order = new flexbox_layout_Order();
            order.order = flexbox_layout_FlexboxLayout.getOrder(child);
            order.index = i;
            orders.push(order);
        }
        return orders;
    }
    get _isOrderChangedFromLastMeasurement() {
        let childCount = this.measureContext.childrenCount;
        if (!this._orderCache) {
            this._orderCache = [];
        }
        if (this._orderCache.length !== childCount) {
            return true;
        }
        for (let i = 0; i < childCount; i++) {
            let view = this.measureContext.childAt(i);
            if (view === null) {
                continue;
            }
            if (flexbox_layout_FlexboxLayout.getOrder(view) !== this._orderCache[i]) {
                return true;
            }
        }
        return false;
    }
    _measureHorizontal(widthMeasureSpec, heightMeasureSpec) {
        const widthSize = getMeasureSpecSize(widthMeasureSpec);
        const widthMode = getMeasureSpecMode(widthMeasureSpec);
        const heightSize = getMeasureSpecSize(heightMeasureSpec);
        const heightMode = getMeasureSpecMode(heightMeasureSpec);
        let childState = 0;
        this._flexLines.length = 0;
        (() => {
            let childCount = this.measureContext.childrenCount;
            let paddingStart = flexbox_layout_FlexboxLayout.getPaddingStart(this);
            let paddingEnd = flexbox_layout_FlexboxLayout.getPaddingEnd(this);
            let largestHeightInRow = Number.MIN_VALUE;
            let flexLine = new FlexLine();
            let indexInFlexLine = 0;
            flexLine._mainSize = paddingStart + paddingEnd;
            for (let i = 0; i < childCount; i++) {
                let child = this._getReorderedChildAt(i);
                if (child === null) {
                    this._addFlexLineIfLastFlexItem(i, childCount, flexLine);
                    continue;
                }
                else if (child.isCollapsed) {
                    flexLine._itemCount++;
                    this._addFlexLineIfLastFlexItem(i, childCount, flexLine);
                    continue;
                }
                child._updateEffectiveLayoutValues(widthSize, widthMode, heightSize, heightMode);
                let lp = child; // child.style;
                if (flexbox_layout_FlexboxLayout.getAlignSelf(child) === 'stretch') {
                    flexLine._indicesAlignSelfStretch.push(i);
                }
                let childWidth = lp.effectiveWidth;
                if (FlexBasisPercent.DEFAULT /*lp.flexBasisPercent*/ !== FlexBasisPercent.DEFAULT && widthMode === EXACTLY) {
                    childWidth = Math.round(widthSize * FlexBasisPercent.DEFAULT /*lp.flexBasisPercent*/);
                }
                let childWidthMeasureSpec = flexbox_layout_FlexboxLayout.getChildMeasureSpec(widthMeasureSpec, lp.effectivePaddingLeft + lp.effectivePaddingRight + lp.effectiveMarginLeft + lp.effectiveMarginRight, childWidth < 0 ? WRAP_CONTENT : childWidth);
                let childHeightMeasureSpec = flexbox_layout_FlexboxLayout.getChildMeasureSpec(heightMeasureSpec, lp.effectivePaddingTop + lp.effectivePaddingBottom + lp.effectiveMarginTop + lp.effectiveMarginBottom, lp.effectiveHeight < 0 ? WRAP_CONTENT : lp.effectiveHeight);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                this._checkSizeConstraints(child);
                childState = core_view["c" /* View */].combineMeasuredStates(childState, child.getMeasuredState());
                largestHeightInRow = Math.max(largestHeightInRow, child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom);
                if (this._isWrapRequired(child, widthMode, widthSize, flexLine._mainSize, child.getMeasuredWidth() + lp.effectiveMarginLeft + lp.effectiveMarginRight, i, indexInFlexLine)) {
                    if (flexLine.itemCount > 0) {
                        this._addFlexLine(flexLine);
                    }
                    flexLine = new FlexLine();
                    flexLine._itemCount = 1;
                    flexLine._mainSize = paddingStart + paddingEnd;
                    largestHeightInRow = child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom;
                    indexInFlexLine = 0;
                }
                else {
                    flexLine._itemCount++;
                    indexInFlexLine++;
                }
                flexLine._mainSize += child.getMeasuredWidth() + lp.effectiveMarginLeft + lp.effectiveMarginRight;
                flexLine._totalFlexGrow += flexbox_layout_FlexboxLayout.getFlexGrow(child);
                flexLine._totalFlexShrink += flexbox_layout_FlexboxLayout.getFlexShrink(child);
                flexLine._crossSize = Math.max(flexLine._crossSize, largestHeightInRow);
                // Omit divider
                if (this.flexWrap !== flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    flexLine._maxBaseline = Math.max(flexLine._maxBaseline, flexbox_layout_FlexboxLayout.getBaseline(child) + lp.effectiveMarginTop);
                }
                else {
                    flexLine._maxBaseline = Math.max(flexLine._maxBaseline, child.getMeasuredHeight() - flexbox_layout_FlexboxLayout.getBaseline(child) + lp.effectiveMarginBottom);
                }
                this._addFlexLineIfLastFlexItem(i, childCount, flexLine);
            }
        })();
        this._determineMainSize(this.flexDirection, widthMeasureSpec, heightMeasureSpec);
        if (this.alignItems === flexbox_layout_common_AlignItems.BASELINE) {
            let viewIndex = 0;
            this._flexLines.forEach((flexLine) => {
                let largestHeightInLine = Number.MIN_VALUE;
                for (let i = viewIndex; i < viewIndex + flexLine._itemCount; i++) {
                    let child = this._getReorderedChildAt(i);
                    const lp = child; // .style;
                    if (this.flexWrap !== flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                        let marginTop = flexLine._maxBaseline - flexbox_layout_FlexboxLayout.getBaseline(child);
                        marginTop = Math.max(marginTop, lp.effectiveMarginTop);
                        largestHeightInLine = Math.max(largestHeightInLine, child.getActualSize().height + marginTop + lp.effectiveMarginBottom);
                    }
                    else {
                        let marginBottom = flexLine._maxBaseline - child.getMeasuredHeight() + flexbox_layout_FlexboxLayout.getBaseline(child);
                        marginBottom = Math.max(marginBottom, lp.effectiveMarginBottom);
                        largestHeightInLine = Math.max(largestHeightInLine, child.getActualSize().height + lp.effectiveMarginTop + marginBottom);
                    }
                }
                flexLine._crossSize = largestHeightInLine;
                viewIndex += flexLine.itemCount;
            });
        }
        this._determineCrossSize(this.flexDirection, widthMeasureSpec, heightMeasureSpec, this.effectivePaddingTop + this.effectivePaddingBottom);
        this._stretchViews(this.flexDirection, this.alignItems);
        this._setMeasuredDimensionForFlex(this.flexDirection, widthMeasureSpec, heightMeasureSpec, childState);
    }
    _measureVertical(widthMeasureSpec, heightMeasureSpec) {
        const widthSize = getMeasureSpecSize(widthMeasureSpec);
        const widthMode = getMeasureSpecMode(widthMeasureSpec);
        const heightSize = getMeasureSpecSize(heightMeasureSpec);
        const heightMode = getMeasureSpecMode(heightMeasureSpec);
        let childState = 0;
        this._flexLines.length = 0;
        let childCount = this.measureContext.childrenCount;
        let paddingTop = this.effectivePaddingTop;
        let paddingBottom = this.effectivePaddingBottom;
        let largestWidthInColumn = Number.MIN_VALUE;
        let flexLine = new FlexLine();
        flexLine._mainSize = paddingTop + paddingBottom;
        let indexInFlexLine = 0;
        for (let i = 0; i < childCount; i++) {
            let child = this._getReorderedChildAt(i);
            if (child === null) {
                this._addFlexLineIfLastFlexItem(i, childCount, flexLine);
                continue;
            }
            else if (child.isCollapsed) {
                flexLine._itemCount++;
                this._addFlexLineIfLastFlexItem(i, childCount, flexLine);
                continue;
            }
            child._updateEffectiveLayoutValues(widthSize, widthMode, heightSize, heightMode);
            const lp = child; // .style;
            if (flexbox_layout_FlexboxLayout.getAlignSelf(child) === 'stretch') {
                flexLine._indicesAlignSelfStretch.push(i);
            }
            let childHeight = lp.effectiveHeight;
            // TODO: This should always be false
            if (FlexBasisPercent.DEFAULT /* lp.flexBasisPercent */ !== FlexBasisPercent.DEFAULT && heightMode === EXACTLY) {
                childHeight = Math.round(heightSize * FlexBasisPercent.DEFAULT /* lp.flexBasisPercent */);
            }
            let childWidthMeasureSpec = flexbox_layout_FlexboxLayout.getChildMeasureSpec(widthMeasureSpec, this.effectivePaddingLeft + this.effectivePaddingRight + lp.effectiveMarginLeft + lp.effectiveMarginRight, lp.effectiveWidth < 0 ? WRAP_CONTENT : lp.effectiveWidth);
            let childHeightMeasureSpec = flexbox_layout_FlexboxLayout.getChildMeasureSpec(heightMeasureSpec, this.effectivePaddingTop + this.effectivePaddingBottom + lp.effectiveMarginTop + lp.effectiveMarginBottom, childHeight < 0 ? WRAP_CONTENT : childHeight);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            this._checkSizeConstraints(child);
            childState = core_view["c" /* View */].combineMeasuredStates(childState, child.getMeasuredState());
            largestWidthInColumn = Math.max(largestWidthInColumn, child.getMeasuredWidth() + lp.effectiveMarginLeft + lp.effectiveMarginRight);
            if (this._isWrapRequired(child, heightMode, heightSize, flexLine.mainSize, child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom, i, indexInFlexLine)) {
                if (flexLine._itemCount > 0) {
                    this._addFlexLine(flexLine);
                }
                flexLine = new FlexLine();
                flexLine._itemCount = 1;
                flexLine._mainSize = paddingTop + paddingBottom;
                largestWidthInColumn = child.getMeasuredWidth() + lp.effectiveMarginLeft + lp.effectiveMarginRight;
                indexInFlexLine = 0;
            }
            else {
                flexLine._itemCount++;
                indexInFlexLine++;
            }
            flexLine._mainSize += child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom;
            flexLine._totalFlexGrow += flexbox_layout_FlexboxLayout.getFlexGrow(child);
            flexLine._totalFlexShrink += flexbox_layout_FlexboxLayout.getFlexShrink(child);
            flexLine._crossSize = Math.max(flexLine._crossSize, largestWidthInColumn);
            // Omit divider
            this._addFlexLineIfLastFlexItem(i, childCount, flexLine);
        }
        this._determineMainSize(this.flexDirection, widthMeasureSpec, heightMeasureSpec);
        this._determineCrossSize(this.flexDirection, widthMeasureSpec, heightMeasureSpec, this.effectivePaddingLeft + this.effectivePaddingRight);
        this._stretchViews(this.flexDirection, this.alignItems);
        this._setMeasuredDimensionForFlex(this.flexDirection, widthMeasureSpec, heightMeasureSpec, childState);
    }
    _checkSizeConstraints(view) {
        let needsMeasure = false;
        let childWidth = view.getMeasuredWidth();
        let childHeight = view.getMeasuredHeight();
        let minWidth = view.effectiveMinWidth;
        view.effectiveMinWidth = 0;
        if (view.getMeasuredWidth() < minWidth) {
            needsMeasure = true;
            childWidth = minWidth;
        }
        else if (view.getMeasuredWidth() > MAX_SIZE /*lp.maxWidth*/) {
            needsMeasure = true;
            childWidth = MAX_SIZE /*lp.maxWidth*/;
        }
        let minHeight = view.effectiveMinHeight;
        view.effectiveMinHeight = 0;
        if (childHeight < minHeight) {
            needsMeasure = true;
            childHeight = minHeight;
        }
        else if (childHeight > MAX_SIZE /*lp.maxWidth*/) {
            needsMeasure = true;
            childHeight = MAX_SIZE /*lp.maxWidth*/;
        }
        if (needsMeasure) {
            view.measure(makeMeasureSpec(childWidth, EXACTLY), makeMeasureSpec(childHeight, EXACTLY));
        }
        view.effectiveMinWidth = minWidth;
        view.effectiveMinHeight = minHeight;
    }
    _addFlexLineIfLastFlexItem(childIndex, childCount, flexLine) {
        if (childIndex === childCount - 1 && flexLine.itemCount !== 0) {
            this._addFlexLine(flexLine);
        }
    }
    _addFlexLine(flexLine) {
        // Omit divider
        this._flexLines.push(flexLine);
    }
    _determineMainSize(flexDirection, widthMeasureSpec, heightMeasureSpec) {
        let mainSize;
        let paddingAlongMainAxis;
        switch (flexDirection) {
            case flexbox_layout_common_FlexDirection.ROW:
            case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                let widthMode = getMeasureSpecMode(widthMeasureSpec);
                let widthSize = getMeasureSpecSize(widthMeasureSpec);
                if (widthMode === EXACTLY) {
                    mainSize = widthSize;
                }
                else {
                    mainSize = this._getLargestMainSize();
                }
                paddingAlongMainAxis = this.effectivePaddingLeft + this.effectivePaddingRight;
                break;
            case flexbox_layout_common_FlexDirection.COLUMN:
            case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                let heightMode = getMeasureSpecMode(heightMeasureSpec);
                let heightSize = getMeasureSpecSize(heightMeasureSpec);
                if (heightMode === EXACTLY) {
                    mainSize = heightSize;
                }
                else {
                    mainSize = this._getLargestMainSize();
                }
                paddingAlongMainAxis = this.effectivePaddingTop + this.effectivePaddingBottom;
                break;
            default:
                throw new Error('Invalid flex direction: ' + flexDirection);
        }
        let childIndex = 0;
        this._flexLines.forEach((flexLine) => {
            if (flexLine.mainSize < mainSize) {
                childIndex = this._expandFlexItems(flexLine, flexDirection, mainSize, paddingAlongMainAxis, childIndex);
            }
            else {
                childIndex = this._shrinkFlexItems(flexLine, flexDirection, mainSize, paddingAlongMainAxis, childIndex);
            }
        });
    }
    _expandFlexItems(flexLine, flexDirection, maxMainSize, paddingAlongMainAxis, startIndex) {
        let childIndex = startIndex;
        if (flexLine._totalFlexGrow <= 0 || maxMainSize < flexLine._mainSize) {
            childIndex += flexLine._itemCount;
            return childIndex;
        }
        let sizeBeforeExpand = flexLine._mainSize;
        let needsReexpand = false;
        let pendingSpace = maxMainSize - flexLine._mainSize;
        let unitSpace = pendingSpace / flexLine._totalFlexGrow;
        flexLine._mainSize = paddingAlongMainAxis + flexLine._dividerLengthInMainSize;
        let accumulatedRoundError = 0;
        for (let i = 0; i < flexLine.itemCount; i++) {
            let child = this._getReorderedChildAt(childIndex);
            if (child === null) {
                continue;
            }
            else if (child.isCollapsed) {
                childIndex++;
                continue;
            }
            const lp = child; // .style;
            if (this._isMainAxisDirectionHorizontal(flexDirection)) {
                if (!this._childrenFrozen[childIndex]) {
                    let flexGrow = flexbox_layout_FlexboxLayout.getFlexGrow(child);
                    let rawCalculatedWidth = child.getMeasuredWidth() + unitSpace * flexGrow + accumulatedRoundError;
                    let roundedCalculatedWidth = Math.round(rawCalculatedWidth);
                    // TODO: MAX_SIZE is so big, this is always false:
                    if (roundedCalculatedWidth > MAX_SIZE /* lp.maxWidth */) {
                        needsReexpand = true;
                        roundedCalculatedWidth = MAX_SIZE /* lp.maxWidth */;
                        this._childrenFrozen[childIndex] = true;
                        flexLine._totalFlexGrow -= flexGrow;
                    }
                    else {
                        accumulatedRoundError = rawCalculatedWidth - roundedCalculatedWidth;
                    }
                    child.measure(makeMeasureSpec(roundedCalculatedWidth, EXACTLY), makeMeasureSpec(child.getMeasuredHeight(), EXACTLY));
                }
                flexLine._mainSize += child.getMeasuredWidth() + lp.effectiveMarginLeft + lp.effectiveMarginRight;
            }
            else {
                if (!this._childrenFrozen[childIndex]) {
                    let flexGrow = flexbox_layout_FlexboxLayout.getFlexGrow(child);
                    let rawCalculatedHeight = child.getMeasuredHeight() + unitSpace * flexGrow + accumulatedRoundError;
                    let roundedCalculatedHeight = Math.round(rawCalculatedHeight);
                    // TODO: MAX_SIZE is so big this is always false:
                    if (roundedCalculatedHeight > MAX_SIZE /*lp.maxHeight*/) {
                        needsReexpand = true;
                        roundedCalculatedHeight = MAX_SIZE /*lp.maxHeight*/;
                        this._childrenFrozen[childIndex] = true;
                        flexLine._totalFlexGrow -= flexGrow;
                    }
                    else {
                        accumulatedRoundError = rawCalculatedHeight - roundedCalculatedHeight;
                    }
                    child.measure(makeMeasureSpec(child.getMeasuredWidth(), EXACTLY), makeMeasureSpec(roundedCalculatedHeight, EXACTLY));
                }
                flexLine._mainSize += child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom;
            }
            childIndex++;
        }
        if (needsReexpand && sizeBeforeExpand !== flexLine._mainSize) {
            this._expandFlexItems(flexLine, flexDirection, maxMainSize, paddingAlongMainAxis, startIndex);
        }
        return childIndex;
    }
    _shrinkFlexItems(flexLine, flexDirection, maxMainSize, paddingAlongMainAxis, startIndex) {
        let childIndex = startIndex;
        let sizeBeforeShrink = flexLine._mainSize;
        if (flexLine._totalFlexShrink <= 0 || maxMainSize > flexLine._mainSize) {
            childIndex += flexLine.itemCount;
            return childIndex;
        }
        let needsReshrink = false;
        let unitShrink = (flexLine._mainSize - maxMainSize) / flexLine._totalFlexShrink;
        let accumulatedRoundError = 0;
        flexLine._mainSize = paddingAlongMainAxis + flexLine._dividerLengthInMainSize;
        for (let i = 0; i < flexLine.itemCount; i++) {
            let child = this._getReorderedChildAt(childIndex);
            if (child === null) {
                continue;
            }
            else if (child.isCollapsed) {
                childIndex++;
                continue;
            }
            const lp = child; // .style;
            if (this._isMainAxisDirectionHorizontal(flexDirection)) {
                // The direction of main axis is horizontal
                if (!this._childrenFrozen[childIndex]) {
                    let flexShrink = flexbox_layout_FlexboxLayout.getFlexShrink(child);
                    let rawCalculatedWidth = child.getMeasuredWidth() - unitShrink * flexShrink + accumulatedRoundError;
                    let roundedCalculatedWidth = Math.round(rawCalculatedWidth);
                    let minWidth = child.effectiveMinWidth;
                    child.effectiveMinWidth = 0;
                    if (roundedCalculatedWidth < minWidth) {
                        needsReshrink = true;
                        roundedCalculatedWidth = minWidth;
                        this._childrenFrozen[childIndex] = true;
                        flexLine._totalFlexShrink -= flexShrink;
                    }
                    else {
                        accumulatedRoundError = rawCalculatedWidth - roundedCalculatedWidth;
                    }
                    const childWidthMeasureSpec = makeMeasureSpec(roundedCalculatedWidth, EXACTLY);
                    // NOTE: for controls that support internal content wrapping (e.g. UILabel) reducing the width
                    // might result in increased height e.g. text that could be shown on one line for larger
                    // width needs to be wrapped in two when width is reduced.
                    // As a result we cannot unconditionally measure with EXACTLY the current measured height
                    const childHeightMeasureSpec = flexbox_layout_FlexboxLayout.getChildMeasureSpec(this._currentHeightMeasureSpec, lp.effectivePaddingTop + lp.effectivePaddingBottom + lp.effectiveMarginTop + lp.effectiveMarginBottom, lp.effectiveHeight < 0 ? WRAP_CONTENT : lp.effectiveHeight);
                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    child.effectiveMinWidth = minWidth;
                    // make sure crossSize is up-to-date as child calculated height might have increased
                    flexLine._crossSize = Math.max(flexLine._crossSize, child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom);
                }
                flexLine._mainSize += child.getMeasuredWidth() + lp.effectiveMarginLeft + lp.effectiveMarginRight;
            }
            else {
                if (!this._childrenFrozen[childIndex]) {
                    let flexShrink = flexbox_layout_FlexboxLayout.getFlexShrink(child);
                    let rawCalculatedHeight = child.getMeasuredHeight() - unitShrink * flexShrink + accumulatedRoundError;
                    let roundedCalculatedHeight = Math.round(rawCalculatedHeight);
                    const minHeight = child.effectiveMinHeight;
                    child.effectiveMinHeight = 0;
                    if (roundedCalculatedHeight < minHeight) {
                        needsReshrink = true;
                        roundedCalculatedHeight = minHeight;
                        this._childrenFrozen[childIndex] = true;
                        flexLine._totalFlexShrink -= flexShrink;
                    }
                    else {
                        accumulatedRoundError = rawCalculatedHeight - roundedCalculatedHeight;
                    }
                    child.measure(makeMeasureSpec(child.getMeasuredWidth(), EXACTLY), makeMeasureSpec(roundedCalculatedHeight, EXACTLY));
                    child.effectiveMinHeight = minHeight;
                }
                flexLine._mainSize += child.getMeasuredHeight() + lp.effectiveMarginTop + lp.effectiveMarginBottom;
            }
            childIndex++;
        }
        if (needsReshrink && sizeBeforeShrink !== flexLine._mainSize) {
            this._shrinkFlexItems(flexLine, flexDirection, maxMainSize, paddingAlongMainAxis, startIndex);
        }
        return childIndex;
    }
    _determineCrossSize(flexDirection, widthMeasureSpec, heightMeasureSpec, paddingAlongCrossAxis) {
        let mode;
        let size;
        switch (flexDirection) {
            case flexbox_layout_common_FlexDirection.ROW:
            case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                mode = getMeasureSpecMode(heightMeasureSpec);
                size = getMeasureSpecSize(heightMeasureSpec);
                break;
            case flexbox_layout_common_FlexDirection.COLUMN:
            case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                mode = getMeasureSpecMode(widthMeasureSpec);
                size = getMeasureSpecSize(widthMeasureSpec);
                break;
            default:
                throw new Error('Invalid flex direction: ' + flexDirection);
        }
        if (mode === EXACTLY) {
            let totalCrossSize = this._getSumOfCrossSize() + paddingAlongCrossAxis;
            if (this._flexLines.length === 1) {
                this._flexLines[0]._crossSize = size - paddingAlongCrossAxis;
            }
            else if (this._flexLines.length >= 2 && totalCrossSize < size) {
                switch (this.alignContent) {
                    case flexbox_layout_common_AlignContent.STRETCH:
                        (() => {
                            let freeSpaceUnit = (size - totalCrossSize) / this._flexLines.length;
                            let accumulatedError = 0;
                            for (let i = 0, flexLinesSize = this._flexLines.length; i < flexLinesSize; i++) {
                                let flexLine = this._flexLines[i];
                                let newCrossSizeAsFloat = flexLine._crossSize + freeSpaceUnit;
                                if (i === this._flexLines.length - 1) {
                                    newCrossSizeAsFloat += accumulatedError;
                                    accumulatedError = 0;
                                }
                                let newCrossSize = Math.round(newCrossSizeAsFloat);
                                accumulatedError += newCrossSizeAsFloat - newCrossSize;
                                if (accumulatedError > 1) {
                                    newCrossSize += 1;
                                    accumulatedError -= 1;
                                }
                                else if (accumulatedError < -1) {
                                    newCrossSize -= 1;
                                    accumulatedError += 1;
                                }
                                flexLine._crossSize = newCrossSize;
                            }
                        })();
                        break;
                    case flexbox_layout_common_AlignContent.SPACE_AROUND:
                        (() => {
                            let spaceTopAndBottom = size - totalCrossSize;
                            let numberOfSpaces = this._flexLines.length * 2;
                            spaceTopAndBottom = spaceTopAndBottom / numberOfSpaces;
                            let newFlexLines = [];
                            let dummySpaceFlexLine = new FlexLine();
                            dummySpaceFlexLine._crossSize = spaceTopAndBottom;
                            this._flexLines.forEach((flexLine) => {
                                newFlexLines.push(dummySpaceFlexLine);
                                newFlexLines.push(flexLine);
                                newFlexLines.push(dummySpaceFlexLine);
                            });
                            this._flexLines = newFlexLines;
                        })();
                        break;
                    case flexbox_layout_common_AlignContent.SPACE_BETWEEN:
                        (() => {
                            let spaceBetweenFlexLine = size - totalCrossSize;
                            let numberOfSpaces = this._flexLines.length - 1;
                            spaceBetweenFlexLine = spaceBetweenFlexLine / numberOfSpaces;
                            let accumulatedError = 0;
                            let newFlexLines = [];
                            for (let i = 0, flexLineSize = this._flexLines.length; i < flexLineSize; i++) {
                                let flexLine = this._flexLines[i];
                                newFlexLines.push(flexLine);
                                if (i !== this._flexLines.length - 1) {
                                    let dummySpaceFlexLine = new FlexLine();
                                    if (i === this._flexLines.length - 2) {
                                        dummySpaceFlexLine._crossSize = Math.round(spaceBetweenFlexLine + accumulatedError);
                                        accumulatedError = 0;
                                    }
                                    else {
                                        dummySpaceFlexLine._crossSize = Math.round(spaceBetweenFlexLine);
                                    }
                                    accumulatedError += spaceBetweenFlexLine - dummySpaceFlexLine._crossSize;
                                    if (accumulatedError > 1) {
                                        dummySpaceFlexLine._crossSize += 1;
                                        accumulatedError -= 1;
                                    }
                                    else if (accumulatedError < -1) {
                                        dummySpaceFlexLine._crossSize -= 1;
                                        accumulatedError += 1;
                                    }
                                    newFlexLines.push(dummySpaceFlexLine);
                                }
                            }
                            this._flexLines = newFlexLines;
                        })();
                        break;
                    case flexbox_layout_common_AlignContent.CENTER: {
                        let spaceAboveAndBottom = size - totalCrossSize;
                        spaceAboveAndBottom = spaceAboveAndBottom / 2;
                        let newFlexLines = [];
                        let dummySpaceFlexLine = new FlexLine();
                        dummySpaceFlexLine._crossSize = spaceAboveAndBottom;
                        for (let i = 0, flexLineSize = this._flexLines.length; i < flexLineSize; i++) {
                            if (i === 0) {
                                newFlexLines.push(dummySpaceFlexLine);
                            }
                            let flexLine = this._flexLines[i];
                            newFlexLines.push(flexLine);
                            if (i === this._flexLines.length - 1) {
                                newFlexLines.push(dummySpaceFlexLine);
                            }
                        }
                        this._flexLines = newFlexLines;
                        break;
                    }
                    case flexbox_layout_common_AlignContent.FLEX_END: {
                        let spaceTop = size - totalCrossSize;
                        let dummySpaceFlexLine = new FlexLine();
                        dummySpaceFlexLine._crossSize = spaceTop;
                        this._flexLines.unshift(dummySpaceFlexLine);
                        break;
                    }
                }
            }
        }
    }
    _stretchViews(flexDirection, alignItems) {
        if (alignItems === flexbox_layout_common_AlignItems.STRETCH) {
            let viewIndex = 0;
            this._flexLines.forEach((flexLine) => {
                for (let i = 0; i < flexLine.itemCount; i++, viewIndex++) {
                    let view = this._getReorderedChildAt(viewIndex);
                    let alignSelf = flexbox_layout_FlexboxLayout.getAlignSelf(view);
                    if (alignSelf !== 'auto' && alignSelf !== 'stretch') {
                        continue;
                    }
                    switch (flexDirection) {
                        case flexbox_layout_common_FlexDirection.ROW:
                        case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                            this._stretchViewVertically(view, flexLine._crossSize);
                            break;
                        case flexbox_layout_common_FlexDirection.COLUMN:
                        case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                            this._stretchViewHorizontally(view, flexLine._crossSize);
                            break;
                        default:
                            throw new Error('Invalid flex direction: ' + flexDirection);
                    }
                }
            });
        }
        else {
            this._flexLines.forEach((flexLine) => {
                flexLine._indicesAlignSelfStretch.forEach((index) => {
                    let view = this._getReorderedChildAt(index);
                    switch (flexDirection) {
                        case flexbox_layout_common_FlexDirection.ROW:
                        case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                            this._stretchViewVertically(view, flexLine._crossSize);
                            break;
                        case flexbox_layout_common_FlexDirection.COLUMN:
                        case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                            this._stretchViewHorizontally(view, flexLine._crossSize);
                            break;
                        default:
                            throw new Error('Invalid flex direction: ' + flexDirection);
                    }
                });
            });
        }
    }
    _stretchViewVertically(view, crossSize) {
        let newHeight = crossSize - view.effectiveMarginTop - view.effectiveMarginBottom;
        newHeight = Math.max(newHeight, 0);
        let originalMeasuredWidth = view.getMeasuredWidth();
        let childWidthMeasureSpec = flexbox_layout_FlexboxLayout.getChildMeasureSpec(this._currentWidthMeasureSpec, view.effectivePaddingLeft + view.effectivePaddingRight + view.effectiveMarginLeft + view.effectiveMarginRight, view.effectiveWidth < 0 ? WRAP_CONTENT : Math.min(view.effectiveWidth, originalMeasuredWidth));
        view.measure(childWidthMeasureSpec, makeMeasureSpec(newHeight, EXACTLY));
        if (originalMeasuredWidth > view.getMeasuredWidth()) {
            childWidthMeasureSpec = makeMeasureSpec(originalMeasuredWidth, EXACTLY);
            view.measure(childWidthMeasureSpec, makeMeasureSpec(newHeight, EXACTLY));
        }
    }
    _stretchViewHorizontally(view, crossSize) {
        let newWidth = crossSize - view.effectiveMarginLeft - view.effectiveMarginRight;
        newWidth = Math.max(newWidth, 0);
        view.measure(makeMeasureSpec(newWidth, EXACTLY), makeMeasureSpec(view.getMeasuredHeight(), EXACTLY));
    }
    _setMeasuredDimensionForFlex(flexDirection, widthMeasureSpec, heightMeasureSpec, childState) {
        let widthMode = getMeasureSpecMode(widthMeasureSpec);
        let widthSize = getMeasureSpecSize(widthMeasureSpec);
        let heightMode = getMeasureSpecMode(heightMeasureSpec);
        let heightSize = getMeasureSpecSize(heightMeasureSpec);
        let calculatedMaxHeight;
        let calculatedMaxWidth;
        switch (flexDirection) {
            case flexbox_layout_common_FlexDirection.ROW:
            case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                calculatedMaxHeight = this._getSumOfCrossSize() + this.effectivePaddingTop + this.effectivePaddingBottom;
                calculatedMaxWidth = this._getLargestMainSize();
                break;
            case flexbox_layout_common_FlexDirection.COLUMN:
            case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                calculatedMaxHeight = this._getLargestMainSize();
                calculatedMaxWidth = this._getSumOfCrossSize() + this.effectivePaddingLeft + this.effectivePaddingRight;
                break;
            default:
                throw new Error('Invalid flex direction: ' + flexDirection);
        }
        let widthSizeAndState;
        switch (widthMode) {
            case EXACTLY:
                if (widthSize < calculatedMaxWidth) {
                    childState = core_view["c" /* View */].combineMeasuredStates(childState, MEASURED_STATE_TOO_SMALL);
                }
                widthSizeAndState = core_view["c" /* View */].resolveSizeAndState(widthSize, widthSize, widthMode, childState);
                break;
            case AT_MOST: {
                if (widthSize < calculatedMaxWidth) {
                    childState = core_view["c" /* View */].combineMeasuredStates(childState, MEASURED_STATE_TOO_SMALL);
                }
                else {
                    widthSize = calculatedMaxWidth;
                }
                widthSizeAndState = core_view["c" /* View */].resolveSizeAndState(widthSize, widthSize, widthMode, childState);
                break;
            }
            case UNSPECIFIED: {
                widthSizeAndState = core_view["c" /* View */].resolveSizeAndState(calculatedMaxWidth, widthSize, widthMode, childState);
                break;
            }
            default:
                throw new Error('Unknown width mode is set: ' + widthMode);
        }
        let heightSizeAndState;
        switch (heightMode) {
            case EXACTLY:
                if (heightSize < calculatedMaxHeight) {
                    childState = core_view["c" /* View */].combineMeasuredStates(childState, MEASURED_STATE_TOO_SMALL >> utils_common["n" /* layout */].MEASURED_HEIGHT_STATE_SHIFT);
                }
                heightSizeAndState = core_view["c" /* View */].resolveSizeAndState(heightSize, heightSize, heightMode, childState);
                break;
            case AT_MOST: {
                if (heightSize < calculatedMaxHeight) {
                    childState = core_view["c" /* View */].combineMeasuredStates(childState, MEASURED_STATE_TOO_SMALL >> utils_common["n" /* layout */].MEASURED_HEIGHT_STATE_SHIFT);
                }
                else {
                    heightSize = calculatedMaxHeight;
                }
                heightSizeAndState = core_view["c" /* View */].resolveSizeAndState(heightSize, heightSize, heightMode, childState);
                break;
            }
            case UNSPECIFIED: {
                heightSizeAndState = core_view["c" /* View */].resolveSizeAndState(calculatedMaxHeight, heightSize, heightMode, childState);
                break;
            }
            default:
                throw new Error('Unknown height mode is set: ' + heightMode);
        }
        this.setMeasuredDimension(widthSizeAndState, heightSizeAndState);
    }
    _isWrapRequired(child, mode, maxSize, currentLength, childLength, childAbsoluteIndex, childRelativeIndexInFlexLine) {
        if (this.flexWrap === flexbox_layout_common_FlexWrap.NOWRAP) {
            return false;
        }
        if (flexbox_layout_FlexboxLayout.getFlexWrapBefore(child)) {
            return true;
        }
        if (mode === UNSPECIFIED) {
            return false;
        }
        // Omit divider
        return maxSize < currentLength + childLength;
    }
    _getLargestMainSize() {
        return this._flexLines.reduce((max, flexLine) => Math.max(max, flexLine.mainSize), Number.MIN_VALUE);
    }
    _getSumOfCrossSize() {
        // Omit divider
        return this._flexLines.reduce((sum, flexLine) => sum + flexLine._crossSize, 0);
    }
    _isMainAxisDirectionHorizontal(flexDirection) {
        return flexDirection === flexbox_layout_common_FlexDirection.ROW || flexDirection === flexbox_layout_common_FlexDirection.ROW_REVERSE;
    }
    onLayout(left, top, right, bottom) {
        const insets = this.getSafeAreaInsets();
        let isRtl;
        switch (this.flexDirection) {
            case flexbox_layout_common_FlexDirection.ROW:
                isRtl = false;
                this._layoutHorizontal(isRtl, left, top, right, bottom, insets);
                break;
            case flexbox_layout_common_FlexDirection.ROW_REVERSE:
                isRtl = true;
                this._layoutHorizontal(isRtl, left, top, right, bottom, insets);
                break;
            case flexbox_layout_common_FlexDirection.COLUMN:
                isRtl = false;
                if (this.flexWrap === flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    isRtl = !isRtl;
                }
                this._layoutVertical(isRtl, false, left, top, right, bottom, insets);
                break;
            case flexbox_layout_common_FlexDirection.COLUMN_REVERSE:
                isRtl = false;
                if (this.flexWrap === flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    isRtl = !isRtl;
                }
                this._layoutVertical(isRtl, true, left, top, right, bottom, insets);
                break;
            default:
                throw new Error('Invalid flex direction is set: ' + this.flexDirection);
        }
    }
    _layoutHorizontal(isRtl, left, top, right, bottom, insets) {
        // include insets
        let paddingLeft = this.effectivePaddingLeft + insets.left;
        let paddingTop = this.effectivePaddingTop + insets.top;
        let paddingRight = this.effectivePaddingRight + insets.right;
        let paddingBottom = this.effectivePaddingBottom + insets.bottom;
        let childLeft;
        let currentViewIndex = 0;
        let height = bottom - top;
        let width = right - left;
        // include insets
        let childBottom = height - paddingBottom;
        let childTop = paddingTop;
        let childRight;
        this._flexLines.forEach((flexLine, i) => {
            // Omit divider
            let spaceBetweenItem = 0.0;
            switch (this.justifyContent) {
                case flexbox_layout_common_JustifyContent.FLEX_START:
                    childLeft = paddingLeft;
                    childRight = width - paddingRight;
                    break;
                case flexbox_layout_common_JustifyContent.FLEX_END:
                    childLeft = width - flexLine._mainSize + paddingRight;
                    childRight = flexLine._mainSize - paddingLeft;
                    break;
                case flexbox_layout_common_JustifyContent.CENTER:
                    childLeft = paddingLeft + (width - insets.left - insets.right - flexLine._mainSize) / 2.0;
                    childRight = width - paddingRight - (width - insets.left - insets.right - flexLine._mainSize) / 2.0;
                    break;
                case flexbox_layout_common_JustifyContent.SPACE_AROUND:
                    if (flexLine._itemCount !== 0) {
                        spaceBetweenItem = (width - insets.left - insets.right - flexLine.mainSize) / flexLine._itemCount;
                    }
                    childLeft = paddingLeft + spaceBetweenItem / 2.0;
                    childRight = width - paddingRight - spaceBetweenItem / 2.0;
                    break;
                case flexbox_layout_common_JustifyContent.SPACE_BETWEEN:
                    childLeft = paddingLeft;
                    let denominator = flexLine.itemCount !== 1 ? flexLine.itemCount - 1 : 1.0;
                    spaceBetweenItem = (width - insets.left - insets.right - flexLine.mainSize) / denominator;
                    childRight = width - paddingRight;
                    break;
                default:
                    throw new Error('Invalid justifyContent is set: ' + this.justifyContent);
            }
            spaceBetweenItem = Math.max(spaceBetweenItem, 0);
            for (let j = 0; j < flexLine.itemCount; j++) {
                let child = this._getReorderedChildAt(currentViewIndex);
                if (child === null) {
                    continue;
                }
                else if (child.isCollapsed) {
                    currentViewIndex++;
                    continue;
                }
                const lp = child; // .style;
                childLeft += lp.effectiveMarginLeft;
                childRight -= lp.effectiveMarginRight;
                // Omit divider
                if (this.flexWrap === flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    if (isRtl) {
                        this._layoutSingleChildHorizontal(child, flexLine, this.flexWrap, this.alignItems, Math.round(childRight) - child.getMeasuredWidth(), childBottom - child.getMeasuredHeight(), Math.round(childRight), childBottom);
                    }
                    else {
                        this._layoutSingleChildHorizontal(child, flexLine, this.flexWrap, this.alignItems, Math.round(childLeft), childBottom - child.getMeasuredHeight(), Math.round(childLeft) + child.getMeasuredWidth(), childBottom);
                    }
                }
                else {
                    if (isRtl) {
                        this._layoutSingleChildHorizontal(child, flexLine, this.flexWrap, this.alignItems, Math.round(childRight) - child.getMeasuredWidth(), childTop, Math.round(childRight), childTop + child.getMeasuredHeight());
                    }
                    else {
                        this._layoutSingleChildHorizontal(child, flexLine, this.flexWrap, this.alignItems, Math.round(childLeft), childTop, Math.round(childLeft) + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                    }
                }
                childLeft += child.getMeasuredWidth() + spaceBetweenItem + lp.effectiveMarginRight;
                childRight -= child.getMeasuredWidth() + spaceBetweenItem + lp.effectiveMarginLeft;
                currentViewIndex++;
                let bounds = child._getCurrentLayoutBounds();
                flexLine._left = Math.min(flexLine._left, bounds.left - lp.effectiveMarginLeft);
                flexLine._top = Math.min(flexLine._top, bounds.top - lp.effectiveMarginTop);
                flexLine._right = Math.max(flexLine._right, bounds.right + lp.effectiveMarginRight);
                flexLine._bottom = Math.max(flexLine._bottom, bounds.bottom + lp.effectiveMarginBottom);
            }
            childTop += flexLine._crossSize;
            childBottom -= flexLine._crossSize;
        });
    }
    _layoutSingleChildHorizontal(view, flexLine, flexWrap, alignItems, left, top, right, bottom) {
        let lp = view; // .style;
        let alignSelf = flexbox_layout_FlexboxLayout.getAlignSelf(view);
        if (alignSelf !== 'auto') {
            alignItems = alignSelf;
        }
        let crossSize = flexLine._crossSize;
        switch (alignItems) {
            case flexbox_layout_common_AlignItems.FLEX_START:
            case flexbox_layout_common_AlignItems.STRETCH:
                if (flexWrap !== flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    view.layout(left, top + lp.effectiveMarginTop, right, bottom + lp.effectiveMarginTop);
                }
                else {
                    view.layout(left, top - lp.effectiveMarginBottom, right, bottom - lp.effectiveMarginBottom);
                }
                break;
            case flexbox_layout_common_AlignItems.BASELINE:
                if (flexWrap !== flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    let marginTop = flexLine._maxBaseline - flexbox_layout_FlexboxLayout.getBaseline(view);
                    marginTop = Math.max(marginTop, lp.effectiveMarginTop);
                    view.layout(left, top + marginTop, right, bottom + marginTop);
                }
                else {
                    let marginBottom = flexLine._maxBaseline - view.getMeasuredHeight() + flexbox_layout_FlexboxLayout.getBaseline(view);
                    marginBottom = Math.max(marginBottom, lp.effectiveMarginBottom);
                    view.layout(left, top - marginBottom, right, bottom - marginBottom);
                }
                break;
            case flexbox_layout_common_AlignItems.FLEX_END:
                if (flexWrap !== flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    view.layout(left, top + crossSize - view.getMeasuredHeight() - lp.effectiveMarginBottom, right, top + crossSize - lp.effectiveMarginBottom);
                }
                else {
                    view.layout(left, top - crossSize + view.getMeasuredHeight() + lp.effectiveMarginTop, right, bottom - crossSize + view.getMeasuredHeight() + lp.effectiveMarginTop);
                }
                break;
            case flexbox_layout_common_AlignItems.CENTER:
                let topFromCrossAxis = (crossSize - view.getMeasuredHeight()) / 2;
                if (flexWrap !== flexbox_layout_common_FlexWrap.WRAP_REVERSE) {
                    view.layout(left, top + topFromCrossAxis + lp.effectiveMarginTop - lp.effectiveMarginBottom, right, top + topFromCrossAxis + view.getMeasuredHeight() + lp.effectiveMarginTop - lp.effectiveMarginBottom);
                }
                else {
                    view.layout(left, top - topFromCrossAxis + lp.effectiveMarginTop - lp.effectiveMarginBottom, right, top - topFromCrossAxis + view.getMeasuredHeight() + lp.effectiveMarginTop - lp.effectiveMarginBottom);
                }
                break;
        }
    }
    _layoutVertical(isRtl, fromBottomToTop, left, top, right, bottom, insets) {
        let paddingLeft = this.effectivePaddingLeft + insets.left;
        let paddingTop = this.effectivePaddingTop + insets.top;
        let paddingRight = this.effectivePaddingRight + insets.right;
        let paddingBottom = this.effectivePaddingBottom + insets.bottom;
        let childLeft = paddingLeft;
        let currentViewIndex = 0;
        let width = right - left;
        let height = bottom - top;
        let childRight = width - paddingRight;
        let childTop;
        let childBottom;
        this._flexLines.forEach((flexLine) => {
            // Omit divider.
            let spaceBetweenItem = 0.0;
            switch (this.justifyContent) {
                case flexbox_layout_common_JustifyContent.FLEX_START:
                    childTop = paddingTop;
                    childBottom = height - paddingBottom;
                    break;
                case flexbox_layout_common_JustifyContent.FLEX_END:
                    childTop = height - flexLine._mainSize + paddingBottom;
                    childBottom = flexLine._mainSize - paddingTop;
                    break;
                case flexbox_layout_common_JustifyContent.CENTER:
                    childTop = paddingTop + (height - insets.top - insets.bottom - flexLine._mainSize) / 2.0;
                    childBottom = height - paddingBottom - (height - insets.top - insets.bottom - flexLine._mainSize) / 2.0;
                    break;
                case flexbox_layout_common_JustifyContent.SPACE_AROUND:
                    if (flexLine._itemCount !== 0) {
                        spaceBetweenItem = (height - insets.top - insets.bottom - flexLine._mainSize) / flexLine.itemCount;
                    }
                    childTop = paddingTop + spaceBetweenItem / 2.0;
                    childBottom = height - paddingBottom - spaceBetweenItem / 2.0;
                    break;
                case flexbox_layout_common_JustifyContent.SPACE_BETWEEN:
                    childTop = paddingTop;
                    let denominator = flexLine.itemCount !== 1 ? flexLine.itemCount - 1 : 1.0;
                    spaceBetweenItem = (height - insets.top - insets.bottom - flexLine.mainSize) / denominator;
                    childBottom = height - paddingBottom;
                    break;
                default:
                    throw new Error('Invalid justifyContent is set: ' + this.justifyContent);
            }
            spaceBetweenItem = Math.max(spaceBetweenItem, 0);
            for (let j = 0; j < flexLine.itemCount; j++) {
                let child = this._getReorderedChildAt(currentViewIndex);
                if (child === null) {
                    continue;
                }
                else if (child.isCollapsed) {
                    currentViewIndex++;
                    continue;
                }
                const lp = child; // .style;
                childTop += lp.effectiveMarginTop;
                childBottom -= lp.effectiveMarginBottom;
                // Omit divider.
                if (isRtl) {
                    if (fromBottomToTop) {
                        this._layoutSingleChildVertical(child, flexLine, true, this.alignItems, childRight - child.getMeasuredWidth(), Math.round(childBottom) - child.getMeasuredHeight(), childRight, Math.round(childBottom));
                    }
                    else {
                        this._layoutSingleChildVertical(child, flexLine, true, this.alignItems, childRight - child.getMeasuredWidth(), Math.round(childTop), childRight, Math.round(childTop) + child.getMeasuredHeight());
                    }
                }
                else {
                    if (fromBottomToTop) {
                        this._layoutSingleChildVertical(child, flexLine, false, this.alignItems, childLeft, Math.round(childBottom) - child.getMeasuredHeight(), childLeft + child.getMeasuredWidth(), Math.round(childBottom));
                    }
                    else {
                        this._layoutSingleChildVertical(child, flexLine, false, this.alignItems, childLeft, Math.round(childTop), childLeft + child.getMeasuredWidth(), Math.round(childTop) + child.getMeasuredHeight());
                    }
                }
                childTop += child.getMeasuredHeight() + spaceBetweenItem + lp.effectiveMarginBottom;
                childBottom -= child.getMeasuredHeight() + spaceBetweenItem + lp.effectiveMarginTop;
                currentViewIndex++;
                let bounds = child._getCurrentLayoutBounds();
                flexLine._left = Math.min(flexLine._left, bounds.left - lp.effectiveMarginLeft);
                flexLine._top = Math.min(flexLine._top, bounds.top - lp.effectiveMarginTop);
                flexLine._right = Math.max(flexLine._right, bounds.right + lp.effectiveMarginRight);
                flexLine._bottom = Math.max(flexLine._bottom, bounds.bottom + lp.effectiveMarginBottom);
            }
            childLeft += flexLine.crossSize;
            childRight -= flexLine.crossSize;
        });
    }
    _layoutSingleChildVertical(view, flexLine, isRtl, alignItems, left, top, right, bottom) {
        let lp = view; // .style;
        let alignSelf = flexbox_layout_FlexboxLayout.getAlignSelf(view);
        if (alignSelf !== 'auto') {
            alignItems = alignSelf;
        }
        let crossSize = flexLine.crossSize;
        switch (alignItems) {
            case flexbox_layout_common_AlignItems.FLEX_START:
            case flexbox_layout_common_AlignItems.STRETCH:
            case flexbox_layout_common_AlignItems.BASELINE:
                if (!isRtl) {
                    view.layout(left + lp.effectiveMarginLeft, top, right + lp.effectiveMarginLeft, bottom);
                }
                else {
                    view.layout(left - lp.effectiveMarginRight, top, right - lp.effectiveMarginRight, bottom);
                }
                break;
            case flexbox_layout_common_AlignItems.FLEX_END:
                if (!isRtl) {
                    view.layout(left + crossSize - view.getMeasuredWidth() - lp.effectiveMarginRight, top, right + crossSize - view.getMeasuredWidth() - lp.effectiveMarginRight, bottom);
                }
                else {
                    // If the flexWrap === FLEX_WRAP_WRAP_REVERSE, the direction of the
                    // flexEnd is flipped (from left to right).
                    view.layout(left - crossSize + view.getMeasuredWidth() + lp.effectiveMarginLeft, top, right - crossSize + view.getMeasuredWidth() + lp.effectiveMarginLeft, bottom);
                }
                break;
            case flexbox_layout_common_AlignItems.CENTER:
                let leftFromCrossAxis = (crossSize - view.getMeasuredWidth()) / 2;
                if (!isRtl) {
                    view.layout(left + leftFromCrossAxis + lp.effectiveMarginLeft - lp.effectiveMarginRight, top, right + leftFromCrossAxis + lp.effectiveMarginLeft - lp.effectiveMarginRight, bottom);
                }
                else {
                    view.layout(left - leftFromCrossAxis + lp.effectiveMarginLeft - lp.effectiveMarginRight, top, right - leftFromCrossAxis + lp.effectiveMarginLeft - lp.effectiveMarginRight, bottom);
                }
                break;
        }
    }
    // Omit divider in onDraw(), drawDividersHorizontal, drawDividersVertical, drawVerticalDivider
    // requestLayout on set flexDirection, set flexWrap, set justifyContent, set alignItems, set alignContent
    // NOTE Consider moving to View if frequently used
    static getChildMeasureSpec(spec, padding, childDimension) {
        let specMode = utils_common["n" /* layout */].getMeasureSpecMode(spec);
        let specSize = utils_common["n" /* layout */].getMeasureSpecSize(spec);
        let size = Math.max(0, specSize - padding);
        let resultSize = 0;
        let resultMode = 0;
        switch (specMode) {
            // Parent has imposed an exact size on us
            case EXACTLY:
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = EXACTLY;
                }
                else if (childDimension === MATCH_PARENT) {
                    resultSize = size;
                    resultMode = EXACTLY;
                }
                else if (childDimension === WRAP_CONTENT) {
                    resultSize = size;
                    resultMode = AT_MOST;
                }
                break;
            case AT_MOST:
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = EXACTLY;
                }
                else if (childDimension === MATCH_PARENT) {
                    resultSize = size;
                    resultMode = AT_MOST;
                }
                else if (childDimension === WRAP_CONTENT) {
                    resultSize = size;
                    resultMode = AT_MOST;
                }
                break;
            case UNSPECIFIED:
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = EXACTLY;
                }
                else if (childDimension === MATCH_PARENT) {
                    resultSize = View_sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                    resultMode = UNSPECIFIED;
                }
                else if (childDimension === WRAP_CONTENT) {
                    resultSize = View_sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                    resultMode = UNSPECIFIED;
                }
                break;
        }
        return utils_common["n" /* layout */].makeMeasureSpec(resultSize, resultMode);
    }
}
(function (FlexboxLayout) {
    function getBaseline(child) {
        // TODO: Check if we support baseline for iOS.
        return 0;
    }
    FlexboxLayout.getBaseline = getBaseline;
    function getPaddingStart(child) {
        return child.effectivePaddingLeft;
    }
    FlexboxLayout.getPaddingStart = getPaddingStart;
    function getPaddingEnd(child) {
        return child.effectivePaddingRight;
    }
    FlexboxLayout.getPaddingEnd = getPaddingEnd;
})(flexbox_layout_FlexboxLayout || (flexbox_layout_FlexboxLayout = {}));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/layouts/grid-layout/index.js
var grid_layout = __webpack_require__(97);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/layouts/grid-layout/grid-layout-common.js
var grid_layout_common = __webpack_require__(73);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/layouts/stack-layout/index.js + 1 modules
var stack_layout = __webpack_require__(65);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/wrap-layout/wrap-layout-common.js





let wrap_layout_common_WrapLayoutBase = class WrapLayoutBase extends layout_base["a" /* LayoutBase */] {
};
wrap_layout_common_WrapLayoutBase = __decorate([
    Object(view_common["a" /* CSSType */])('WrapLayout')
], wrap_layout_common_WrapLayoutBase);

wrap_layout_common_WrapLayoutBase.prototype.recycleNativeView = 'auto';
const itemWidthProperty = new core_properties["Property"]({
    name: 'itemWidth',
    defaultValue: 'auto',
    affectsLayout: true,
    valueConverter: (v) => style_properties["Length"].parse(v),
    valueChanged: (target, oldValue, newValue) => (target.effectiveItemWidth = style_properties["Length"].toDevicePixels(newValue, -1)),
});
itemWidthProperty.register(wrap_layout_common_WrapLayoutBase);
const itemHeightProperty = new core_properties["Property"]({
    name: 'itemHeight',
    defaultValue: 'auto',
    affectsLayout: true,
    valueConverter: (v) => style_properties["Length"].parse(v),
    valueChanged: (target, oldValue, newValue) => (target.effectiveItemHeight = style_properties["Length"].toDevicePixels(newValue, -1)),
});
itemHeightProperty.register(wrap_layout_common_WrapLayoutBase);
const converter = Object(core_properties["makeParser"])(Object(core_properties["makeValidator"])('horizontal', 'vertical'));
const orientationProperty = new core_properties["Property"]({
    name: 'orientation',
    defaultValue: 'horizontal',
    affectsLayout: true,
    valueConverter: converter,
});
orientationProperty.register(wrap_layout_common_WrapLayoutBase);
//# sourceMappingURL=wrap-layout-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/wrap-layout/index.js




class wrap_layout_WrapLayout extends wrap_layout_common_WrapLayoutBase {
    constructor() {
        super(...arguments);
        this._lengths = new Array();
    }
    static getChildMeasureSpec(parentMode, parentLength, itemLength) {
        if (itemLength > 0) {
            return utils_common["n" /* layout */].makeMeasureSpec(itemLength, utils_common["n" /* layout */].EXACTLY);
        }
        else if (parentMode === utils_common["n" /* layout */].UNSPECIFIED) {
            return utils_common["n" /* layout */].makeMeasureSpec(0, utils_common["n" /* layout */].UNSPECIFIED);
        }
        else {
            return utils_common["n" /* layout */].makeMeasureSpec(parentLength, utils_common["n" /* layout */].AT_MOST);
        }
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        let measureWidth = 0;
        let measureHeight = 0;
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const horizontalPaddingsAndMargins = this.effectivePaddingLeft + this.effectivePaddingRight + this.effectiveBorderLeftWidth + this.effectiveBorderRightWidth;
        const verticalPaddingsAndMargins = this.effectivePaddingTop + this.effectivePaddingBottom + this.effectiveBorderTopWidth + this.effectiveBorderBottomWidth;
        const availableWidth = widthMode === utils_common["n" /* layout */].UNSPECIFIED ? Number.MAX_VALUE : width - horizontalPaddingsAndMargins;
        const availableHeight = heightMode === utils_common["n" /* layout */].UNSPECIFIED ? Number.MAX_VALUE : height - verticalPaddingsAndMargins;
        const childWidthMeasureSpec = wrap_layout_WrapLayout.getChildMeasureSpec(widthMode, availableWidth, this.effectiveItemWidth);
        const childHeightMeasureSpec = wrap_layout_WrapLayout.getChildMeasureSpec(heightMode, availableHeight, this.effectiveItemHeight);
        let remainingWidth = availableWidth;
        let remainingHeight = availableHeight;
        this._lengths.length = 0;
        let rowOrColumn = 0;
        let maxLength = 0;
        const isVertical = this.orientation === 'vertical';
        let useItemWidth = this.effectiveItemWidth > 0;
        let useItemHeight = this.effectiveItemHeight > 0;
        let itemWidth = this.effectiveItemWidth;
        let itemHeight = this.effectiveItemHeight;
        this.eachLayoutChild((child, last) => {
            const desiredSize = core_view["c" /* View */].measureChild(this, child, childWidthMeasureSpec, childHeightMeasureSpec);
            let childMeasuredWidth = useItemWidth ? itemWidth : desiredSize.measuredWidth;
            let childMeasuredHeight = useItemHeight ? itemHeight : desiredSize.measuredHeight;
            let isFirst = this._lengths.length <= rowOrColumn;
            if (isVertical) {
                if (childMeasuredHeight > remainingHeight) {
                    rowOrColumn++;
                    maxLength = Math.max(maxLength, measureHeight);
                    measureHeight = childMeasuredHeight;
                    remainingHeight = availableHeight - childMeasuredHeight;
                    this._lengths[isFirst ? rowOrColumn - 1 : rowOrColumn] = childMeasuredWidth;
                }
                else {
                    remainingHeight -= childMeasuredHeight;
                    measureHeight += childMeasuredHeight;
                }
            }
            else {
                if (childMeasuredWidth > remainingWidth) {
                    rowOrColumn++;
                    maxLength = Math.max(maxLength, measureWidth);
                    measureWidth = childMeasuredWidth;
                    remainingWidth = availableWidth - childMeasuredWidth;
                    this._lengths[isFirst ? rowOrColumn - 1 : rowOrColumn] = childMeasuredHeight;
                }
                else {
                    remainingWidth -= childMeasuredWidth;
                    measureWidth += childMeasuredWidth;
                }
            }
            if (isFirst) {
                this._lengths[rowOrColumn] = isVertical ? childMeasuredWidth : childMeasuredHeight;
            }
            else {
                this._lengths[rowOrColumn] = Math.max(this._lengths[rowOrColumn], isVertical ? childMeasuredWidth : childMeasuredHeight);
            }
        });
        if (isVertical) {
            measureHeight = Math.max(maxLength, measureHeight);
            this._lengths.forEach((value, index, array) => {
                measureWidth += value;
            });
        }
        else {
            measureWidth = Math.max(maxLength, measureWidth);
            this._lengths.forEach((value, index, array) => {
                measureHeight += value;
            });
        }
        measureWidth += horizontalPaddingsAndMargins;
        measureHeight += verticalPaddingsAndMargins;
        // Check against our minimum sizes
        measureWidth = Math.max(measureWidth, this.effectiveMinWidth);
        measureHeight = Math.max(measureHeight, this.effectiveMinHeight);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        super.onLayout(left, top, right, bottom);
        const insets = this.getSafeAreaInsets();
        const isVertical = this.orientation === 'vertical';
        const paddingLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
        const paddingTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
        const paddingRight = this.effectiveBorderRightWidth + this.effectivePaddingRight + insets.right;
        const paddingBottom = this.effectiveBorderBottomWidth + this.effectivePaddingBottom + insets.bottom;
        let childLeft = paddingLeft;
        let childTop = paddingTop;
        let childrenHeight = bottom - top - paddingBottom;
        let childrenWidth = right - left - paddingRight;
        let rowOrColumn = 0;
        this.eachLayoutChild((child, last) => {
            // Add margins because layoutChild will sustract them.
            // * density converts them to device pixels.
            let childHeight = child.getMeasuredHeight() + child.effectiveMarginTop + child.effectiveMarginBottom;
            let childWidth = child.getMeasuredWidth() + child.effectiveMarginLeft + child.effectiveMarginRight;
            let length = this._lengths[rowOrColumn];
            if (isVertical) {
                childWidth = length;
                childHeight = this.effectiveItemHeight > 0 ? this.effectiveItemHeight : childHeight;
                let isFirst = childTop === paddingTop;
                if (childTop + childHeight > childrenHeight && childLeft + childWidth <= childrenWidth) {
                    // Move to top.
                    childTop = paddingTop;
                    if (!isFirst) {
                        // Move to right with current column width.
                        childLeft += length;
                    }
                    // Move to next column.
                    rowOrColumn++;
                    // Take respective column width.
                    childWidth = this._lengths[isFirst ? rowOrColumn - 1 : rowOrColumn];
                }
                if (childLeft < childrenWidth && childTop < childrenHeight) {
                    core_view["c" /* View */].layoutChild(this, child, childLeft, childTop, childLeft + childWidth, childTop + childHeight);
                }
                // Move next child Top position to bottom.
                childTop += childHeight;
            }
            else {
                childWidth = this.effectiveItemWidth > 0 ? this.effectiveItemWidth : childWidth;
                childHeight = length;
                let isFirst = childLeft === paddingLeft;
                if (childLeft + childWidth > childrenWidth && childTop + childHeight <= childrenHeight) {
                    // Move to left.
                    childLeft = paddingLeft;
                    if (!isFirst) {
                        // Move to bottom with current row height.
                        childTop += length;
                    }
                    // Move to next row.
                    rowOrColumn++;
                    // Take respective row height.
                    childHeight = this._lengths[isFirst ? rowOrColumn - 1 : rowOrColumn];
                }
                if (childLeft < childrenWidth && childTop < childrenHeight) {
                    core_view["c" /* View */].layoutChild(this, child, childLeft, childTop, childLeft + childWidth, childTop + childHeight);
                }
                // Move next child Left position to right.
                childLeft += childWidth;
            }
        });
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/layouts/index.js







//# sourceMappingURL=index.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/list-picker/list-picker-common.js


let list_picker_common_ListPickerBase = class ListPickerBase extends core_view["c" /* View */] {
    _getItemAsString(index) {
        let items = this.items;
        if (!items) {
            return ' ';
        }
        let item = this.isItemsSource ? this.items.getItem(index) : this.items[index];
        return item === undefined || item === null ? index + '' : this.parseItem(item);
    }
    parseItem(item) {
        return this.textField ? item[this.textField] + '' : item + '';
    }
    updateSelectedValue(index) {
        let newVal = null;
        if (index >= 0) {
            const item = this.items[index];
            newVal = this.valueField ? item[this.valueField] : item;
        }
        if (this.selectedValue !== newVal) {
            this.set('selectedValue', newVal);
        }
    }
};
list_picker_common_ListPickerBase = __decorate([
    Object(view_common["a" /* CSSType */])('ListPicker')
], list_picker_common_ListPickerBase);

list_picker_common_ListPickerBase.prototype.recycleNativeView = 'auto';
const list_picker_common_selectedIndexProperty = new core_properties["CoercibleProperty"]({
    name: 'selectedIndex',
    defaultValue: -1,
    valueConverter: (v) => parseInt(v),
    coerceValue: (target, value) => {
        let items = target.items;
        if (items) {
            let max = items.length - 1;
            if (value < 0) {
                value = 0;
            }
            if (value > max) {
                value = max;
            }
        }
        else {
            value = -1;
        }
        target.updateSelectedValue(value);
        return value;
    },
});
list_picker_common_selectedIndexProperty.register(list_picker_common_ListPickerBase);
const list_picker_common_itemsProperty = new core_properties["Property"]({
    name: 'items',
    valueChanged: (target, oldValue, newValue) => {
        let getItem = newValue && newValue.getItem;
        target.isItemsSource = typeof getItem === 'function';
    },
});
list_picker_common_itemsProperty.register(list_picker_common_ListPickerBase);
const textFieldProperty = new core_properties["Property"]({
    name: 'textField',
    defaultValue: '',
});
textFieldProperty.register(list_picker_common_ListPickerBase);
const valueFieldProperty = new core_properties["Property"]({
    name: 'valueField',
    defaultValue: '',
});
valueFieldProperty.register(list_picker_common_ListPickerBase);
const selectedValueProperty = new core_properties["Property"]({
    name: 'selectedValue',
    defaultValue: null,
});
selectedValueProperty.register(list_picker_common_ListPickerBase);
//# sourceMappingURL=list-picker-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/profiling/index.js
var profiling = __webpack_require__(9);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/list-picker/index.js





class list_picker_ListPicker extends list_picker_common_ListPickerBase {
    createNativeView() {
        return UIPickerView.new();
    }
    initNativeView() {
        super.initNativeView();
        const nativeView = this.nativeViewProtected;
        nativeView.dataSource = this._dataSource = ListPickerDataSource.initWithOwner(new WeakRef(this));
        this._delegate = list_picker_ListPickerDelegateImpl.initWithOwner(new WeakRef(this));
    }
    disposeNativeView() {
        this._dataSource = null;
        this._delegate = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    onLoaded() {
        super.onLoaded();
        this.ios.delegate = this._delegate;
    }
    onUnloaded() {
        this.ios.delegate = null;
        super.onUnloaded();
    }
    [list_picker_common_selectedIndexProperty.getDefault]() {
        return -1;
    }
    [list_picker_common_selectedIndexProperty.setNative](value) {
        if (value >= 0) {
            this.ios.selectRowInComponentAnimated(value, 0, false);
        }
    }
    [list_picker_common_itemsProperty.getDefault]() {
        return null;
    }
    [list_picker_common_itemsProperty.setNative](value) {
        this.ios.reloadAllComponents();
        // Coerce selected index after we have set items to native view.
        list_picker_common_selectedIndexProperty.coerce(this);
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        return this.ios.backgroundColor;
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        this.ios.backgroundColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    [style_properties["colorProperty"].getDefault]() {
        return this.ios.tintColor;
    }
    [style_properties["colorProperty"].setNative](value) {
        this.ios.tintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
}
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], list_picker_ListPicker.prototype, "onLoaded", null);
var ListPickerDataSource = /** @class */ (function (_super) {
    __extends(ListPickerDataSource, _super);
    function ListPickerDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListPickerDataSource.initWithOwner = function (owner) {
        var dataSource = ListPickerDataSource.new();
        dataSource._owner = owner;
        return dataSource;
    };
    ListPickerDataSource.prototype.numberOfComponentsInPickerView = function (pickerView) {
        return 1;
    };
    ListPickerDataSource.prototype.pickerViewNumberOfRowsInComponent = function (pickerView, component) {
        var owner = this._owner.get();
        return owner && owner.items ? owner.items.length : 0;
    };
    ListPickerDataSource.ObjCProtocols = [UIPickerViewDataSource];
    return ListPickerDataSource;
}(NSObject));
var list_picker_ListPickerDelegateImpl = /** @class */ (function (_super) {
    __extends(ListPickerDelegateImpl, _super);
    function ListPickerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListPickerDelegateImpl.initWithOwner = function (owner) {
        var delegate = ListPickerDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    ListPickerDelegateImpl.prototype.pickerViewAttributedTitleForRowForComponent = function (pickerView, row, component) {
        var _a, _b;
        var owner = this._owner.get();
        if (owner) {
            var title = NSAttributedString.alloc().initWithStringAttributes(owner._getItemAsString(row), (_a = {}, _a[NSForegroundColorAttributeName] = pickerView.tintColor, _a));
            return title;
        }
        return NSAttributedString.alloc().initWithStringAttributes(row.toString(), (_b = {}, _b[NSForegroundColorAttributeName] = pickerView.tintColor, _b));
    };
    ListPickerDelegateImpl.prototype.pickerViewDidSelectRowInComponent = function (pickerView, row, component) {
        var owner = this._owner.get();
        if (owner) {
            list_picker_common_selectedIndexProperty.nativeValueChange(owner, row);
            owner.updateSelectedValue(row);
        }
    };
    ListPickerDelegateImpl.ObjCProtocols = [UIPickerViewDelegate];
    return ListPickerDelegateImpl;
}(NSObject));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable-array/index.js
var observable_array = __webpack_require__(14);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/list-view/list-view-common.js










const autoEffectiveRowHeight = -1;
let list_view_common_ListViewBase = class ListViewBase extends core_view["a" /* ContainerView */] {
    constructor() {
        super(...arguments);
        this._itemIdGenerator = (_item, index) => index;
        this._itemTemplateSelectorBindable = new ui_label["Label"]();
        this._defaultTemplate = {
            key: 'default',
            createView: () => {
                if (this.itemTemplate) {
                    return builder["a" /* Builder */].parse(this.itemTemplate, this);
                }
                return undefined;
            },
        };
        this._itemTemplatesInternal = new Array(this._defaultTemplate);
        this._effectiveRowHeight = autoEffectiveRowHeight;
    }
    get separatorColor() {
        return this.style.separatorColor;
    }
    set separatorColor(value) {
        this.style.separatorColor = value;
    }
    get itemTemplateSelector() {
        return this._itemTemplateSelector;
    }
    set itemTemplateSelector(value) {
        if (typeof value === 'string') {
            this._itemTemplateSelectorBindable.bind({
                sourceProperty: null,
                targetProperty: 'templateKey',
                expression: value,
            });
            this._itemTemplateSelector = (item, index, items) => {
                item['$index'] = index;
                if (this._itemTemplateSelectorBindable.bindingContext === item) {
                    this._itemTemplateSelectorBindable.bindingContext = null;
                }
                this._itemTemplateSelectorBindable.bindingContext = item;
                return this._itemTemplateSelectorBindable.get('templateKey');
            };
        }
        else if (typeof value === 'function') {
            this._itemTemplateSelector = value;
        }
    }
    get itemIdGenerator() {
        return this._itemIdGenerator;
    }
    set itemIdGenerator(generatorFn) {
        this._itemIdGenerator = generatorFn;
    }
    refresh() {
        //
    }
    scrollToIndex(index) {
        //
    }
    scrollToIndexAnimated(index) {
        //
    }
    _getItemTemplate(index) {
        let templateKey = 'default';
        if (this.itemTemplateSelector) {
            let dataItem = this._getDataItem(index);
            templateKey = this._itemTemplateSelector(dataItem, index, this.items);
        }
        for (let i = 0, length = this._itemTemplatesInternal.length; i < length; i++) {
            if (this._itemTemplatesInternal[i].key === templateKey) {
                return this._itemTemplatesInternal[i];
            }
        }
        // This is the default template
        return this._itemTemplatesInternal[0];
    }
    _prepareItem(item, index) {
        if (item) {
            item.bindingContext = this._getDataItem(index);
        }
    }
    _getDataItem(index) {
        let thisItems = this.items;
        return thisItems.getItem ? thisItems.getItem(index) : thisItems[index];
    }
    _getDefaultItemContent(index) {
        let lbl = new ui_label["Label"]();
        lbl.bind({
            targetProperty: 'text',
            sourceProperty: '$value',
        });
        return lbl;
    }
    _onItemsChanged(args) {
        this.refresh();
    }
    _onRowHeightPropertyChanged(oldValue, newValue) {
        this.refresh();
    }
    isItemAtIndexVisible(index) {
        return false;
    }
    updateEffectiveRowHeight() {
        rowHeightProperty.coerce(this);
    }
};
list_view_common_ListViewBase.itemLoadingEvent = 'itemLoading';
list_view_common_ListViewBase.itemTapEvent = 'itemTap';
list_view_common_ListViewBase.loadMoreItemsEvent = 'loadMoreItems';
// TODO: get rid of such hacks.
list_view_common_ListViewBase.knownFunctions = ['itemTemplateSelector', 'itemIdGenerator']; //See component-builder.ts isKnownFunction
list_view_common_ListViewBase = __decorate([
    Object(view_common["a" /* CSSType */])('ListView')
], list_view_common_ListViewBase);

list_view_common_ListViewBase.prototype.recycleNativeView = 'auto';
/**
 * Represents the property backing the items property of each ListView instance.
 */
const list_view_common_itemsProperty = new core_properties["Property"]({
    name: 'items',
    valueChanged: (target, oldValue, newValue) => {
        if (oldValue instanceof observable["Observable"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, target._onItemsChanged, target);
        }
        if (newValue instanceof observable["Observable"]) {
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, target._onItemsChanged, target);
        }
        target.refresh();
    },
});
list_view_common_itemsProperty.register(list_view_common_ListViewBase);
/**
 * Represents the item template property of each ListView instance.
 */
const itemTemplateProperty = new core_properties["Property"]({
    name: 'itemTemplate',
    valueChanged: (target) => {
        target.refresh();
    },
});
itemTemplateProperty.register(list_view_common_ListViewBase);
/**
 * Represents the items template property of each ListView instance.
 */
const itemTemplatesProperty = new core_properties["Property"]({
    name: 'itemTemplates',
    valueConverter: (value) => {
        if (typeof value === 'string') {
            return builder["a" /* Builder */].parseMultipleTemplates(value, null);
        }
        return value;
    },
});
itemTemplatesProperty.register(list_view_common_ListViewBase);
const defaultRowHeight = 'auto';
/**
 * Represents the observable property backing the rowHeight property of each ListView instance.
 */
const rowHeightProperty = new core_properties["CoercibleProperty"]({
    name: 'rowHeight',
    defaultValue: defaultRowHeight,
    equalityComparer: style_properties["Length"].equals,
    coerceValue: (target, value) => {
        // We coerce to default value if we don't have display density.
        return target.nativeViewProtected ? value : defaultRowHeight;
    },
    valueChanged: (target, oldValue, newValue) => {
        target._effectiveRowHeight = style_properties["Length"].toDevicePixels(newValue, autoEffectiveRowHeight);
        target._onRowHeightPropertyChanged(oldValue, newValue);
    },
    valueConverter: style_properties["Length"].parse,
});
rowHeightProperty.register(list_view_common_ListViewBase);
const iosEstimatedRowHeightProperty = new core_properties["Property"]({
    name: 'iosEstimatedRowHeight',
    valueConverter: (v) => style_properties["Length"].parse(v),
});
iosEstimatedRowHeightProperty.register(list_view_common_ListViewBase);
const separatorColorProperty = new core_properties["CssProperty"]({
    name: 'separatorColor',
    cssName: 'separator-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
separatorColorProperty.register(style["a" /* Style */]);
//# sourceMappingURL=list-view-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/proxy-view-container/index.js




/**
 * Proxy view container that adds all its native children directly to the parent.
 * To be used as a logical grouping container of views.
 */
// Cases to cover:
// * Child is added to the attached proxy. Handled in _addViewToNativeVisualTree.
// * Proxy (with children) is added to the DOM. In _addViewToNativeVisualTree _addViewToNativeVisualTree recursively when the proxy is added to the parent.
// * Child is removed from attached proxy. Handled in _removeViewFromNativeVisualTree.
// * Proxy (with children) is removed form the DOM. In _removeViewFromNativeVisualTree recursively when the proxy is removed from its parent.
let proxy_view_container_ProxyViewContainer = class ProxyViewContainer extends layout_base["a" /* LayoutBase */] {
    constructor() {
        super();
        this.proxiedLayoutProperties = new Set();
        this.nativeViewProtected = undefined;
    }
    // No native view for proxy container.
    // @ts-ignore
    get ios() {
        return null;
    }
    // @ts-ignore
    get android() {
        return null;
    }
    // get nativeView(): any {
    //     return null;
    // }
    get isLayoutRequested() {
        // Always return false so all layout requests from children bubble up.
        return false;
    }
    createNativeView() {
        return undefined;
    }
    _getNativeViewsCount() {
        let result = 0;
        this.eachChildView((cv) => {
            result += cv._getNativeViewsCount();
            return true;
        });
        return result;
    }
    _eachLayoutView(callback) {
        this.eachChildView((cv) => {
            if (!cv.isCollapsed) {
                cv._eachLayoutView(callback);
            }
            return true;
        });
    }
    _addViewToNativeVisualTree(child, atIndex) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('ProxyViewContainer._addViewToNativeVisualTree for a child ' + child + ' ViewContainer.parent: ' + this.parent, trace["a" /* Trace */].categories.ViewHierarchy);
        }
        super._addViewToNativeVisualTree(child);
        layoutProperties.forEach((propName) => {
            const proxyPropName = makeProxyPropName(propName);
            child[proxyPropName] = child[propName];
            if (this.proxiedLayoutProperties.has(propName)) {
                this._applyLayoutPropertyToChild(child, propName, this[propName]);
            }
        });
        const parent = this.parent;
        if (parent instanceof core_view["c" /* View */]) {
            let baseIndex = 0;
            let insideIndex = 0;
            if (parent instanceof layout_base["a" /* LayoutBase */]) {
                // Get my index in parent and convert it to native index.
                baseIndex = parent._childIndexToNativeChildIndex(parent.getChildIndex(this));
            }
            if (atIndex !== undefined) {
                insideIndex = this._childIndexToNativeChildIndex(atIndex);
            }
            else {
                // Add last;
                insideIndex = this._getNativeViewsCount();
            }
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write('ProxyViewContainer._addViewToNativeVisualTree at: ' + atIndex + ' base: ' + baseIndex + ' additional: ' + insideIndex, trace["a" /* Trace */].categories.ViewHierarchy);
            }
            return parent._addViewToNativeVisualTree(child, baseIndex + insideIndex);
        }
        return false;
    }
    _removeViewFromNativeVisualTree(child) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('ProxyViewContainer._removeViewFromNativeVisualTree for a child ' + child + ' ViewContainer.parent: ' + this.parent, trace["a" /* Trace */].categories.ViewHierarchy);
        }
        super._removeViewFromNativeVisualTree(child);
        const parent = this.parent;
        if (parent instanceof core_view["c" /* View */]) {
            return parent._removeViewFromNativeVisualTree(child);
        }
    }
    /*
     * Some layouts (e.g. GridLayout) need to get notified when adding and
     * removing children, so that they can update private measure data.
     *
     * We register our children with the parent to avoid breakage.
     */
    _registerLayoutChild(child) {
        const parent = this.parent;
        if (parent instanceof layout_base["a" /* LayoutBase */]) {
            parent._registerLayoutChild(child);
        }
    }
    _unregisterLayoutChild(child) {
        const parent = this.parent;
        if (parent instanceof layout_base["a" /* LayoutBase */]) {
            parent._unregisterLayoutChild(child);
        }
    }
    /*
     * Register/unregister existing children with the parent layout.
     */
    _parentChanged(oldParent) {
        // call super in order to execute base logic like clear inherited properties, etc.
        super._parentChanged(oldParent);
        const addingToParent = this.parent && !oldParent;
        const newLayout = this.parent;
        const oldLayout = oldParent;
        if (addingToParent && newLayout instanceof layout_base["a" /* LayoutBase */]) {
            this.eachLayoutChild((child) => {
                newLayout._registerLayoutChild(child);
                return true;
            });
        }
        else if (oldLayout instanceof layout_base["a" /* LayoutBase */]) {
            this.eachLayoutChild((child) => {
                oldLayout._unregisterLayoutChild(child);
                return true;
            });
        }
    }
    /**
     * Layout property changed, proxy the new value to the child view(s)
     */
    _changedLayoutProperty(propName, value) {
        const numChildren = this._getNativeViewsCount();
        if (numChildren > 1) {
            trace["a" /* Trace */].write("ProxyViewContainer._changeLayoutProperty - you're setting '" + propName + "' for " + this + ' with more than one child. Probably this is not what you want, consider wrapping it in a StackLayout ', trace["a" /* Trace */].categories.ViewHierarchy, trace["a" /* Trace */].messageType.error);
        }
        this.eachLayoutChild((child) => {
            this._applyLayoutPropertyToChild(child, propName, value);
            return true;
        });
        this.proxiedLayoutProperties.add(propName);
    }
    /**
     * Apply the layout property to the child view.
     */
    _applyLayoutPropertyToChild(child, propName, value) {
        const proxyPropName = makeProxyPropName(propName);
        if (proxyPropName in child) {
            if (child[propName] !== child[proxyPropName]) {
                // Value was set directly on the child view, don't override.
                if (trace["a" /* Trace */].isEnabled()) {
                    trace["a" /* Trace */].write('ProxyViewContainer._applyLayoutPropertyToChild child ' + child + ' has its own value [' + child[propName] + '] for [' + propName + ']', trace["a" /* Trace */].categories.ViewHierarchy);
                }
                return;
            }
        }
        child[propName] = value;
        child[proxyPropName] = value;
    }
};
proxy_view_container_ProxyViewContainer = __decorate([
    Object(view_common["a" /* CSSType */])('ProxyViewContainer'),
    __metadata("design:paramtypes", [])
], proxy_view_container_ProxyViewContainer);

// Layout propeties to be proxyed to the child views
const layoutProperties = [
    // AbsoluteLayout
    'left',
    'top',
    // DockLayout
    'dock',
    // FlexLayout
    'flexDirection',
    'flexWrap',
    'justifyContent',
    'alignItems',
    'alignContent',
    'order',
    'flexGrow',
    'flexShrink',
    'flexWrapBefore',
    'alignSelf',
    'flexFlow',
    'flex',
    // GridLayout
    'column',
    'columnSpan',
    'col',
    'colSpan',
    'row',
    'rowSpan',
];
// Override the inherited layout properties
for (const name of layoutProperties) {
    const proxyProperty = new core_properties["Property"]({
        name,
        valueChanged(target, oldValue, value) {
            target._changedLayoutProperty(name, value);
        },
    });
    proxyProperty.register(proxy_view_container_ProxyViewContainer);
}
function makeProxyPropName(propName) {
    return `_proxy:${propName}`;
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/list-view/index.js











const ITEMLOADING = list_view_common_ListViewBase.itemLoadingEvent;
const LOADMOREITEMS = list_view_common_ListViewBase.loadMoreItemsEvent;
const ITEMTAP = list_view_common_ListViewBase.itemTapEvent;
const DEFAULT_HEIGHT = 44;
const infinity = utils_common["n" /* layout */].makeMeasureSpec(0, utils_common["n" /* layout */].UNSPECIFIED);
var ListViewCell = /** @class */ (function (_super) {
    __extends(ListViewCell, _super);
    function ListViewCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListViewCell.initWithEmptyBackground = function () {
        var cell = ListViewCell.new();
        // Clear background by default - this will make cells transparent
        cell.backgroundColor = UIColor.clearColor;
        return cell;
    };
    ListViewCell.prototype.initWithStyleReuseIdentifier = function (style, reuseIdentifier) {
        var cell = _super.prototype.initWithStyleReuseIdentifier.call(this, style, reuseIdentifier);
        // Clear background by default - this will make cells transparent
        cell.backgroundColor = UIColor.clearColor;
        return cell;
    };
    ListViewCell.prototype.willMoveToSuperview = function (newSuperview) {
        var parent = (this.view ? this.view.parent : null);
        // When inside ListView and there is no newSuperview this cell is
        // removed from native visual tree so we remove it from our tree too.
        if (parent && !newSuperview) {
            parent._removeContainer(this);
        }
    };
    Object.defineProperty(ListViewCell.prototype, "view", {
        get: function () {
            return this.owner ? this.owner.get() : null;
        },
        enumerable: true,
        configurable: true
    });
    return ListViewCell;
}(UITableViewCell));
function notifyForItemAtIndex(listView, cell, view, eventName, indexPath) {
    let args = {
        eventName: eventName,
        object: listView,
        index: indexPath.row,
        view: view,
        ios: cell,
        android: undefined,
    };
    listView.notify(args);
    return args;
}
var list_view_DataSource = /** @class */ (function (_super) {
    __extends(DataSource, _super);
    function DataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DataSource.initWithOwner = function (owner) {
        var dataSource = DataSource.new();
        dataSource._owner = owner;
        return dataSource;
    };
    DataSource.prototype.tableViewNumberOfRowsInSection = function (tableView, section) {
        var owner = this._owner.get();
        return owner && owner.items ? owner.items.length : 0;
    };
    DataSource.prototype.tableViewCellForRowAtIndexPath = function (tableView, indexPath) {
        // We call this method because ...ForIndexPath calls tableViewHeightForRowAtIndexPath immediately (before we can prepare and measure it).
        var owner = this._owner.get();
        var cell;
        if (owner) {
            var template = owner._getItemTemplate(indexPath.row);
            cell = (tableView.dequeueReusableCellWithIdentifier(template.key) || ListViewCell.initWithEmptyBackground());
            owner._prepareCell(cell, indexPath);
            var cellView = cell.view;
            if (cellView && cellView.isLayoutRequired) {
                // Arrange cell views. We do it here instead of _layoutCell because _layoutCell is called
                // from 'tableViewHeightForRowAtIndexPath' method too (in iOS 7.1) and we don't want to arrange the fake cell.
                var width = utils_common["n" /* layout */].getMeasureSpecSize(owner.widthMeasureSpec);
                var rowHeight = owner._effectiveRowHeight;
                var cellHeight = rowHeight > 0 ? rowHeight : owner.getHeight(indexPath.row);
                cellView.iosOverflowSafeAreaEnabled = false;
                core_view["c" /* View */].layoutChild(owner, cellView, 0, 0, width, cellHeight);
            }
        }
        else {
            cell = ListViewCell.initWithEmptyBackground();
        }
        return cell;
    };
    DataSource.ObjCProtocols = [UITableViewDataSource];
    return DataSource;
}(NSObject));
var list_view_UITableViewDelegateImpl = /** @class */ (function (_super) {
    __extends(UITableViewDelegateImpl, _super);
    function UITableViewDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITableViewDelegateImpl.initWithOwner = function (owner) {
        var delegate = UITableViewDelegateImpl.new();
        delegate._owner = owner;
        delegate._measureCellMap = new Map();
        return delegate;
    };
    UITableViewDelegateImpl.prototype.tableViewWillDisplayCellForRowAtIndexPath = function (tableView, cell, indexPath) {
        var owner = this._owner.get();
        if (owner && indexPath.row === owner.items.length - 1) {
            owner.notify({
                eventName: LOADMOREITEMS,
                object: owner,
            });
        }
    };
    UITableViewDelegateImpl.prototype.tableViewWillSelectRowAtIndexPath = function (tableView, indexPath) {
        var cell = tableView.cellForRowAtIndexPath(indexPath);
        var owner = this._owner.get();
        if (owner) {
            notifyForItemAtIndex(owner, cell, cell.view, ITEMTAP, indexPath);
        }
        return indexPath;
    };
    UITableViewDelegateImpl.prototype.tableViewDidSelectRowAtIndexPath = function (tableView, indexPath) {
        tableView.deselectRowAtIndexPathAnimated(indexPath, true);
        return indexPath;
    };
    UITableViewDelegateImpl.prototype.tableViewHeightForRowAtIndexPath = function (tableView, indexPath) {
        var owner = this._owner.get();
        if (!owner) {
            return tableView.estimatedRowHeight;
        }
        var height = owner.getHeight(indexPath.row);
        if (height === undefined) {
            // in iOS8+ after call to scrollToRowAtIndexPath:atScrollPosition:animated: this method is called before tableViewCellForRowAtIndexPath so we need fake cell to measure its content.
            var template = owner._getItemTemplate(indexPath.row);
            var cell = this._measureCellMap.get(template.key);
            if (!cell) {
                cell = tableView.dequeueReusableCellWithIdentifier(template.key) || ListViewCell.initWithEmptyBackground();
                this._measureCellMap.set(template.key, cell);
            }
            height = owner._prepareCell(cell, indexPath);
        }
        return utils_common["n" /* layout */].toDeviceIndependentPixels(height);
    };
    UITableViewDelegateImpl.ObjCProtocols = [UITableViewDelegate];
    return UITableViewDelegateImpl;
}(NSObject));
var list_view_UITableViewRowHeightDelegateImpl = /** @class */ (function (_super) {
    __extends(UITableViewRowHeightDelegateImpl, _super);
    function UITableViewRowHeightDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITableViewRowHeightDelegateImpl.initWithOwner = function (owner) {
        var delegate = UITableViewRowHeightDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UITableViewRowHeightDelegateImpl.prototype.tableViewWillDisplayCellForRowAtIndexPath = function (tableView, cell, indexPath) {
        var owner = this._owner.get();
        if (owner && indexPath.row === owner.items.length - 1) {
            owner.notify({
                eventName: LOADMOREITEMS,
                object: owner,
            });
        }
    };
    UITableViewRowHeightDelegateImpl.prototype.tableViewWillSelectRowAtIndexPath = function (tableView, indexPath) {
        var cell = tableView.cellForRowAtIndexPath(indexPath);
        var owner = this._owner.get();
        if (owner) {
            notifyForItemAtIndex(owner, cell, cell.view, ITEMTAP, indexPath);
        }
        return indexPath;
    };
    UITableViewRowHeightDelegateImpl.prototype.tableViewDidSelectRowAtIndexPath = function (tableView, indexPath) {
        tableView.deselectRowAtIndexPathAnimated(indexPath, true);
        return indexPath;
    };
    UITableViewRowHeightDelegateImpl.prototype.tableViewHeightForRowAtIndexPath = function (tableView, indexPath) {
        var owner = this._owner.get();
        if (!owner) {
            return tableView.estimatedRowHeight;
        }
        return utils_common["n" /* layout */].toDeviceIndependentPixels(owner._effectiveRowHeight);
    };
    UITableViewRowHeightDelegateImpl.ObjCProtocols = [UITableViewDelegate];
    return UITableViewRowHeightDelegateImpl;
}(NSObject));
class list_view_ListView extends list_view_common_ListViewBase {
    constructor() {
        super();
        this.widthMeasureSpec = 0;
        this._map = new Map();
        this._heights = new Array();
    }
    createNativeView() {
        return UITableView.new();
    }
    initNativeView() {
        super.initNativeView();
        const nativeView = this.nativeViewProtected;
        nativeView.registerClassForCellReuseIdentifier(ListViewCell.class(), this._defaultTemplate.key);
        nativeView.estimatedRowHeight = DEFAULT_HEIGHT;
        nativeView.rowHeight = UITableViewAutomaticDimension;
        nativeView.dataSource = this._dataSource = list_view_DataSource.initWithOwner(new WeakRef(this));
        this._delegate = list_view_UITableViewDelegateImpl.initWithOwner(new WeakRef(this));
        this._setNativeClipToBounds();
    }
    disposeNativeView() {
        this._delegate = null;
        this._dataSource = null;
        super.disposeNativeView();
    }
    _setNativeClipToBounds() {
        // Always set clipsToBounds for list-view
        this.ios.clipsToBounds = true;
    }
    onLoaded() {
        super.onLoaded();
        if (this._isDataDirty) {
            this.refresh();
        }
        this.ios.delegate = this._delegate;
    }
    onUnloaded() {
        this.ios.delegate = null;
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    get _childrenCount() {
        return this._map.size;
    }
    eachChildView(callback) {
        this._map.forEach((view, key) => {
            callback(view);
        });
    }
    scrollToIndex(index) {
        this._scrollToIndex(index, false);
    }
    scrollToIndexAnimated(index) {
        this._scrollToIndex(index);
    }
    _scrollToIndex(index, animated = true) {
        if (!this.ios) {
            return;
        }
        const itemsLength = this.items ? this.items.length : 0;
        // mimic Android behavior that silently coerces index values within [0, itemsLength - 1] range
        if (itemsLength > 0) {
            if (index < 0) {
                index = 0;
            }
            else if (index >= itemsLength) {
                index = itemsLength - 1;
            }
            this.ios.scrollToRowAtIndexPathAtScrollPositionAnimated(NSIndexPath.indexPathForItemInSection(index, 0), 1 /* Top */, animated);
        }
        else if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`Cannot scroll listview to index ${index} when listview items not set`, trace["a" /* Trace */].categories.Binding);
        }
    }
    refresh() {
        // clear bindingContext when it is not observable because otherwise bindings to items won't reevaluate
        this._map.forEach((view, nativeView, map) => {
            if (!(view.bindingContext instanceof observable["Observable"])) {
                view.bindingContext = null;
            }
        });
        if (this.isLoaded) {
            this.ios.reloadData();
            this.requestLayout();
            this._isDataDirty = false;
        }
        else {
            this._isDataDirty = true;
        }
    }
    isItemAtIndexVisible(itemIndex) {
        const indexes = Array.from(this.ios.indexPathsForVisibleRows);
        return indexes.some((visIndex) => visIndex.row === itemIndex);
    }
    getHeight(index) {
        return this._heights[index];
    }
    setHeight(index, value) {
        this._heights[index] = value;
    }
    _onRowHeightPropertyChanged(oldValue, newValue) {
        const value = utils_common["n" /* layout */].toDeviceIndependentPixels(this._effectiveRowHeight);
        const nativeView = this.ios;
        if (value < 0) {
            nativeView.rowHeight = UITableViewAutomaticDimension;
            nativeView.estimatedRowHeight = DEFAULT_HEIGHT;
            this._delegate = list_view_UITableViewDelegateImpl.initWithOwner(new WeakRef(this));
        }
        else {
            nativeView.rowHeight = value;
            nativeView.estimatedRowHeight = value;
            this._delegate = list_view_UITableViewRowHeightDelegateImpl.initWithOwner(new WeakRef(this));
        }
        if (this.isLoaded) {
            nativeView.delegate = this._delegate;
        }
        super._onRowHeightPropertyChanged(oldValue, newValue);
    }
    requestLayout() {
        // When preparing cell don't call super - no need to invalidate our measure when cell desiredSize is changed.
        if (!this._preparingCell) {
            super.requestLayout();
        }
    }
    measure(widthMeasureSpec, heightMeasureSpec) {
        this.widthMeasureSpec = widthMeasureSpec;
        const changed = this._setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec);
        super.measure(widthMeasureSpec, heightMeasureSpec);
        if (changed) {
            this.ios.reloadData();
        }
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        this._map.forEach((childView, listViewCell) => {
            core_view["c" /* View */].measureChild(this, childView, childView._currentWidthMeasureSpec, childView._currentHeightMeasureSpec);
        });
    }
    onLayout(left, top, right, bottom) {
        super.onLayout(left, top, right, bottom);
        this._map.forEach((childView, listViewCell) => {
            let rowHeight = this._effectiveRowHeight;
            let cellHeight = rowHeight > 0 ? rowHeight : this.getHeight(childView._listViewItemIndex);
            if (cellHeight) {
                let width = utils_common["n" /* layout */].getMeasureSpecSize(this.widthMeasureSpec);
                childView.iosOverflowSafeAreaEnabled = false;
                core_view["c" /* View */].layoutChild(this, childView, 0, 0, width, cellHeight);
            }
        });
    }
    _layoutCell(cellView, indexPath) {
        if (cellView) {
            const rowHeight = this._effectiveRowHeight;
            const heightMeasureSpec = rowHeight >= 0 ? utils_common["n" /* layout */].makeMeasureSpec(rowHeight, utils_common["n" /* layout */].EXACTLY) : infinity;
            const measuredSize = core_view["c" /* View */].measureChild(this, cellView, this.widthMeasureSpec, heightMeasureSpec);
            const height = measuredSize.measuredHeight;
            this.setHeight(indexPath.row, height);
            return height;
        }
        return this.ios.estimatedRowHeight;
    }
    _prepareCell(cell, indexPath) {
        let cellHeight;
        try {
            this._preparingCell = true;
            let view = cell.view;
            if (!view) {
                view = this._getItemTemplate(indexPath.row).createView();
            }
            let args = notifyForItemAtIndex(this, cell, view, ITEMLOADING, indexPath);
            view = args.view || this._getDefaultItemContent(indexPath.row);
            // Proxy containers should not get treated as layouts.
            // Wrap them in a real layout as well.
            if (view instanceof proxy_view_container_ProxyViewContainer) {
                let sp = new stack_layout["StackLayout"]();
                sp.addChild(view);
                view = sp;
            }
            // If cell is reused it have old content - remove it first.
            if (!cell.view) {
                cell.owner = new WeakRef(view);
            }
            else if (cell.view !== view) {
                this._removeContainer(cell);
                cell.view.nativeViewProtected.removeFromSuperview();
                cell.owner = new WeakRef(view);
            }
            this._prepareItem(view, indexPath.row);
            view._listViewItemIndex = indexPath.row;
            this._map.set(cell, view);
            // We expect that views returned from itemLoading are new (e.g. not reused).
            if (view && !view.parent) {
                this._addView(view);
                cell.contentView.addSubview(view.nativeViewProtected);
            }
            cellHeight = this._layoutCell(view, indexPath);
        }
        finally {
            this._preparingCell = false;
        }
        return cellHeight;
    }
    _removeContainer(cell) {
        let view = cell.view;
        // This is to clear the StackLayout that is used to wrap ProxyViewContainer instances.
        if (!(view.parent instanceof list_view_ListView)) {
            this._removeView(view.parent);
        }
        // No need to request layout when we are removing cells.
        const preparing = this._preparingCell;
        this._preparingCell = true;
        view.parent._removeView(view);
        view._listViewItemIndex = undefined;
        this._preparingCell = preparing;
        this._map.delete(cell);
    }
    [separatorColorProperty.getDefault]() {
        return this.ios.separatorColor;
    }
    [separatorColorProperty.setNative](value) {
        this.ios.separatorColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    [itemTemplatesProperty.getDefault]() {
        return null;
    }
    [itemTemplatesProperty.setNative](value) {
        this._itemTemplatesInternal = new Array(this._defaultTemplate);
        if (value) {
            for (let i = 0, length = value.length; i < length; i++) {
                this.ios.registerClassForCellReuseIdentifier(ListViewCell.class(), value[i].key);
            }
            this._itemTemplatesInternal = this._itemTemplatesInternal.concat(value);
        }
        this.refresh();
    }
    [iosEstimatedRowHeightProperty.getDefault]() {
        return DEFAULT_HEIGHT;
    }
    [iosEstimatedRowHeightProperty.setNative](value) {
        const nativeView = this.ios;
        const estimatedHeight = style_properties["Length"].toDevicePixels(value, 0);
        nativeView.estimatedRowHeight = estimatedHeight < 0 ? DEFAULT_HEIGHT : estimatedHeight;
    }
}
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], list_view_ListView.prototype, "onLoaded", null);
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/page/index.js
var ui_page = __webpack_require__(84);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/page/page-common.js
var page_common = __webpack_require__(66);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/placeholder/index.js


class placeholder_Placeholder extends core_view["c" /* View */] {
    createNativeView() {
        const args = {
            eventName: placeholder_Placeholder.creatingViewEvent,
            object: this,
            view: undefined,
            context: this._context,
        };
        this.notify(args);
        return args.view;
    }
}
placeholder_Placeholder.creatingViewEvent = 'creatingView';
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/progress/progress-common.js


let progress_common_ProgressBase = class ProgressBase extends core_view["c" /* View */] {
};
progress_common_ProgressBase = __decorate([
    Object(view_common["a" /* CSSType */])('Progress')
], progress_common_ProgressBase);

progress_common_ProgressBase.prototype.recycleNativeView = 'auto';
/**
 * Represents the observable property backing the value property of each Progress instance.
 */
const valueProperty = new core_properties["CoercibleProperty"]({
    name: 'value',
    defaultValue: 0,
    coerceValue: (t, v) => {
        return v < 0 ? 0 : Math.min(v, t.maxValue);
    },
    valueConverter: (v) => parseInt(v),
});
valueProperty.register(progress_common_ProgressBase);
/**
 * Represents the observable property backing the maxValue property of each Progress instance.
 */
const maxValueProperty = new core_properties["Property"]({
    name: 'maxValue',
    defaultValue: 100,
    valueChanged: (target, oldValue, newValue) => {
        valueProperty.coerce(target);
    },
    valueConverter: (v) => parseInt(v),
});
maxValueProperty.register(progress_common_ProgressBase);
//# sourceMappingURL=progress-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/progress/index.js




class progress_Progress extends progress_common_ProgressBase {
    createNativeView() {
        return UIProgressView.new();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    [valueProperty.getDefault]() {
        return 0;
    }
    [valueProperty.setNative](value) {
        this.ios.progress = value / this.maxValue;
    }
    [maxValueProperty.getDefault]() {
        return 100;
    }
    [maxValueProperty.setNative](value) {
        this.ios.progress = this.value / value;
    }
    [style_properties["colorProperty"].getDefault]() {
        return this.ios.progressTintColor;
    }
    [style_properties["colorProperty"].setNative](value) {
        this.ios.progressTintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        return this.ios.trackTintColor;
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.ios.trackTintColor = color;
    }
    [style_properties["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["backgroundInternalProperty"].setNative](value) {
        //
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/repeater/index.js









/**
 * Represents a UI Repeater component.
 */
let repeater_Repeater = class Repeater extends core_view["b" /* CustomLayoutView */] {
    constructor() {
        super();
        this._isDirty = false;
        // TODO: Do we need this as property?
        this.itemsLayout = new stack_layout["StackLayout"]();
    }
    onLoaded() {
        if (this._isDirty) {
            this.refresh();
        }
        super.onLoaded();
    }
    get itemTemplateSelector() {
        return this._itemTemplateSelector;
    }
    set itemTemplateSelector(value) {
        if (typeof value === 'string') {
            if (!this._itemTemplateSelectorBindable) {
                this._itemTemplateSelectorBindable = new ui_label["Label"]();
            }
            this._itemTemplateSelectorBindable.bind({
                sourceProperty: null,
                targetProperty: 'templateKey',
                expression: value,
            });
            this._itemTemplateSelector = (item, index, items) => {
                item['$index'] = index;
                if (this._itemTemplateSelectorBindable.bindingContext === item) {
                    this._itemTemplateSelectorBindable.bindingContext = null;
                }
                this._itemTemplateSelectorBindable.bindingContext = item;
                return this._itemTemplateSelectorBindable.get('templateKey');
            };
        }
        else if (typeof value === 'function') {
            this._itemTemplateSelector = value;
        }
    }
    _requestRefresh() {
        this._isDirty = true;
        if (this.isLoaded) {
            this.refresh();
        }
    }
    /**
     * Forces the Repeater to reload all its items.
     */
    refresh() {
        if (this.itemsLayout) {
            this.itemsLayout.removeChildren();
        }
        if (!this.items) {
            return;
        }
        const length = this.items.length;
        for (let i = 0; i < length; i++) {
            const dataItem = this._getDataItem(i);
            let viewToAdd = null;
            if (this._itemTemplateSelector && this.itemTemplates) {
                const key = this._itemTemplateSelector(dataItem, i, this.items);
                const length2 = this.itemTemplates.length;
                for (let j = 0; j < length2; j++) {
                    const template = this.itemTemplates[j];
                    if (template.key === key) {
                        viewToAdd = template.createView();
                        break;
                    }
                }
            }
            if (!viewToAdd) {
                viewToAdd = this.itemTemplate ? builder["a" /* Builder */].parse(this.itemTemplate, this) : this._getDefaultItemContent(i);
            }
            viewToAdd.bindingContext = dataItem;
            this.itemsLayout.addChild(viewToAdd);
        }
        this._isDirty = false;
    }
    _onItemsChanged(data) {
        // TODO: use the event args and optimize this code by remove/add single items instead of full rebuild.
        this._requestRefresh();
    }
    _getDefaultItemContent(index) {
        const lbl = new ui_label["Label"]();
        lbl.bind({
            targetProperty: 'text',
            sourceProperty: '$value',
        });
        return lbl;
    }
    _getDataItem(index) {
        let items = this.items;
        return items.getItem ? items.getItem(index) : this.items[index];
    }
    get _childrenCount() {
        return this.itemsLayout ? 1 : 0;
    }
    eachChildView(callback) {
        if (this.itemsLayout) {
            callback(this.itemsLayout);
        }
    }
    onLayout(left, top, right, bottom) {
        const insets = this.getSafeAreaInsets();
        const paddingLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
        const paddingTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
        const paddingRight = this.effectiveBorderRightWidth + this.effectivePaddingRight + insets.right;
        const paddingBottom = this.effectiveBorderBottomWidth + this.effectivePaddingBottom + insets.bottom;
        const childLeft = paddingLeft;
        const childTop = paddingTop;
        const childRight = right - left - paddingRight;
        const childBottom = bottom - top - paddingBottom;
        core_view["c" /* View */].layoutChild(this, this.itemsLayout, childLeft, childTop, childRight, childBottom);
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const result = core_view["c" /* View */].measureChild(this, this.itemsLayout, widthMeasureSpec, heightMeasureSpec);
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(result.measuredWidth, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(result.measuredHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
};
// TODO: get rid of such hacks.
repeater_Repeater.knownFunctions = ['itemTemplateSelector']; // See component-builder.ts isKnownFunction
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], repeater_Repeater.prototype, "onLoaded", null);
repeater_Repeater = __decorate([
    Object(view_common["a" /* CSSType */])('Repeater'),
    __metadata("design:paramtypes", [])
], repeater_Repeater);

repeater_Repeater.prototype.recycleNativeView = 'auto';
/**
 * Represents the item template property of each Repeater instance.
 */
const repeater_itemTemplateProperty = new core_properties["Property"]({
    name: 'itemTemplate',
    affectsLayout: true,
    valueChanged: (target) => {
        target._requestRefresh();
    },
});
repeater_itemTemplateProperty.register(repeater_Repeater);
/**
 * Represents the items template property of each Repeater instance.
 */
const repeater_itemTemplatesProperty = new core_properties["Property"]({
    name: 'itemTemplates',
    affectsLayout: true,
    valueConverter: (value) => {
        if (typeof value === 'string') {
            return builder["a" /* Builder */].parseMultipleTemplates(value, null);
        }
        return value;
    },
    valueChanged: (target) => {
        target._requestRefresh();
    },
});
repeater_itemTemplatesProperty.register(repeater_Repeater);
/**
 * Represents the property backing the items property of each Repeater instance.
 */
const repeater_itemsProperty = new core_properties["Property"]({
    name: 'items',
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        if (oldValue instanceof observable_array["ObservableArray"]) {
            Object(weak_event_listener["b" /* removeWeakEventListener */])(oldValue, observable_array["ObservableArray"].changeEvent, target._onItemsChanged, target);
        }
        if (newValue instanceof observable_array["ObservableArray"]) {
            Object(weak_event_listener["a" /* addWeakEventListener */])(newValue, observable_array["ObservableArray"].changeEvent, target._onItemsChanged, target);
        }
        target._requestRefresh();
    },
});
repeater_itemsProperty.register(repeater_Repeater);
const itemsLayoutProperty = new core_properties["Property"]({
    name: 'itemsLayout',
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        if (oldValue) {
            target._removeView(oldValue);
            oldValue.removeChildren();
        }
        if (newValue) {
            target._addView(newValue);
        }
        target._requestRefresh();
    },
});
itemsLayoutProperty.register(repeater_Repeater);
//# sourceMappingURL=index.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/scroll-view/scroll-view-common.js
var ScrollViewBase_1;





let scroll_view_common_ScrollViewBase = ScrollViewBase_1 = class ScrollViewBase extends content_view["a" /* ContentView */] {
    constructor() {
        super(...arguments);
        this._scrollChangeCount = 0;
    }
    addEventListener(arg, callback, thisArg) {
        super.addEventListener(arg, callback, thisArg);
        if (arg === ScrollViewBase_1.scrollEvent) {
            this._scrollChangeCount++;
            this.attach();
        }
    }
    removeEventListener(arg, callback, thisArg) {
        super.removeEventListener(arg, callback, thisArg);
        if (arg === ScrollViewBase_1.scrollEvent) {
            this._scrollChangeCount--;
            this.dettach();
        }
    }
    onLoaded() {
        super.onLoaded();
        this.attach();
    }
    onUnloaded() {
        super.onUnloaded();
        this.dettach();
    }
    attach() {
        if (this._scrollChangeCount > 0 && this.isLoaded) {
            this.attachNative();
        }
    }
    dettach() {
        if (this._scrollChangeCount === 0 && this.isLoaded) {
            this.dettachNative();
        }
    }
    attachNative() {
        //
    }
    dettachNative() {
        //
    }
    get horizontalOffset() {
        return 0;
    }
    get verticalOffset() {
        return 0;
    }
    get scrollableWidth() {
        return 0;
    }
    get scrollableHeight() {
        return 0;
    }
};
scroll_view_common_ScrollViewBase.scrollEvent = 'scroll';
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], scroll_view_common_ScrollViewBase.prototype, "onLoaded", null);
scroll_view_common_ScrollViewBase = ScrollViewBase_1 = __decorate([
    Object(view_common["a" /* CSSType */])('ScrollView')
], scroll_view_common_ScrollViewBase);

const scroll_view_common_converter = Object(core_properties["makeParser"])(Object(core_properties["makeValidator"])('horizontal', 'vertical'));
const scroll_view_common_orientationProperty = new core_properties["Property"]({
    name: 'orientation',
    defaultValue: 'vertical',
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        target._onOrientationChanged();
    },
    valueConverter: scroll_view_common_converter,
});
scroll_view_common_orientationProperty.register(scroll_view_common_ScrollViewBase);
const scrollBarIndicatorVisibleProperty = new core_properties["Property"]({
    name: 'scrollBarIndicatorVisible',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
scrollBarIndicatorVisibleProperty.register(scroll_view_common_ScrollViewBase);
const isScrollEnabledProperty = new core_properties["Property"]({
    name: 'isScrollEnabled',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
isScrollEnabledProperty.register(scroll_view_common_ScrollViewBase);
//# sourceMappingURL=scroll-view-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/scroll-view/index.js




const scroll_view_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
var UIScrollViewDelegateImpl = /** @class */ (function (_super) {
    __extends(UIScrollViewDelegateImpl, _super);
    function UIScrollViewDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIScrollViewDelegateImpl.initWithOwner = function (owner) {
        var impl = UIScrollViewDelegateImpl.new();
        impl._owner = owner;
        return impl;
    };
    UIScrollViewDelegateImpl.prototype.scrollViewDidScroll = function (sv) {
        var owner = this._owner.get();
        if (owner) {
            owner.notify({
                object: owner,
                eventName: 'scroll',
                scrollX: owner.horizontalOffset,
                scrollY: owner.verticalOffset,
            });
        }
    };
    UIScrollViewDelegateImpl.ObjCProtocols = [UIScrollViewDelegate];
    return UIScrollViewDelegateImpl;
}(NSObject));
class scroll_view_ScrollView extends scroll_view_common_ScrollViewBase {
    constructor() {
        super(...arguments);
        this._contentMeasuredWidth = 0;
        this._contentMeasuredHeight = 0;
    }
    createNativeView() {
        const view = UIScrollView.new();
        return view;
    }
    initNativeView() {
        super.initNativeView();
        this.updateScrollBarVisibility(this.scrollBarIndicatorVisible);
        this._setNativeClipToBounds();
    }
    _setNativeClipToBounds() {
        // Always set clipsToBounds for scroll-view
        this.nativeViewProtected.clipsToBounds = true;
    }
    attachNative() {
        this._delegate = UIScrollViewDelegateImpl.initWithOwner(new WeakRef(this));
        this.nativeViewProtected.delegate = this._delegate;
    }
    dettachNative() {
        this.nativeViewProtected.delegate = null;
    }
    updateScrollBarVisibility(value) {
        if (!this.nativeViewProtected) {
            return;
        }
        if (this.orientation === 'horizontal') {
            this.nativeViewProtected.showsHorizontalScrollIndicator = value;
        }
        else {
            this.nativeViewProtected.showsVerticalScrollIndicator = value;
        }
    }
    get horizontalOffset() {
        return this.nativeViewProtected ? this.nativeViewProtected.contentOffset.x : 0;
    }
    get verticalOffset() {
        return this.nativeViewProtected ? this.nativeViewProtected.contentOffset.y : 0;
    }
    get scrollableWidth() {
        if (!this.nativeViewProtected || this.orientation !== 'horizontal') {
            return 0;
        }
        return Math.max(0, this.nativeViewProtected.contentSize.width - this.nativeViewProtected.bounds.size.width);
    }
    get scrollableHeight() {
        if (!this.nativeViewProtected || this.orientation !== 'vertical') {
            return 0;
        }
        return Math.max(0, this.nativeViewProtected.contentSize.height - this.nativeViewProtected.bounds.size.height);
    }
    [isScrollEnabledProperty.getDefault]() {
        return this.nativeViewProtected.scrollEnabled;
    }
    [isScrollEnabledProperty.setNative](value) {
        this.nativeViewProtected.scrollEnabled = value;
    }
    [scrollBarIndicatorVisibleProperty.getDefault]() {
        return true;
    }
    [scrollBarIndicatorVisibleProperty.setNative](value) {
        this.updateScrollBarVisibility(value);
    }
    scrollToVerticalOffset(value, animated) {
        if (this.nativeViewProtected && this.orientation === 'vertical' && this.isScrollEnabled) {
            const bounds = this.nativeViewProtected.bounds.size;
            this.nativeViewProtected.scrollRectToVisibleAnimated(CGRectMake(0, value, bounds.width, bounds.height), animated);
        }
    }
    scrollToHorizontalOffset(value, animated) {
        if (this.nativeViewProtected && this.orientation === 'horizontal' && this.isScrollEnabled) {
            const bounds = this.nativeViewProtected.bounds.size;
            this.nativeViewProtected.scrollRectToVisibleAnimated(CGRectMake(value, 0, bounds.width, bounds.height), animated);
        }
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        // Don't call measure because it will measure content twice.
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const child = this.layoutView;
        this._contentMeasuredWidth = this.effectiveMinWidth;
        this._contentMeasuredHeight = this.effectiveMinHeight;
        if (child) {
            let childSize;
            if (this.orientation === 'vertical') {
                childSize = core_view["c" /* View */].measureChild(this, child, widthMeasureSpec, utils_common["n" /* layout */].makeMeasureSpec(0, utils_common["n" /* layout */].UNSPECIFIED));
            }
            else {
                childSize = core_view["c" /* View */].measureChild(this, child, utils_common["n" /* layout */].makeMeasureSpec(0, utils_common["n" /* layout */].UNSPECIFIED), heightMeasureSpec);
            }
            this._contentMeasuredWidth = Math.max(childSize.measuredWidth, this.effectiveMinWidth);
            this._contentMeasuredHeight = Math.max(childSize.measuredHeight, this.effectiveMinHeight);
        }
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(this._contentMeasuredWidth, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(this._contentMeasuredHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    onLayout(left, top, right, bottom) {
        const insets = this.getSafeAreaInsets();
        let width = right - left - insets.right - insets.left;
        let height = bottom - top - insets.bottom - insets.top;
        const nativeView = this.nativeViewProtected;
        if (scroll_view_majorVersion > 10) {
            // Disable automatic adjustment of scroll view insets
            // Consider exposing this as property with all 4 modes
            // https://developer.apple.com/documentation/uikit/uiscrollview/contentinsetadjustmentbehavior
            nativeView.contentInsetAdjustmentBehavior = 2;
        }
        let scrollWidth = width + insets.left + insets.right;
        let scrollHeight = height + insets.top + insets.bottom;
        if (this.orientation === 'horizontal') {
            scrollWidth = Math.max(this._contentMeasuredWidth + insets.left + insets.right, scrollWidth);
            width = Math.max(this._contentMeasuredWidth, width);
        }
        else {
            scrollHeight = Math.max(this._contentMeasuredHeight + insets.top + insets.bottom, scrollHeight);
            height = Math.max(this._contentMeasuredHeight, height);
        }
        nativeView.contentSize = CGSizeMake(utils_common["n" /* layout */].toDeviceIndependentPixels(scrollWidth), utils_common["n" /* layout */].toDeviceIndependentPixels(scrollHeight));
        core_view["c" /* View */].layoutChild(this, this.layoutView, insets.left, insets.top, insets.left + width, insets.top + height);
    }
    _onOrientationChanged() {
        this.updateScrollBarVisibility(this.scrollBarIndicatorVisible);
    }
}
scroll_view_ScrollView.prototype.recycleNativeView = 'auto';
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/search-bar/search-bar-common.js



let search_bar_common_SearchBarBase = class SearchBarBase extends core_view["c" /* View */] {
};
search_bar_common_SearchBarBase.submitEvent = 'submit';
search_bar_common_SearchBarBase.clearEvent = 'clear';
search_bar_common_SearchBarBase = __decorate([
    Object(view_common["a" /* CSSType */])('SearchBar')
], search_bar_common_SearchBarBase);

search_bar_common_SearchBarBase.prototype.recycleNativeView = 'auto';
const textProperty = new core_properties["Property"]({
    name: 'text',
    defaultValue: '',
    affectsLayout: true,
});
textProperty.register(search_bar_common_SearchBarBase);
const hintProperty = new core_properties["Property"]({
    name: 'hint',
    defaultValue: '',
});
hintProperty.register(search_bar_common_SearchBarBase);
const textFieldHintColorProperty = new core_properties["Property"]({
    name: 'textFieldHintColor',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
textFieldHintColorProperty.register(search_bar_common_SearchBarBase);
const textFieldBackgroundColorProperty = new core_properties["Property"]({
    name: 'textFieldBackgroundColor',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
textFieldBackgroundColorProperty.register(search_bar_common_SearchBarBase);
//# sourceMappingURL=search-bar-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/search-bar/index.js







const search_bar_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
var search_bar_UISearchBarDelegateImpl = /** @class */ (function (_super) {
    __extends(UISearchBarDelegateImpl, _super);
    function UISearchBarDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UISearchBarDelegateImpl.initWithOwner = function (owner) {
        var delegate = UISearchBarDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UISearchBarDelegateImpl.prototype.searchBarTextDidChange = function (searchBar, searchText) {
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        textProperty.nativeValueChange(owner, searchText);
        // This code is needed since sometimes searchBarCancelButtonClicked is not called!
        if (searchText === '') {
            owner._emit(search_bar_common_SearchBarBase.clearEvent);
        }
    };
    UISearchBarDelegateImpl.prototype.searchBarCancelButtonClicked = function (searchBar) {
        searchBar.resignFirstResponder();
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        owner._emit(search_bar_common_SearchBarBase.clearEvent);
    };
    UISearchBarDelegateImpl.prototype.searchBarSearchButtonClicked = function (searchBar) {
        searchBar.resignFirstResponder();
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        owner._emit(search_bar_common_SearchBarBase.submitEvent);
    };
    UISearchBarDelegateImpl.ObjCProtocols = [UISearchBarDelegate];
    return UISearchBarDelegateImpl;
}(NSObject));
var UISearchBarImpl = /** @class */ (function (_super) {
    __extends(UISearchBarImpl, _super);
    function UISearchBarImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UISearchBarImpl.prototype.sizeThatFits = function (size) {
        // iOS11 SDK does not support passing sizeThatFits(...) non-finite width value;
        // iOS layout system will take care to size the element properly when passed 0
        if (search_bar_majorVersion >= 11 && size.width === Number.POSITIVE_INFINITY) {
            size.width = 0;
        }
        return _super.prototype.sizeThatFits.call(this, size);
    };
    return UISearchBarImpl;
}(UISearchBar));
class search_bar_SearchBar extends search_bar_common_SearchBarBase {
    createNativeView() {
        return UISearchBarImpl.new();
    }
    initNativeView() {
        super.initNativeView();
        this._delegate = search_bar_UISearchBarDelegateImpl.initWithOwner(new WeakRef(this));
    }
    disposeNativeView() {
        this._delegate = null;
        super.disposeNativeView();
    }
    onLoaded() {
        super.onLoaded();
        this.ios.delegate = this._delegate;
    }
    onUnloaded() {
        this.ios.delegate = null;
        super.onUnloaded();
    }
    dismissSoftInput() {
        this.ios.resignFirstResponder();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    get _textField() {
        if (!this.__textField) {
            this.__textField = this.ios.valueForKey('searchField');
        }
        return this.__textField;
    }
    [view_common["e" /* isEnabledProperty */].setNative](value) {
        const nativeView = this.nativeViewProtected;
        if (nativeView instanceof UIControl) {
            nativeView.enabled = value;
        }
        const textField = this._textField;
        if (textField) {
            textField.enabled = value;
        }
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        return this.ios.barTintColor;
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.ios.barTintColor = color;
    }
    [style_properties["colorProperty"].getDefault]() {
        let sf = this._textField;
        if (sf) {
            return sf.textColor;
        }
        return null;
    }
    [style_properties["colorProperty"].setNative](value) {
        let sf = this._textField;
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        if (sf) {
            sf.textColor = color;
            sf.tintColor = color;
        }
    }
    [style_properties["fontInternalProperty"].getDefault]() {
        let sf = this._textField;
        return sf ? sf.font : null;
    }
    [style_properties["fontInternalProperty"].setNative](value) {
        let sf = this._textField;
        if (sf) {
            sf.font = value instanceof styling_font["a" /* Font */] ? value.getUIFont(sf.font) : value;
        }
    }
    [style_properties["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["backgroundInternalProperty"].setNative](value) {
        //
    }
    [textProperty.getDefault]() {
        return '';
    }
    [textProperty.setNative](value) {
        const text = value === null || value === undefined ? '' : value.toString();
        this.ios.text = text;
    }
    [hintProperty.getDefault]() {
        return '';
    }
    [hintProperty.setNative](value) {
        this._updateAttributedPlaceholder();
    }
    [textFieldBackgroundColorProperty.getDefault]() {
        const textField = this._textField;
        if (textField) {
            return textField.backgroundColor;
        }
        return null;
    }
    [textFieldBackgroundColorProperty.setNative](value) {
        const color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        const textField = this._textField;
        if (textField) {
            textField.backgroundColor = color;
        }
    }
    [textFieldHintColorProperty.getDefault]() {
        return null;
    }
    [textFieldHintColorProperty.setNative](value) {
        this._updateAttributedPlaceholder();
    }
    // Very similar to text-field.ios.ts implementation. Maybe unify APIs and base classes?
    _updateAttributedPlaceholder() {
        let stringValue = this.hint;
        if (stringValue === null || stringValue === void 0) {
            stringValue = '';
        }
        else {
            stringValue = stringValue + '';
        }
        if (stringValue === '') {
            // we do not use empty string since initWithStringAttributes does not return proper value and
            // nativeView.attributedPlaceholder will be null
            stringValue = ' ';
        }
        const attributes = {};
        if (this.textFieldHintColor) {
            attributes[NSForegroundColorAttributeName] = this.textFieldHintColor.ios;
        }
        const attributedPlaceholder = NSAttributedString.alloc().initWithStringAttributes(stringValue, attributes);
        this._textField.attributedPlaceholder = attributedPlaceholder;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/segmented-bar/segmented-bar-common.js





let segmented_bar_common_SegmentedBarItemBase = class SegmentedBarItemBase extends view_base["ViewBase"] {
    constructor() {
        super(...arguments);
        this._title = '';
    }
    get title() {
        return this._title;
    }
    set title(value) {
        let strValue = value !== null && value !== undefined ? value.toString() : '';
        if (this._title !== strValue) {
            this._title = strValue;
            this._update();
        }
    }
};
segmented_bar_common_SegmentedBarItemBase = __decorate([
    Object(view_common["a" /* CSSType */])('SegmentedBarItem')
], segmented_bar_common_SegmentedBarItemBase);

let segmented_bar_common_SegmentedBarBase = class SegmentedBarBase extends core_view["c" /* View */] {
    get selectedBackgroundColor() {
        return this.style.selectedBackgroundColor;
    }
    set selectedBackgroundColor(value) {
        this.style.selectedBackgroundColor = value;
    }
    _addArrayFromBuilder(name, value) {
        if (name === 'items') {
            this.items = value;
        }
    }
    _addChildFromBuilder(name, value) {
        if (name === 'SegmentedBarItem') {
            const item = value;
            let items = this.items;
            if (!items) {
                items = new Array();
                items.push(item);
                this.items = items;
            }
            else {
                items.push(item);
                this._addView(item);
            }
            if (this.nativeViewProtected) {
                this[segmented_bar_common_itemsProperty.setNative](items);
            }
        }
    }
    onItemsChanged(oldItems, newItems) {
        if (oldItems) {
            for (let i = 0, count = oldItems.length; i < count; i++) {
                this._removeView(oldItems[i]);
            }
        }
        if (newItems) {
            for (let i = 0, count = newItems.length; i < count; i++) {
                this._addView(newItems[i]);
            }
        }
    }
    // TODO: Make _addView to keep its children so this method is not needed!
    eachChild(callback) {
        const items = this.items;
        if (items) {
            items.forEach((item, i) => {
                callback(item);
            });
        }
    }
};
segmented_bar_common_SegmentedBarBase.selectedIndexChangedEvent = 'selectedIndexChanged';
segmented_bar_common_SegmentedBarBase = __decorate([
    Object(view_common["a" /* CSSType */])('SegmentedBar')
], segmented_bar_common_SegmentedBarBase);

segmented_bar_common_SegmentedBarBase.prototype.recycleNativeView = 'auto';
/**
 * Gets or sets the selected index dependency property of the SegmentedBar.
 */
const segmented_bar_common_selectedIndexProperty = new core_properties["CoercibleProperty"]({
    name: 'selectedIndex',
    defaultValue: -1,
    valueChanged: (target, oldValue, newValue) => {
        target.notify({
            eventName: segmented_bar_common_SegmentedBarBase.selectedIndexChangedEvent,
            object: target,
            oldIndex: oldValue,
            newIndex: newValue,
        });
    },
    coerceValue: (target, value) => {
        let items = target.items;
        if (items) {
            let max = items.length - 1;
            if (value < 0) {
                value = 0;
            }
            if (value > max) {
                value = max;
            }
        }
        else {
            value = -1;
        }
        return value;
    },
    valueConverter: (v) => parseInt(v),
});
segmented_bar_common_selectedIndexProperty.register(segmented_bar_common_SegmentedBarBase);
const segmented_bar_common_itemsProperty = new core_properties["Property"]({
    name: 'items',
    valueChanged: (target, oldValue, newValue) => {
        target.onItemsChanged(oldValue, newValue);
    },
});
segmented_bar_common_itemsProperty.register(segmented_bar_common_SegmentedBarBase);
const selectedBackgroundColorProperty = new core_properties["InheritedCssProperty"]({
    name: 'selectedBackgroundColor',
    cssName: 'selected-background-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
selectedBackgroundColorProperty.register(style["a" /* Style */]);
//# sourceMappingURL=segmented-bar-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/segmented-bar/index.js





class segmented_bar_SegmentedBarItem extends segmented_bar_common_SegmentedBarItemBase {
    _update() {
        const parent = this.parent;
        if (parent) {
            let tabIndex = parent.items.indexOf(this);
            let title = this.title;
            title = title === null || title === undefined ? '' : title;
            parent.ios.setTitleForSegmentAtIndex(title, tabIndex);
        }
    }
}
class segmented_bar_SegmentedBar extends segmented_bar_common_SegmentedBarBase {
    createNativeView() {
        return UISegmentedControl.new();
    }
    initNativeView() {
        super.initNativeView();
        this._selectionHandler = SelectionHandlerImpl.initWithOwner(new WeakRef(this));
        this.nativeViewProtected.addTargetActionForControlEvents(this._selectionHandler, 'selected', 4096 /* ValueChanged */);
    }
    disposeNativeView() {
        this._selectionHandler = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    [segmented_bar_common_selectedIndexProperty.getDefault]() {
        return -1;
    }
    [segmented_bar_common_selectedIndexProperty.setNative](value) {
        this.ios.selectedSegmentIndex = value;
    }
    [segmented_bar_common_itemsProperty.getDefault]() {
        return null;
    }
    [segmented_bar_common_itemsProperty.setNative](value) {
        const segmentedControl = this.ios;
        segmentedControl.removeAllSegments();
        const newItems = value;
        if (newItems && newItems.length) {
            newItems.forEach((item, index, arr) => {
                let title = item.title;
                title = title === null || title === undefined ? '' : title;
                segmentedControl.insertSegmentWithTitleAtIndexAnimated(title, index, false);
            });
        }
        segmented_bar_common_selectedIndexProperty.coerce(this);
    }
    [selectedBackgroundColorProperty.getDefault]() {
        const currentOsVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
        return currentOsVersion < 13 ? this.ios.tintColor : this.ios.selectedSegmentTintColor;
    }
    [selectedBackgroundColorProperty.setNative](value) {
        const currentOsVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        if (currentOsVersion < 13) {
            this.ios.tintColor = color;
        }
        else {
            this.ios.selectedSegmentTintColor = color;
        }
    }
    [style_properties["colorProperty"].getDefault]() {
        return null;
    }
    [style_properties["colorProperty"].setNative](value) {
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        let bar = this.ios;
        let currentAttrs = bar.titleTextAttributesForState(0 /* Normal */);
        let attrs = currentAttrs ? currentAttrs.mutableCopy() : NSMutableDictionary.new();
        attrs.setValueForKey(color, NSForegroundColorAttributeName);
        bar.setTitleTextAttributesForState(attrs, 0 /* Normal */);
    }
    [style_properties["fontInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["fontInternalProperty"].setNative](value) {
        let font = value ? value.getUIFont(UIFont.systemFontOfSize(UIFont.labelFontSize)) : null;
        let bar = this.ios;
        let currentAttrs = bar.titleTextAttributesForState(0 /* Normal */);
        let attrs = currentAttrs ? currentAttrs.mutableCopy() : NSMutableDictionary.new();
        attrs.setValueForKey(font, NSFontAttributeName);
        bar.setTitleTextAttributesForState(attrs, 0 /* Normal */);
    }
}
var SelectionHandlerImpl = /** @class */ (function (_super) {
    __extends(SelectionHandlerImpl, _super);
    function SelectionHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SelectionHandlerImpl.initWithOwner = function (owner) {
        var handler = SelectionHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    SelectionHandlerImpl.prototype.selected = function (sender) {
        var owner = this._owner.get();
        if (owner) {
            owner.selectedIndex = sender.selectedSegmentIndex;
        }
    };
    SelectionHandlerImpl.ObjCExposedMethods = {
        selected: { returns: interop.types.void, params: [UISegmentedControl] },
    };
    return SelectionHandlerImpl;
}(NSObject));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/slider/slider-common.js


// TODO: Extract base Range class for slider and progress
let slider_common_SliderBase = class SliderBase extends core_view["c" /* View */] {
};
slider_common_SliderBase = __decorate([
    Object(view_common["a" /* CSSType */])('Slider')
], slider_common_SliderBase);

slider_common_SliderBase.prototype.recycleNativeView = 'auto';
/**
 * Represents the observable property backing the value property of each Slider instance.
 */
const slider_common_valueProperty = new core_properties["CoercibleProperty"]({
    name: 'value',
    defaultValue: 0,
    coerceValue: (target, value) => {
        value = Math.max(value, target.minValue);
        value = Math.min(value, target.maxValue);
        return value;
    },
    valueConverter: (v) => ( true ? parseFloat(v) : undefined),
});
slider_common_valueProperty.register(slider_common_SliderBase);
/**
 * Represents the observable property backing the minValue property of each Slider instance.
 */
const minValueProperty = new core_properties["Property"]({
    name: 'minValue',
    defaultValue: 0,
    valueChanged: (target, oldValue, newValue) => {
        slider_common_maxValueProperty.coerce(target);
        slider_common_valueProperty.coerce(target);
    },
    valueConverter: (v) => ( true ? parseFloat(v) : undefined),
});
minValueProperty.register(slider_common_SliderBase);
/**
 * Represents the observable property backing the maxValue property of each Slider instance.
 */
const slider_common_maxValueProperty = new core_properties["CoercibleProperty"]({
    name: 'maxValue',
    defaultValue: 100,
    coerceValue: (target, value) => {
        let minValue = target.minValue;
        if (value < minValue) {
            value = minValue;
        }
        return value;
    },
    valueChanged: (target, oldValue, newValue) => slider_common_valueProperty.coerce(target),
    valueConverter: (v) => ( true ? parseFloat(v) : undefined),
});
slider_common_maxValueProperty.register(slider_common_SliderBase);
//# sourceMappingURL=slider-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/slider/index.js




var slider_SliderChangeHandlerImpl = /** @class */ (function (_super) {
    __extends(SliderChangeHandlerImpl, _super);
    function SliderChangeHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SliderChangeHandlerImpl.initWithOwner = function (owner) {
        var handler = SliderChangeHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    SliderChangeHandlerImpl.prototype.sliderValueChanged = function (sender) {
        var owner = this._owner.get();
        if (owner) {
            slider_common_valueProperty.nativeValueChange(owner, sender.value);
        }
    };
    SliderChangeHandlerImpl.ObjCExposedMethods = {
        sliderValueChanged: { returns: interop.types.void, params: [UISlider] },
    };
    return SliderChangeHandlerImpl;
}(NSObject));
class slider_Slider extends slider_common_SliderBase {
    createNativeView() {
        return UISlider.new();
    }
    initNativeView() {
        super.initNativeView();
        const nativeView = this.nativeViewProtected;
        // default values
        nativeView.minimumValue = 0;
        nativeView.maximumValue = this.maxValue;
        this._changeHandler = slider_SliderChangeHandlerImpl.initWithOwner(new WeakRef(this));
        nativeView.addTargetActionForControlEvents(this._changeHandler, 'sliderValueChanged', 4096 /* ValueChanged */);
    }
    disposeNativeView() {
        this._changeHandler = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    [slider_common_valueProperty.getDefault]() {
        return 0;
    }
    [slider_common_valueProperty.setNative](value) {
        this.ios.value = value;
    }
    [minValueProperty.getDefault]() {
        return 0;
    }
    [minValueProperty.setNative](value) {
        this.ios.minimumValue = value;
    }
    [slider_common_maxValueProperty.getDefault]() {
        return 100;
    }
    [slider_common_maxValueProperty.setNative](value) {
        this.ios.maximumValue = value;
    }
    [style_properties["colorProperty"].getDefault]() {
        return this.ios.thumbTintColor;
    }
    [style_properties["colorProperty"].setNative](value) {
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.ios.thumbTintColor = color;
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        return this.ios.minimumTrackTintColor;
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.ios.minimumTrackTintColor = color;
    }
    [style_properties["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["backgroundInternalProperty"].setNative](value) {
        //
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style-scope.js
var style_scope = __webpack_require__(50);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/background-common.js
var background_common = __webpack_require__(102);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/converters.js
var converters = __webpack_require__(52);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/css-animation-parser.js
var css_animation_parser = __webpack_require__(83);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/css-selector/index.js
var css_selector = __webpack_require__(72);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/switch/switch-common.js




let switch_common_SwitchBase = class SwitchBase extends core_view["c" /* View */] {
    _onCheckedPropertyChanged(newValue) {
        //
    }
};
switch_common_SwitchBase.checkedChangeEvent = 'checkedChange';
switch_common_SwitchBase = __decorate([
    Object(view_common["a" /* CSSType */])('Switch')
], switch_common_SwitchBase);

switch_common_SwitchBase.prototype.recycleNativeView = 'auto';
function onCheckedPropertyChanged(switchBase, oldValue, newValue) {
    switchBase._onCheckedPropertyChanged(newValue);
}
const checkedProperty = new core_properties["Property"]({
    name: 'checked',
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
    valueChanged: onCheckedPropertyChanged,
});
checkedProperty.register(switch_common_SwitchBase);
const offBackgroundColorProperty = new core_properties["Property"]({
    name: 'offBackgroundColor',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
offBackgroundColorProperty.register(switch_common_SwitchBase);
//# sourceMappingURL=switch-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/switch/index.js





var switch_SwitchChangeHandlerImpl = /** @class */ (function (_super) {
    __extends(SwitchChangeHandlerImpl, _super);
    function SwitchChangeHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SwitchChangeHandlerImpl.initWithOwner = function (owner) {
        var handler = SwitchChangeHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    SwitchChangeHandlerImpl.prototype.valueChanged = function (sender) {
        var owner = this._owner.get();
        if (owner) {
            checkedProperty.nativeValueChange(owner, sender.on);
        }
    };
    SwitchChangeHandlerImpl.ObjCExposedMethods = {
        valueChanged: { returns: interop.types.void, params: [UISwitch] },
    };
    return SwitchChangeHandlerImpl;
}(NSObject));
const zeroSize = { width: 0, height: 0 };
class switch_Switch extends switch_common_SwitchBase {
    constructor() {
        super();
        this.width = 51;
        this.height = 31;
    }
    createNativeView() {
        return UISwitch.new();
    }
    initNativeView() {
        super.initNativeView();
        const nativeView = this.nativeViewProtected;
        this._handler = switch_SwitchChangeHandlerImpl.initWithOwner(new WeakRef(this));
        nativeView.addTargetActionForControlEvents(this._handler, 'valueChanged', 4096 /* ValueChanged */);
    }
    disposeNativeView() {
        this._handler = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        // It can't be anything different from 51x31
        let nativeSize = this.nativeViewProtected.sizeThatFits(zeroSize);
        this.width = nativeSize.width;
        this.height = nativeSize.height;
        const widthAndState = switch_Switch.resolveSizeAndState(utils_common["n" /* layout */].toDevicePixels(nativeSize.width), utils_common["n" /* layout */].toDevicePixels(51), utils_common["n" /* layout */].EXACTLY, 0);
        const heightAndState = switch_Switch.resolveSizeAndState(utils_common["n" /* layout */].toDevicePixels(nativeSize.height), utils_common["n" /* layout */].toDevicePixels(31), utils_common["n" /* layout */].EXACTLY, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    [checkedProperty.getDefault]() {
        return false;
    }
    [checkedProperty.setNative](value) {
        this.nativeViewProtected.on = value;
    }
    [style_properties["colorProperty"].getDefault]() {
        return this.nativeViewProtected.thumbTintColor;
    }
    [style_properties["colorProperty"].setNative](value) {
        this.nativeViewProtected.thumbTintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    [style_properties["backgroundColorProperty"].getDefault]() {
        return this.nativeViewProtected.onTintColor;
    }
    [style_properties["backgroundColorProperty"].setNative](value) {
        this.nativeViewProtected.onTintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    [style_properties["backgroundInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["backgroundInternalProperty"].setNative](value) {
        //
    }
    [offBackgroundColorProperty.getDefault]() {
        return this.nativeViewProtected.backgroundColor;
    }
    [offBackgroundColorProperty.setNative](value) {
        const nativeValue = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.nativeViewProtected.tintColor = nativeValue;
        this.nativeViewProtected.backgroundColor = nativeValue;
        this.nativeViewProtected.layer.cornerRadius = this.nativeViewProtected.frame.size.height / 2;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-view/tab-view-common.js
var TabViewBase_1;






const tab_view_common_traceCategory = 'TabView';
let tab_view_common_TabViewItemBase = class TabViewItemBase extends view_base["ViewBase"] {
    constructor() {
        super(...arguments);
        this._title = '';
    }
    get textTransform() {
        return this.style.textTransform;
    }
    set textTransform(value) {
        this.style.textTransform = value;
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof core_view["c" /* View */]) {
            this.view = value;
        }
    }
    get title() {
        return this._title;
    }
    set title(value) {
        if (this._title !== value) {
            this._title = value;
            this._update();
        }
    }
    get view() {
        return this._view;
    }
    set view(value) {
        if (this._view !== value) {
            if (this._view) {
                throw new Error('Changing the view of an already loaded TabViewItem is not currently supported.');
            }
            this._view = value;
            this._addView(value);
        }
    }
    get iconSource() {
        return this._iconSource;
    }
    set iconSource(value) {
        if (this._iconSource !== value) {
            this._iconSource = value;
            this._update();
        }
    }
    eachChild(callback) {
        const view = this._view;
        if (view) {
            callback(view);
        }
    }
    loadView(view) {
        const tabView = this.parent;
        if (tabView && tabView.items) {
            // Don't load items until their fragments are instantiated.
            if (this.canBeLoaded) {
                super.loadView(view);
            }
        }
    }
};
tab_view_common_TabViewItemBase = __decorate([
    Object(view_common["a" /* CSSType */])('TabViewItem')
], tab_view_common_TabViewItemBase);

let tab_view_common_TabViewBase = TabViewBase_1 = class TabViewBase extends core_view["c" /* View */] {
    get androidSelectedTabHighlightColor() {
        return this.style.androidSelectedTabHighlightColor;
    }
    set androidSelectedTabHighlightColor(value) {
        this.style.androidSelectedTabHighlightColor = value;
    }
    get tabTextFontSize() {
        return this.style.tabTextFontSize;
    }
    set tabTextFontSize(value) {
        this.style.tabTextFontSize = value;
    }
    get tabTextColor() {
        return this.style.tabTextColor;
    }
    set tabTextColor(value) {
        this.style.tabTextColor = value;
    }
    get tabBackgroundColor() {
        return this.style.tabBackgroundColor;
    }
    set tabBackgroundColor(value) {
        this.style.tabBackgroundColor = value;
    }
    get selectedTabTextColor() {
        return this.style.selectedTabTextColor;
    }
    set selectedTabTextColor(value) {
        this.style.selectedTabTextColor = value;
    }
    _addArrayFromBuilder(name, value) {
        if (name === 'items') {
            this.items = value;
        }
    }
    _addChildFromBuilder(name, value) {
        if (value instanceof tab_view_common_TabViewItemBase) {
            if (!this.items) {
                this.items = new Array();
            }
            this.items.push(value);
            this._addView(value);
            tab_view_common_selectedIndexProperty.coerce(this);
        }
    }
    get _selectedView() {
        let selectedIndex = this.selectedIndex;
        return selectedIndex > -1 ? this.items[selectedIndex].view : null;
    }
    get _childrenCount() {
        const items = this.items;
        return items ? items.length : 0;
    }
    eachChild(callback) {
        const items = this.items;
        if (items) {
            items.forEach((item, i) => {
                callback(item);
            });
        }
    }
    eachChildView(callback) {
        const items = this.items;
        if (items) {
            items.forEach((item, i) => {
                callback(item.view);
            });
        }
    }
    onItemsChanged(oldItems, newItems) {
        if (oldItems) {
            oldItems.forEach((item) => this._removeView(item));
        }
        if (newItems) {
            newItems.forEach((item) => {
                if (!item.view) {
                    throw new Error(`TabViewItem must have a view.`);
                }
                this._addView(item);
            });
        }
    }
    onSelectedIndexChanged(oldIndex, newIndex) {
        // to be overridden in platform specific files
        this.notify({
            eventName: TabViewBase_1.selectedIndexChangedEvent,
            object: this,
            oldIndex,
            newIndex,
        });
    }
};
tab_view_common_TabViewBase.selectedIndexChangedEvent = 'selectedIndexChanged';
tab_view_common_TabViewBase = TabViewBase_1 = __decorate([
    Object(view_common["a" /* CSSType */])('TabView')
], tab_view_common_TabViewBase);

function traceMissingIcon(icon) {
    trace["a" /* Trace */].write('Could not load tab bar icon: ' + icon, trace["a" /* Trace */].categories.Error, trace["a" /* Trace */].messageType.error);
}
const tab_view_common_selectedIndexProperty = new core_properties["CoercibleProperty"]({
    name: 'selectedIndex',
    defaultValue: -1,
    affectsLayout: true,
    valueChanged: (target, oldValue, newValue) => {
        target.onSelectedIndexChanged(oldValue, newValue);
    },
    coerceValue: (target, value) => {
        let items = target.items;
        if (items) {
            let max = items.length - 1;
            if (value < 0) {
                value = 0;
            }
            if (value > max) {
                value = max;
            }
        }
        else {
            value = -1;
        }
        return value;
    },
    valueConverter: (v) => parseInt(v),
});
tab_view_common_selectedIndexProperty.register(tab_view_common_TabViewBase);
const tab_view_common_itemsProperty = new core_properties["Property"]({
    name: 'items',
    valueChanged: (target, oldValue, newValue) => {
        target.onItemsChanged(oldValue, newValue);
    },
});
tab_view_common_itemsProperty.register(tab_view_common_TabViewBase);
const tab_view_common_iosIconRenderingModeProperty = new core_properties["Property"]({ name: 'iosIconRenderingMode', defaultValue: 'automatic' });
tab_view_common_iosIconRenderingModeProperty.register(tab_view_common_TabViewBase);
const androidOffscreenTabLimitProperty = new core_properties["Property"]({
    name: 'androidOffscreenTabLimit',
    defaultValue: 1,
    affectsLayout: true,
    valueConverter: (v) => parseInt(v),
});
androidOffscreenTabLimitProperty.register(tab_view_common_TabViewBase);
const androidTabsPositionProperty = new core_properties["Property"]({ name: 'androidTabsPosition', defaultValue: 'top' });
androidTabsPositionProperty.register(tab_view_common_TabViewBase);
const androidSwipeEnabledProperty = new core_properties["Property"]({
    name: 'androidSwipeEnabled',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
androidSwipeEnabledProperty.register(tab_view_common_TabViewBase);
const tabTextFontSizeProperty = new core_properties["CssProperty"]({
    name: 'tabTextFontSize',
    cssName: 'tab-text-font-size',
    valueConverter: (v) => parseFloat(v),
});
tabTextFontSizeProperty.register(style["a" /* Style */]);
const tabTextColorProperty = new core_properties["CssProperty"]({
    name: 'tabTextColor',
    cssName: 'tab-text-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
tabTextColorProperty.register(style["a" /* Style */]);
const tabBackgroundColorProperty = new core_properties["CssProperty"]({
    name: 'tabBackgroundColor',
    cssName: 'tab-background-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
tabBackgroundColorProperty.register(style["a" /* Style */]);
const selectedTabTextColorProperty = new core_properties["CssProperty"]({
    name: 'selectedTabTextColor',
    cssName: 'selected-tab-text-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
selectedTabTextColorProperty.register(style["a" /* Style */]);
const androidSelectedTabHighlightColorProperty = new core_properties["CssProperty"]({
    name: 'androidSelectedTabHighlightColor',
    cssName: 'android-selected-tab-highlight-color',
    equalityComparer: core_color["a" /* Color */].equals,
    valueConverter: (v) => new core_color["a" /* Color */](v),
});
androidSelectedTabHighlightColorProperty.register(style["a" /* Style */]);
//# sourceMappingURL=tab-view-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tab-view/index.js













const tab_view_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
const tab_view_isPhone = platform["Device"].deviceType === 'Phone';
let tab_view_UITabBarControllerImpl;
let tab_view_UITabBarControllerDelegateImpl;
let tab_view_UINavigationControllerDelegateImpl;
const setupControllers = function () {
    if (typeof tab_view_UITabBarControllerImpl === 'undefined') {
        var UITabBarControllerClass = /** @class */ (function (_super) {
    __extends(UITabBarControllerClass, _super);
    function UITabBarControllerClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITabBarControllerClass.initWithOwner = function (owner) {
        var handler = tab_view_UITabBarControllerImpl.new();
        handler._owner = owner;
        return handler;
    };
    UITabBarControllerClass.prototype.viewDidLoad = function () {
        _super.prototype.viewDidLoad.call(this);
        // Unify translucent and opaque bars layout
        // this.edgesForExtendedLayout = UIRectEdgeBottom;
        this.extendedLayoutIncludesOpaqueBars = true;
    };
    UITabBarControllerClass.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        view_helper["a" /* IOSHelper */].updateAutoAdjustScrollInsets(this, owner);
        if (!owner.parent) {
            owner.callLoaded();
        }
    };
    UITabBarControllerClass.prototype.viewDidDisappear = function (animated) {
        _super.prototype.viewDidDisappear.call(this, animated);
        var owner = this._owner.get();
        if (owner && !owner.parent && owner.isLoaded && !this.presentedViewController) {
            owner.callUnloaded();
        }
    };
    UITabBarControllerClass.prototype.viewWillTransitionToSizeWithTransitionCoordinator = function (size, coordinator) {
        var _this = this;
        _super.prototype.viewWillTransitionToSizeWithTransitionCoordinator.call(this, size, coordinator);
        coordinator.animateAlongsideTransitionCompletion(null, function () {
            var owner = _this._owner.get();
            if (owner && owner.items) {
                owner.items.forEach(function (tabItem) { return tabItem._updateTitleAndIconPositions(); });
            }
        });
    };
    // Mind implementation for other controllers
    UITabBarControllerClass.prototype.traitCollectionDidChange = function (previousTraitCollection) {
        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
        if (tab_view_majorVersion >= 13) {
            var owner = this._owner.get();
            if (owner && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection(previousTraitCollection)) {
                owner.notify({
                    eventName: view_helper["a" /* IOSHelper */].traitCollectionColorAppearanceChangedEvent,
                    object: owner,
                });
            }
        }
    };
    __decorate([
        profiling["f" /* profile */]
    ], UITabBarControllerClass.prototype, "viewWillAppear", null);
    __decorate([
        profiling["f" /* profile */]
    ], UITabBarControllerClass.prototype, "viewDidDisappear", null);
    return UITabBarControllerClass;
}(UITabBarController));
        tab_view_UITabBarControllerImpl = UITabBarControllerClass;
        var UITabBarControllerDelegateClass = /** @class */ (function (_super) {
    __extends(UITabBarControllerDelegateClass, _super);
    function UITabBarControllerDelegateClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITabBarControllerDelegateClass.initWithOwner = function (owner) {
        var delegate = tab_view_UITabBarControllerDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UITabBarControllerDelegateClass.prototype.tabBarControllerShouldSelectViewController = function (tabBarController, viewController) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('TabView.delegate.SHOULD_select(' + tabBarController + ', ' + viewController + ');', trace["a" /* Trace */].categories.Debug);
        }
        var owner = this._owner.get();
        if (owner) {
            // "< More" cannot be visible after clicking on the main tab bar buttons.
            var backToMoreWillBeVisible = false;
            owner._handleTwoNavigationBars(backToMoreWillBeVisible);
        }
        if (tabBarController.selectedViewController === viewController) {
            return false;
        }
        tabBarController._willSelectViewController = viewController;
        return true;
    };
    UITabBarControllerDelegateClass.prototype.tabBarControllerDidSelectViewController = function (tabBarController, viewController) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('TabView.delegate.DID_select(' + tabBarController + ', ' + viewController + ');', trace["a" /* Trace */].categories.Debug);
        }
        var owner = this._owner.get();
        if (owner) {
            owner._onViewControllerShown(viewController);
        }
        tabBarController._willSelectViewController = undefined;
    };
    UITabBarControllerDelegateClass.ObjCProtocols = [UITabBarControllerDelegate];
    return UITabBarControllerDelegateClass;
}(NSObject));
        tab_view_UITabBarControllerDelegateImpl = UITabBarControllerDelegateClass;
        var UINavigationControllerDelegateClass = /** @class */ (function (_super) {
    __extends(UINavigationControllerDelegateClass, _super);
    function UINavigationControllerDelegateClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UINavigationControllerDelegateClass.initWithOwner = function (owner) {
        var delegate = tab_view_UINavigationControllerDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UINavigationControllerDelegateClass.prototype.navigationControllerWillShowViewControllerAnimated = function (navigationController, viewController, animated) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('TabView.moreNavigationController.WILL_show(' + navigationController + ', ' + viewController + ', ' + animated + ');', trace["a" /* Trace */].categories.Debug);
        }
        var owner = this._owner.get();
        if (owner) {
            // If viewController is one of our tab item controllers, then "< More" will be visible shortly.
            // Otherwise viewController is the UIMoreListController which shows the list of all tabs beyond the 4th tab.
            var backToMoreWillBeVisible = owner._ios.viewControllers.containsObject(viewController);
            owner._handleTwoNavigationBars(backToMoreWillBeVisible);
        }
    };
    UINavigationControllerDelegateClass.prototype.navigationControllerDidShowViewControllerAnimated = function (navigationController, viewController, animated) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('TabView.moreNavigationController.DID_show(' + navigationController + ', ' + viewController + ', ' + animated + ');', trace["a" /* Trace */].categories.Debug);
        }
        // We don't need Edit button in More screen.
        navigationController.navigationBar.topItem.rightBarButtonItem = null;
        var owner = this._owner.get();
        if (owner) {
            owner._onViewControllerShown(viewController);
        }
    };
    UINavigationControllerDelegateClass.ObjCProtocols = [UINavigationControllerDelegate];
    return UINavigationControllerDelegateClass;
}(NSObject));
        tab_view_UINavigationControllerDelegateImpl = UINavigationControllerDelegateClass;
    }
};
setupControllers();
function tab_view_updateTitleAndIconPositions(tabItem, tabBarItem, controller) {
    if (!tabItem || !tabBarItem) {
        return;
    }
    // For iOS <11 icon is *always* above the text.
    // For iOS 11 icon is above the text *only* on phones in portrait mode.
    const orientation = controller.interfaceOrientation;
    const isPortrait = orientation !== 4 /* LandscapeLeft */ && orientation !== 3 /* LandscapeRight */;
    const isIconAboveTitle = tab_view_majorVersion < 11 || (tab_view_isPhone && isPortrait);
    if (!tabItem.iconSource) {
        if (isIconAboveTitle) {
            tabBarItem.titlePositionAdjustment = {
                horizontal: 0,
                vertical: -20,
            };
        }
        else {
            tabBarItem.titlePositionAdjustment = { horizontal: 0, vertical: 0 };
        }
    }
    if (!tabItem.title) {
        if (isIconAboveTitle) {
            tabBarItem.imageInsets = new UIEdgeInsets({
                top: 6,
                left: 0,
                bottom: -6,
                right: 0,
            });
        }
        else {
            tabBarItem.imageInsets = new UIEdgeInsets({
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
            });
        }
    }
}
class tab_view_TabViewItem extends tab_view_common_TabViewItemBase {
    setViewController(controller, nativeView) {
        this.__controller = controller;
        this.setNativeView(nativeView);
    }
    disposeNativeView() {
        this.__controller = undefined;
        this.setNativeView(undefined);
    }
    loadView(view) {
        const tabView = this.parent;
        if (tabView && tabView.items) {
            const index = tabView.items.indexOf(this);
            if (index === tabView.selectedIndex) {
                super.loadView(view);
            }
        }
    }
    _update() {
        const parent = this.parent;
        const controller = this.__controller;
        if (parent && controller) {
            const icon = parent._getIcon(this.iconSource);
            const index = parent.items.indexOf(this);
            const title = Object(text_base["b" /* getTransformedText */])(this.title, this.style.textTransform);
            const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(title, icon, index);
            tab_view_updateTitleAndIconPositions(this, tabBarItem, controller);
            // TODO: Repeating code. Make TabViewItemBase - ViewBase and move the colorProperty on tabViewItem.
            // Delete the repeating code.
            const states = getTitleAttributesForStates(parent);
            applyStatesToItem(tabBarItem, states);
            controller.tabBarItem = tabBarItem;
        }
    }
    _updateTitleAndIconPositions() {
        if (!this.__controller || !this.__controller.tabBarItem) {
            return;
        }
        tab_view_updateTitleAndIconPositions(this, this.__controller.tabBarItem, this.__controller);
    }
    [text_base_common["j" /* textTransformProperty */].setNative](value) {
        this._update();
    }
}
class tab_view_TabView extends tab_view_common_TabViewBase {
    constructor() {
        super();
        this._iconsCache = {};
        this.viewController = this._ios = tab_view_UITabBarControllerImpl.initWithOwner(new WeakRef(this));
        this.nativeViewProtected = this._ios.view;
    }
    initNativeView() {
        super.initNativeView();
        this._delegate = tab_view_UITabBarControllerDelegateImpl.initWithOwner(new WeakRef(this));
        this._moreNavigationControllerDelegate = tab_view_UINavigationControllerDelegateImpl.initWithOwner(new WeakRef(this));
    }
    disposeNativeView() {
        this._delegate = null;
        this._moreNavigationControllerDelegate = null;
        super.disposeNativeView();
    }
    onLoaded() {
        super.onLoaded();
        const selectedIndex = this.selectedIndex;
        const selectedView = this.items && this.items[selectedIndex] && this.items[selectedIndex].view;
        if (selectedView instanceof ui_frame["Frame"]) {
            selectedView._pushInFrameStackRecursive();
        }
        this._ios.delegate = this._delegate;
    }
    onUnloaded() {
        this._ios.delegate = null;
        this._ios.moreNavigationController.delegate = null;
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    layoutNativeView(left, top, right, bottom) {
        //
    }
    _setNativeViewFrame(nativeView, frame) {
        //
    }
    onSelectedIndexChanged(oldIndex, newIndex) {
        const items = this.items;
        if (!items) {
            return;
        }
        const oldItem = items[oldIndex];
        if (oldItem) {
            oldItem.unloadView(oldItem.view);
        }
        const newItem = items[newIndex];
        if (newItem && this.isLoaded) {
            const selectedView = items[newIndex].view;
            if (selectedView instanceof ui_frame["Frame"]) {
                selectedView._pushInFrameStackRecursive();
            }
            newItem.loadView(newItem.view);
        }
        super.onSelectedIndexChanged(oldIndex, newIndex);
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(width, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(height, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    _onViewControllerShown(viewController) {
        // This method could be called with the moreNavigationController or its list controller, so we have to check.
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('TabView._onViewControllerShown(' + viewController + ');', trace["a" /* Trace */].categories.Debug);
        }
        if (this._ios.viewControllers && this._ios.viewControllers.containsObject(viewController)) {
            this.selectedIndex = this._ios.viewControllers.indexOfObject(viewController);
        }
        else {
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write('TabView._onViewControllerShown: viewController is not one of our viewControllers', trace["a" /* Trace */].categories.Debug);
            }
        }
    }
    _handleTwoNavigationBars(backToMoreWillBeVisible) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write(`TabView._handleTwoNavigationBars(backToMoreWillBeVisible: ${backToMoreWillBeVisible})`, trace["a" /* Trace */].categories.Debug);
        }
        // The "< Back" and "< More" navigation bars should not be visible simultaneously.
        const page = this.page || this._selectedView.page || this._selectedView.currentPage;
        if (!page || !page.frame) {
            return;
        }
        let actionBarVisible = page.frame._getNavBarVisible(page);
        if (backToMoreWillBeVisible && actionBarVisible) {
            page.frame.ios._disableNavBarAnimation = true;
            page.actionBarHidden = true;
            page.frame.ios._disableNavBarAnimation = false;
            this._actionBarHiddenByTabView = true;
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write(`TabView hid action bar`, trace["a" /* Trace */].categories.Debug);
            }
            return;
        }
        if (!backToMoreWillBeVisible && this._actionBarHiddenByTabView) {
            page.frame.ios._disableNavBarAnimation = true;
            page.actionBarHidden = false;
            page.frame.ios._disableNavBarAnimation = false;
            this._actionBarHiddenByTabView = undefined;
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write(`TabView restored action bar`, trace["a" /* Trace */].categories.Debug);
            }
            return;
        }
    }
    getViewController(item) {
        let newController = item.view ? item.view.viewController : null;
        if (newController) {
            item.setViewController(newController, newController.view);
            return newController;
        }
        if (item.view.ios instanceof UIViewController) {
            newController = item.view.ios;
            item.setViewController(newController, newController.view);
        }
        else if (item.view.ios && item.view.ios.controller instanceof UIViewController) {
            newController = item.view.ios.controller;
            item.setViewController(newController, newController.view);
        }
        else {
            newController = view_helper["a" /* IOSHelper */].UILayoutViewController.initWithOwner(new WeakRef(item.view));
            newController.view.addSubview(item.view.nativeViewProtected);
            item.view.viewController = newController;
            item.setViewController(newController, item.view.nativeViewProtected);
        }
        return newController;
    }
    setViewControllers(items) {
        const length = items ? items.length : 0;
        if (length === 0) {
            this._ios.viewControllers = null;
            return;
        }
        const controllers = NSMutableArray.alloc().initWithCapacity(length);
        const states = getTitleAttributesForStates(this);
        items.forEach((item, i) => {
            const controller = this.getViewController(item);
            const icon = this._getIcon(item.iconSource);
            const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(item.title || '', icon, i);
            tab_view_updateTitleAndIconPositions(item, tabBarItem, controller);
            applyStatesToItem(tabBarItem, states);
            controller.tabBarItem = tabBarItem;
            controllers.addObject(controller);
            item.canBeLoaded = true;
        });
        this._ios.viewControllers = controllers;
        this._ios.customizableViewControllers = null;
        // When we set this._ios.viewControllers, someone is clearing the moreNavigationController.delegate, so we have to reassign it each time here.
        this._ios.moreNavigationController.delegate = this._moreNavigationControllerDelegate;
    }
    _getIconRenderingMode() {
        switch (this.iosIconRenderingMode) {
            case 'alwaysOriginal':
                return 1 /* AlwaysOriginal */;
            case 'alwaysTemplate':
                return 2 /* AlwaysTemplate */;
            case 'automatic':
            default:
                return 0 /* Automatic */;
        }
    }
    _getIcon(iconSource) {
        if (!iconSource) {
            return null;
        }
        let image = this._iconsCache[iconSource];
        if (!image) {
            const is = image_source["ImageSource"].fromFileOrResourceSync(iconSource);
            if (is && is.ios) {
                const originalRenderedImage = is.ios.imageWithRenderingMode(this._getIconRenderingMode());
                this._iconsCache[iconSource] = originalRenderedImage;
                image = originalRenderedImage;
            }
            else {
                traceMissingIcon(iconSource);
            }
        }
        return image;
    }
    _updateIOSTabBarColorsAndFonts() {
        if (!this.items) {
            return;
        }
        const tabBar = this.ios.tabBar;
        const states = getTitleAttributesForStates(this);
        for (let i = 0; i < tabBar.items.count; i++) {
            applyStatesToItem(tabBar.items[i], states);
        }
    }
    [tab_view_common_selectedIndexProperty.setNative](value) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('TabView._onSelectedIndexPropertyChangedSetNativeValue(' + value + ')', trace["a" /* Trace */].categories.Debug);
        }
        if (value > -1) {
            this._ios._willSelectViewController = this._ios.viewControllers[value];
            this._ios.selectedIndex = value;
        }
    }
    [tab_view_common_itemsProperty.getDefault]() {
        return null;
    }
    [tab_view_common_itemsProperty.setNative](value) {
        this.setViewControllers(value);
        tab_view_common_selectedIndexProperty.coerce(this);
    }
    [tabTextFontSizeProperty.getDefault]() {
        return null;
    }
    [tabTextFontSizeProperty.setNative](value) {
        this._updateIOSTabBarColorsAndFonts();
    }
    [tabTextColorProperty.getDefault]() {
        return null;
    }
    [tabTextColorProperty.setNative](value) {
        this._updateIOSTabBarColorsAndFonts();
    }
    [tabBackgroundColorProperty.getDefault]() {
        return this._ios.tabBar.barTintColor;
    }
    [tabBackgroundColorProperty.setNative](value) {
        this._ios.tabBar.barTintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
    }
    [selectedTabTextColorProperty.getDefault]() {
        return this._ios.tabBar.tintColor;
    }
    [selectedTabTextColorProperty.setNative](value) {
        this._ios.tabBar.tintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this._updateIOSTabBarColorsAndFonts();
    }
    // TODO: Move this to TabViewItem
    [style_properties["fontInternalProperty"].getDefault]() {
        return null;
    }
    [style_properties["fontInternalProperty"].setNative](value) {
        this._updateIOSTabBarColorsAndFonts();
    }
    // TODO: Move this to TabViewItem
    [tab_view_common_iosIconRenderingModeProperty.getDefault]() {
        return 'automatic';
    }
    [tab_view_common_iosIconRenderingModeProperty.setNative](value) {
        this._iconsCache = {};
        let items = this.items;
        if (items && items.length) {
            for (let i = 0, length = items.length; i < length; i++) {
                const item = items[i];
                if (item.iconSource) {
                    item._update();
                }
            }
        }
    }
}
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], tab_view_TabView.prototype, "onLoaded", null);
function getTitleAttributesForStates(tabView) {
    const result = {};
    const defaultTabItemFontSize = 10;
    const tabItemFontSize = tabView.style.tabTextFontSize || defaultTabItemFontSize;
    const font = (tabView.style.fontInternal || styling_font["a" /* Font */].default).getUIFont(UIFont.systemFontOfSize(tabItemFontSize));
    const tabItemTextColor = tabView.style.tabTextColor;
    const textColor = tabItemTextColor instanceof core_color["a" /* Color */] ? tabItemTextColor.ios : null;
    result.normalState = { [NSFontAttributeName]: font };
    if (textColor) {
        result.normalState[UITextAttributeTextColor] = textColor;
    }
    const tabSelectedItemTextColor = tabView.style.selectedTabTextColor;
    const selectedTextColor = tabSelectedItemTextColor instanceof core_color["a" /* Color */] ? tabSelectedItemTextColor.ios : null;
    result.selectedState = { [NSFontAttributeName]: font };
    if (selectedTextColor) {
        result.selectedState[UITextAttributeTextColor] = selectedTextColor;
    }
    return result;
}
function applyStatesToItem(item, states) {
    item.setTitleTextAttributesForState(states.normalState, 0 /* Normal */);
    item.setTitleTextAttributesForState(states.selectedState, 4 /* Selected */);
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tabs/tabs-common.js
// Requires








const tabs_common_traceCategory = 'TabView';
let tabs_common_TabsBase = class TabsBase extends tab_navigation_base_TabNavigationBase {
};
tabs_common_TabsBase = __decorate([
    Object(view_common["a" /* CSSType */])('Tabs')
], tabs_common_TabsBase);

// TODO: Add Unit tests
const swipeEnabledProperty = new core_properties["Property"]({
    name: 'swipeEnabled',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
swipeEnabledProperty.register(tabs_common_TabsBase);
// TODO: Add Unit tests
// TODO: Coerce to max number of items?
const offscreenTabLimitProperty = new core_properties["Property"]({
    name: 'offscreenTabLimit',
    defaultValue: 1,
    valueConverter: (v) => parseInt(v),
});
offscreenTabLimitProperty.register(tabs_common_TabsBase);
const tabsPositionProperty = new core_properties["Property"]({
    name: 'tabsPosition',
    defaultValue: 'top',
});
tabsPositionProperty.register(tabs_common_TabsBase);
const iOSTabBarItemsAlignmentProperty = new core_properties["Property"]({ name: 'iOSTabBarItemsAlignment', defaultValue: 'justified' });
iOSTabBarItemsAlignmentProperty.register(tabs_common_TabsBase);
const animationEnabledProperty = new core_properties["Property"]({ name: 'animationEnabled', defaultValue: true, valueConverter: view_base["booleanConverter"] });
animationEnabledProperty.register(tabs_common_TabsBase);
//# sourceMappingURL=tabs-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/tabs/index.js


// Requires









// TODO
// import { profile } from "../../profiling";

const tabs_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
const tabs_isPhone = platform["Device"].deviceType === 'Phone';
// Equivalent to dispatch_async(dispatch_get_main_queue(...)) call
const invokeOnRunLoop = (function () {
    const runloop = CFRunLoopGetMain();
    return (action) => {
        CFRunLoopPerformBlock(runloop, kCFRunLoopDefaultMode, action);
        CFRunLoopWakeUp(runloop);
    };
})();
var tabs_MDCTabBarDelegateImpl = /** @class */ (function (_super) {
    __extends(MDCTabBarDelegateImpl, _super);
    function MDCTabBarDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabBarDelegateImpl.initWithOwner = function (owner) {
        var delegate = MDCTabBarDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    MDCTabBarDelegateImpl.prototype.tabBarShouldSelectItem = function (tabBar, item) {
        var owner = this._owner.get();
        var shouldSelectItem = owner._canSelectItem;
        var selectedIndex = owner.tabBarItems.indexOf(item);
        if (owner.selectedIndex !== selectedIndex) {
            owner._canSelectItem = false;
        }
        var tabStrip = owner.tabStrip;
        var tabStripItems = tabStrip && tabStrip.items;
        if (tabStripItems && tabStripItems[selectedIndex]) {
            tabStripItems[selectedIndex]._emit(tab_strip_item_TabStripItem.tapEvent);
            tabStrip.notify({
                eventName: tab_strip_TabStrip.itemTapEvent,
                object: tabStrip,
                index: selectedIndex,
            });
        }
        return shouldSelectItem;
    };
    MDCTabBarDelegateImpl.prototype.tabBarDidSelectItem = function (tabBar, selectedItem) {
        var owner = this._owner.get();
        var tabBarItems = owner.tabBarItems;
        var selectedIndex = tabBarItems.indexOf(selectedItem);
        owner.selectedIndex = selectedIndex;
    };
    MDCTabBarDelegateImpl.ObjCProtocols = [MDCTabBarDelegate];
    return MDCTabBarDelegateImpl;
}(NSObject));
var BackgroundIndicatorTemplate = /** @class */ (function (_super) {
    __extends(BackgroundIndicatorTemplate, _super);
    function BackgroundIndicatorTemplate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BackgroundIndicatorTemplate.prototype.indicatorAttributesForContext = function (context) {
        var attributes = new MDCTabBarIndicatorAttributes();
        attributes.path = UIBezierPath.bezierPathWithRect(context.bounds);
        return attributes;
    };
    BackgroundIndicatorTemplate.ObjCProtocols = [MDCTabBarIndicatorTemplate];
    return BackgroundIndicatorTemplate;
}(NSObject));
var tabs_UIPageViewControllerImpl = /** @class */ (function (_super) {
    __extends(UIPageViewControllerImpl, _super);
    function UIPageViewControllerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIPageViewControllerImpl.initWithOwner = function (owner) {
        var handler = UIPageViewControllerImpl.alloc().initWithTransitionStyleNavigationOrientationOptions(UIPageViewControllerTransitionStyle.Scroll, UIPageViewControllerNavigationOrientation.Horizontal, null);
        handler._owner = owner;
        return handler;
    };
    UIPageViewControllerImpl.prototype.viewDidLoad = function () {
        var owner = this._owner.get();
        var tabBarItems = owner.tabBarItems;
        var tabBar = MDCTabBar.alloc().initWithFrame(this.view.bounds);
        if (tabBarItems && tabBarItems.length) {
            tabBar.items = NSArray.arrayWithArray(tabBarItems);
        }
        tabBar.delegate = this.tabBarDelegate = tabs_MDCTabBarDelegateImpl.initWithOwner(new WeakRef(owner));
        if (tabs_majorVersion <= 12 || !UIColor.labelColor) {
            tabBar.tintColor = UIColor.blueColor;
            tabBar.barTintColor = UIColor.whiteColor;
            tabBar.setTitleColorForState(UIColor.blackColor, MDCTabBarItemState.Normal);
            tabBar.setTitleColorForState(UIColor.blackColor, MDCTabBarItemState.Selected);
        }
        else {
            tabBar.tintColor = UIColor.systemBlueColor;
            tabBar.barTintColor = UIColor.systemBackgroundColor;
            tabBar.setTitleColorForState(UIColor.labelColor, MDCTabBarItemState.Normal);
            tabBar.setTitleColorForState(UIColor.labelColor, MDCTabBarItemState.Selected);
            tabBar.inkColor = UIColor.clearColor;
        }
        tabBar.autoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleBottomMargin;
        tabBar.alignment = MDCTabBarAlignment.Justified;
        tabBar.sizeToFit();
        this.tabBar = tabBar;
        this.view.addSubview(tabBar);
    };
    UIPageViewControllerImpl.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        view_helper["a" /* IOSHelper */].updateAutoAdjustScrollInsets(this, owner);
        // Tabs can be reset as a root view. Call loaded here in this scenario.
        if (!owner.isLoaded) {
            owner.callLoaded();
        }
    };
    UIPageViewControllerImpl.prototype.viewDidLayoutSubviews = function () {
        _super.prototype.viewDidLayoutSubviews.call(this);
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        var safeAreaInsetsBottom = 0;
        var safeAreaInsetsTop = 0;
        if (tabs_majorVersion > 10) {
            safeAreaInsetsBottom = this.view.safeAreaInsets.bottom;
            safeAreaInsetsTop = this.view.safeAreaInsets.top;
        }
        else {
            safeAreaInsetsTop = this.topLayoutGuide.length;
        }
        var scrollViewTop = 0;
        var scrollViewHeight = this.view.bounds.size.height + safeAreaInsetsBottom;
        if (owner.tabStrip) {
            scrollViewTop = this.tabBar.frame.size.height;
            scrollViewHeight = this.view.bounds.size.height - this.tabBar.frame.size.height + safeAreaInsetsBottom;
            var tabBarTop = safeAreaInsetsTop;
            var tabBarHeight = this.tabBar.frame.size.height;
            var tabsPosition = owner.tabsPosition;
            if (tabsPosition === 'bottom') {
                tabBarTop = this.view.frame.size.height - this.tabBar.frame.size.height - safeAreaInsetsBottom;
                scrollViewTop = this.view.frame.origin.y;
                scrollViewHeight = this.view.frame.size.height - safeAreaInsetsBottom;
            }
            var parent = owner.parent;
            // Handle Angular scenario where Tabs is in a ProxyViewContainer
            // It is possible to wrap components in ProxyViewContainers indefinitely
            while (parent && !parent.nativeViewProtected) {
                parent = parent.parent;
            }
            if (parent && tabs_majorVersion > 10) {
                // TODO: Figure out a better way to handle ViewController nesting/Safe Area nesting
                tabBarTop = Math.max(tabBarTop, parent.nativeView.safeAreaInsets.top);
            }
            this.tabBar.frame = CGRectMake(0, tabBarTop, this.tabBar.frame.size.width, tabBarHeight);
        }
        else {
            this.tabBar.hidden = true;
        }
        var subViews = this.view.subviews;
        var scrollView = null;
        for (var i = 0; i < subViews.count; i++) {
            var view = subViews[i];
            if (view instanceof UIScrollView) {
                scrollView = view;
            }
        }
        if (scrollView) {
            // The part of the UIPageViewController that is changing the pages is a UIScrollView
            // We want to expand it to the size of the UIPageViewController as it is not so by default
            this.scrollView = scrollView;
            if (!owner.swipeEnabled) {
                scrollView.scrollEnabled = false;
            }
            scrollView.frame = CGRectMake(0, scrollViewTop, this.view.bounds.size.width, scrollViewHeight); //this.view.bounds;
        }
    };
    // Mind implementation for other controllers
    UIPageViewControllerImpl.prototype.traitCollectionDidChange = function (previousTraitCollection) {
        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
        if (tabs_majorVersion >= 13) {
            var owner = this._owner.get();
            if (owner && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection && this.traitCollection.hasDifferentColorAppearanceComparedToTraitCollection(previousTraitCollection)) {
                owner.notify({
                    eventName: view_helper["a" /* IOSHelper */].traitCollectionColorAppearanceChangedEvent,
                    object: owner,
                });
            }
        }
    };
    UIPageViewControllerImpl.prototype.viewWillTransitionToSizeWithTransitionCoordinator = function (size, coordinator) {
        var _this = this;
        _super.prototype.viewWillTransitionToSizeWithTransitionCoordinator.call(this, size, coordinator);
        coordinator.animateAlongsideTransitionCompletion(function () {
            var owner = _this._owner.get();
            if (owner && owner.tabStrip && owner.tabStrip.items) {
                var tabStrip_1 = owner.tabStrip;
                tabStrip_1.items.forEach(function (tabStripItem) {
                    tabs_updateBackgroundPositions(tabStrip_1, tabStripItem, _this.tabBar.alignment !== MDCTabBarAlignment.Justified || owner.selectedIndex !== tabStripItem._index ? owner._defaultItemBackgroundColor : null);
                    var index = tabStripItem._index;
                    var tabBarItemController = owner.viewControllers[index];
                    tabs_updateTitleAndIconPositions(tabStripItem, tabBarItemController.tabBarItem, tabBarItemController);
                });
            }
        }, null);
    };
    return UIPageViewControllerImpl;
}(UIPageViewController));
var UIPageViewControllerDataSourceImpl = /** @class */ (function (_super) {
    __extends(UIPageViewControllerDataSourceImpl, _super);
    function UIPageViewControllerDataSourceImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIPageViewControllerDataSourceImpl.initWithOwner = function (owner) {
        var dataSource = UIPageViewControllerDataSourceImpl.new();
        dataSource._owner = owner;
        return dataSource;
    };
    UIPageViewControllerDataSourceImpl.prototype.pageViewControllerViewControllerBeforeViewController = function (pageViewController, viewController) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.delegate.SHOULD_select(" + tabBarController + ", " + viewController + ");", Trace.categories.Debug);
        // }
        var owner = this._owner.get();
        var selectedIndex = owner.selectedIndex;
        if (selectedIndex === 0) {
            return null;
        }
        selectedIndex--;
        var prevItem = owner.items[selectedIndex];
        var prevViewController = prevItem.__controller;
        // if (!prevViewController) {
        //     prevViewController = owner.getViewController(prevItem);
        // }
        owner._setCanBeLoaded(selectedIndex);
        owner._loadUnloadTabItems(selectedIndex);
        return prevViewController;
    };
    UIPageViewControllerDataSourceImpl.prototype.pageViewControllerViewControllerAfterViewController = function (pageViewController, viewController) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.delegate.SHOULD_select(" + tabBarController + ", " + viewController + ");", Trace.categories.Debug);
        // }
        var owner = this._owner.get();
        var selectedIndex = owner.selectedIndex;
        if (selectedIndex === owner.items.length - 1) {
            return null;
        }
        selectedIndex++;
        var nextItem = owner.items[selectedIndex];
        var nextViewController = nextItem.__controller;
        // if (!nextViewController) {
        //     nextViewController = owner.getViewController(nextItem);
        // }
        owner._setCanBeLoaded(selectedIndex);
        owner._loadUnloadTabItems(selectedIndex);
        // nextItem.loadView(nextItem.view);
        return nextViewController;
    };
    UIPageViewControllerDataSourceImpl.prototype.presentationCountForPageViewController = function (pageViewController) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.delegate.SHOULD_select(" + tabBarController + ", " + viewController + ");", Trace.categories.Debug);
        // }
        return 0;
    };
    UIPageViewControllerDataSourceImpl.prototype.presentationIndexForPageViewController = function (pageViewController) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView.delegate.SHOULD_select(" + tabBarController + ", " + viewController + ");", Trace.categories.Debug);
        // }
        return 0;
    };
    UIPageViewControllerDataSourceImpl.ObjCProtocols = [UIPageViewControllerDataSource];
    return UIPageViewControllerDataSourceImpl;
}(NSObject));
var UIPageViewControllerDelegateImpl = /** @class */ (function (_super) {
    __extends(UIPageViewControllerDelegateImpl, _super);
    function UIPageViewControllerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIPageViewControllerDelegateImpl.initWithOwner = function (owner) {
        var delegate = UIPageViewControllerDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UIPageViewControllerDelegateImpl.prototype.pageViewControllerWillTransitionToViewControllers = function (pageViewController, viewControllers) {
        // const owner = this._owner.get();
        // const ownerViewControllers = owner.viewControllers;
        // const selectedIndex = owner.selectedIndex;
        // const nextViewController = viewControllers[0];
        // const nextViewControllerIndex = ownerViewControllers.indexOf(nextViewController);
        // if (selectedIndex > nextViewControllerIndex) {
        //     owner.selectedIndex--;
        // } else {
        //     owner.selectedIndex++;
        // }
    };
    UIPageViewControllerDelegateImpl.prototype.pageViewControllerDidFinishAnimatingPreviousViewControllersTransitionCompleted = function (pageViewController, didFinishAnimating, previousViewControllers, transitionCompleted) {
        if (!transitionCompleted) {
            return;
        }
        var owner = this._owner.get();
        var ownerViewControllers = owner.viewControllers;
        var selectedIndex = owner.selectedIndex;
        var nextViewController = pageViewController.viewControllers[0];
        var nextViewControllerIndex = ownerViewControllers.indexOf(nextViewController);
        if (selectedIndex !== nextViewControllerIndex) {
            owner.selectedIndex = nextViewControllerIndex;
            owner._canSelectItem = true;
        }
    };
    UIPageViewControllerDelegateImpl.ObjCProtocols = [UIPageViewControllerDelegate];
    return UIPageViewControllerDelegateImpl;
}(NSObject));
function iterateIndexRange(index, eps, lastIndex, callback) {
    const rangeStart = Math.max(0, index - eps);
    const rangeEnd = Math.min(index + eps, lastIndex);
    for (let i = rangeStart; i <= rangeEnd; i++) {
        callback(i);
    }
}
function tabs_updateBackgroundPositions(tabStrip, tabStripItem, color = null) {
    let bgView = tabStripItem.bgView;
    const index = tabStripItem._index;
    let width = tabStrip.nativeView.frame.size.width / tabStrip.items.length;
    const frame = CGRectMake(width * index, 0, width, tabStrip.nativeView.frame.size.width);
    if (!bgView) {
        bgView = UIView.alloc().initWithFrame(frame);
        tabStrip.nativeView.insertSubviewAtIndex(bgView, 0);
        tabStripItem.bgView = bgView;
    }
    else {
        bgView.frame = frame;
    }
    const backgroundColor = tabStripItem.style.backgroundColor;
    bgView.backgroundColor = color || (backgroundColor instanceof core_color["a" /* Color */] ? backgroundColor.ios : backgroundColor);
}
function tabs_updateTitleAndIconPositions(tabStripItem, tabBarItem, controller) {
    if (!tabStripItem || !tabBarItem) {
        return;
    }
    // For iOS <11 icon is *always* above the text.
    // For iOS 11 icon is above the text *only* on phones in portrait mode.
    const orientation = controller.interfaceOrientation;
    const isPortrait = orientation !== 4 /* LandscapeLeft */ && orientation !== 3 /* LandscapeRight */;
    const isIconAboveTitle = tabs_majorVersion < 11 || (tabs_isPhone && isPortrait);
    if (!tabStripItem.iconSource) {
        if (isIconAboveTitle) {
            tabBarItem.titlePositionAdjustment = {
                horizontal: 0,
                vertical: -20,
            };
        }
        else {
            tabBarItem.titlePositionAdjustment = { horizontal: 0, vertical: 0 };
        }
    }
    if (!tabStripItem.title) {
        if (isIconAboveTitle) {
            tabBarItem.imageInsets = new UIEdgeInsets({
                top: 6,
                left: 0,
                bottom: -6,
                right: 0,
            });
        }
        else {
            tabBarItem.imageInsets = new UIEdgeInsets({
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
            });
        }
    }
}
class tabs_Tabs extends tabs_common_TabsBase {
    constructor() {
        super();
        // private _moreNavigationControllerDelegate: UINavigationControllerDelegateImpl;
        this._iconsCache = {};
        this.viewController = this._ios = tabs_UIPageViewControllerImpl.initWithOwner(new WeakRef(this)); //alloc().initWithTransitionStyleNavigationOrientationOptions(UIPageViewControllerTransitionStyle.Scroll, UIPageViewControllerNavigationOrientation.Horizontal, null);;
    }
    createNativeView() {
        return this._ios.view;
    }
    initNativeView() {
        super.initNativeView();
        this._dataSource = UIPageViewControllerDataSourceImpl.initWithOwner(new WeakRef(this));
        this._delegate = UIPageViewControllerDelegateImpl.initWithOwner(new WeakRef(this));
    }
    disposeNativeView() {
        this._dataSource = null;
        this._delegate = null;
        this._ios.tabBarDelegate = null;
        this._ios.tabBar = null;
        super.disposeNativeView();
    }
    // TODO
    // @profile()
    onLoaded() {
        super.onLoaded();
        this.setViewControllers(this.items);
        const selectedIndex = this.selectedIndex;
        const selectedView = this.items && this.items[selectedIndex] && this.items[selectedIndex].content;
        if (selectedView instanceof ui_frame["Frame"]) {
            selectedView._pushInFrameStackRecursive();
        }
        this._ios.dataSource = this._dataSource;
        this._ios.delegate = this._delegate;
    }
    onUnloaded() {
        this._ios.dataSource = null;
        this._ios.delegate = null;
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    layoutNativeView(left, top, right, bottom) {
        //
    }
    _setNativeViewFrame(nativeView, frame) {
        //
    }
    onSelectedIndexChanged(oldIndex, newIndex) {
        const items = this.items;
        if (!items) {
            return;
        }
        const oldItem = items[oldIndex];
        if (oldItem) {
            oldItem.canBeLoaded = false;
            oldItem.unloadView(oldItem.content);
        }
        const newItem = items[newIndex];
        if (newItem && this.isLoaded) {
            const selectedView = items[newIndex].content;
            if (selectedView instanceof ui_frame["Frame"]) {
                selectedView._pushInFrameStackRecursive();
            }
            newItem.canBeLoaded = true;
            newItem.loadView(newItem.content);
        }
        const tabStripItems = this.tabStrip && this.tabStrip.items;
        if (tabStripItems) {
            if (tabStripItems[newIndex]) {
                tabStripItems[newIndex]._emit(tab_strip_item_TabStripItem.selectEvent);
                this.updateItemColors(tabStripItems[newIndex]);
            }
            if (tabStripItems[oldIndex]) {
                tabStripItems[oldIndex]._emit(tab_strip_item_TabStripItem.unselectEvent);
                this.updateItemColors(tabStripItems[oldIndex]);
            }
        }
        this._loadUnloadTabItems(newIndex);
        super.onSelectedIndexChanged(oldIndex, newIndex);
    }
    _loadUnloadTabItems(newIndex) {
        const items = this.items;
        if (!items) {
            return;
        }
        const lastIndex = items.length - 1;
        const offsideItems = this.offscreenTabLimit;
        let toUnload = [];
        let toLoad = [];
        iterateIndexRange(newIndex, offsideItems, lastIndex, (i) => toLoad.push(i));
        items.forEach((item, i) => {
            const indexOfI = toLoad.indexOf(i);
            if (indexOfI < 0) {
                toUnload.push(i);
            }
        });
        toUnload.forEach((index) => {
            const item = items[index];
            if (items[index]) {
                item.unloadView(item.content);
            }
        });
        const newItem = items[newIndex];
        const selectedView = newItem && newItem.content;
        if (selectedView instanceof ui_frame["Frame"]) {
            selectedView._pushInFrameStackRecursive();
        }
        toLoad.forEach((index) => {
            const item = items[index];
            if (this.isLoaded && items[index]) {
                item.loadView(item.content);
            }
        });
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
        const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
        const widthAndState = core_view["c" /* View */].resolveSizeAndState(width, width, widthMode, 0);
        const heightAndState = core_view["c" /* View */].resolveSizeAndState(height, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    }
    _onViewControllerShown(viewController) {
        // This method could be called with the moreNavigationController or its list controller, so we have to check.
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView._onViewControllerShown(" + viewController + ");", Trace.categories.Debug);
        // }
        if (this._ios.viewControllers && this._ios.viewControllers.containsObject(viewController)) {
            this.selectedIndex = this._ios.viewControllers.indexOfObject(viewController);
        }
        else {
            // TODO
            // if (Trace.isEnabled()) {
            //     Trace.write("TabView._onViewControllerShown: viewController is not one of our viewControllers", Trace.categories.Debug);
            // }
        }
    }
    getViewController(item) {
        let newController = item.content ? item.content.viewController : null;
        if (newController) {
            item.setViewController(newController, newController.view);
            return newController;
        }
        if (item.content.ios instanceof UIViewController) {
            newController = item.content.ios;
            item.setViewController(newController, newController.view);
        }
        else if (item.content.ios && item.content.ios.controller instanceof UIViewController) {
            newController = item.content.ios.controller;
            item.setViewController(newController, newController.view);
        }
        else {
            newController = view_helper["a" /* IOSHelper */].UILayoutViewController.initWithOwner(new WeakRef(item.content));
            newController.view.addSubview(item.content.nativeViewProtected);
            item.content.viewController = newController;
            item.setViewController(newController, item.content.nativeViewProtected);
        }
        return newController;
    }
    _setCanBeLoaded(index) {
        const items = this.items;
        if (!this.items) {
            return;
        }
        const lastIndex = items.length - 1;
        const offsideItems = this.offscreenTabLimit;
        iterateIndexRange(index, offsideItems, lastIndex, (i) => {
            if (items[i]) {
                items[i].canBeLoaded = true;
            }
        });
    }
    setViewControllers(items) {
        const length = items ? items.length : 0;
        if (length === 0) {
            this.viewControllers = null;
            return;
        }
        const viewControllers = [];
        const tabBarItems = [];
        if (this.tabStrip) {
            this.tabStrip.setNativeView(this._ios.tabBar);
        }
        const tabStripItems = this.tabStrip && this.tabStrip.items;
        if (tabStripItems) {
            if (tabStripItems[this.selectedIndex]) {
                tabStripItems[this.selectedIndex]._emit(tab_strip_item_TabStripItem.selectEvent);
            }
        }
        items.forEach((item, i) => {
            const controller = this.getViewController(item);
            if (this.tabStrip && this.tabStrip.items && this.tabStrip.items[i]) {
                const tabStripItem = this.tabStrip.items[i];
                const tabBarItem = this.createTabBarItem(tabStripItem, i);
                tabs_updateTitleAndIconPositions(tabStripItem, tabBarItem, controller);
                this.setViewTextAttributes(tabStripItem.label, i === this.selectedIndex);
                controller.tabBarItem = tabBarItem;
                tabStripItem._index = i;
                tabBarItems.push(tabBarItem);
                tabStripItem.setNativeView(tabBarItem);
            }
            item.canBeLoaded = true;
            viewControllers.push(controller);
        });
        this.setItemImages();
        this.viewControllers = viewControllers;
        this.tabBarItems = tabBarItems;
        if (this.viewController && this.viewController.tabBar) {
            this.viewController.tabBar.itemAppearance = this.getTabBarItemAppearance();
            this.viewController.tabBar.items = NSArray.arrayWithArray(this.tabBarItems);
            // TODO: investigate why this call is necessary to actually toggle item appearance
            this.viewController.tabBar.sizeToFit();
            if (this.selectedIndex) {
                this.viewController.tabBar.setSelectedItemAnimated(this.tabBarItems[this.selectedIndex], false);
            }
        }
    }
    setItemImages() {
        if (this._selectedItemColor || this._unSelectedItemColor) {
            if (this.tabStrip && this.tabStrip.items) {
                this.tabStrip.items.forEach((item) => {
                    if (this._unSelectedItemColor && item.nativeView) {
                        item.nativeView.image = this.getIcon(item, this._unSelectedItemColor);
                    }
                    if (this._selectedItemColor && item.nativeView) {
                        if (this.selectedIndex === item._index) {
                            item.nativeView.image = this.getIcon(item, this._selectedItemColor);
                        }
                    }
                });
            }
        }
    }
    updateAllItemsColors() {
        this._defaultItemBackgroundColor = null;
        this.setItemColors();
        if (this.tabStrip && this.tabStrip.items) {
            this.tabStrip.items.forEach((tabStripItem) => {
                this.updateItemColors(tabStripItem);
            });
        }
    }
    updateItemColors(tabStripItem) {
        tabs_updateBackgroundPositions(this.tabStrip, tabStripItem);
        this.setIconColor(tabStripItem, true);
    }
    createTabBarItem(item, index) {
        let image;
        let title;
        if (item.isLoaded) {
            image = this.getIcon(item);
            title = item.label.text;
            if (!this.tabStrip._hasImage) {
                this.tabStrip._hasImage = !!image;
            }
            if (!this.tabStrip._hasTitle) {
                this.tabStrip._hasTitle = !!title;
            }
        }
        const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(title, image, index);
        return tabBarItem;
    }
    getTabBarItemAppearance() {
        let itemAppearance;
        if (this.tabStrip && this.tabStrip._hasImage && this.tabStrip._hasTitle) {
            itemAppearance = 2 /* TitledImages */;
        }
        else if (this.tabStrip && this.tabStrip._hasImage) {
            itemAppearance = 1 /* Images */;
        }
        else {
            itemAppearance = 0 /* Titles */;
        }
        return itemAppearance;
    }
    getIconRenderingMode() {
        switch (this.tabStrip && this.tabStrip.iosIconRenderingMode) {
            case 'alwaysOriginal':
                return 1 /* AlwaysOriginal */;
            case 'alwaysTemplate':
                return 2 /* AlwaysTemplate */;
            case 'automatic':
            default:
                const hasItemColor = this._selectedItemColor || this._unSelectedItemColor;
                return hasItemColor ? 2 /* AlwaysTemplate */ : 1 /* AlwaysOriginal */;
        }
    }
    getIcon(tabStripItem, color) {
        // Image and Label children of TabStripItem
        // take priority over its `iconSource` and `title` properties
        const iconSource = tabStripItem.image && tabStripItem.image.src;
        if (!iconSource) {
            return null;
        }
        const target = tabStripItem.image;
        const font = target.style.fontInternal || styling_font["a" /* Font */].default;
        if (!color) {
            color = target.style.color;
        }
        const iconTag = [iconSource, font.fontStyle, font.fontWeight, font.fontSize, font.fontFamily, color].join(';');
        let isFontIcon = false;
        let image = this._iconsCache[iconTag];
        if (!image) {
            let is = new image_source["ImageSource"]();
            if (Object(utils_common["l" /* isFontIconURI */])(iconSource)) {
                isFontIcon = true;
                const fontIconCode = iconSource.split('//')[1];
                is = image_source["ImageSource"].fromFontIconCodeSync(fontIconCode, font, color);
            }
            else {
                is = image_source["ImageSource"].fromFileOrResourceSync(iconSource);
            }
            if (is && is.ios) {
                image = is.ios;
                if (this.tabStrip && this.tabStrip.isIconSizeFixed) {
                    image = this.getFixedSizeIcon(image);
                }
                let renderingMode = 0 /* Automatic */;
                if (!isFontIcon) {
                    renderingMode = this.getIconRenderingMode();
                }
                const originalRenderedImage = image.imageWithRenderingMode(renderingMode);
                this._iconsCache[iconTag] = originalRenderedImage;
                image = originalRenderedImage;
            }
        }
        return image;
    }
    getFixedSizeIcon(image) {
        const inWidth = image.size.width;
        const inHeight = image.size.height;
        const iconSpecSize = getIconSpecSize({ width: inWidth, height: inHeight });
        const widthPts = iconSpecSize.width;
        const heightPts = iconSpecSize.height;
        UIGraphicsBeginImageContextWithOptions({ width: widthPts, height: heightPts }, false, utils_common["n" /* layout */].getDisplayDensity());
        image.drawInRect(CGRectMake(0, 0, widthPts, heightPts));
        let resultImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return resultImage;
    }
    getTabBarBackgroundColor() {
        return this._ios.tabBar.barTintColor;
    }
    setTabBarBackgroundColor(value) {
        this._ios.tabBar.barTintColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this.updateAllItemsColors();
    }
    setTabBarItemTitle(tabStripItem, value) {
        tabStripItem.nativeView.title = value;
    }
    equalUIColor(first, second) {
        if (!first && !second) {
            return true;
        }
        if (!first || !second) {
            return false;
        }
        const firstComponents = CGColorGetComponents(first.CGColor);
        const secondComponents = CGColorGetComponents(second.CGColor);
        return firstComponents[0] === secondComponents[0] && firstComponents[1] === secondComponents[1] && firstComponents[2] === secondComponents[2] && firstComponents[3] === secondComponents[3];
    }
    isSelectedAndHightlightedItem(tabStripItem) {
        // to find out whether the current tab strip item is active (has style with :active selector applied)
        // we need to check whether its _visualState is equal to "highlighted" as when changing tabs
        // we first go through setTabBarItemBackgroundColor thice, once before setting the "highlighted" state
        // and once after that, but if the "highlighted" state is not set we cannot get the backgroundColor
        // set using :active selector
        return tabStripItem._index === this.selectedIndex && tabStripItem['_visualState'] === 'highlighted';
    }
    setTabBarItemBackgroundColor(tabStripItem, value) {
        if (!this.tabStrip || !tabStripItem) {
            return;
        }
        let newColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
        const itemSelectedAndHighlighted = this.isSelectedAndHightlightedItem(tabStripItem);
        // As we cannot implement selected item background color in Tabs we are using the Indicator for this
        // To be able to detect that there are two different background colors (one for selected and one for not selected item)
        // we are checking whether the current item is not selected and higlighted and we store the value of its
        // background color to _defaultItemBackgroundColor and later if we need to process a selected and highlighted item
        // we are comparing it's backgroun color to the default one and if there's a difference
        // we are changing the selectionIndicatorTemplate from underline to the whole item
        // in that mode we are not able to show the indicator as it is used for the background of the selected item
        if (!this._defaultItemBackgroundColor && !itemSelectedAndHighlighted) {
            this._defaultItemBackgroundColor = newColor;
        }
        if (this.viewController.tabBar.alignment !== 1 /* Justified */ && itemSelectedAndHighlighted && !this.equalUIColor(this._defaultItemBackgroundColor, newColor)) {
            if (!this._backgroundIndicatorColor) {
                this._backgroundIndicatorColor = newColor;
                this._ios.tabBar.selectionIndicatorTemplate = new BackgroundIndicatorTemplate();
                this._ios.tabBar.tintColor = newColor;
            }
        }
        else {
            tabs_updateBackgroundPositions(this.tabStrip, tabStripItem, newColor);
        }
    }
    setTabBarItemColor(tabStripItem, value) {
        this.setViewTextAttributes(tabStripItem.label);
    }
    setItemColors() {
        if (this._selectedItemColor) {
            this.viewController.tabBar.selectedItemTintColor = this._selectedItemColor.ios;
        }
        if (this._unSelectedItemColor) {
            this.viewController.tabBar.unselectedItemTintColor = this._unSelectedItemColor.ios;
        }
    }
    setIconColor(tabStripItem, forceReload = false) {
        // if there is no change in the css color and there is no item color set
        // we don't need to reload the icon
        if (!forceReload && !this._selectedItemColor && !this._unSelectedItemColor) {
            return;
        }
        let image;
        // if selectedItemColor or unSelectedItemColor is set we don't respect the color from the style
        const tabStripColor = this.selectedIndex === tabStripItem._index ? this._selectedItemColor : this._unSelectedItemColor;
        image = this.getIcon(tabStripItem, tabStripColor);
        tabStripItem.nativeView.image = image;
    }
    setTabBarIconColor(tabStripItem, value) {
        this.setIconColor(tabStripItem, true);
    }
    setTabBarIconSource(tabStripItem, value) {
        this.updateItemColors(tabStripItem);
    }
    setTabBarItemFontInternal(tabStripItem, value) {
        this.setViewTextAttributes(tabStripItem.label);
    }
    getTabBarFontInternal() {
        return this._ios.tabBar.unselectedItemTitleFont;
    }
    setTabBarFontInternal(value) {
        const defaultTabItemFontSize = 10;
        const tabItemFontSize = this.tabStrip.style.fontSize || defaultTabItemFontSize;
        const font = (this.tabStrip.style.fontInternal || styling_font["a" /* Font */].default).getUIFont(UIFont.systemFontOfSize(tabItemFontSize));
        this._ios.tabBar.unselectedItemTitleFont = font;
        this._ios.tabBar.selectedItemTitleFont = font;
    }
    getTabBarTextTransform() {
        switch (this._ios.tabBar.titleTextTransform) {
            case 1 /* None */:
                return 'none';
            case 0 /* Automatic */:
                return 'initial';
            case 2 /* Uppercase */:
            default:
                return 'uppercase';
        }
    }
    setTabBarTextTransform(value) {
        if (value === 'none') {
            this._ios.tabBar.titleTextTransform = 1 /* None */;
        }
        else if (value === 'uppercase') {
            this._ios.tabBar.titleTextTransform = 2 /* Uppercase */;
        }
        else if (value === 'initial') {
            this._ios.tabBar.titleTextTransform = 0 /* Automatic */;
        }
    }
    getTabBarColor() {
        return this._ios.tabBar.titleColorForState(0 /* Normal */);
    }
    setTabBarColor(value) {
        const nativeColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this._ios.tabBar.setTitleColorForState(nativeColor, 0 /* Normal */);
        this._ios.tabBar.setTitleColorForState(nativeColor, 1 /* Selected */);
    }
    getTabBarHighlightColor() {
        return this._ios.tabBar.tintColor;
    }
    setTabBarHighlightColor(value) {
        const nativeColor = value instanceof core_color["a" /* Color */] ? value.ios : value;
        this._ios.tabBar.tintColor = nativeColor;
    }
    getTabBarSelectedItemColor() {
        return this._selectedItemColor;
    }
    setTabBarSelectedItemColor(value) {
        this._selectedItemColor = value;
        this.updateAllItemsColors();
    }
    getTabBarUnSelectedItemColor() {
        return this._unSelectedItemColor;
    }
    setTabBarUnSelectedItemColor(value) {
        this._unSelectedItemColor = value;
        this.updateAllItemsColors();
    }
    visitFrames(view, operation) {
        if (view instanceof ui_frame["Frame"]) {
            operation(view);
        }
        view.eachChild((child) => {
            this.visitFrames(child, operation);
            return true;
        });
    }
    [selectedIndexProperty.setNative](value) {
        // TODO
        // if (Trace.isEnabled()) {
        //     Trace.write("TabView._onSelectedIndexPropertyChangedSetNativeValue(" + value + ")", Trace.categories.Debug);
        // }
        if (value > -1) {
            const item = this.items[value];
            const controllers = NSMutableArray.alloc().initWithCapacity(1);
            let itemController = item.__controller;
            // if (!itemController) {
            //     itemController = this.getViewController(item);
            // }
            controllers.addObject(itemController);
            let navigationDirection = 0 /* Forward */;
            if (this._currentNativeSelectedIndex && this._currentNativeSelectedIndex > value) {
                navigationDirection = 1 /* Reverse */;
            }
            this._currentNativeSelectedIndex = value;
            // do not make layout changes while the animation is in progress https://stackoverflow.com/a/47031524/613113
            this.visitFrames(item, (frame) => (frame._animationInProgress = true));
            invokeOnRunLoop(() => this.viewController.setViewControllersDirectionAnimatedCompletion(controllers, navigationDirection, this.animationEnabled, (finished) => {
                this.visitFrames(item, (frame) => (frame._animationInProgress = false));
                if (finished) {
                    // HACK: UIPageViewController fix; see https://stackoverflow.com/a/17330606
                    invokeOnRunLoop(() => this.viewController.setViewControllersDirectionAnimatedCompletion(controllers, navigationDirection, false, null));
                    this._canSelectItem = true;
                    this._setCanBeLoaded(value);
                    this._loadUnloadTabItems(value);
                }
            }));
            if (this.tabBarItems && this.tabBarItems.length && this.viewController && this.viewController.tabBar) {
                this.viewController.tabBar.setSelectedItemAnimated(this.tabBarItems[value], this.animationEnabled);
            }
            // TODO:
            // (<any>this._ios)._willSelectViewController = this._ios.viewControllers[value];
            // this._ios.selectedIndex = value;
        }
    }
    [tab_navigation_base_itemsProperty.getDefault]() {
        return null;
    }
    [tab_navigation_base_itemsProperty.setNative](value) {
        if (value) {
            value.forEach((item, i) => {
                item.index = i;
            });
        }
        this.setViewControllers(value);
        selectedIndexProperty.coerce(this);
    }
    [tabStripProperty.getDefault]() {
        return null;
    }
    [tabStripProperty.setNative](value) {
        this.setViewControllers(this.items);
        selectedIndexProperty.coerce(this);
    }
    [swipeEnabledProperty.getDefault]() {
        return true;
    }
    [swipeEnabledProperty.setNative](value) {
        if (this.viewController && this.viewController.scrollView) {
            this.viewController.scrollView.scrollEnabled = value;
        }
    }
    [iOSTabBarItemsAlignmentProperty.getDefault]() {
        if (!this.viewController || !this.viewController.tabBar) {
            return 'justified';
        }
        let alignment = this.viewController.tabBar.alignment.toString();
        return (alignment.charAt(0).toLowerCase() + alignment.substring(1));
    }
    [iOSTabBarItemsAlignmentProperty.setNative](value) {
        if (!this.viewController || !this.viewController.tabBar) {
            return;
        }
        let alignment = 1 /* Justified */;
        switch (value) {
            case 'leading':
                alignment = 0 /* Leading */;
                break;
            case 'center':
                alignment = 2 /* Center */;
                break;
            case 'centerSelected':
                alignment = 3 /* CenterSelected */;
                break;
        }
        this.viewController.tabBar.alignment = alignment;
    }
    setViewTextAttributes(view, setSelected = false) {
        if (!view) {
            return null;
        }
        const defaultTabItemFontSize = 10;
        const tabItemFontSize = view.style.fontSize || defaultTabItemFontSize;
        const font = (view.style.fontInternal || styling_font["a" /* Font */].default).getUIFont(UIFont.systemFontOfSize(tabItemFontSize));
        this.viewController.tabBar.unselectedItemTitleFont = font;
        this.viewController.tabBar.selectedItemTitleFont = font;
        const tabItemTextColor = view.style.color;
        const textColor = tabItemTextColor instanceof core_color["a" /* Color */] ? tabItemTextColor.ios : null;
        if (textColor) {
            this.viewController.tabBar.setTitleColorForState(textColor, 0 /* Normal */);
            this.viewController.tabBar.setImageTintColorForState(textColor, 0 /* Normal */);
            if (setSelected) {
                this.viewController.tabBar.setTitleColorForState(textColor, 1 /* Selected */);
                this.viewController.tabBar.setImageTintColorForState(textColor, 1 /* Selected */);
            }
        }
        if (this._selectedItemColor) {
            this.viewController.tabBar.selectedItemTintColor = this._selectedItemColor.ios;
        }
        if (this._unSelectedItemColor) {
            this.viewController.tabBar.unselectedItemTintColor = this._unSelectedItemColor.ios;
        }
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/formatted-string.js
var formatted_string = __webpack_require__(85);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/span.js
var span = __webpack_require__(71);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-field/index.js + 1 modules
var text_field = __webpack_require__(101);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/text-view/text-view-common.js


class text_view_common_TextViewBase extends editable_text_base["a" /* EditableTextBase */] {
}
const maxLinesProperty = new core_properties["Property"]({
    name: 'maxLines',
    valueConverter: parseInt,
});
maxLinesProperty.register(editable_text_base["a" /* EditableTextBase */]);
//# sourceMappingURL=text-view-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/editable-text-base/editable-text-base-common.js
var editable_text_base_common = __webpack_require__(48);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/text-view/index.js
var TextView_1;







const text_view_majorVersion = native_helper["a" /* iOSNativeHelper */].MajorVersion;
var UITextViewDelegateImpl = /** @class */ (function (_super) {
    __extends(UITextViewDelegateImpl, _super);
    function UITextViewDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITextViewDelegateImpl.initWithOwner = function (owner) {
        var impl = UITextViewDelegateImpl.new();
        impl._owner = owner;
        return impl;
    };
    UITextViewDelegateImpl.prototype.textViewShouldBeginEditing = function (textView) {
        var owner = this._owner.get();
        if (owner) {
            return owner.textViewShouldBeginEditing(textView);
        }
        return true;
    };
    UITextViewDelegateImpl.prototype.textViewDidBeginEditing = function (textView) {
        var owner = this._owner.get();
        if (owner) {
            owner.textViewDidBeginEditing(textView);
        }
    };
    UITextViewDelegateImpl.prototype.textViewDidEndEditing = function (textView) {
        var owner = this._owner.get();
        if (owner) {
            owner.textViewDidEndEditing(textView);
        }
    };
    UITextViewDelegateImpl.prototype.textViewDidChange = function (textView) {
        var owner = this._owner.get();
        if (owner) {
            owner.textViewDidChange(textView);
        }
    };
    UITextViewDelegateImpl.prototype.textViewShouldChangeTextInRangeReplacementText = function (textView, range, replacementString) {
        var owner = this._owner.get();
        if (owner) {
            return owner.textViewShouldChangeTextInRangeReplacementText(textView, range, replacementString);
        }
        return true;
    };
    UITextViewDelegateImpl.prototype.scrollViewDidScroll = function (sv) {
        var owner = this._owner.get();
        if (owner) {
            return owner.scrollViewDidScroll(sv);
        }
    };
    UITextViewDelegateImpl.ObjCProtocols = [UITextViewDelegate];
    return UITextViewDelegateImpl;
}(NSObject));
var NoScrollAnimationUITextView = /** @class */ (function (_super) {
    __extends(NoScrollAnimationUITextView, _super);
    function NoScrollAnimationUITextView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // see https://github.com/NativeScript/NativeScript/issues/6863
    // UITextView internally scrolls the text you are currently typing to visible when newline character
    // is typed but the scroll animation is not needed because at the same time we are expanding
    // the textview (setting its frame)
    NoScrollAnimationUITextView.prototype.setContentOffsetAnimated = function (contentOffset, animated) {
        _super.prototype.setContentOffsetAnimated.call(this, contentOffset, false);
    };
    return NoScrollAnimationUITextView;
}(UITextView));
let text_view_TextView = TextView_1 = class TextView extends text_view_common_TextViewBase {
    constructor() {
        super(...arguments);
        this._hintColor = text_view_majorVersion <= 12 || !UIColor.placeholderTextColor ? UIColor.blackColor.colorWithAlphaComponent(0.22) : UIColor.placeholderTextColor;
        this._textColor = text_view_majorVersion <= 12 || !UIColor.labelColor ? null : UIColor.labelColor;
    }
    createNativeView() {
        const textView = NoScrollAnimationUITextView.new();
        if (!textView.font) {
            textView.font = UIFont.systemFontOfSize(12);
        }
        return textView;
    }
    initNativeView() {
        super.initNativeView();
        this._delegate = UITextViewDelegateImpl.initWithOwner(new WeakRef(this));
    }
    disposeNativeView() {
        this._delegate = null;
        super.disposeNativeView();
    }
    onLoaded() {
        super.onLoaded();
        this.nativeTextViewProtected.delegate = this._delegate;
    }
    onUnloaded() {
        this.nativeTextViewProtected.delegate = null;
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    textViewShouldBeginEditing(textView) {
        if (this._isShowingHint) {
            this.showText();
        }
        return true;
    }
    textViewDidBeginEditing(textView) {
        this._isEditing = true;
        this.notify({ eventName: TextView_1.focusEvent, object: this });
    }
    textViewDidEndEditing(textView) {
        if (this.updateTextTrigger === 'focusLost') {
            text_base_common["i" /* textProperty */].nativeValueChange(this, textView.text);
        }
        this._isEditing = false;
        this.dismissSoftInput();
        this._refreshHintState(this.hint, textView.text);
    }
    textViewDidChange(textView) {
        if (this.updateTextTrigger === 'textChanged') {
            text_base_common["i" /* textProperty */].nativeValueChange(this, textView.text);
        }
        this.requestLayout();
    }
    textViewShouldChangeTextInRangeReplacementText(textView, range, replacementString) {
        const delta = replacementString.length - range.length;
        if (delta > 0) {
            if (textView.text.length + delta > this.maxLength) {
                return false;
            }
        }
        if (this.formattedText) {
            Object(editable_text_base["b" /* _updateCharactersInRangeReplacementString */])(this.formattedText, range.location, range.length, replacementString);
        }
        return true;
    }
    scrollViewDidScroll(sv) {
        const contentOffset = this.nativeViewProtected.contentOffset;
        this.notify({
            object: this,
            eventName: 'scroll',
            scrollX: contentOffset.x,
            scrollY: contentOffset.y,
        });
    }
    _refreshHintState(hint, text) {
        if (this.formattedText) {
            return;
        }
        if (text !== null && text !== undefined && text !== '') {
            this.showText();
        }
        else if (!this._isEditing && hint !== null && hint !== undefined && hint !== '') {
            this.showHint(hint);
        }
        else {
            this._isShowingHint = false;
            this.nativeTextViewProtected.text = '';
        }
    }
    _refreshColor() {
        if (this._isShowingHint) {
            const placeholderColor = this.style.placeholderColor;
            const color = this.style.color;
            if (placeholderColor) {
                this.nativeTextViewProtected.textColor = placeholderColor.ios;
            }
            else if (color) {
                // Use semi-transparent version of color for back-compatibility
                this.nativeTextViewProtected.textColor = color.ios.colorWithAlphaComponent(0.22);
            }
            else {
                this.nativeTextViewProtected.textColor = this._hintColor;
            }
        }
        else {
            const color = this.style.color;
            if (color) {
                this.nativeTextViewProtected.textColor = color.ios;
                this.nativeTextViewProtected.tintColor = color.ios;
            }
            else {
                this.nativeTextViewProtected.textColor = this._textColor;
                this.nativeTextViewProtected.tintColor = this._textColor;
            }
        }
    }
    showHint(hint) {
        const nativeView = this.nativeTextViewProtected;
        this._isShowingHint = true;
        this._refreshColor();
        const hintAsString = hint === null || hint === undefined ? '' : hint.toString();
        nativeView.text = hintAsString;
    }
    showText() {
        this._isShowingHint = false;
        this._setNativeText();
        this._refreshColor();
        this.requestLayout();
    }
    [text_base_common["i" /* textProperty */].getDefault]() {
        return '';
    }
    [text_base_common["i" /* textProperty */].setNative](value) {
        this._refreshHintState(this.hint, value);
    }
    [editable_text_base_common["e" /* hintProperty */].getDefault]() {
        return '';
    }
    [editable_text_base_common["e" /* hintProperty */].setNative](value) {
        this._refreshHintState(value, this.text);
    }
    [editable_text_base_common["d" /* editableProperty */].getDefault]() {
        return this.nativeTextViewProtected.editable;
    }
    [editable_text_base_common["d" /* editableProperty */].setNative](value) {
        this.nativeTextViewProtected.editable = value;
    }
    [style_properties["colorProperty"].setNative](color) {
        this._refreshColor();
    }
    [editable_text_base_common["h" /* placeholderColorProperty */].setNative](value) {
        this._refreshColor();
    }
    [style_properties["borderTopWidthProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.top,
            unit: 'px',
        };
    }
    [style_properties["borderTopWidthProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let top = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingTop + this.effectiveBorderTopWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: top,
            left: inset.left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [style_properties["borderRightWidthProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.right,
            unit: 'px',
        };
    }
    [style_properties["borderRightWidthProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let right = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingRight + this.effectiveBorderRightWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: inset.top,
            left: inset.left,
            bottom: inset.bottom,
            right: right,
        };
    }
    [style_properties["borderBottomWidthProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.bottom,
            unit: 'px',
        };
    }
    [style_properties["borderBottomWidthProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let bottom = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingBottom + this.effectiveBorderBottomWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: inset.top,
            left: inset.left,
            bottom: bottom,
            right: inset.right,
        };
    }
    [style_properties["borderLeftWidthProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.left,
            unit: 'px',
        };
    }
    [style_properties["borderLeftWidthProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let left = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingLeft + this.effectiveBorderLeftWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: inset.top,
            left: left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [style_properties["paddingTopProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.top,
            unit: 'px',
        };
    }
    [style_properties["paddingTopProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let top = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingTop + this.effectiveBorderTopWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: top,
            left: inset.left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [style_properties["paddingRightProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.right,
            unit: 'px',
        };
    }
    [style_properties["paddingRightProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let right = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingRight + this.effectiveBorderRightWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: inset.top,
            left: inset.left,
            bottom: inset.bottom,
            right: right,
        };
    }
    [style_properties["paddingBottomProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.bottom,
            unit: 'px',
        };
    }
    [style_properties["paddingBottomProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let bottom = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingBottom + this.effectiveBorderBottomWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: inset.top,
            left: inset.left,
            bottom: bottom,
            right: inset.right,
        };
    }
    [style_properties["paddingLeftProperty"].getDefault]() {
        return {
            value: this.nativeTextViewProtected.textContainerInset.left,
            unit: 'px',
        };
    }
    [style_properties["paddingLeftProperty"].setNative](value) {
        let inset = this.nativeTextViewProtected.textContainerInset;
        let left = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingLeft + this.effectiveBorderLeftWidth);
        this.nativeTextViewProtected.textContainerInset = {
            top: inset.top,
            left: left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [maxLinesProperty.getDefault]() {
        return 0;
    }
    [maxLinesProperty.setNative](value) {
        this.nativeTextViewProtected.textContainer.maximumNumberOfLines = value;
        if (value !== 0) {
            this.nativeTextViewProtected.textContainer.lineBreakMode = 4 /* ByTruncatingTail */;
        }
        else {
            this.nativeTextViewProtected.textContainer.lineBreakMode = 0 /* ByWordWrapping */;
        }
    }
};
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], text_view_TextView.prototype, "onLoaded", null);
text_view_TextView = TextView_1 = __decorate([
    Object(view_common["a" /* CSSType */])('TextView')
], text_view_TextView);

text_view_TextView.prototype.recycleNativeView = 'auto';
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/time-picker/time-picker-common.js


const time_picker_common_dateComparer = (x, y) => x <= y && x >= y;
function getValidTime(picker, hour, minute) {
    if (picker.minuteInterval > 1) {
        let minuteFloor = minute - (minute % picker.minuteInterval);
        minute = minuteFloor + (minute === minuteFloor + 1 ? picker.minuteInterval : 0);
        if (minute === 60) {
            hour++;
            minute = 0;
        }
    }
    let time = { hour: hour, minute: minute };
    if (!isLessThanMaxTime(picker, hour, minute)) {
        time = { hour: picker.maxHour, minute: picker.maxMinute };
    }
    if (!isGreaterThanMinTime(picker, hour, minute)) {
        time = { hour: picker.minHour, minute: picker.minMinute };
    }
    return time;
}
function isValidTime(picker) {
    return isGreaterThanMinTime(picker) && isLessThanMaxTime(picker);
}
function isHourValid(value) {
    return typeof value === 'number' && value >= 0 && value <= 23;
}
function isMinuteValid(value) {
    return typeof value === 'number' && value >= 0 && value <= 59;
}
function isMinuteIntervalValid(value) {
    return typeof value === 'number' && value >= 1 && value <= 30 && 60 % value === 0;
}
function getMinutes(hour) {
    return hour * 60;
}
function isDefined(value) {
    return value !== undefined;
}
function isGreaterThanMinTime(picker, hour, minute) {
    if (picker.minHour === undefined || picker.minMinute === undefined) {
        return true;
    }
    return getMinutes(hour !== undefined ? hour : picker.hour) + (minute !== undefined ? minute : picker.minute) >= getMinutes(picker.minHour) + picker.minMinute;
}
function isLessThanMaxTime(picker, hour, minute) {
    if (!isDefined(picker.maxHour) || !isDefined(picker.maxMinute)) {
        return true;
    }
    return getMinutes(isDefined(hour) ? hour : picker.hour) + (isDefined(minute) ? minute : picker.minute) <= getMinutes(picker.maxHour) + picker.maxMinute;
}
function time_picker_common_toString(value) {
    if (value instanceof Date) {
        return value + '';
    }
    return value < 10 ? `0${value}` : `${value}`;
}
function getMinMaxTimeErrorMessage(picker) {
    return `Min time: (${time_picker_common_toString(picker.minHour)}:${time_picker_common_toString(picker.minMinute)}), max time: (${time_picker_common_toString(picker.maxHour)}:${time_picker_common_toString(picker.maxMinute)})`;
}
function getErrorMessage(picker, propertyName, newValue) {
    return `${propertyName} property value (${time_picker_common_toString(newValue)}:${time_picker_common_toString(picker.minute)}) is not valid. ${getMinMaxTimeErrorMessage(picker)}.`;
}
let time_picker_common_TimePickerBase = class TimePickerBase extends core_view["c" /* View */] {
};
time_picker_common_TimePickerBase = __decorate([
    Object(view_common["a" /* CSSType */])('TimePicker')
], time_picker_common_TimePickerBase);

time_picker_common_TimePickerBase.prototype.recycleNativeView = 'auto';
const minHourProperty = new core_properties["Property"]({
    name: 'minHour',
    defaultValue: 0,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isHourValid(newValue) || !isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'minHour', newValue));
        }
    },
    valueConverter: (v) => parseInt(v),
});
minHourProperty.register(time_picker_common_TimePickerBase);
const maxHourProperty = new core_properties["Property"]({
    name: 'maxHour',
    defaultValue: 23,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isHourValid(newValue) || !isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'maxHour', newValue));
        }
    },
    valueConverter: (v) => parseInt(v),
});
maxHourProperty.register(time_picker_common_TimePickerBase);
const minMinuteProperty = new core_properties["Property"]({
    name: 'minMinute',
    defaultValue: 0,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isMinuteValid(newValue) || !isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'minMinute', newValue));
        }
    },
    valueConverter: (v) => parseInt(v),
});
minMinuteProperty.register(time_picker_common_TimePickerBase);
const maxMinuteProperty = new core_properties["Property"]({
    name: 'maxMinute',
    defaultValue: 59,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isMinuteValid(newValue) || !isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'maxMinute', newValue));
        }
    },
    valueConverter: (v) => parseInt(v),
});
maxMinuteProperty.register(time_picker_common_TimePickerBase);
const minuteIntervalProperty = new core_properties["Property"]({
    name: 'minuteInterval',
    defaultValue: 1,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isMinuteIntervalValid(newValue)) {
            throw new Error(getErrorMessage(picker, 'minuteInterval', newValue));
        }
    },
    valueConverter: (v) => parseInt(v),
});
minuteIntervalProperty.register(time_picker_common_TimePickerBase);
const minuteProperty = new core_properties["Property"]({
    name: 'minute',
    defaultValue: 0,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isMinuteValid(newValue) || !isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'minute', newValue));
        }
        picker.time = new Date(0, 0, 0, picker.hour, picker.minute);
    },
    valueConverter: (v) => parseInt(v),
});
minuteProperty.register(time_picker_common_TimePickerBase);
const hourProperty = new core_properties["Property"]({
    name: 'hour',
    defaultValue: 0,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isHourValid(newValue) || !isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'Hour', newValue));
        }
        picker.time = new Date(0, 0, 0, picker.hour, picker.minute);
    },
    valueConverter: (v) => parseInt(v),
});
hourProperty.register(time_picker_common_TimePickerBase);
const timeProperty = new core_properties["Property"]({
    name: 'time',
    defaultValue: new Date(),
    equalityComparer: time_picker_common_dateComparer,
    valueChanged: (picker, oldValue, newValue) => {
        if (!isValidTime(picker)) {
            throw new Error(getErrorMessage(picker, 'time', newValue));
        }
        picker.hour = newValue.getHours();
        picker.minute = newValue.getMinutes();
    },
});
timeProperty.register(time_picker_common_TimePickerBase);
const time_picker_common_iosPreferredDatePickerStyleProperty = new core_properties["Property"]({
    name: 'iosPreferredDatePickerStyle',
    defaultValue: 0,
    valueConverter: (v) => parseInt(v),
});
time_picker_common_iosPreferredDatePickerStyleProperty.register(time_picker_common_TimePickerBase);
//# sourceMappingURL=time-picker-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/time-picker/index.js





const time_picker_SUPPORT_DATE_PICKER_STYLE = parseFloat(platform["Device"].osVersion) >= 13.4;
const time_picker_SUPPORT_TEXT_COLOR = parseFloat(platform["Device"].osVersion) < 14.0;
function getDate(hour, minute) {
    let components = NSDateComponents.alloc().init();
    components.hour = hour;
    components.minute = minute;
    return NSCalendar.currentCalendar.dateFromComponents(components);
}
function getComponents(date) {
    return NSCalendar.currentCalendar.componentsFromDate(32 /* CalendarUnitHour */ | 64 /* CalendarUnitMinute */, date);
}
class time_picker_TimePicker extends time_picker_common_TimePickerBase {
    constructor() {
        super();
        let components = getComponents(NSDate.date());
        this.hour = components.hour;
        this.minute = components.minute;
    }
    createNativeView() {
        const picker = UIDatePicker.new();
        picker.datePickerMode = 0 /* Time */;
        if (time_picker_SUPPORT_DATE_PICKER_STYLE) {
            picker.preferredDatePickerStyle = this.iosPreferredDatePickerStyle;
        }
        return picker;
    }
    initNativeView() {
        super.initNativeView();
        this._changeHandler = time_picker_UITimePickerChangeHandlerImpl.initWithOwner(new WeakRef(this));
        this.nativeViewProtected.addTargetActionForControlEvents(this._changeHandler, 'valueChanged', 4096 /* ValueChanged */);
    }
    disposeNativeView() {
        this._changeHandler = null;
        super.initNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    [timeProperty.getDefault]() {
        return this.nativeViewProtected.date;
    }
    [timeProperty.setNative](value) {
        this.nativeViewProtected.date = getDate(this.hour, this.minute);
    }
    [minuteProperty.getDefault]() {
        return this.nativeViewProtected.date.getMinutes();
    }
    [minuteProperty.setNative](value) {
        this.nativeViewProtected.date = getDate(this.hour, value);
    }
    [hourProperty.getDefault]() {
        return this.nativeViewProtected.date.getHours();
    }
    [hourProperty.setNative](value) {
        this.nativeViewProtected.date = getDate(value, this.minute);
    }
    [minHourProperty.getDefault]() {
        return this.nativeViewProtected.minimumDate ? this.nativeViewProtected.minimumDate.getHours() : 0;
    }
    [minHourProperty.setNative](value) {
        this.nativeViewProtected.minimumDate = getDate(value, this.minute);
    }
    [maxHourProperty.getDefault]() {
        return this.nativeViewProtected.maximumDate ? this.nativeViewProtected.maximumDate.getHours() : 24;
    }
    [maxHourProperty.setNative](value) {
        this.nativeViewProtected.maximumDate = getDate(value, this.minute);
    }
    [minMinuteProperty.getDefault]() {
        return this.nativeViewProtected.minimumDate ? this.nativeViewProtected.minimumDate.getMinutes() : 0;
    }
    [minMinuteProperty.setNative](value) {
        this.nativeViewProtected.minimumDate = getDate(this.hour, value);
    }
    [maxMinuteProperty.getDefault]() {
        return this.nativeViewProtected.maximumDate ? this.nativeViewProtected.maximumDate.getMinutes() : 60;
    }
    [maxMinuteProperty.setNative](value) {
        this.nativeViewProtected.maximumDate = getDate(this.hour, value);
    }
    [minuteIntervalProperty.getDefault]() {
        return this.nativeViewProtected.minuteInterval;
    }
    [minuteIntervalProperty.setNative](value) {
        this.nativeViewProtected.minuteInterval = value;
    }
    [style_properties["colorProperty"].getDefault]() {
        return time_picker_SUPPORT_TEXT_COLOR ? this.nativeViewProtected.valueForKey('textColor') : UIColor.new();
    }
    [style_properties["colorProperty"].setNative](value) {
        if (time_picker_SUPPORT_TEXT_COLOR) {
            const color = value instanceof core_color["a" /* Color */] ? value.ios : value;
            this.nativeViewProtected.setValueForKey(color, 'textColor');
        }
    }
}
var time_picker_UITimePickerChangeHandlerImpl = /** @class */ (function (_super) {
    __extends(UITimePickerChangeHandlerImpl, _super);
    function UITimePickerChangeHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITimePickerChangeHandlerImpl.initWithOwner = function (owner) {
        var handler = UITimePickerChangeHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    UITimePickerChangeHandlerImpl.prototype.valueChanged = function (sender) {
        var owner = this._owner.get();
        if (!owner) {
            return;
        }
        var components = getComponents(sender.date);
        var timeChanged = false;
        if (components.hour !== owner.hour) {
            hourProperty.nativeValueChange(owner, components.hour);
            timeChanged = true;
        }
        if (components.minute !== owner.minute) {
            minuteProperty.nativeValueChange(owner, components.minute);
            timeChanged = true;
        }
        if (timeChanged) {
            timeProperty.nativeValueChange(owner, new Date(0, 0, 0, components.hour, components.minute));
        }
    };
    UITimePickerChangeHandlerImpl.ObjCExposedMethods = {
        valueChanged: { returns: interop.types.void, params: [UIDatePicker] },
    };
    return UITimePickerChangeHandlerImpl;
}(NSObject));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/transition/index.js
var transition = __webpack_require__(70);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/file-system/index.js + 1 modules
var file_system = __webpack_require__(21);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/web-view/web-view-common.js
var WebViewBase_1;




const web_view_common_srcProperty = new core_properties["Property"]({ name: 'src' });
let web_view_common_WebViewBase = WebViewBase_1 = class WebViewBase extends core_view["a" /* ContainerView */] {
    _onLoadFinished(url, error) {
        let args = {
            eventName: WebViewBase_1.loadFinishedEvent,
            object: this,
            url: url,
            navigationType: undefined,
            error: error,
        };
        this.notify(args);
    }
    _onLoadStarted(url, navigationType) {
        let args = {
            eventName: WebViewBase_1.loadStartedEvent,
            object: this,
            url: url,
            navigationType: navigationType,
            error: undefined,
        };
        this.notify(args);
    }
    get canGoBack() {
        throw new Error('This member is abstract.');
    }
    get canGoForward() {
        throw new Error('This member is abstract.');
    }
    [web_view_common_srcProperty.getDefault]() {
        return '';
    }
    [web_view_common_srcProperty.setNative](src) {
        this.stopLoading();
        // Add file:// prefix for local files.
        // They should be loaded with _loadUrl() method as it handles query params.
        if (src.indexOf('~/') === 0) {
            let appPath = file_system["knownFolders"].currentApp().path;
            if (appPath && appPath.indexOf('/') !== 0) {
                // ensure slash is correct
                appPath = `/${appPath}`;
            }
            src = `file://${appPath}/` + src.substr(2);
        }
        else if (src.indexOf('/') === 0) {
            src = 'file://' + src;
        }
        // loading local files from paths with spaces may fail
        if (src.toLowerCase().indexOf('file:///') === 0) {
            src = encodeURI(src);
        }
        if (src.toLowerCase().indexOf('http://') === 0 || src.toLowerCase().indexOf('https://') === 0 || src.toLowerCase().indexOf('file:///') === 0) {
            this._loadUrl(src);
        }
        else {
            this._loadData(src);
        }
    }
};
web_view_common_WebViewBase.loadStartedEvent = 'loadStarted';
web_view_common_WebViewBase.loadFinishedEvent = 'loadFinished';
web_view_common_WebViewBase = WebViewBase_1 = __decorate([
    Object(view_common["a" /* CSSType */])('WebView')
], web_view_common_WebViewBase);

web_view_common_srcProperty.register(web_view_common_WebViewBase);
//# sourceMappingURL=web-view-common.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/web-view/index.js





var web_view_WKNavigationDelegateImpl = /** @class */ (function (_super) {
    __extends(WKNavigationDelegateImpl, _super);
    function WKNavigationDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WKNavigationDelegateImpl.initWithOwner = function (owner) {
        var handler = WKNavigationDelegateImpl.new();
        handler._owner = owner;
        return handler;
    };
    WKNavigationDelegateImpl.prototype.webViewDecidePolicyForNavigationActionDecisionHandler = function (webView, navigationAction, decisionHandler) {
        var owner = this._owner.get();
        if (owner && navigationAction.request.URL) {
            var navType = 'other';
            switch (navigationAction.navigationType) {
                case WKNavigationType.LinkActivated:
                    navType = 'linkClicked';
                    break;
                case WKNavigationType.FormSubmitted:
                    navType = 'formSubmitted';
                    break;
                case WKNavigationType.BackForward:
                    navType = 'backForward';
                    break;
                case WKNavigationType.Reload:
                    navType = 'reload';
                    break;
                case WKNavigationType.FormResubmitted:
                    navType = 'formResubmitted';
                    break;
            }
            decisionHandler(WKNavigationActionPolicy.Allow);
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write('WKNavigationDelegateClass.webViewDecidePolicyForNavigationActionDecisionHandler(' + navigationAction.request.URL.absoluteString + ', ' + navigationAction.navigationType + ')', trace["a" /* Trace */].categories.Debug);
            }
            owner._onLoadStarted(navigationAction.request.URL.absoluteString, navType);
        }
    };
    WKNavigationDelegateImpl.prototype.webViewDidStartProvisionalNavigation = function (webView, navigation) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('WKNavigationDelegateClass.webViewDidStartProvisionalNavigation(' + webView.URL + ')', trace["a" /* Trace */].categories.Debug);
        }
    };
    WKNavigationDelegateImpl.prototype.webViewDidFinishNavigation = function (webView, navigation) {
        if (trace["a" /* Trace */].isEnabled()) {
            trace["a" /* Trace */].write('WKNavigationDelegateClass.webViewDidFinishNavigation(' + webView.URL + ')', trace["a" /* Trace */].categories.Debug);
        }
        var owner = this._owner.get();
        if (owner) {
            var src = owner.src;
            if (webView.URL) {
                src = webView.URL.absoluteString;
            }
            owner._onLoadFinished(src);
        }
    };
    WKNavigationDelegateImpl.prototype.webViewDidFailNavigationWithError = function (webView, navigation, error) {
        var owner = this._owner.get();
        if (owner) {
            var src = owner.src;
            if (webView.URL) {
                src = webView.URL.absoluteString;
            }
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write('WKNavigationDelegateClass.webViewDidFailNavigationWithError(' + error.localizedDescription + ')', trace["a" /* Trace */].categories.Debug);
            }
            owner._onLoadFinished(src, error.localizedDescription);
        }
    };
    WKNavigationDelegateImpl.prototype.webViewDidFailProvisionalNavigationWithError = function (webView, navigation, error) {
        var owner = this._owner.get();
        if (owner) {
            var src = owner.src;
            if (webView.URL) {
                src = webView.URL.absoluteString;
            }
            if (trace["a" /* Trace */].isEnabled()) {
                trace["a" /* Trace */].write('WKNavigationDelegateClass.webViewDidFailProvisionalNavigationWithError(' + error.localizedDescription + ')', trace["a" /* Trace */].categories.Debug);
            }
            owner._onLoadFinished(src, error.localizedDescription);
        }
    };
    WKNavigationDelegateImpl.ObjCProtocols = [WKNavigationDelegate];
    return WKNavigationDelegateImpl;
}(NSObject));
class web_view_WebView extends web_view_common_WebViewBase {
    createNativeView() {
        const jScript = "var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'initial-scale=1.0'); document.getElementsByTagName('head')[0].appendChild(meta);";
        const wkUScript = WKUserScript.alloc().initWithSourceInjectionTimeForMainFrameOnly(jScript, 1 /* AtDocumentEnd */, true);
        const wkUController = WKUserContentController.new();
        wkUController.addUserScript(wkUScript);
        const configuration = WKWebViewConfiguration.new();
        configuration.userContentController = wkUController;
        configuration.preferences.setValueForKey(true, 'allowFileAccessFromFileURLs');
        return new WKWebView({
            frame: CGRectZero,
            configuration: configuration,
        });
    }
    initNativeView() {
        super.initNativeView();
        this._delegate = web_view_WKNavigationDelegateImpl.initWithOwner(new WeakRef(this));
        this.ios.navigationDelegate = this._delegate;
    }
    onLoaded() {
        super.onLoaded();
    }
    onUnloaded() {
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    stopLoading() {
        this.ios.stopLoading();
    }
    _loadUrl(src) {
        if (src.startsWith('file:///')) {
            const cachePath = src.substring(0, src.lastIndexOf('/'));
            this.ios.loadFileURLAllowingReadAccessToURL(NSURL.URLWithString(src), NSURL.URLWithString(cachePath));
        }
        else {
            this.ios.loadRequest(NSURLRequest.requestWithURL(NSURL.URLWithString(src)));
        }
    }
    _loadData(content) {
        this.ios.loadHTMLStringBaseURL(content, NSURL.alloc().initWithString(`file:///${file_system["knownFolders"].currentApp().path}/`));
    }
    get canGoBack() {
        return this.ios.canGoBack;
    }
    get canGoForward() {
        return this.ios.canGoForward;
    }
    goBack() {
        this.ios.goBack();
    }
    goForward() {
        this.ios.goForward();
    }
    reload() {
        this.ios.reload();
    }
}
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], web_view_WebView.prototype, "onLoaded", null);
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/index.js















// No need go export dialogs, they are already export exported globally









 // barrel export


































//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ image_asset_ImageAsset; });

// UNUSED EXPORTS: ImageAssetBase, getAspectSafeDimensions, getRequestedImageSize

// EXTERNAL MODULE: ../node_modules/@nativescript/core/data/observable/index.js
var observable = __webpack_require__(5);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/platform/index.js
var platform = __webpack_require__(13);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/image-asset/image-asset-common.js


class image_asset_common_ImageAssetBase extends observable["Observable"] {
    constructor() {
        super();
        this._options = { keepAspectRatio: true, autoScaleFactor: true };
    }
    get options() {
        return this._options;
    }
    set options(value) {
        this._options = value;
    }
    get nativeImage() {
        return this._nativeImage;
    }
    set nativeImage(value) {
        this._nativeImage = value;
    }
    getImageAsync(callback) {
        //
    }
}
function getAspectSafeDimensions(sourceWidth, sourceHeight, reqWidth, reqHeight) {
    let widthCoef = sourceWidth / reqWidth;
    let heightCoef = sourceHeight / reqHeight;
    let aspectCoef = Math.min(widthCoef, heightCoef);
    return {
        width: Math.floor(sourceWidth / aspectCoef),
        height: Math.floor(sourceHeight / aspectCoef),
    };
}
function getRequestedImageSize(src, options) {
    let reqWidth = options.width || Math.min(src.width, platform["Screen"].mainScreen.widthPixels);
    let reqHeight = options.height || Math.min(src.height, platform["Screen"].mainScreen.heightPixels);
    if (options && options.keepAspectRatio) {
        let safeAspectSize = getAspectSafeDimensions(src.width, src.height, reqWidth, reqHeight);
        reqWidth = safeAspectSize.width;
        reqHeight = safeAspectSize.height;
    }
    return {
        width: reqWidth,
        height: reqHeight,
    };
}
//# sourceMappingURL=image-asset-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/file-system/index.js + 1 modules
var file_system = __webpack_require__(21);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/image-asset/index.js



class image_asset_ImageAsset extends image_asset_common_ImageAssetBase {
    constructor(asset) {
        super();
        if (typeof asset === 'string') {
            if (asset.indexOf('~/') === 0) {
                asset = file_system["path"].join(file_system["knownFolders"].currentApp().path, asset.replace('~/', ''));
            }
            this.nativeImage = UIImage.imageWithContentsOfFile(asset);
        }
        else if (asset instanceof UIImage) {
            this.nativeImage = asset;
        }
        else {
            this.ios = asset;
        }
    }
    // @ts-ignore
    get ios() {
        return this._ios;
    }
    set ios(value) {
        this._ios = value;
    }
    getImageAsync(callback) {
        if (!this.ios && !this.nativeImage) {
            callback(null, 'Asset cannot be found.');
        }
        let srcWidth = this.nativeImage ? this.nativeImage.size.width : this.ios.pixelWidth;
        let srcHeight = this.nativeImage ? this.nativeImage.size.height : this.ios.pixelHeight;
        let requestedSize = getRequestedImageSize({ width: srcWidth, height: srcHeight }, this.options);
        if (this.nativeImage) {
            let newSize = CGSizeMake(requestedSize.width, requestedSize.height);
            let resizedImage = this.scaleImage(this.nativeImage, newSize);
            callback(resizedImage, null);
            return;
        }
        let imageRequestOptions = PHImageRequestOptions.alloc().init();
        imageRequestOptions.deliveryMode = 1 /* HighQualityFormat */;
        imageRequestOptions.networkAccessAllowed = true;
        PHImageManager.defaultManager().requestImageForAssetTargetSizeContentModeOptionsResultHandler(this.ios, requestedSize, 0 /* AspectFit */, imageRequestOptions, (image, imageResultInfo) => {
            if (image) {
                let resultImage = this.scaleImage(image, requestedSize);
                callback(resultImage, null);
            }
            else {
                callback(null, imageResultInfo.valueForKey(PHImageErrorKey));
            }
        });
    }
    scaleImage(image, requestedSize) {
        // scaleFactor = 0 takes the scale factor of the devices's main screen.
        const scaleFactor = this.options && this.options.autoScaleFactor === false ? 1.0 : 0.0;
        UIGraphicsBeginImageContextWithOptions(requestedSize, false, scaleFactor);
        image.drawInRect(CGRectMake(0, 0, requestedSize.width, requestedSize.height));
        let resultImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return resultImage;
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getComponentModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setPropertyValue; });
/* harmony import */ var _core_bindable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _binding_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _profiling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var _module_name_sanitizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _module_name_resolver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);
// Types.






const legacyShortBarrels = [
    'text/formatted-string',
    'text/span',
    'ui/text-base/formatted-string',
    'ui/text-base/span',
    'ui/action-bar',
    'ui/activity-indicator',
    'ui/bottom-navigation',
    'ui/button',
    'ui/content-view',
    'ui/date-picker',
    'ui/frame',
    'ui/html-view',
    'ui/image',
    'ui/label',
    'ui/layouts/absolute-layout',
    'ui/layouts/dock-layout',
    'ui/layouts/grid-layout',
    'ui/layouts/stack-layout',
    'ui/layouts/flexbox-layout',
    'ui/layouts/wrap-layout',
    'ui/list-picker',
    'ui/page',
    'ui/placeholder',
    'ui/progress',
    'ui/proxy-view-container',
    'ui/repeater',
    'ui/scroll-view',
    'ui/search-bar',
    'ui/segmented-bar',
    'ui/slider',
    'ui/switch',
    'ui/tab-view',
    'ui/tab-navigation-base/tab-strip',
    'ui/tab-navigation-base/tab-strip-item',
    'ui/tab-navigation-base/tab-content-item',
    'ui/tabs',
    'ui/web-view',
    'ui/text-field',
    'ui/text-view',
    'ui/time-picker',
    'ui/list-view',
];
const CORE_UI_BARREL = '@nativescript/core/ui';
const CODE_FILE = 'codeFile';
const CSS_FILE = 'cssFile';
const IMPORT = 'import';
const createComponentInstance = Object(_profiling__WEBPACK_IMPORTED_MODULE_2__[/* profile */ "f"])('createComponentInstance', (elementName, namespace) => {
    let instance;
    let instanceModule;
    // Get module id.
    let resolvedModuleName;
    try {
        if (typeof namespace === 'string') {
            if (legacyShortBarrels.includes(namespace)) {
                // console.log('CORE_UI_BARREL namespace:', namespace)
                resolvedModuleName = CORE_UI_BARREL;
            }
            else {
                // console.log('CUSTOM namespace:', namespace)
                resolvedModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_5__[/* resolveModuleName */ "c"])(namespace, '');
            }
            instanceModule = global.loadModule(resolvedModuleName, true);
        }
        else {
            // load module from @nativescript/core/ui or mapped paths
            // resolvedModuleName =
            // 	MODULES[elementName] ||
            // 	UI_PATH +
            // 		(elementName.toLowerCase().indexOf('layout') !== -1 ? 'layouts/' : '') +
            // 		elementName
            // 			.split(/(?=[A-Z])/)
            // 			.join('-')
            // 			.toLowerCase();
            instanceModule = global.loadModule(CORE_UI_BARREL, false);
            // don't register core modules for HMR self-accept
            // instanceModule = global.loadModule(resolvedModuleName, false);
        }
        // Get the component type from module.
        const instanceType = instanceModule[elementName];
        // Create instance of the component.
        instance = new instanceType();
    }
    catch (ex) {
        const debug = __webpack_require__(41);
        throw new debug.ScopeError(ex, "Module '" + (resolvedModuleName || elementName) + "' not found for element '" + (namespace ? namespace + ':' : '') + elementName + "'.");
    }
    return { instance, instanceModule };
});
const getComponentModuleExports = Object(_profiling__WEBPACK_IMPORTED_MODULE_2__[/* profile */ "f"])('getComponentModuleExports', (instance, moduleExports, attributes) => {
    if (attributes) {
        const codeFileAttribute = attributes[CODE_FILE] || attributes[IMPORT];
        if (codeFileAttribute) {
            const resolvedCodeFileModule = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_5__[/* resolveModuleName */ "c"])(Object(_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_4__[/* sanitizeModuleName */ "a"])(codeFileAttribute), '');
            if (resolvedCodeFileModule) {
                moduleExports = global.loadModule(resolvedCodeFileModule, true);
                instance.exports = moduleExports;
            }
            else {
                throw new Error(`Code file with path "${codeFileAttribute}" cannot be found! Looking for webpack module with name "${resolvedCodeFileModule}"`);
            }
        }
    }
    return moduleExports;
});
const applyComponentCss = Object(_profiling__WEBPACK_IMPORTED_MODULE_2__[/* profile */ "f"])('applyComponentCss', (instance, moduleName, attributes) => {
    let cssApplied = false;
    if (attributes && attributes[CSS_FILE]) {
        let resolvedCssModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_5__[/* resolveModuleName */ "c"])(Object(_module_name_sanitizer__WEBPACK_IMPORTED_MODULE_4__[/* sanitizeModuleName */ "a"])(attributes[CSS_FILE]), 'css');
        if (resolvedCssModuleName) {
            instance.addCssFile(resolvedCssModuleName);
            cssApplied = true;
        }
        else {
            throw new Error(`Css file with path "${attributes[CSS_FILE]}" cannot be found! Looking for webpack module with name "${resolvedCssModuleName}"`);
        }
    }
    if (moduleName && !cssApplied) {
        let resolvedCssModuleName = Object(_module_name_resolver__WEBPACK_IMPORTED_MODULE_5__[/* resolveModuleName */ "c"])(moduleName, 'css');
        if (resolvedCssModuleName) {
            instance.addCssFile(resolvedCssModuleName);
        }
    }
});
const applyComponentAttributes = Object(_profiling__WEBPACK_IMPORTED_MODULE_2__[/* profile */ "f"])('applyComponentAttributes', (instance, instanceModule, moduleExports, attributes) => {
    if (instance && instanceModule) {
        for (let attr in attributes) {
            const attrValue = attributes[attr];
            if (attr.indexOf(':') !== -1) {
                const platformName = attr.split(':')[0].trim();
                if (platformName.toLowerCase() === _platform__WEBPACK_IMPORTED_MODULE_3__["Device"].os.toLowerCase()) {
                    attr = attr.split(':')[1].trim();
                }
                else {
                    continue;
                }
            }
            if (attr.indexOf('.') !== -1) {
                let subObj = instance;
                const properties = attr.split('.');
                const subPropName = properties[properties.length - 1];
                for (let i = 0; i < properties.length - 1; i++) {
                    if (subObj !== undefined && subObj !== null) {
                        subObj = subObj[properties[i]];
                    }
                }
                if (subObj !== undefined && subObj !== null) {
                    setPropertyValue(subObj, instanceModule, moduleExports, subPropName, attrValue);
                }
            }
            else {
                setPropertyValue(instance, instanceModule, moduleExports, attr, attrValue);
            }
        }
    }
});
function getComponentModule(elementName, namespace, attributes, moduleExports, moduleNamePath, isRootComponent) {
    // Support lower-case-dashed component declaration in the XML (https://github.com/NativeScript/NativeScript/issues/309).
    elementName = elementName
        .split('-')
        .map((s) => s[0].toUpperCase() + s.substring(1))
        .join('');
    const { instance, instanceModule } = createComponentInstance(elementName, namespace, null);
    moduleExports = getComponentModuleExports(instance, moduleExports, attributes);
    if (isRootComponent) {
        applyComponentCss(instance, moduleNamePath, attributes);
    }
    applyComponentAttributes(instance, instanceModule, moduleExports, attributes);
    let componentModule;
    if (instance && instanceModule) {
        componentModule = { component: instance, exports: instanceModule };
    }
    return componentModule;
}
function setPropertyValue(instance, instanceModule, exports, propertyName, propertyValue) {
    // Note: instanceModule can be null if we are loading custom component with no code-behind.
    if (isBinding(propertyValue) && instance.bind) {
        const bindOptions = Object(_binding_builder__WEBPACK_IMPORTED_MODULE_1__[/* getBindingOptions */ "b"])(propertyName, getBindingExpressionFromAttribute(propertyValue));
        instance.bind({
            sourceProperty: bindOptions[_binding_builder__WEBPACK_IMPORTED_MODULE_1__[/* bindingConstants */ "a"].sourceProperty],
            targetProperty: bindOptions[_binding_builder__WEBPACK_IMPORTED_MODULE_1__[/* bindingConstants */ "a"].targetProperty],
            expression: bindOptions[_binding_builder__WEBPACK_IMPORTED_MODULE_1__[/* bindingConstants */ "a"].expression],
            twoWay: bindOptions[_binding_builder__WEBPACK_IMPORTED_MODULE_1__[/* bindingConstants */ "a"].twoWay],
        }, bindOptions[_binding_builder__WEBPACK_IMPORTED_MODULE_1__[/* bindingConstants */ "a"].source]);
    }
    else if (Object(_core_bindable__WEBPACK_IMPORTED_MODULE_0__[/* isEventOrGesture */ "c"])(propertyName, instance)) {
        // Get the event handler from page module exports.
        const handler = exports && exports[propertyValue];
        // Check if the handler is function and add it to the instance for specified event name.
        if (typeof handler === 'function') {
            instance.on(propertyName, handler);
        }
    }
    else if (isKnownFunction(propertyName, instance) && exports && typeof exports[propertyValue] === 'function') {
        instance[propertyName] = exports[propertyValue];
    }
    else {
        instance[propertyName] = propertyValue;
    }
}
function getBindingExpressionFromAttribute(value) {
    return value.replace('{{', '').replace('}}', '').trim();
}
function isBinding(value) {
    let isBinding;
    if (typeof value === 'string') {
        const str = value.trim();
        isBinding = str.indexOf('{{') === 0 && str.lastIndexOf('}}') === str.length - 2;
    }
    return isBinding;
}
// For example, ListView.itemTemplateSelector
let KNOWN_FUNCTIONS = 'knownFunctions';
function isKnownFunction(name, instance) {
    return instance.constructor && KNOWN_FUNCTIONS in instance.constructor && instance.constructor[KNOWN_FUNCTIONS].indexOf(name) !== -1;
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 90 */,
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();

    error.name = name;
    error.message = message;

    Object.defineProperty(error, 'stack', {
        get: function() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
        }
    });

    return error;
};
; 
if (false ) {} 

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

function noop(value) {
    return value;
}

function generateMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
        return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
        return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
        return '';
    }

    return (
        (multiplier.comma ? '#' : '') +
        (multiplier.min === multiplier.max
            ? '{' + multiplier.min + '}'
            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-∞' : node.min) +
                ',' +
                (node.max === null ? '∞' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    var result = node.terms.map(function(term) {
        return generate(term, decorate, forceBraces, compact);
    }).join(combinator);

    if (node.explicit || forceBraces) {
        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function generate(node, decorate, forceBraces, compact) {
    var result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                generate(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

module.exports = function(node, options) {
    var decorate = noop;
    var forceBraces = false;
    var compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return generate(node, decorate, forceBraces, compact);
};
; 
if (false ) {} 

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var keywords = Object.create(null);
var properties = Object.create(null);
var HYPHENMINUS = 45; // '-'.charCodeAt()

function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS &&
           str.charCodeAt(offset + 1) === HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
            // vendor prefix should contain a hyper minus at the ending
            var secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
        return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
    }

    var custom = isCustomProperty(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    return keywords[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name: name,
        vendor: vendor,
        prefix: vendor,
        custom: custom
    });
}

function getPropertyDescriptor(property) {
    if (hasOwnProperty.call(properties, property)) {
        return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    var custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty.call(properties, name)) {
            return properties[property] = properties[name];
        }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);

    return properties[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack: hack,
        vendor: vendor,
        prefix: prefix,
        custom: custom
    });
}

module.exports = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty,
    vendorPrefix: getVendorPrefix
};
; 
if (false ) {} 

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var Tokenizer = __webpack_require__(313);
var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var EXCLAMATIONMARK = 33;    // !
var NUMBERSIGN = 35;         // #
var AMPERSAND = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS = 40;    // (
var RIGHTPARENTHESIS = 41;   // )
var ASTERISK = 42;           // *
var PLUSSIGN = 43;           // +
var COMMA = 44;              // ,
var HYPERMINUS = 45;         // -
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN = 62;    // >
var QUESTIONMARK = 63;       // ?
var COMMERCIALAT = 64;       // @
var LEFTSQUAREBRACKET = 91;  // [
var RIGHTSQUAREBRACKET = 93; // ]
var LEFTCURLYBRACKET = 123;  // {
var VERTICALLINE = 124;      // |
var RIGHTCURLYBRACKET = 125; // }
var INFINITY = 8734;         // ∞
var NAME_CHAR = createCharMap(function(ch) {
    return /[a-zA-Z0-9\-]/.test(ch);
});
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function createCharMap(fn) {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
}

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    var range = null;
    var comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
                range = readMultiplierRange(tokenizer);
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma: comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    var ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name: name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation—[min,max]—within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    var min = null; // -Infinity
    var max = null; // Infinity
    var sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));
    }

    tokenizer.eat(RIGHTSQUAREBRACKET);

    // If no range is indicated, either by using the bracketed range notation
    // or in the property description, then [−∞,∞] is assumed.
    if (min === null && max === null) {
        return null;
    }

    return {
        type: 'Range',
        min: min,
        max: max
    };
}

function readType(tokenizer) {
    var name;
    var opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name: name,
        opts: opts
    });
}

function readKeywordOrFunction(tokenizer) {
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name: name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name: name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms: terms,
            combinator: combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    var result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
                ? readProperty(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.nextCharCode() === VERTICALLINE
                        ? tokenizer.pos + 2
                        : tokenizer.pos + 1
                )
            };

        case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse(source) {
    var tokenizer = new Tokenizer(source);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== source.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        result = result.terms[0];
    }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

module.exports = parse;
; 
if (false ) {} 

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
; 
if (false ) {} 

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    AnPlusB: __webpack_require__(340),
    Atrule: __webpack_require__(341),
    AtrulePrelude: __webpack_require__(342),
    AttributeSelector: __webpack_require__(343),
    Block: __webpack_require__(344),
    Brackets: __webpack_require__(345),
    CDC: __webpack_require__(346),
    CDO: __webpack_require__(347),
    ClassSelector: __webpack_require__(348),
    Combinator: __webpack_require__(349),
    Comment: __webpack_require__(350),
    Declaration: __webpack_require__(351),
    DeclarationList: __webpack_require__(352),
    Dimension: __webpack_require__(353),
    Function: __webpack_require__(354),
    Hash: __webpack_require__(355),
    Identifier: __webpack_require__(356),
    IdSelector: __webpack_require__(357),
    MediaFeature: __webpack_require__(358),
    MediaQuery: __webpack_require__(359),
    MediaQueryList: __webpack_require__(360),
    Nth: __webpack_require__(361),
    Number: __webpack_require__(362),
    Operator: __webpack_require__(363),
    Parentheses: __webpack_require__(364),
    Percentage: __webpack_require__(365),
    PseudoClassSelector: __webpack_require__(366),
    PseudoElementSelector: __webpack_require__(367),
    Ratio: __webpack_require__(368),
    Raw: __webpack_require__(62),
    Rule: __webpack_require__(369),
    Selector: __webpack_require__(370),
    SelectorList: __webpack_require__(371),
    String: __webpack_require__(372),
    StyleSheet: __webpack_require__(373),
    TypeSelector: __webpack_require__(374),
    UnicodeRange: __webpack_require__(375),
    Url: __webpack_require__(376),
    Value: __webpack_require__(377),
    WhiteSpace: __webpack_require__(378)
};
; 
if (false ) {} 

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridLayout", function() { return GridLayout; });
/* harmony import */ var _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* harmony import */ var _core_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ItemSpec", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridLayoutBase", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "columnProperty", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "columnSpanProperty", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rowProperty", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rowSpanProperty", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridUnitType", function() { return _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__["b"]; });





class GridLayout extends _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__[/* GridLayoutBase */ "a"] {
    constructor() {
        super();
        this.columnOffsets = new Array();
        this.rowOffsets = new Array();
        this.map = new Map();
        this.helper = new MeasureHelper(this);
    }
    _onRowAdded(itemSpec) {
        this.helper.rows.push(new ItemGroup(itemSpec));
    }
    _onColumnAdded(itemSpec) {
        this.helper.columns.push(new ItemGroup(itemSpec));
    }
    _onRowRemoved(itemSpec, index) {
        this.helper.rows[index].children.length = 0;
        this.helper.rows.splice(index, 1);
    }
    _onColumnRemoved(itemSpec, index) {
        this.helper.columns[index].children.length = 0;
        this.helper.columns.splice(index, 1);
    }
    _registerLayoutChild(child) {
        this.addToMap(child);
    }
    _unregisterLayoutChild(child) {
        this.removeFromMap(child);
    }
    invalidate() {
        super.invalidate();
        this.requestLayout();
    }
    getColumnIndex(view) {
        return Math.max(0, Math.min(GridLayout.getColumn(view), this.columnsInternal.length - 1));
    }
    getRowIndex(view) {
        return Math.max(0, Math.min(GridLayout.getRow(view), this.rowsInternal.length - 1));
    }
    getColumnSpan(view, columnIndex) {
        return Math.max(1, Math.min(GridLayout.getColumnSpan(view), this.columnsInternal.length - columnIndex));
    }
    getRowSpan(view, rowIndex) {
        return Math.max(1, Math.min(GridLayout.getRowSpan(view), this.rowsInternal.length - rowIndex));
    }
    getColumnSpec(view) {
        return this.columnsInternal[this.getColumnIndex(view)] || this.helper.singleColumn;
    }
    getRowSpec(view) {
        return this.rowsInternal[this.getRowIndex(view)] || this.helper.singleRow;
    }
    updateMeasureSpecs(child, measureSpec) {
        let column = this.getColumnSpec(child);
        let columnIndex = this.getColumnIndex(child);
        let columnSpan = this.getColumnSpan(child, columnIndex);
        let row = this.getRowSpec(child);
        let rowIndex = this.getRowIndex(child);
        let rowSpan = this.getRowSpan(child, rowIndex);
        measureSpec.setColumn(column);
        measureSpec.setColumnIndex(columnIndex);
        measureSpec.setColumnSpan(columnSpan);
        measureSpec.setRow(row);
        measureSpec.setRowIndex(rowIndex);
        measureSpec.setRowSpan(rowSpan);
        measureSpec.autoColumnsCount = 0;
        measureSpec.autoRowsCount = 0;
        measureSpec.measured = false;
        measureSpec.pixelHeight = 0;
        measureSpec.pixelWidth = 0;
        measureSpec.starColumnsCount = 0;
        measureSpec.starRowsCount = 0;
    }
    addToMap(child) {
        this.map.set(child, new MeasureSpecs(child));
    }
    removeFromMap(child) {
        this.map.delete(child);
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        let measureWidth = 0;
        let measureHeight = 0;
        const width = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].getMeasureSpecSize(widthMeasureSpec);
        const widthMode = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].getMeasureSpecMode(widthMeasureSpec);
        const height = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].getMeasureSpecSize(heightMeasureSpec);
        const heightMode = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].getMeasureSpecMode(heightMeasureSpec);
        const horizontalPaddingsAndMargins = this.effectivePaddingLeft + this.effectivePaddingRight + this.effectiveBorderLeftWidth + this.effectiveBorderRightWidth;
        const verticalPaddingsAndMargins = this.effectivePaddingTop + this.effectivePaddingBottom + this.effectiveBorderTopWidth + this.effectiveBorderBottomWidth;
        let infinityWidth = widthMode === _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].UNSPECIFIED;
        let infinityHeight = heightMode === _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].UNSPECIFIED;
        this.helper.width = Math.max(0, width - horizontalPaddingsAndMargins);
        this.helper.height = Math.max(0, height - verticalPaddingsAndMargins);
        this.helper.stretchedHorizontally = widthMode === _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY || (this.horizontalAlignment === 'stretch' && !infinityWidth);
        this.helper.stretchedVertically = heightMode === _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY || (this.verticalAlignment === 'stretch' && !infinityHeight);
        this.helper.setInfinityWidth(infinityWidth);
        this.helper.setInfinityHeight(infinityHeight);
        this.helper.clearMeasureSpecs();
        this.helper.init();
        this.eachLayoutChild((child, last) => {
            let measureSpecs = this.map.get(child);
            if (!measureSpecs) {
                return;
            }
            this.updateMeasureSpecs(child, measureSpecs);
            this.helper.addMeasureSpec(measureSpecs);
        });
        this.helper.measure();
        // Add in our padding
        measureWidth = this.helper.measuredWidth + horizontalPaddingsAndMargins;
        measureHeight = this.helper.measuredHeight + verticalPaddingsAndMargins;
        // Check against our minimum sizes
        measureWidth = Math.max(measureWidth, this.effectiveMinWidth);
        measureHeight = Math.max(measureHeight, this.effectiveMinHeight);
        const widthSizeAndState = _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].resolveSizeAndState(measureWidth, width, widthMode, 0);
        const heightSizeAndState = _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthSizeAndState, heightSizeAndState);
    }
    onLayout(left, top, right, bottom) {
        super.onLayout(left, top, right, bottom);
        const insets = this.getSafeAreaInsets();
        let paddingLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
        let paddingTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
        this.columnOffsets.length = 0;
        this.rowOffsets.length = 0;
        this.columnOffsets.push(paddingLeft);
        this.rowOffsets.push(paddingTop);
        let offset = this.columnOffsets[0];
        let roundedOffset = paddingLeft;
        let roundedLength = 0;
        let actualLength = 0;
        for (let i = 0, size = this.helper.columns.length; i < size; i++) {
            let columnGroup = this.helper.columns[i];
            offset += columnGroup.length;
            actualLength = offset - roundedOffset;
            roundedLength = Math.round(actualLength);
            columnGroup.rowOrColumn._actualLength = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(roundedLength));
            roundedOffset += roundedLength;
            this.columnOffsets.push(roundedOffset);
        }
        offset = this.rowOffsets[0];
        roundedOffset = paddingTop;
        roundedLength = 0;
        actualLength = 0;
        for (let i = 0, size = this.helper.rows.length; i < size; i++) {
            let rowGroup = this.helper.rows[i];
            offset += rowGroup.length;
            actualLength = offset - roundedOffset;
            roundedLength = Math.round(actualLength);
            rowGroup.rowOrColumn._actualLength = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].round(_utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDeviceIndependentPixels(roundedLength));
            roundedOffset += roundedLength;
            this.rowOffsets.push(roundedOffset);
        }
        for (let i = 0, columns = this.helper.columns.length; i < columns; i++) {
            let columnGroup = this.helper.columns[i];
            for (let j = 0, children = columnGroup.children.length; j < children; j++) {
                let measureSpec = columnGroup.children[j];
                let childLeft = this.columnOffsets[measureSpec.getColumnIndex()];
                let childRight = this.columnOffsets[measureSpec.getColumnIndex() + measureSpec.getColumnSpan()];
                let childTop = this.rowOffsets[measureSpec.getRowIndex()];
                let childBottom = this.rowOffsets[measureSpec.getRowIndex() + measureSpec.getRowSpan()];
                // No need to include margins in the width, height
                _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].layoutChild(this, measureSpec.child, childLeft, childTop, childRight, childBottom);
            }
        }
    }
}
class MeasureSpecs {
    constructor(child) {
        this._columnSpan = 1;
        this._rowSpan = 1;
        this.pixelWidth = 0;
        this.pixelHeight = 0;
        this.starColumnsCount = 0;
        this.starRowsCount = 0;
        this.autoColumnsCount = 0;
        this.autoRowsCount = 0;
        this.measured = false;
        this.columnIndex = 0;
        this.rowIndex = 0;
        this.child = child;
    }
    getSpanned() {
        return this._columnSpan > 1 || this._rowSpan > 1;
    }
    getIsStar() {
        return this.starRowsCount > 0 || this.starColumnsCount > 0;
    }
    getColumnSpan() {
        return this._columnSpan;
    }
    getRowSpan() {
        return this._rowSpan;
    }
    setRowSpan(value) {
        // cannot have zero rowSpan.
        this._rowSpan = Math.max(1, value);
    }
    setColumnSpan(value) {
        // cannot have zero colSpan.
        this._columnSpan = Math.max(1, value);
    }
    getRowIndex() {
        return this.rowIndex;
    }
    getColumnIndex() {
        return this.columnIndex;
    }
    setRowIndex(value) {
        this.rowIndex = value;
    }
    setColumnIndex(value) {
        this.columnIndex = value;
    }
    getRow() {
        return this.row;
    }
    getColumn() {
        return this.column;
    }
    setRow(value) {
        this.row = value;
    }
    setColumn(value) {
        this.column = value;
    }
}
class ItemGroup {
    constructor(spec) {
        this.length = 0;
        this.measuredCount = 0;
        this.children = new Array();
        this.measureToFix = 0;
        this.currentMeasureToFixCount = 0;
        this.infinityLength = false;
        this.rowOrColumn = spec;
    }
    setIsLengthInfinity(infinityLength) {
        this.infinityLength = infinityLength;
    }
    init(density) {
        this.measuredCount = 0;
        this.currentMeasureToFixCount = 0;
        this.length = this.rowOrColumn.isAbsolute ? this.rowOrColumn.value * density : 0;
    }
    getAllMeasured() {
        return this.measuredCount === this.children.length;
    }
    getCanBeFixed() {
        return this.currentMeasureToFixCount === this.measureToFix;
    }
    getIsAuto() {
        return this.rowOrColumn.isAuto || (this.rowOrColumn.isStar && this.infinityLength);
    }
    getIsStar() {
        return this.rowOrColumn.isStar && !this.infinityLength;
    }
    getIsAbsolute() {
        return this.rowOrColumn.isAbsolute;
    }
}
class MeasureHelper {
    constructor(grid) {
        this.infinity = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(0, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].UNSPECIFIED);
        this.rows = new Array();
        this.columns = new Array();
        this.width = 0;
        this.height = 0;
        this.stretchedHorizontally = false;
        this.stretchedVertically = false;
        this.infinityWidth = false;
        this.infinityHeight = false;
        this.minColumnStarValue = 0;
        this.maxColumnStarValue = 0;
        this.minRowStarValue = 0;
        this.maxRowStarValue = 0;
        this.measuredWidth = 0;
        this.measuredHeight = 0;
        this.fakeRowAdded = false;
        this.fakeColumnAdded = false;
        this.grid = grid;
        this.singleRow = new _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__[/* ItemSpec */ "c"]();
        this.singleColumn = new _grid_layout_common__WEBPACK_IMPORTED_MODULE_0__[/* ItemSpec */ "c"]();
        this.singleRowGroup = new ItemGroup(this.singleRow);
        this.singleColumnGroup = new ItemGroup(this.singleColumn);
    }
    setInfinityWidth(value) {
        this.infinityWidth = value;
        for (let i = 0, size = this.columns.length; i < size; i++) {
            let columnGroup = this.columns[i];
            columnGroup.setIsLengthInfinity(value);
        }
    }
    setInfinityHeight(value) {
        this.infinityHeight = value;
        for (let i = 0, size = this.rows.length; i < size; i++) {
            let rowGroup = this.rows[i];
            rowGroup.setIsLengthInfinity(value);
        }
    }
    addMeasureSpec(measureSpec) {
        // Get column stats
        let size = measureSpec.getColumnIndex() + measureSpec.getColumnSpan();
        for (let i = measureSpec.getColumnIndex(); i < size; i++) {
            let columnGroup = this.columns[i];
            if (columnGroup.getIsAuto()) {
                measureSpec.autoColumnsCount++;
            }
            else if (columnGroup.getIsStar()) {
                measureSpec.starColumnsCount += columnGroup.rowOrColumn.value;
            }
            else if (columnGroup.getIsAbsolute()) {
                measureSpec.pixelWidth += _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(columnGroup.rowOrColumn.value);
            }
        }
        if (measureSpec.autoColumnsCount > 0 && measureSpec.starColumnsCount === 0) {
            // Determine which auto columns are affected by this element
            for (let i = measureSpec.getColumnIndex(); i < size; i++) {
                let columnGroup = this.columns[i];
                if (columnGroup.getIsAuto()) {
                    columnGroup.measureToFix++;
                }
            }
        }
        // Get row stats
        size = measureSpec.getRowIndex() + measureSpec.getRowSpan();
        for (let i = measureSpec.getRowIndex(); i < size; i++) {
            let rowGroup = this.rows[i];
            if (rowGroup.getIsAuto()) {
                measureSpec.autoRowsCount++;
            }
            else if (rowGroup.getIsStar()) {
                measureSpec.starRowsCount += rowGroup.rowOrColumn.value;
            }
            else if (rowGroup.getIsAbsolute()) {
                measureSpec.pixelHeight += _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].toDevicePixels(rowGroup.rowOrColumn.value);
            }
        }
        if (measureSpec.autoRowsCount > 0 && measureSpec.starRowsCount === 0) {
            // Determine which auto rows are affected by this element
            for (let i = measureSpec.getRowIndex(); i < size; i++) {
                let rowGroup = this.rows[i];
                if (rowGroup.getIsAuto()) {
                    rowGroup.measureToFix++;
                }
            }
        }
        this.columns[measureSpec.getColumnIndex()].children.push(measureSpec);
        this.rows[measureSpec.getRowIndex()].children.push(measureSpec);
    }
    clearMeasureSpecs() {
        for (let i = 0, size = this.columns.length; i < size; i++) {
            this.columns[i].children.length = 0;
        }
        for (let i = 0, size = this.rows.length; i < size; i++) {
            this.rows[i].children.length = 0;
        }
    }
    static initList(list) {
        let density = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].getDisplayDensity();
        for (let i = 0, size = list.length; i < size; i++) {
            let item = list[i];
            item.init(density);
        }
    }
    init() {
        let rows = this.rows.length;
        if (rows === 0) {
            this.singleRowGroup.setIsLengthInfinity(this.infinityHeight);
            this.rows.push(this.singleRowGroup);
            this.fakeRowAdded = true;
        }
        else if (rows > 1 && this.fakeRowAdded) {
            this.rows.splice(0, 1);
            this.fakeRowAdded = false;
        }
        let cols = this.columns.length;
        if (cols === 0) {
            this.fakeColumnAdded = true;
            this.singleColumnGroup.setIsLengthInfinity(this.infinityWidth);
            this.columns.push(this.singleColumnGroup);
        }
        else if (cols > 1 && this.fakeColumnAdded) {
            this.columns.splice(0, 1);
            this.fakeColumnAdded = false;
        }
        MeasureHelper.initList(this.rows);
        MeasureHelper.initList(this.columns);
        this.minColumnStarValue = -1;
        this.minRowStarValue = -1;
        this.maxColumnStarValue = -1;
        this.maxRowStarValue = -1;
    }
    itemMeasured(measureSpec, isFakeMeasure) {
        if (!isFakeMeasure) {
            this.columns[measureSpec.getColumnIndex()].measuredCount++;
            this.rows[measureSpec.getRowIndex()].measuredCount++;
            measureSpec.measured = true;
        }
        if (measureSpec.autoColumnsCount > 0 && measureSpec.starColumnsCount === 0) {
            let size = measureSpec.getColumnIndex() + measureSpec.getColumnSpan();
            for (let i = measureSpec.getColumnIndex(); i < size; i++) {
                let columnGroup = this.columns[i];
                if (columnGroup.getIsAuto()) {
                    columnGroup.currentMeasureToFixCount++;
                }
            }
        }
        if (measureSpec.autoRowsCount > 0 && measureSpec.starRowsCount === 0) {
            let size = measureSpec.getRowIndex() + measureSpec.getRowSpan();
            for (let i = measureSpec.getRowIndex(); i < size; i++) {
                let rowGroup = this.rows[i];
                if (rowGroup.getIsAuto()) {
                    rowGroup.currentMeasureToFixCount++;
                }
            }
        }
    }
    fixColumns() {
        let currentColumnWidth = 0;
        let columnStarCount = 0;
        let columnCount = this.columns.length;
        for (let i = 0; i < columnCount; i++) {
            let item = this.columns[i];
            if (item.rowOrColumn.isStar) {
                columnStarCount += item.rowOrColumn.value;
            }
            else {
                // Star columns are still zeros (not calculated).
                currentColumnWidth += item.length;
            }
        }
        let widthForStarColumns = Math.max(0, this.width - currentColumnWidth);
        this.maxColumnStarValue = columnStarCount > 0 ? widthForStarColumns / columnStarCount : 0;
        MeasureHelper.updateStarLength(this.columns, this.maxColumnStarValue);
    }
    fixRows() {
        let currentRowHeight = 0;
        let rowStarCount = 0;
        let rowCount = this.rows.length;
        for (let i = 0; i < rowCount; i++) {
            let item = this.rows[i];
            if (item.rowOrColumn.isStar) {
                rowStarCount += item.rowOrColumn.value;
            }
            else {
                // Star rows are still zeros (not calculated).
                currentRowHeight += item.length;
            }
        }
        let heightForStarRows = Math.max(0, this.height - currentRowHeight);
        this.maxRowStarValue = rowStarCount > 0 ? heightForStarRows / rowStarCount : 0;
        MeasureHelper.updateStarLength(this.rows, this.maxRowStarValue);
    }
    static updateStarLength(list, starValue) {
        let offset = 0;
        let roundedOffset = 0;
        for (let i = 0, rowCount = list.length; i < rowCount; i++) {
            let item = list[i];
            if (item.getIsStar()) {
                offset += item.rowOrColumn.value * starValue;
                let actualLength = offset - roundedOffset;
                let roundedLength = Math.round(actualLength);
                item.length = roundedLength;
                roundedOffset += roundedLength;
            }
        }
    }
    fakeMeasure() {
        // Fake measure - measure all elements that have star rows and auto columns - with infinity Width and infinity Height
        for (let i = 0, size = this.columns.length; i < size; i++) {
            let columnGroup = this.columns[i];
            if (columnGroup.getAllMeasured()) {
                continue;
            }
            for (let j = 0, childrenCount = columnGroup.children.length; j < childrenCount; j++) {
                let measureSpec = columnGroup.children[j];
                if (measureSpec.starRowsCount > 0 && measureSpec.autoColumnsCount > 0 && measureSpec.starColumnsCount === 0) {
                    this.measureChild(measureSpec, true);
                }
            }
        }
    }
    measureFixedColumnsNoStarRows() {
        for (let i = 0, size = this.columns.length; i < size; i++) {
            let columnGroup = this.columns[i];
            for (let j = 0, childrenCount = columnGroup.children.length; j < childrenCount; j++) {
                let measureSpec = columnGroup.children[j];
                if (measureSpec.starColumnsCount > 0 && measureSpec.starRowsCount === 0) {
                    this.measureChildFixedColumns(measureSpec);
                }
            }
        }
    }
    measureNoStarColumnsFixedRows() {
        for (let i = 0, size = this.columns.length; i < size; i++) {
            let columnGroup = this.columns[i];
            for (let j = 0, childrenCount = columnGroup.children.length; j < childrenCount; j++) {
                let measureSpec = columnGroup.children[j];
                if (measureSpec.starRowsCount > 0 && measureSpec.starColumnsCount === 0) {
                    this.measureChildFixedRows(measureSpec);
                }
            }
        }
    }
    static canFix(list) {
        for (let i = 0, size = list.length; i < size; i++) {
            let item = list[i];
            if (!item.getCanBeFixed()) {
                return false;
            }
        }
        return true;
    }
    static getMeasureLength(list) {
        let result = 0;
        for (let i = 0, size = list.length; i < size; i++) {
            let item = list[i];
            result += item.length;
        }
        return result;
    }
    measure() {
        // Measure auto & pixel columns and rows (no spans).
        let size = this.columns.length;
        for (let i = 0; i < size; i++) {
            let columnGroup = this.columns[i];
            for (let j = 0, childrenCount = columnGroup.children.length; j < childrenCount; j++) {
                let measureSpec = columnGroup.children[j];
                if (measureSpec.getIsStar() || measureSpec.getSpanned()) {
                    continue;
                }
                this.measureChild(measureSpec, false);
            }
        }
        // Measure auto & pixel columns and rows (with spans).
        for (let i = 0; i < size; i++) {
            let columnGroup = this.columns[i];
            for (let j = 0, childrenCount = columnGroup.children.length; j < childrenCount; j++) {
                let measureSpec = columnGroup.children[j];
                if (measureSpec.getIsStar() || !measureSpec.getSpanned()) {
                    continue;
                }
                this.measureChild(measureSpec, false);
            }
        }
        // try fix stars!
        let fixColumns = MeasureHelper.canFix(this.columns);
        let fixRows = MeasureHelper.canFix(this.rows);
        if (fixColumns) {
            this.fixColumns();
        }
        if (fixRows) {
            this.fixRows();
        }
        if (!fixColumns && !fixRows) {
            // Fake measure - measure all elements that have star rows and auto columns - with infinity Width and infinity Height
            // should be able to fix rows after that
            this.fakeMeasure();
            this.fixColumns();
            // Measure all elements that have star columns(already fixed), but no stars at the rows
            this.measureFixedColumnsNoStarRows();
            this.fixRows();
        }
        else if (fixColumns && !fixRows) {
            // Measure all elements that have star columns(already fixed) but no stars at the rows
            this.measureFixedColumnsNoStarRows();
            // Then
            this.fixRows();
        }
        else if (!fixColumns && fixRows) {
            // Measure all elements that have star rows(already fixed) but no star at the columns
            this.measureNoStarColumnsFixedRows();
            // Then
            this.fixColumns();
        }
        // Rows and columns are fixed here - measure remaining elements
        size = this.columns.length;
        for (let i = 0; i < size; i++) {
            let columnGroup = this.columns[i];
            for (let j = 0, childCount = columnGroup.children.length; j < childCount; j++) {
                let measureSpec = columnGroup.children[j];
                if (!measureSpec.measured) {
                    this.measureChildFixedColumnsAndRows(measureSpec);
                }
            }
        }
        // If we are not stretched and minColumnStarValue is less than maxColumnStarValue
        // we need to reduce the width of star columns.
        if (!this.stretchedHorizontally && this.minColumnStarValue !== -1 && this.minColumnStarValue < this.maxColumnStarValue) {
            MeasureHelper.updateStarLength(this.columns, this.minColumnStarValue);
        }
        // If we are not stretched and minRowStarValue is less than maxRowStarValue
        // we need to reduce the height of star maxRowStarValue.
        if (!this.stretchedVertically && this.minRowStarValue !== -1 && this.minRowStarValue < this.maxRowStarValue) {
            MeasureHelper.updateStarLength(this.rows, this.minRowStarValue);
        }
        this.measuredWidth = MeasureHelper.getMeasureLength(this.columns);
        this.measuredHeight = MeasureHelper.getMeasureLength(this.rows);
    }
    measureChild(measureSpec, isFakeMeasure) {
        let widthMeasureSpec = measureSpec.autoColumnsCount > 0 ? this.infinity : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureSpec.pixelWidth, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        let heightMeasureSpec = isFakeMeasure || measureSpec.autoRowsCount > 0 ? this.infinity : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureSpec.pixelHeight, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        let childSize = _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].measureChild(this.grid, measureSpec.child, widthMeasureSpec, heightMeasureSpec);
        let childMeasuredWidth = childSize.measuredWidth;
        let childMeasuredHeight = childSize.measuredHeight;
        let columnSpanEnd = measureSpec.getColumnIndex() + measureSpec.getColumnSpan();
        let rowSpanEnd = measureSpec.getRowIndex() + measureSpec.getRowSpan();
        if (measureSpec.autoColumnsCount > 0) {
            let remainingSpace = childMeasuredWidth;
            for (let i = measureSpec.getColumnIndex(); i < columnSpanEnd; i++) {
                let columnGroup = this.columns[i];
                remainingSpace -= columnGroup.length;
            }
            if (remainingSpace > 0) {
                let growSize = remainingSpace / measureSpec.autoColumnsCount;
                for (let i = measureSpec.getColumnIndex(); i < columnSpanEnd; i++) {
                    let columnGroup = this.columns[i];
                    if (columnGroup.getIsAuto()) {
                        columnGroup.length += growSize;
                    }
                }
            }
        }
        if (!isFakeMeasure && measureSpec.autoRowsCount > 0) {
            let remainingSpace = childMeasuredHeight;
            for (let i = measureSpec.getRowIndex(); i < rowSpanEnd; i++) {
                let rowGroup = this.rows[i];
                remainingSpace -= rowGroup.length;
            }
            if (remainingSpace > 0) {
                let growSize = remainingSpace / measureSpec.autoRowsCount;
                for (let i = measureSpec.getRowIndex(); i < rowSpanEnd; i++) {
                    let rowGroup = this.rows[i];
                    if (rowGroup.getIsAuto()) {
                        rowGroup.length += growSize;
                    }
                }
            }
        }
        this.itemMeasured(measureSpec, isFakeMeasure);
    }
    measureChildFixedColumns(measureSpec) {
        let columnIndex = measureSpec.getColumnIndex();
        let columnSpanEnd = columnIndex + measureSpec.getColumnSpan();
        let rowIndex = measureSpec.getRowIndex();
        let rowSpanEnd = rowIndex + measureSpec.getRowSpan();
        let measureWidth = 0;
        let growSize = 0;
        for (let i = columnIndex; i < columnSpanEnd; i++) {
            let columnGroup = this.columns[i];
            measureWidth += columnGroup.length;
        }
        let widthMeasureSpec = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureWidth, this.stretchedHorizontally ? _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].AT_MOST);
        let heightMeasureSpec = measureSpec.autoRowsCount > 0 ? this.infinity : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureSpec.pixelHeight, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        let childSize = _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].measureChild(this.grid, measureSpec.child, widthMeasureSpec, heightMeasureSpec);
        let childMeasuredWidth = childSize.measuredWidth;
        let childMeasuredHeight = childSize.measuredHeight;
        this.updateMinColumnStarValueIfNeeded(measureSpec, childMeasuredWidth);
        // Distribute height over auto rows
        if (measureSpec.autoRowsCount > 0) {
            let remainingSpace = childMeasuredHeight;
            for (let i = rowIndex; i < rowSpanEnd; i++) {
                let rowGroup = this.rows[i];
                remainingSpace -= rowGroup.length;
            }
            if (remainingSpace > 0) {
                growSize = remainingSpace / measureSpec.autoRowsCount;
                for (let i = rowIndex; i < rowSpanEnd; i++) {
                    let rowGroup = this.rows[i];
                    if (rowGroup.getIsAuto()) {
                        rowGroup.length += growSize;
                    }
                }
            }
        }
        this.itemMeasured(measureSpec, false);
    }
    measureChildFixedRows(measureSpec) {
        let columnIndex = measureSpec.getColumnIndex();
        let columnSpanEnd = columnIndex + measureSpec.getColumnSpan();
        let rowIndex = measureSpec.getRowIndex();
        let rowSpanEnd = rowIndex + measureSpec.getRowSpan();
        let measureHeight = 0;
        for (let i = rowIndex; i < rowSpanEnd; i++) {
            let rowGroup = this.rows[i];
            measureHeight += rowGroup.length;
        }
        let widthMeasureSpec = measureSpec.autoColumnsCount > 0 ? this.infinity : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureSpec.pixelWidth, _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        let heightMeasureSpec = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureHeight, this.stretchedVertically ? _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].AT_MOST);
        let childSize = _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].measureChild(this.grid, measureSpec.child, widthMeasureSpec, heightMeasureSpec);
        let childMeasuredWidth = childSize.measuredWidth;
        let childMeasuredHeight = childSize.measuredHeight;
        let remainingSpace = 0;
        let growSize = 0;
        // Distribute width over auto columns
        if (measureSpec.autoColumnsCount > 0) {
            remainingSpace = childMeasuredWidth;
            for (let i = columnIndex; i < columnSpanEnd; i++) {
                let columnGroup = this.columns[i];
                remainingSpace -= columnGroup.length;
            }
            if (remainingSpace > 0) {
                growSize = remainingSpace / measureSpec.autoColumnsCount;
                for (let i = columnIndex; i < columnSpanEnd; i++) {
                    let columnGroup = this.columns[i];
                    if (columnGroup.getIsAuto()) {
                        columnGroup.length += growSize;
                    }
                }
            }
        }
        this.updateMinRowStarValueIfNeeded(measureSpec, childMeasuredHeight);
        this.itemMeasured(measureSpec, false);
    }
    measureChildFixedColumnsAndRows(measureSpec) {
        let columnIndex = measureSpec.getColumnIndex();
        let columnSpanEnd = columnIndex + measureSpec.getColumnSpan();
        let rowIndex = measureSpec.getRowIndex();
        let rowSpanEnd = rowIndex + measureSpec.getRowSpan();
        let measureWidth = 0;
        for (let i = columnIndex; i < columnSpanEnd; i++) {
            let columnGroup = this.columns[i];
            measureWidth += columnGroup.length;
        }
        let measureHeight = 0;
        for (let i = rowIndex; i < rowSpanEnd; i++) {
            let rowGroup = this.rows[i];
            measureHeight += rowGroup.length;
        }
        // if (have stars) & (not stretch) - at most
        let widthMeasureSpec = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureWidth, measureSpec.starColumnsCount > 0 && !this.stretchedHorizontally ? _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].AT_MOST : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        let heightMeasureSpec = _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].makeMeasureSpec(measureHeight, measureSpec.starRowsCount > 0 && !this.stretchedVertically ? _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].AT_MOST : _utils__WEBPACK_IMPORTED_MODULE_2__[/* layout */ "n"].EXACTLY);
        let childSize = _core_view__WEBPACK_IMPORTED_MODULE_1__[/* View */ "c"].measureChild(this.grid, measureSpec.child, widthMeasureSpec, heightMeasureSpec);
        let childMeasuredWidth = childSize.measuredWidth;
        let childMeasuredHeight = childSize.measuredHeight;
        this.updateMinColumnStarValueIfNeeded(measureSpec, childMeasuredWidth);
        this.updateMinRowStarValueIfNeeded(measureSpec, childMeasuredHeight);
        this.itemMeasured(measureSpec, false);
    }
    updateMinRowStarValueIfNeeded(measureSpec, childMeasuredHeight) {
        if (!this.stretchedVertically && measureSpec.starRowsCount > 0) {
            let remainingSpace = childMeasuredHeight;
            let rowIndex = measureSpec.getRowIndex();
            let rowSpanEnd = rowIndex + measureSpec.getRowSpan();
            for (let i = rowIndex; i < rowSpanEnd; i++) {
                let rowGroup = this.rows[i];
                if (!rowGroup.getIsStar()) {
                    remainingSpace -= rowGroup.length;
                }
            }
            if (remainingSpace > 0) {
                this.minRowStarValue = Math.max(remainingSpace / measureSpec.starRowsCount, this.minRowStarValue);
            }
        }
    }
    updateMinColumnStarValueIfNeeded(measureSpec, childMeasuredWidth) {
        // When not stretched star columns are not fixed so we may grow them here
        // if there is an element that spans on multiple columns
        if (!this.stretchedHorizontally && measureSpec.starColumnsCount > 0) {
            let remainingSpace = childMeasuredWidth;
            let columnIndex = measureSpec.getColumnIndex();
            let columnSpanEnd = columnIndex + measureSpec.getColumnSpan();
            for (let i = columnIndex; i < columnSpanEnd; i++) {
                let columnGroup = this.columns[i];
                if (!columnGroup.getIsStar()) {
                    remainingSpace -= columnGroup.length;
                }
            }
            if (remainingSpace > 0) {
                this.minColumnStarValue = Math.max(remainingSpace / measureSpec.starColumnsCount, this.minColumnStarValue);
            }
        }
    }
}
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _ui_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87);
// using import is important to ensure webpack keep it in order

// Register "dynamically" loaded module that need to be resolved by the
// XML/component builders.

global.registerModule('@nativescript/core/ui', () => _ui_index__WEBPACK_IMPORTED_MODULE_1__);
// global.registerModule('text/formatted-string', () => require('./text/formatted-string'));
// global.registerModule('text/span', () => require('./text/span'));
// global.registerModule('ui/text-base/formatted-string', () => require('./ui/text-base/formatted-string'));
// global.registerModule('ui/text-base/span', () => require('./ui/text-base/span'));
// global.registerModule('ui/action-bar', () => require('./ui/action-bar'));
// global.registerModule('ui/activity-indicator', () => require('./ui/activity-indicator'));
// global.registerModule('ui/bottom-navigation', () => require('./ui/bottom-navigation'));
// global.registerModule('ui/button', () => require('./ui/button'));
// global.registerModule('ui/content-view', () => require('./ui/content-view'));
// global.registerModule('ui/date-picker', () => require('./ui/date-picker'));
// global.registerModule('ui/frame', () => require('./ui/frame'));
// global.registerModule('ui/html-view', () => require('./ui/html-view'));
// global.registerModule('ui/image', () => require('./ui/image'));
// global.registerModule('ui/label', () => require('./ui/label'));
// global.registerModule('ui/layouts/absolute-layout', () => require('./ui/layouts/absolute-layout'));
// global.registerModule('ui/layouts/dock-layout', () => require('./ui/layouts/dock-layout'));
// global.registerModule('ui/layouts/grid-layout', () => require('./ui/layouts/grid-layout'));
// global.registerModule('ui/layouts/stack-layout', () => require('./ui/layouts/stack-layout'));
// global.registerModule('ui/layouts/flexbox-layout', () => require('./ui/layouts/flexbox-layout'));
// global.registerModule('ui/layouts/wrap-layout', () => require('./ui/layouts/wrap-layout'));
// global.registerModule('ui/list-picker', () => require('./ui/list-picker'));
// global.registerModule('ui/page', () => require('./ui/page'));
// global.registerModule('ui/placeholder', () => require('./ui/placeholder'));
// global.registerModule('ui/progress', () => require('./ui/progress'));
// global.registerModule('ui/proxy-view-container', () => require('./ui/proxy-view-container'));
// global.registerModule('ui/repeater', () => require('./ui/repeater'));
// global.registerModule('ui/scroll-view', () => require('./ui/scroll-view'));
// global.registerModule('ui/search-bar', () => require('./ui/search-bar'));
// global.registerModule('ui/segmented-bar', () => require('./ui/segmented-bar'));
// global.registerModule('ui/slider', () => require('./ui/slider'));
// global.registerModule('ui/switch', () => require('./ui/switch'));
// global.registerModule('ui/tab-view', () => require('./ui/tab-view'));
// global.registerModule('ui/tab-navigation-base/tab-strip', () => require('./ui/tab-navigation-base/tab-strip'));
// global.registerModule('ui/tab-navigation-base/tab-strip-item', () => require('./ui/tab-navigation-base/tab-strip-item'));
// global.registerModule('ui/tab-navigation-base/tab-content-item', () => require('./ui/tab-navigation-base/tab-content-item'));
// global.registerModule('ui/tabs', () => require('./ui/tabs'));
// global.registerModule('ui/web-view', () => require('./ui/web-view'));
// global.registerModule('ui/text-field', () => require('./ui/text-field'));
// global.registerModule('ui/text-view', () => require('./ui/text-view'));
// global.registerModule('ui/time-picker', () => require('./ui/time-picker'));
// global.registerModule('ui/list-view', () => require('./ui/list-view'));
//# sourceMappingURL=bundle-entry-points.js.map; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomainDispatcher", function() { return DomainDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeapDomain", function() { return HeapDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DebuggerDomain", function() { return DebuggerDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RuntimeDomain", function() { return RuntimeDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleDomain", function() { return ConsoleDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PageDomain", function() { return PageDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetworkDomain", function() { return NetworkDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMDomain", function() { return DOMDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSDomain", function() { return CSSDomain; });
function DomainDispatcher(domain) {
    return (klass) => __registerDomainDispatcher(domain, klass);
}
// Heap
// Heap domain exposes JavaScript heap attributes and capabilities.
var HeapDomain;
(function (HeapDomain) {
    class HeapFrontend {
        // Information about the garbage collection.
        garbageCollected(collection) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Heap.garbageCollected',
                params: { collection: collection },
            }));
        }
        // Tracking started.
        trackingStart(timestamp, snapshotData) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Heap.trackingStart',
                params: {
                    timestamp: timestamp,
                    snapshotData: snapshotData,
                },
            }));
        }
        // Tracking stopped.
        trackingComplete(timestamp, snapshotData) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Heap.trackingComplete',
                params: {
                    timestamp: timestamp,
                    snapshotData: snapshotData,
                },
            }));
        }
    }
    HeapDomain.HeapFrontend = HeapFrontend;
})(HeapDomain || (HeapDomain = {}));
// Debugger
// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.
var DebuggerDomain;
(function (DebuggerDomain) {
    class DebuggerFrontend {
        // Called when global has been cleared and debugger client should reset its state. Happens upon navigation or reload.
        globalObjectCleared() {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.globalObjectCleared',
                params: {},
            }));
        }
        // Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
        scriptParsed(scriptId, url, startLine, startColumn, endLine, endColumn, isContentScript, sourceURL, sourceMapURL) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.scriptParsed',
                params: {
                    scriptId: scriptId,
                    url: url,
                    startLine: startLine,
                    startColumn: startColumn,
                    endLine: endLine,
                    endColumn: endColumn,
                    isContentScript: isContentScript,
                    sourceURL: sourceURL,
                    sourceMapURL: sourceMapURL,
                },
            }));
        }
        // Fired when virtual machine fails to parse the script.
        scriptFailedToParse(url, scriptSource, startLine, errorLine, errorMessage) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.scriptFailedToParse',
                params: {
                    url: url,
                    scriptSource: scriptSource,
                    startLine: startLine,
                    errorLine: errorLine,
                    errorMessage: errorMessage,
                },
            }));
        }
        // Fired when breakpoint is resolved to an actual script and location.
        breakpointResolved(breakpointId, location) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.breakpointResolved',
                params: { breakpointId: breakpointId, location: location },
            }));
        }
        // Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
        paused(callFrames, reason /* XHR,DOM,EventListener,exception,assert,CSPViolation,DebuggerStatement,Breakpoint,PauseOnNextStatement,other */, data) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.paused',
                params: {
                    callFrames: callFrames,
                    reason: reason,
                    data: data,
                },
            }));
        }
        // Fired when the virtual machine resumed execution.
        resumed() {
            __inspectorSendEvent(JSON.stringify({ method: 'Debugger.resumed', params: {} }));
        }
        // Fires when a new probe sample is collected.
        didSampleProbe(sample) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.didSampleProbe',
                params: { sample: sample },
            }));
        }
        // Fired when a "sound" breakpoint action is triggered on a breakpoint.
        playBreakpointActionSound(breakpointActionId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Debugger.playBreakpointActionSound',
                params: { breakpointActionId: breakpointActionId },
            }));
        }
    }
    DebuggerDomain.DebuggerFrontend = DebuggerFrontend;
})(DebuggerDomain || (DebuggerDomain = {}));
// Runtime
// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.
var RuntimeDomain;
(function (RuntimeDomain) {
    class RuntimeFrontend {
        // Issued when new execution context is created.
        executionContextCreated(context) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Runtime.executionContextCreated',
                params: { context: context },
            }));
        }
    }
    RuntimeDomain.RuntimeFrontend = RuntimeFrontend;
})(RuntimeDomain || (RuntimeDomain = {}));
// Console
// Console domain defines methods and events for interaction with the JavaScript console. Console collects messages created by means of the <a href='http://getfirebug.com/wiki/index.php/Console_API'>JavaScript Console API</a>. One needs to enable this domain using <code>enable</code> command in order to start receiving the console messages. Browser collects messages issued while console domain is not enabled as well and reports them using <code>messageAdded</code> notification upon enabling.
var ConsoleDomain;
(function (ConsoleDomain) {
    class ConsoleFrontend {
        // Issued when new console message is added.
        messageAdded(message) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Console.messageAdded',
                params: { message: message },
            }));
        }
        // Issued when subsequent message(s) are equal to the previous one(s).
        messageRepeatCountUpdated(count) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Console.messageRepeatCountUpdated',
                params: { count: count },
            }));
        }
        // Issued when console is cleared. This happens either upon <code>clearMessages</code> command or after page navigation.
        messagesCleared() {
            __inspectorSendEvent(JSON.stringify({
                method: 'Console.messagesCleared',
                params: {},
            }));
        }
        // Issued from console.takeHeapSnapshot.
        heapSnapshot(timestamp, snapshotData, title) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Console.heapSnapshot',
                params: {
                    timestamp: timestamp,
                    snapshotData: snapshotData,
                    title: title,
                },
            }));
        }
    }
    ConsoleDomain.ConsoleFrontend = ConsoleFrontend;
})(ConsoleDomain || (ConsoleDomain = {}));
// Page
// Actions and events related to the inspected page belong to the page domain.
var PageDomain;
(function (PageDomain) {
    class PageFrontend {
        domContentEventFired(timestamp) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.domContentEventFired',
                params: { timestamp: timestamp },
            }));
        }
        loadEventFired(timestamp) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.loadEventFired',
                params: { timestamp: timestamp },
            }));
        }
        // Fired once navigation of the frame has completed. Frame is now associated with the new loader.
        frameNavigated(frame) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.frameNavigated',
                params: { frame: frame },
            }));
        }
        // Fired when frame has been detached from its parent.
        frameDetached(frameId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.frameDetached',
                params: { frameId: frameId },
            }));
        }
        // Fired when frame has started loading.
        frameStartedLoading(frameId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.frameStartedLoading',
                params: { frameId: frameId },
            }));
        }
        // Fired when frame has stopped loading.
        frameStoppedLoading(frameId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.frameStoppedLoading',
                params: { frameId: frameId },
            }));
        }
        // Fired when frame schedules a potential navigation.
        frameScheduledNavigation(frameId, delay) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.frameScheduledNavigation',
                params: { frameId: frameId, delay: delay },
            }));
        }
        // Fired when frame no longer has a scheduled navigation.
        frameClearedScheduledNavigation(frameId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.frameClearedScheduledNavigation',
                params: { frameId: frameId },
            }));
        }
        // Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.
        javascriptDialogOpening(message) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.javascriptDialogOpening',
                params: { message: message },
            }));
        }
        // Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.
        javascriptDialogClosed() {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.javascriptDialogClosed',
                params: {},
            }));
        }
        // Fired when the JavaScript is enabled/disabled on the page
        scriptsEnabled(isEnabled) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Page.scriptsEnabled',
                params: { isEnabled: isEnabled },
            }));
        }
    }
    PageDomain.PageFrontend = PageFrontend;
})(PageDomain || (PageDomain = {}));
// Network
// Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.
var NetworkDomain;
(function (NetworkDomain) {
    class NetworkFrontend {
        // Fired when page is about to send HTTP request.
        requestWillBeSent(requestId, frameId, loaderId, documentURL, request, timestamp, initiator, redirectResponse, type) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.requestWillBeSent',
                params: {
                    requestId: requestId,
                    frameId: frameId,
                    loaderId: loaderId,
                    documentURL: documentURL,
                    request: request,
                    timestamp: timestamp,
                    initiator: initiator,
                    redirectResponse: redirectResponse,
                    type: type,
                },
            }));
        }
        // Fired if request ended up loading from cache.
        requestServedFromCache(requestId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.requestServedFromCache',
                params: { requestId: requestId },
            }));
        }
        // Fired when HTTP response is available.
        responseReceived(requestId, frameId, loaderId, timestamp, type, response) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.responseReceived',
                params: {
                    requestId: requestId,
                    frameId: frameId,
                    loaderId: loaderId,
                    timestamp: timestamp,
                    type: type,
                    response: response,
                },
            }));
        }
        // Fired when data chunk was received over the network.
        dataReceived(requestId, timestamp, dataLength, encodedDataLength) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.dataReceived',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    dataLength: dataLength,
                    encodedDataLength: encodedDataLength,
                },
            }));
        }
        // Fired when HTTP request has finished loading.
        loadingFinished(requestId, timestamp, sourceMapURL) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.loadingFinished',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    sourceMapURL: sourceMapURL,
                },
            }));
        }
        // Fired when HTTP request has failed to load.
        loadingFailed(requestId, timestamp, errorText, canceled) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.loadingFailed',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    errorText: errorText,
                    canceled: canceled,
                },
            }));
        }
        // Fired when HTTP request has been served from memory cache.
        requestServedFromMemoryCache(requestId, frameId, loaderId, documentURL, timestamp, initiator, resource) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.requestServedFromMemoryCache',
                params: {
                    requestId: requestId,
                    frameId: frameId,
                    loaderId: loaderId,
                    documentURL: documentURL,
                    timestamp: timestamp,
                    initiator: initiator,
                    resource: resource,
                },
            }));
        }
        // Fired when WebSocket is about to initiate handshake.
        webSocketWillSendHandshakeRequest(requestId, timestamp, request) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketWillSendHandshakeRequest',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    request: request,
                },
            }));
        }
        // Fired when WebSocket handshake response becomes available.
        webSocketHandshakeResponseReceived(requestId, timestamp, response) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketHandshakeResponseReceived',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    response: response,
                },
            }));
        }
        // Fired upon WebSocket creation.
        webSocketCreated(requestId, url) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketCreated',
                params: { requestId: requestId, url: url },
            }));
        }
        // Fired when WebSocket is closed.
        webSocketClosed(requestId, timestamp) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketClosed',
                params: { requestId: requestId, timestamp: timestamp },
            }));
        }
        // Fired when WebSocket frame is received.
        webSocketFrameReceived(requestId, timestamp, response) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketFrameReceived',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    response: response,
                },
            }));
        }
        // Fired when WebSocket frame error occurs.
        webSocketFrameError(requestId, timestamp, errorMessage) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketFrameError',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    errorMessage: errorMessage,
                },
            }));
        }
        // Fired when WebSocket frame is sent.
        webSocketFrameSent(requestId, timestamp, response) {
            __inspectorSendEvent(JSON.stringify({
                method: 'Network.webSocketFrameSent',
                params: {
                    requestId: requestId,
                    timestamp: timestamp,
                    response: response,
                },
            }));
        }
    }
    NetworkDomain.NetworkFrontend = NetworkFrontend;
})(NetworkDomain || (NetworkDomain = {}));
// DOM
// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.
var DOMDomain;
(function (DOMDomain) {
    class DOMFrontend {
        // Fired when <code>Document</code> has been totally updated. Node ids are no longer valid.
        documentUpdated() {
            __inspectorSendEvent(JSON.stringify({ method: 'DOM.documentUpdated', params: {} }));
        }
        // Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.
        setChildNodes(parentId, nodes) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.setChildNodes',
                params: { parentId: parentId, nodes: nodes },
            }));
        }
        // Fired when <code>Element</code>'s attribute is modified.
        attributeModified(nodeId, name, value) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.attributeModified',
                params: { nodeId: nodeId, name: name, value: value },
            }));
        }
        // Fired when <code>Element</code>'s attribute is removed.
        attributeRemoved(nodeId, name) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.attributeRemoved',
                params: { nodeId: nodeId, name: name },
            }));
        }
        // Fired when <code>Element</code>'s inline style is modified via a CSS property modification.
        inlineStyleInvalidated(nodeIds) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.inlineStyleInvalidated',
                params: { nodeIds: nodeIds },
            }));
        }
        // Mirrors <code>DOMCharacterDataModified</code> event.
        characterDataModified(nodeId, characterData) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.characterDataModified',
                params: { nodeId: nodeId, characterData: characterData },
            }));
        }
        // Fired when <code>Container</code>'s child node count has changed.
        childNodeCountUpdated(nodeId, childNodeCount) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.childNodeCountUpdated',
                params: { nodeId: nodeId, childNodeCount: childNodeCount },
            }));
        }
        // Mirrors <code>DOMNodeInserted</code> event.
        childNodeInserted(parentNodeId, previousNodeId, node) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.childNodeInserted',
                params: {
                    parentNodeId: parentNodeId,
                    previousNodeId: previousNodeId,
                    node: node,
                },
            }));
        }
        // Mirrors <code>DOMNodeRemoved</code> event.
        childNodeRemoved(parentNodeId, nodeId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.childNodeRemoved',
                params: { parentNodeId: parentNodeId, nodeId: nodeId },
            }));
        }
        // Called when shadow root is pushed into the element.
        shadowRootPushed(hostId, root) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.shadowRootPushed',
                params: { hostId: hostId, root: root },
            }));
        }
        // Called when shadow root is popped from the element.
        shadowRootPopped(hostId, rootId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.shadowRootPopped',
                params: { hostId: hostId, rootId: rootId },
            }));
        }
        // Called when a pseudo element is added to an element.
        pseudoElementAdded(parentId, pseudoElement) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.pseudoElementAdded',
                params: {
                    parentId: parentId,
                    pseudoElement: pseudoElement,
                },
            }));
        }
        // Called when a pseudo element is removed from an element.
        pseudoElementRemoved(parentId, pseudoElementId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'DOM.pseudoElementRemoved',
                params: {
                    parentId: parentId,
                    pseudoElementId: pseudoElementId,
                },
            }));
        }
    }
    DOMDomain.DOMFrontend = DOMFrontend;
})(DOMDomain || (DOMDomain = {}));
// CSS
// This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles) have an associated 'id' used in subsequent operations on the related object. Each object type has a specific 'id' structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). A client can also discover all the existing stylesheets with the <code>getAllStyleSheets()</code> method (or keeping track of the <code>styleSheetAdded</code>/<code>styleSheetRemoved</code> events) and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods.
var CSSDomain;
(function (CSSDomain) {
    class CSSFrontend {
        // Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features.
        mediaQueryResultChanged() {
            __inspectorSendEvent(JSON.stringify({
                method: 'CSS.mediaQueryResultChanged',
                params: {},
            }));
        }
        // Fires whenever a web font gets loaded.
        fontsUpdated() {
            __inspectorSendEvent(JSON.stringify({ method: 'CSS.fontsUpdated', params: {} }));
        }
        // Fired whenever a stylesheet is changed as a result of the client operation.
        styleSheetChanged(styleSheetId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'CSS.styleSheetChanged',
                params: { styleSheetId: styleSheetId },
            }));
        }
        // Fired whenever an active document stylesheet is added.
        styleSheetAdded(header) {
            __inspectorSendEvent(JSON.stringify({
                method: 'CSS.styleSheetAdded',
                params: { header: header },
            }));
        }
        // Fired whenever an active document stylesheet is removed.
        styleSheetRemoved(styleSheetId) {
            __inspectorSendEvent(JSON.stringify({
                method: 'CSS.styleSheetRemoved',
                params: { styleSheetId: styleSheetId },
            }));
        }
        layoutEditorChange(styleSheetId, changeRange) {
            __inspectorSendEvent(JSON.stringify({
                method: 'CSS.layoutEditorChange',
                params: {
                    styleSheetId: styleSheetId,
                    changeRange: changeRange,
                },
            }));
        }
    }
    CSSDomain.CSSFrontend = CSSFrontend;
})(CSSDomain || (CSSDomain = {}));
//# sourceMappingURL=InspectorBackendCommands.ios.js.map; 
if (false ) {} 

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "ButtonBase", function() { return /* reexport */ button_common_ButtonBase; });
__webpack_require__.d(__webpack_exports__, "Button", function() { return /* binding */ button_Button; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/control-state-change/index.js
var control_state_change = __webpack_require__(86);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/index.js
var text_base = __webpack_require__(34);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-common.js
var view_common = __webpack_require__(31);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view-base/index.js
var view_base = __webpack_require__(15);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/button/button-common.js



let button_common_ButtonBase = class ButtonBase extends text_base["a" /* TextBase */] {
    get textWrap() {
        return this.style.whiteSpace === 'normal';
    }
    set textWrap(value) {
        if (typeof value === 'string') {
            value = Object(view_base["booleanConverter"])(value);
        }
        this.style.whiteSpace = value ? 'normal' : 'nowrap';
    }
};
button_common_ButtonBase.tapEvent = 'tap';
button_common_ButtonBase = __decorate([
    Object(view_common["a" /* CSSType */])('Button')
], button_common_ButtonBase);

button_common_ButtonBase.prototype.recycleNativeView = 'auto';
//# sourceMappingURL=button-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/index.js
var view = __webpack_require__(3);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style-properties.js + 2 modules
var style_properties = __webpack_require__(2);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/text-base-common.js
var text_base_common = __webpack_require__(35);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/button/index.js







class button_Button extends button_common_ButtonBase {
    createNativeView() {
        return UIButton.buttonWithType(1 /* System */);
    }
    initNativeView() {
        super.initNativeView();
        const nativeView = this.nativeViewProtected;
        this._tapHandler = button_TapHandlerImpl.initWithOwner(new WeakRef(this));
        nativeView.addTargetActionForControlEvents(this._tapHandler, 'tap', 64 /* TouchUpInside */);
    }
    disposeNativeView() {
        this._tapHandler = null;
        super.disposeNativeView();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    onUnloaded() {
        super.onUnloaded();
        if (this._stateChangedHandler) {
            this._stateChangedHandler.stop();
        }
    }
    _updateButtonStateChangeHandler(subscribe) {
        if (subscribe) {
            if (!this._stateChangedHandler) {
                this._stateChangedHandler = new control_state_change["a" /* ControlStateChangeListener */](this.nativeViewProtected, (s) => {
                    this._goToVisualState(s);
                });
            }
            this._stateChangedHandler.start();
        }
        else {
            this._stateChangedHandler.stop();
        }
    }
    [style_properties["borderTopWidthProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.top,
            unit: 'px',
        };
    }
    [style_properties["borderTopWidthProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let top = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingTop + this.effectiveBorderTopWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: top,
            left: inset.left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [style_properties["borderRightWidthProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.right,
            unit: 'px',
        };
    }
    [style_properties["borderRightWidthProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let right = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingRight + this.effectiveBorderRightWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: inset.top,
            left: inset.left,
            bottom: inset.bottom,
            right: right,
        };
    }
    [style_properties["borderBottomWidthProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.bottom,
            unit: 'px',
        };
    }
    [style_properties["borderBottomWidthProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let bottom = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingBottom + this.effectiveBorderBottomWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: inset.top,
            left: inset.left,
            bottom: bottom,
            right: inset.right,
        };
    }
    [style_properties["borderLeftWidthProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.left,
            unit: 'px',
        };
    }
    [style_properties["borderLeftWidthProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let left = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingLeft + this.effectiveBorderLeftWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: inset.top,
            left: left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [style_properties["paddingTopProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.top,
            unit: 'px',
        };
    }
    [style_properties["paddingTopProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let top = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingTop + this.effectiveBorderTopWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: top,
            left: inset.left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [style_properties["paddingRightProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.right,
            unit: 'px',
        };
    }
    [style_properties["paddingRightProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let right = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingRight + this.effectiveBorderRightWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: inset.top,
            left: inset.left,
            bottom: inset.bottom,
            right: right,
        };
    }
    [style_properties["paddingBottomProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.bottom,
            unit: 'px',
        };
    }
    [style_properties["paddingBottomProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let bottom = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingBottom + this.effectiveBorderBottomWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: inset.top,
            left: inset.left,
            bottom: bottom,
            right: inset.right,
        };
    }
    [style_properties["paddingLeftProperty"].getDefault]() {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.left,
            unit: 'px',
        };
    }
    [style_properties["paddingLeftProperty"].setNative](value) {
        let inset = this.nativeViewProtected.contentEdgeInsets;
        let left = utils_common["n" /* layout */].toDeviceIndependentPixels(this.effectivePaddingLeft + this.effectiveBorderLeftWidth);
        this.nativeViewProtected.contentEdgeInsets = {
            top: inset.top,
            left: left,
            bottom: inset.bottom,
            right: inset.right,
        };
    }
    [text_base_common["g" /* textAlignmentProperty */].setNative](value) {
        switch (value) {
            case 'left':
                this.nativeViewProtected.titleLabel.textAlignment = 0 /* Left */;
                this.nativeViewProtected.contentHorizontalAlignment = 1 /* Left */;
                break;
            case 'initial':
            case 'center':
                this.nativeViewProtected.titleLabel.textAlignment = 1 /* Center */;
                this.nativeViewProtected.contentHorizontalAlignment = 0 /* Center */;
                break;
            case 'right':
                this.nativeViewProtected.titleLabel.textAlignment = 2 /* Right */;
                this.nativeViewProtected.contentHorizontalAlignment = 2 /* Right */;
                break;
        }
    }
    [text_base_common["k" /* whiteSpaceProperty */].setNative](value) {
        const nativeView = this.nativeViewProtected.titleLabel;
        switch (value) {
            case 'normal':
                nativeView.lineBreakMode = 0 /* ByWordWrapping */;
                nativeView.numberOfLines = 0;
                break;
            case 'nowrap':
            case 'initial':
                nativeView.lineBreakMode = 5 /* ByTruncatingMiddle */;
                nativeView.numberOfLines = 1;
                break;
        }
    }
    onMeasure(widthMeasureSpec, heightMeasureSpec) {
        // If there is text-wrap UIButton.sizeThatFits will return wrong result (not respecting the text wrap).
        // So fallback to original onMeasure if there is no text-wrap and use custom measure otherwise.
        if (!this.textWrap) {
            return super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        }
        let nativeView = this.nativeViewProtected;
        if (nativeView) {
            const width = utils_common["n" /* layout */].getMeasureSpecSize(widthMeasureSpec);
            const widthMode = utils_common["n" /* layout */].getMeasureSpecMode(widthMeasureSpec);
            const height = utils_common["n" /* layout */].getMeasureSpecSize(heightMeasureSpec);
            const heightMode = utils_common["n" /* layout */].getMeasureSpecMode(heightMeasureSpec);
            const horizontalPadding = this.effectivePaddingLeft + this.effectiveBorderLeftWidth + this.effectivePaddingRight + this.effectiveBorderRightWidth;
            let verticalPadding = this.effectivePaddingTop + this.effectiveBorderTopWidth + this.effectivePaddingBottom + this.effectiveBorderBottomWidth;
            // The default button padding for UIButton - 6dip top and bottom.
            if (verticalPadding === 0) {
                verticalPadding = utils_common["n" /* layout */].toDevicePixels(12);
            }
            const desiredSize = utils_common["n" /* layout */].measureNativeView(nativeView.titleLabel, width - horizontalPadding, widthMode, height - verticalPadding, heightMode);
            desiredSize.width = desiredSize.width + horizontalPadding;
            desiredSize.height = desiredSize.height + verticalPadding;
            const measureWidth = Math.max(desiredSize.width, this.effectiveMinWidth);
            const measureHeight = Math.max(desiredSize.height, this.effectiveMinHeight);
            const widthAndState = view["c" /* View */].resolveSizeAndState(measureWidth, width, widthMode, 0);
            const heightAndState = view["c" /* View */].resolveSizeAndState(measureHeight, height, heightMode, 0);
            this.setMeasuredDimension(widthAndState, heightAndState);
        }
    }
}
__decorate([
    Object(view_common["b" /* PseudoClassHandler */])('normal', 'highlighted', 'pressed', 'active'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], button_Button.prototype, "_updateButtonStateChangeHandler", null);
var button_TapHandlerImpl = /** @class */ (function (_super) {
    __extends(TapHandlerImpl, _super);
    function TapHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TapHandlerImpl.initWithOwner = function (owner) {
        var handler = TapHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    TapHandlerImpl.prototype.tap = function (args) {
        // _owner is a {N} view which could get destroyed when a tap initiates (protect!)
        if (this._owner) {
            var owner = this._owner.get();
            if (owner) {
                owner._emit(button_common_ButtonBase.tapEvent);
            }
        }
    };
    TapHandlerImpl.ObjCExposedMethods = {
        tap: { returns: interop.types.void, params: [interop.types.id] },
    };
    return TapHandlerImpl;
}(NSObject));
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "TextFieldBase", function() { return /* reexport */ text_field_common_TextFieldBase; });
__webpack_require__.d(__webpack_exports__, "secureProperty", function() { return /* reexport */ secureProperty; });
__webpack_require__.d(__webpack_exports__, "closeOnReturnProperty", function() { return /* reexport */ closeOnReturnProperty; });
__webpack_require__.d(__webpack_exports__, "TextField", function() { return /* binding */ text_field_TextField; });

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/editable-text-base/index.js
var editable_text_base = __webpack_require__(51);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/properties/index.js
var properties = __webpack_require__(1);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view/view-common.js
var view_common = __webpack_require__(31);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/core/view-base/index.js
var view_base = __webpack_require__(15);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/text-field/text-field-common.js




let text_field_common_TextFieldBase = class TextFieldBase extends editable_text_base["a" /* EditableTextBase */] {
};
text_field_common_TextFieldBase.returnPressEvent = 'returnPress';
text_field_common_TextFieldBase = __decorate([
    Object(view_common["a" /* CSSType */])('TextField')
], text_field_common_TextFieldBase);

text_field_common_TextFieldBase.prototype.recycleNativeView = 'auto';
const secureProperty = new properties["Property"]({
    name: 'secure',
    defaultValue: false,
    valueConverter: view_base["booleanConverter"],
});
secureProperty.register(text_field_common_TextFieldBase);
const closeOnReturnProperty = new properties["Property"]({
    name: 'closeOnReturn',
    defaultValue: true,
    valueConverter: view_base["booleanConverter"],
});
closeOnReturnProperty.register(text_field_common_TextFieldBase);
//# sourceMappingURL=text-field-common.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/text-base/text-base-common.js
var text_base_common = __webpack_require__(35);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/editable-text-base/editable-text-base-common.js
var editable_text_base_common = __webpack_require__(48);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/color/index.js + 2 modules
var core_color = __webpack_require__(6);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/ui/styling/style-properties.js + 2 modules
var style_properties = __webpack_require__(2);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/utils/utils-common.js + 2 modules
var utils_common = __webpack_require__(4);

// EXTERNAL MODULE: ../node_modules/@nativescript/core/profiling/index.js
var profiling = __webpack_require__(9);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/ui/text-field/index.js








const zeroLength = {
    value: 0,
    unit: 'px',
};
var UITextFieldDelegateImpl = /** @class */ (function (_super) {
    __extends(UITextFieldDelegateImpl, _super);
    function UITextFieldDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITextFieldDelegateImpl.initWithOwner = function (owner) {
        var delegate = UITextFieldDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldBeginEditing = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            return owner.textFieldShouldBeginEditing(textField);
        }
        return true;
    };
    UITextFieldDelegateImpl.prototype.textFieldDidBeginEditing = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            owner.textFieldDidBeginEditing(textField);
        }
    };
    UITextFieldDelegateImpl.prototype.textFieldDidEndEditing = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            owner.textFieldDidEndEditing(textField);
        }
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldClear = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            return owner.textFieldShouldClear(textField);
        }
        return true;
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldReturn = function (textField) {
        // Called when the user presses the return button.
        var owner = this._owner.get();
        if (owner) {
            return owner.textFieldShouldReturn(textField);
        }
        return true;
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldChangeCharactersInRangeReplacementString = function (textField, range, replacementString) {
        var owner = this._owner.get();
        if (owner) {
            return owner.textFieldShouldChangeCharactersInRangeReplacementString(textField, range, replacementString);
        }
        return true;
    };
    UITextFieldDelegateImpl.ObjCProtocols = [UITextFieldDelegate];
    return UITextFieldDelegateImpl;
}(NSObject));
var text_field_UITextFieldImpl = /** @class */ (function (_super) {
    __extends(UITextFieldImpl, _super);
    function UITextFieldImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITextFieldImpl.initWithOwner = function (owner) {
        var handler = UITextFieldImpl.new();
        handler._owner = owner;
        return handler;
    };
    UITextFieldImpl.prototype._getTextRectForBounds = function (bounds) {
        var owner = this._owner ? this._owner.get() : null;
        if (!owner) {
            return bounds;
        }
        var size = bounds.size;
        var x = utils_common["n" /* layout */].toDeviceIndependentPixels(owner.effectiveBorderLeftWidth + owner.effectivePaddingLeft);
        var y = utils_common["n" /* layout */].toDeviceIndependentPixels(owner.effectiveBorderTopWidth + owner.effectivePaddingTop);
        var width = utils_common["n" /* layout */].toDeviceIndependentPixels(utils_common["n" /* layout */].toDevicePixels(size.width) - (owner.effectiveBorderLeftWidth + owner.effectivePaddingLeft + owner.effectivePaddingRight + owner.effectiveBorderRightWidth));
        var height = utils_common["n" /* layout */].toDeviceIndependentPixels(utils_common["n" /* layout */].toDevicePixels(size.height) - (owner.effectiveBorderTopWidth + owner.effectivePaddingTop + owner.effectivePaddingBottom + owner.effectiveBorderBottomWidth));
        return CGRectMake(x, y, width, height);
    };
    UITextFieldImpl.prototype.textRectForBounds = function (bounds) {
        return this._getTextRectForBounds(bounds);
    };
    UITextFieldImpl.prototype.editingRectForBounds = function (bounds) {
        return this._getTextRectForBounds(bounds);
    };
    return UITextFieldImpl;
}(UITextField));
class text_field_TextField extends text_field_common_TextFieldBase {
    createNativeView() {
        return text_field_UITextFieldImpl.initWithOwner(new WeakRef(this));
    }
    initNativeView() {
        super.initNativeView();
        this._delegate = UITextFieldDelegateImpl.initWithOwner(new WeakRef(this));
    }
    disposeNativeView() {
        this._delegate = null;
        super.disposeNativeView();
    }
    onLoaded() {
        super.onLoaded();
        this.ios.delegate = this._delegate;
    }
    onUnloaded() {
        this.ios.delegate = null;
        super.onUnloaded();
    }
    // @ts-ignore
    get ios() {
        return this.nativeViewProtected;
    }
    textFieldShouldBeginEditing(textField) {
        this.firstEdit = true;
        return this.editable;
    }
    textFieldDidBeginEditing(textField) {
        this.notify({ eventName: text_field_TextField.focusEvent, object: this });
    }
    textFieldDidEndEditing(textField) {
        if (this.updateTextTrigger === 'focusLost') {
            text_base_common["i" /* textProperty */].nativeValueChange(this, textField.text);
        }
        this.dismissSoftInput();
    }
    textFieldShouldClear(textField) {
        this.firstEdit = false;
        text_base_common["i" /* textProperty */].nativeValueChange(this, '');
        return true;
    }
    textFieldShouldReturn(textField) {
        // Called when the user presses the return button.
        if (this.closeOnReturn) {
            this.dismissSoftInput();
        }
        this.notify({ eventName: text_field_TextField.returnPressEvent, object: this });
        return true;
    }
    textFieldShouldChangeCharactersInRangeReplacementString(textField, range, replacementString) {
        if (this.secureWithoutAutofill && !textField.secureTextEntry) {
            /**
             * Helps avoid iOS 12+ autofill strong password suggestion prompt
             * Discussed in several circles but for example:
             * https://github.com/expo/expo/issues/2571#issuecomment-473347380
             */
            textField.secureTextEntry = true;
        }
        const delta = replacementString.length - range.length;
        if (delta > 0) {
            if (textField.text.length + delta > this.maxLength) {
                return false;
            }
        }
        if (this.updateTextTrigger === 'textChanged') {
            if (textField.secureTextEntry && this.firstEdit) {
                text_base_common["i" /* textProperty */].nativeValueChange(this, replacementString);
            }
            else {
                if (range.location <= textField.text.length) {
                    const newText = NSString.stringWithString(textField.text).stringByReplacingCharactersInRangeWithString(range, replacementString);
                    text_base_common["i" /* textProperty */].nativeValueChange(this, newText);
                }
            }
        }
        if (this.formattedText) {
            Object(editable_text_base["b" /* _updateCharactersInRangeReplacementString */])(this.formattedText, range.location, range.length, replacementString);
        }
        this.firstEdit = false;
        return true;
    }
    [editable_text_base_common["e" /* hintProperty */].getDefault]() {
        return this.nativeTextViewProtected.placeholder;
    }
    [editable_text_base_common["e" /* hintProperty */].setNative](value) {
        this._updateAttributedPlaceholder();
    }
    [secureProperty.getDefault]() {
        return this.nativeTextViewProtected.secureTextEntry;
    }
    [secureProperty.setNative](value) {
        this.nativeTextViewProtected.secureTextEntry = value;
    }
    [style_properties["colorProperty"].getDefault]() {
        return {
            textColor: this.nativeTextViewProtected.textColor,
            tintColor: this.nativeTextViewProtected.tintColor,
        };
    }
    [style_properties["colorProperty"].setNative](value) {
        if (value instanceof core_color["a" /* Color */]) {
            let color = value instanceof core_color["a" /* Color */] ? value.ios : value;
            this.nativeTextViewProtected.textColor = color;
            this.nativeTextViewProtected.tintColor = color;
        }
        else {
            this.nativeTextViewProtected.textColor = value.textColor;
            this.nativeTextViewProtected.tintColor = value.tintColor;
        }
    }
    [editable_text_base_common["h" /* placeholderColorProperty */].getDefault]() {
        return null;
    }
    [editable_text_base_common["h" /* placeholderColorProperty */].setNative](value) {
        this._updateAttributedPlaceholder();
    }
    _updateAttributedPlaceholder() {
        let stringValue = this.hint;
        if (stringValue === null || stringValue === void 0) {
            stringValue = '';
        }
        else {
            stringValue = stringValue + '';
        }
        if (stringValue === '') {
            // we do not use empty string since initWithStringAttributes does not return proper value and
            // nativeView.attributedPlaceholder will be null
            stringValue = ' ';
        }
        const attributes = {};
        if (this.style.placeholderColor) {
            attributes[NSForegroundColorAttributeName] = this.style.placeholderColor.ios;
        }
        const attributedPlaceholder = NSAttributedString.alloc().initWithStringAttributes(stringValue, attributes);
        this.nativeTextViewProtected.attributedPlaceholder = attributedPlaceholder;
    }
    [style_properties["paddingTopProperty"].getDefault]() {
        return zeroLength;
    }
    [style_properties["paddingTopProperty"].setNative](value) {
        // Padding is realized via UITextFieldImpl.textRectForBounds method
    }
    [style_properties["paddingRightProperty"].getDefault]() {
        return zeroLength;
    }
    [style_properties["paddingRightProperty"].setNative](value) {
        // Padding is realized via UITextFieldImpl.textRectForBounds method
    }
    [style_properties["paddingBottomProperty"].getDefault]() {
        return zeroLength;
    }
    [style_properties["paddingBottomProperty"].setNative](value) {
        // Padding is realized via UITextFieldImpl.textRectForBounds method
    }
    [style_properties["paddingLeftProperty"].getDefault]() {
        return zeroLength;
    }
    [style_properties["paddingLeftProperty"].setNative](value) {
        // Padding is realized via UITextFieldImpl.textRectForBounds method
    }
}
__decorate([
    profiling["f" /* profile */],
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], text_field_TextField.prototype, "onLoaded", null);
//# sourceMappingURL=index.ios.js.map; 
if (false ) {} 

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Background; });
/* harmony import */ var _linear_gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);

// Types.

class Background {
    constructor() {
        this.borderTopWidth = 0;
        this.borderRightWidth = 0;
        this.borderBottomWidth = 0;
        this.borderLeftWidth = 0;
        this.borderTopLeftRadius = 0;
        this.borderTopRightRadius = 0;
        this.borderBottomLeftRadius = 0;
        this.borderBottomRightRadius = 0;
    }
    clone() {
        const clone = new Background();
        clone.color = this.color;
        clone.image = this.image;
        clone.repeat = this.repeat;
        clone.position = this.position;
        clone.size = this.size;
        clone.borderTopColor = this.borderTopColor;
        clone.borderRightColor = this.borderRightColor;
        clone.borderBottomColor = this.borderBottomColor;
        clone.borderLeftColor = this.borderLeftColor;
        clone.borderTopWidth = this.borderTopWidth;
        clone.borderRightWidth = this.borderRightWidth;
        clone.borderBottomWidth = this.borderBottomWidth;
        clone.borderLeftWidth = this.borderLeftWidth;
        clone.borderTopLeftRadius = this.borderTopLeftRadius;
        clone.borderTopRightRadius = this.borderTopRightRadius;
        clone.borderBottomRightRadius = this.borderBottomRightRadius;
        clone.borderBottomLeftRadius = this.borderBottomLeftRadius;
        clone.clipPath = this.clipPath;
        return clone;
    }
    withColor(value) {
        const clone = this.clone();
        clone.color = value;
        return clone;
    }
    withImage(value) {
        const clone = this.clone();
        clone.image = value;
        return clone;
    }
    withRepeat(value) {
        const clone = this.clone();
        clone.repeat = value;
        return clone;
    }
    withPosition(value) {
        const clone = this.clone();
        clone.position = value;
        return clone;
    }
    withSize(value) {
        const clone = this.clone();
        clone.size = value;
        return clone;
    }
    withBorderTopColor(value) {
        const clone = this.clone();
        clone.borderTopColor = value;
        return clone;
    }
    withBorderRightColor(value) {
        const clone = this.clone();
        clone.borderRightColor = value;
        return clone;
    }
    withBorderBottomColor(value) {
        const clone = this.clone();
        clone.borderBottomColor = value;
        return clone;
    }
    withBorderLeftColor(value) {
        const clone = this.clone();
        clone.borderLeftColor = value;
        return clone;
    }
    withBorderTopWidth(value) {
        const clone = this.clone();
        clone.borderTopWidth = value;
        return clone;
    }
    withBorderRightWidth(value) {
        const clone = this.clone();
        clone.borderRightWidth = value;
        return clone;
    }
    withBorderBottomWidth(value) {
        const clone = this.clone();
        clone.borderBottomWidth = value;
        return clone;
    }
    withBorderLeftWidth(value) {
        const clone = this.clone();
        clone.borderLeftWidth = value;
        return clone;
    }
    withBorderTopLeftRadius(value) {
        const clone = this.clone();
        clone.borderTopLeftRadius = value;
        return clone;
    }
    withBorderTopRightRadius(value) {
        const clone = this.clone();
        clone.borderTopRightRadius = value;
        return clone;
    }
    withBorderBottomRightRadius(value) {
        const clone = this.clone();
        clone.borderBottomRightRadius = value;
        return clone;
    }
    withBorderBottomLeftRadius(value) {
        const clone = this.clone();
        clone.borderBottomLeftRadius = value;
        return clone;
    }
    withClipPath(value) {
        const clone = this.clone();
        clone.clipPath = value;
        return clone;
    }
    isEmpty() {
        return !this.color && !this.image && !this.hasBorderWidth() && !this.hasBorderRadius() && !this.clipPath;
    }
    static equals(value1, value2) {
        // both values are falsy
        if (!value1 && !value2) {
            return true;
        }
        // only one is falsy
        if (!value1 || !value2) {
            return false;
        }
        let imagesEqual = false;
        if (value1 instanceof _linear_gradient__WEBPACK_IMPORTED_MODULE_0__[/* LinearGradient */ "a"] && value2 instanceof _linear_gradient__WEBPACK_IMPORTED_MODULE_0__[/* LinearGradient */ "a"]) {
            imagesEqual = _linear_gradient__WEBPACK_IMPORTED_MODULE_0__[/* LinearGradient */ "a"].equals(value1, value2);
        }
        else {
            imagesEqual = value1.image === value2.image;
        }
        return (_color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(value1.color, value2.color) &&
            imagesEqual &&
            value1.position === value2.position &&
            value1.repeat === value2.repeat &&
            value1.size === value2.size &&
            _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(value1.borderTopColor, value2.borderTopColor) &&
            _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(value1.borderRightColor, value2.borderRightColor) &&
            _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(value1.borderBottomColor, value2.borderBottomColor) &&
            _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(value1.borderLeftColor, value2.borderLeftColor) &&
            value1.borderTopWidth === value2.borderTopWidth &&
            value1.borderRightWidth === value2.borderRightWidth &&
            value1.borderBottomWidth === value2.borderBottomWidth &&
            value1.borderLeftWidth === value2.borderLeftWidth &&
            value1.borderTopLeftRadius === value2.borderTopLeftRadius &&
            value1.borderTopRightRadius === value2.borderTopRightRadius &&
            value1.borderBottomRightRadius === value2.borderBottomRightRadius &&
            value1.borderBottomLeftRadius === value2.borderBottomLeftRadius &&
            value1.clipPath === value2.clipPath);
    }
    hasBorderColor() {
        return !!this.borderTopColor || !!this.borderRightColor || !!this.borderBottomColor || !!this.borderLeftColor;
    }
    hasBorderWidth() {
        return this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0;
    }
    hasBorderRadius() {
        return this.borderTopLeftRadius > 0 || this.borderTopRightRadius > 0 || this.borderBottomRightRadius > 0 || this.borderBottomLeftRadius > 0;
    }
    hasUniformBorderColor() {
        return _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(this.borderTopColor, this.borderRightColor) && _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(this.borderTopColor, this.borderBottomColor) && _color__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"].equals(this.borderTopColor, this.borderLeftColor);
    }
    hasUniformBorderWidth() {
        return this.borderTopWidth === this.borderRightWidth && this.borderTopWidth === this.borderBottomWidth && this.borderTopWidth === this.borderLeftWidth;
    }
    hasUniformBorderRadius() {
        return this.borderTopLeftRadius === this.borderTopRightRadius && this.borderTopLeftRadius === this.borderBottomRightRadius && this.borderTopLeftRadius === this.borderBottomLeftRadius;
    }
    hasUniformBorder() {
        return this.hasUniformBorderColor() && this.hasUniformBorderWidth() && this.hasUniformBorderRadius();
    }
    getUniformBorderColor() {
        if (this.hasUniformBorderColor()) {
            return this.borderTopColor;
        }
        return undefined;
    }
    getUniformBorderWidth() {
        if (this.hasUniformBorderWidth()) {
            return this.borderTopWidth;
        }
        return 0;
    }
    getUniformBorderRadius() {
        if (this.hasUniformBorderRadius()) {
            return this.borderTopLeftRadius;
        }
        return 0;
    }
    toString() {
        return `isEmpty: ${this.isEmpty()}; color: ${this.color}; image: ${this.image}; repeat: ${this.repeat}; position: ${this.position}; size: ${this.size}; borderTopColor: ${this.borderTopColor}; borderRightColor: ${this.borderRightColor}; borderBottomColor: ${this.borderBottomColor}; borderLeftColor: ${this.borderLeftColor}; borderTopWidth: ${this.borderTopWidth}; borderRightWidth: ${this.borderRightWidth}; borderBottomWidth: ${this.borderBottomWidth}; borderLeftWidth: ${this.borderLeftWidth}; borderTopLeftRadius: ${this.borderTopLeftRadius}; borderTopRightRadius: ${this.borderTopRightRadius}; borderBottomRightRadius: ${this.borderBottomRightRadius}; borderBottomLeftRadius: ${this.borderBottomLeftRadius}; clipPath: ${this.clipPath};`;
    }
}
Background.default = new Background();
//# sourceMappingURL=background-common.js.map; 
if (false ) {} 

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

// Hack to resolve https://github.com/webpack/enhanced-resolve/issues/197 . 
// This issue causes an require like this (`../esprima`) to be resolved to (`esprima`) by the Angular webpack plugin
var esprima = __webpack_require__(405).esprima;

var Path = __webpack_require__(406).Path;

(function (global) {
    'use strict';

    // TODO(rafaelw): Implement simple LRU.
    var expressionParseCache = Object.create(null);

    function getExpression(expressionText) {
        var expression = expressionParseCache[expressionText];
        if (!expression) {
            var delegate = new ASTDelegate();
            esprima.parse(expressionText, delegate);
            expression = new Expression(delegate);
            expressionParseCache[expressionText] = expression;
        }
        return expression;
    }

    function Literal(value) {
        this.value = value;
        this.valueFn_ = undefined;
    }

    Literal.prototype = {
        valueFn: function () {
            if (!this.valueFn_) {
                var value = this.value;
                this.valueFn_ = function () {
                    return value;
                }
            }

            return this.valueFn_;
        }
    }

    function IdentPath(name) {
        this.name = name;
        this.path = Path.get(name);
    }

    IdentPath.prototype = {
        valueFn: function () {
            if (!this.valueFn_) {
                var name = this.name;
                var path = this.path;
                this.valueFn_ = function (model, observer, changedModel) {
                    if (observer)
                        observer.addPath(model, path);

                    if (changedModel) {
                        var result = path.getValueFrom(changedModel);
                        if (result !== undefined) {
                            return result;
                        }
                    }

                    return path.getValueFrom(model);
                }
            }

            return this.valueFn_;
        },

        setValue: function (model, newValue) {
            if (this.path.length == 1) {
                model = findScope(model, this.path[0]);
            }

            return this.path.setValueFrom(model, newValue);
        }
    };

    function MemberExpression(object, property, accessor) {
        this.computed = accessor == '[';

        this.dynamicDeps = typeof object == 'function' ||
                           object.dynamicDeps ||
                           (this.computed && !(property instanceof Literal));

        this.simplePath =
            !this.dynamicDeps &&
            (property instanceof IdentPath || property instanceof Literal) &&
            (object instanceof MemberExpression || object instanceof IdentPath);

        this.object = this.simplePath ? object : getFn(object);
        this.property = !this.computed || this.simplePath ?
            property : getFn(property);
    }

    MemberExpression.prototype = {
        get fullPath() {
            if (!this.fullPath_) {

                var parts = this.object instanceof MemberExpression ?
                    this.object.fullPath.slice() : [this.object.name];
                parts.push(this.property instanceof IdentPath ?
                    this.property.name : this.property.value);
                this.fullPath_ = Path.get(parts);
            }

            return this.fullPath_;
        },

        valueFn: function () {
            if (!this.valueFn_) {
                var object = this.object;

                if (this.simplePath) {
                    var path = this.fullPath;

                    this.valueFn_ = function (model, observer) {
                        if (observer)
                            observer.addPath(model, path);

                        return path.getValueFrom(model);
                    };
                } else if (!this.computed) {
                    var path = Path.get(this.property.name);

                    this.valueFn_ = function (model, observer, filterRegistry) {
                        var context = object(model, observer, filterRegistry);

                        if (observer)
                            observer.addPath(context, path);

                        return path.getValueFrom(context);
                    }
                } else {
                    // Computed property.
                    var property = this.property;

                    this.valueFn_ = function (model, observer, filterRegistry) {
                        var context = object(model, observer, filterRegistry);
                        var propName = property(model, observer, filterRegistry);
                        if (observer)
                            observer.addPath(context, [propName]);

                        return context ? context[propName] : undefined;
                    };
                }
            }
            return this.valueFn_;
        },

        setValue: function (model, newValue) {
            if (this.simplePath) {
                this.fullPath.setValueFrom(model, newValue);
                return newValue;
            }

            var object = this.object(model);
            var propName = this.property instanceof IdentPath ? this.property.name :
                this.property(model);
            return object[propName] = newValue;
        }
    };

    function Filter(name, args) {
        this.name = name;
        this.args = [];
        for (var i = 0; i < args.length; i++) {
            this.args[i] = getFn(args[i]);
        }
    }

    Filter.prototype = {
        transform: function (model, observer, filterRegistry, toModelDirection,
                            initialArgs) {
            var fn = filterRegistry[this.name];
            var context = model;
            if (fn) {
                context = undefined;
            } else {
                fn = context[this.name];
                if (!fn) {
                    console.error('Cannot find function or filter: ' + this.name);
                    return;
                }
            }

            // If toModelDirection is falsey, then the "normal" (dom-bound) direction
            // is used. Otherwise, it looks for a 'toModel' property function on the
            // object.
            if (toModelDirection) {
                fn = fn.toModel;
            } else if (typeof fn.toView == 'function') {
                fn = fn.toView;
            }

            if (typeof fn != 'function') {
                console.error('Cannot find function or filter: ' + this.name);
                return;
            }

            var args = initialArgs || [];
            for (var i = 0; i < this.args.length; i++) {
                args.push(getFn(this.args[i])(model, observer, filterRegistry));
            }

            return fn.apply(context, args);
        }
    };

    function notImplemented() { throw Error('Not Implemented'); }

    var unaryOperators = {
        '+': function (v) { return +v; },
        '-': function (v) { return -v; },
        '!': function (v) { return !v; }
    };

    var binaryOperators = {
        '+': function (l, r) { return l + r; },
        '-': function (l, r) { return l - r; },
        '*': function (l, r) { return l * r; },
        '/': function (l, r) { return l / r; },
        '%': function (l, r) { return l % r; },
        '<': function (l, r) { return l < r; },
        '>': function (l, r) { return l > r; },
        '<=': function (l, r) { return l <= r; },
        '>=': function (l, r) { return l >= r; },
        '==': function (l, r) { return l == r; },
        '!=': function (l, r) { return l != r; },
        '===': function (l, r) { return l === r; },
        '!==': function (l, r) { return l !== r; },
        '&&': function (l, r) { return l && r; },
        '||': function (l, r) { return l || r; },
    };

    function getFn(arg) {
        return typeof arg == 'function' ? arg : arg.valueFn();
    }

    function ASTDelegate() {
        this.expression = null;
        this.filters = [];
        this.deps = {};
        this.currentPath = undefined;
        this.scopeIdent = undefined;
        this.indexIdent = undefined;
        this.dynamicDeps = false;
    }

    ASTDelegate.prototype = {
        createUnaryExpression: function (op, argument) {
            if (!unaryOperators[op])
                throw Error('Disallowed operator: ' + op);

            argument = getFn(argument);

            return function (model, observer, filterRegistry) {
                return unaryOperators[op](argument(model, observer, filterRegistry));
            };
        },

        createBinaryExpression: function (op, left, right) {
            if (!binaryOperators[op])
                throw Error('Disallowed operator: ' + op);

            left = getFn(left);
            right = getFn(right);

            switch (op) {
                case '||':
                    this.dynamicDeps = true;
                    return function (model, observer, filterRegistry) {
                        return left(model, observer, filterRegistry) ||
                            right(model, observer, filterRegistry);
                    };
                case '&&':
                    this.dynamicDeps = true;
                    return function (model, observer, filterRegistry) {
                        return left(model, observer, filterRegistry) &&
                            right(model, observer, filterRegistry);
                    };
            }

            return function (model, observer, filterRegistry) {
                return binaryOperators[op](left(model, observer, filterRegistry),
                                           right(model, observer, filterRegistry));
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            test = getFn(test);
            consequent = getFn(consequent);
            alternate = getFn(alternate);

            this.dynamicDeps = true;

            return function (model, observer, filterRegistry) {
                return test(model, observer, filterRegistry) ?
                    consequent(model, observer, filterRegistry) :
                    alternate(model, observer, filterRegistry);
            }
        },

        createIdentifier: function (name) {
            var ident = new IdentPath(name);
            ident.type = 'Identifier';
            return ident;
        },

        createMemberExpression: function (accessor, object, property) {
            var ex = new MemberExpression(object, property, accessor);
            if (ex.dynamicDeps)
                this.dynamicDeps = true;
            return ex;
        },

        createCallExpression: function (expression, args) {
            if (!(expression instanceof IdentPath))
                throw Error('Only identifier function invocations are allowed');

            var filter = new Filter(expression.name, args);

            return function (model, observer, filterRegistry) {
                return filter.transform(model, observer, filterRegistry, false);
            };
        },

        createLiteral: function (token) {
            return new Literal(token.value);
        },

        createArrayExpression: function (elements) {
            for (var i = 0; i < elements.length; i++)
                elements[i] = getFn(elements[i]);

            return function (model, observer, filterRegistry) {
                var arr = []
                for (var i = 0; i < elements.length; i++)
                    arr.push(elements[i](model, observer, filterRegistry));
                return arr;
            }
        },

        createProperty: function (kind, key, value) {
            return {
                key: key instanceof IdentPath ? key.name : key.value,
                value: value
            };
        },

        createObjectExpression: function (properties) {
            for (var i = 0; i < properties.length; i++)
                properties[i].value = getFn(properties[i].value);

            return function (model, observer, filterRegistry) {
                var obj = {};
                for (var i = 0; i < properties.length; i++)
                    obj[properties[i].key] =
                        properties[i].value(model, observer, filterRegistry);
                return obj;
            }
        },

        createFilter: function (name, args) {
            this.filters.push(new Filter(name, args));
        },

        createAsExpression: function (expression, scopeIdent) {
            this.expression = expression;
            this.scopeIdent = scopeIdent;
        },

        createInExpression: function (scopeIdent, indexIdent, expression) {
            this.expression = expression;
            this.scopeIdent = scopeIdent;
            this.indexIdent = indexIdent;
        },

        createTopLevel: function (expression) {
            this.expression = expression;
        },

        createThisExpression: notImplemented
    }

    function Expression(delegate) {
        this.scopeIdent = delegate.scopeIdent;
        this.indexIdent = delegate.indexIdent;

        if (!delegate.expression)
            throw Error('No expression found.');

        this.expression = delegate.expression;
        getFn(this.expression); // forces enumeration of path dependencies

        this.filters = delegate.filters;
        this.dynamicDeps = delegate.dynamicDeps;
    }

    Expression.prototype = {
        getValue: function (model, isBackConvert, changedModel, observer) {
            var value = getFn(this.expression)(model.context, observer, changedModel);
            for (var i = 0; i < this.filters.length; i++) {
                value = this.filters[i].transform(model.context, observer, model.context, isBackConvert, [value]);
            }

            return value;
        },

        setValue: function (model, newValue, filterRegistry) {
            var count = this.filters ? this.filters.length : 0;
            while (count-- > 0) {
                newValue = this.filters[count].transform(model, undefined,
                    filterRegistry, true, [newValue]);
            }

            if (this.expression.setValue)
                return this.expression.setValue(model, newValue);
        }
    }

    /**
     * Converts a style property name to a css property name. For example:
     * "WebkitUserSelect" to "-webkit-user-select"
     */
    function convertStylePropertyName(name) {
        return String(name).replace(/[A-Z]/g, function (c) {
            return '-' + c.toLowerCase();
        });
    }

    var parentScopeName = '@' + Math.random().toString(36).slice(2);

    // Single ident paths must bind directly to the appropriate scope object.
    // I.e. Pushed values in two-bindings need to be assigned to the actual model
    // object.
    function findScope(model, prop) {
        while (model[parentScopeName] &&
               !Object.prototype.hasOwnProperty.call(model, prop)) {
            model = model[parentScopeName];
        }

        return model;
    }

    function isLiteralExpression(pathString) {
        switch (pathString) {
            case '':
                return false;

            case 'false':
            case 'null':
            case 'true':
                return true;
        }

        if (!isNaN(Number(pathString)))
            return true;

        return false;
    };

    function PolymerExpressions() { }

    PolymerExpressions.prototype = {
        // "built-in" filters
        styleObject: function (value) {
            var parts = [];
            for (var key in value) {
                parts.push(convertStylePropertyName(key) + ': ' + value[key]);
            }
            return parts.join('; ');
        },

        tokenList: function (value) {
            var tokens = [];
            for (var key in value) {
                if (value[key])
                    tokens.push(key);
            }
            return tokens.join(' ');
        },

        // binding delegate API
        prepareInstancePositionChanged: function (template) {
            var indexIdent = template.polymerExpressionIndexIdent_;
            if (!indexIdent)
                return;

            return function (templateInstance, index) {
                templateInstance.model[indexIdent] = index;
            };
        },

        prepareInstanceModel: function (template) {
            var scopeName = template.polymerExpressionScopeIdent_;
            if (!scopeName)
                return;

            var parentScope = template.templateInstance ?
                template.templateInstance.model :
                template.model;

            var indexName = template.polymerExpressionIndexIdent_;

            return function (model) {
                return createScopeObject(parentScope, model, scopeName, indexName);
            };
        }
    };

    var createScopeObject = ('__proto__' in {}) ?
      function (parentScope, model, scopeName, indexName) {
          var scope = {};
          scope[scopeName] = model;
          scope[indexName] = undefined;
          scope[parentScopeName] = parentScope;
          scope.__proto__ = parentScope;
          return scope;
      } :
      function (parentScope, model, scopeName, indexName) {
          var scope = Object.create(parentScope);
          Object.defineProperty(scope, scopeName,
              { value: model, configurable: true, writable: true });
          Object.defineProperty(scope, indexName,
              { value: undefined, configurable: true, writable: true });
          Object.defineProperty(scope, parentScopeName,
              { value: parentScope, configurable: true, writable: true });
          return scope;
      };

    global.PolymerExpressions = PolymerExpressions;
    PolymerExpressions.getExpression = getExpression;
})(module.exports);; 
if (false ) {} 

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	new function() {
		var parser = new EasySAXParser();

		parser.ns('rss', { // or false
			rss: 'http://purl.org/rss/1.0/',
			atom: 'http://www.w3.org/2005/Atom',
			xhtml: 'http://www.w3.org/1999/xhtml',
			media: 'http://search.yahoo.com/mrss/'
		});


		parser.on('error', function(msg) {
			//console.log(msg)
		});

		parser.on('startNode', function(elem, attr, uq, tagend, getStrNode) {
			attr();
			return;
			if (tagend) {
				console.log('   '+str)
			} else {
				console.log('+  '+str)
			};
		});

		parser.on('endNode', function(elem, uq, tagstart, str) {
			return;
			if (!tagstart) console.log('-  ' + str)
		});

		parser.on('textNode', function(s, uq) {
			uq(s);
			return
			console.log('   '+s)
		});

		parser.on('cdata', function(data) {
		});


		parser.on('comment', function(text) {
			//console.log('--'+text+'--')
		});

		//parser.on('question', function() {}); // <? ... ?>
		//parser.on('attention', function() {}); // <!XXXXX zzzz="eeee">

		console.time('easysax');
		for(var z=1000;z--;) {
			parser.parse(xml)
		};
		console.timeEnd('easysax');
	};


	*/

// << ------------------------------------------------------------------------ >> //


if (true /*&& this == exports*/) {
	module.exports.EasySAXParser = EasySAXParser;
};

function EasySAXParser() {
	'use strict';

	if (!this) return null;

    this.angularSyntax = false;

	function nullFunc() {};

	this.onTextNode = nullFunc;
    this.onStartNode = nullFunc;
    this.onEndNode = nullFunc;
    this.onCDATA = nullFunc;
    this.onError = nullFunc;
    this.onComment = null;
    this.onQuestion = null;
    this.onAttention = null;
	this.is_onComment = this.is_onQuestion = this.is_onAttention = false;

	this.isNamespace = false;
    this.useNS = null;
    this.default_xmlns = null;
    this.xmlns = null;
	this.nsmatrix = {xmlns: this.xmlns};
	this.hasSurmiseNS = false;
	;


	this.attr_string = ''; // строка атрибутов
	this.attr_posstart = 0; //
	this.attr_res; // закешированный результат разбора атрибутов , null - разбор не проводился, object - хеш атрибутов, true - нет атрибутов, false - невалидный xml
}

EasySAXParser.prototype.on = function(name, cb) {
    if (typeof cb !== 'function') {
        if (cb !== null) return;
    };

    switch(name) {
        case 'error': this.onError = cb || nullFunc; break;
        case 'startNode': this.onStartNode = cb || nullFunc; break;
        case 'endNode': this.onEndNode = cb || nullFunc; break;
        case 'textNode': this.onTextNode = cb || nullFunc; break;
        case 'cdata': this.onCDATA = cb || nullFunc; break;

        case 'comment': this.onComment = cb; this.is_onComment = !!cb; break;
        case 'question': this.onQuestion = cb; this.is_onQuestion = !!cb; break; // <? ....  ?>
        case 'attention': this.onAttention = cb; this.is_onAttention = !!cb; break; // <!XXXXX zzzz="eeee">
    };
};

EasySAXParser.prototype.ns = function(root, ns) {
    if (!root || typeof root !== 'string' || !ns) {
        return;
    };

    var u, x = {}, ok, v, i;

    for(i in ns) {
        v = ns[i];
        if (typeof v === 'string') {
            if (root === v) ok = true;
            x[i] = v;
        };
    };

    if (ok) {
        this.isNamespace = true;
        this.default_xmlns = root;
        this.useNS = x;
    };
};


EasySAXParser.prototype.parse = function(xml) {
    if (typeof xml !== 'string') {
        return;
    };

    if (this.isNamespace) {
        this.nsmatrix = {xmlns: this.default_xmlns};

        parse(xml);

        this.nsmatrix = false;

    } else {
        parse(xml);
    };

    this.attr_res = true;
};

// -----------------------------------------------------

var xharsQuot={constructor: false, hasOwnProperty: false, isPrototypeOf: false, propertyIsEnumerable: false, toLocaleString: false, toString: false, valueOf: false
    , quot: '"'
    , QUOT: '"'
    , amp: '&'
    , AMP: '&'
    , nbsp: '\u00A0'
    , apos: '\''
    , lt: '<'
    , LT: '<'
    , gt: '>'
    , GT: '>'
    , copy: '\u00A9'
    , laquo: '\u00AB'
    , raquo: '\u00BB'
    , reg: '\u00AE'
    , deg: '\u00B0'
    , plusmn: '\u00B1'
    , sup2: '\u00B2'
    , sup3: '\u00B3'
    , micro: '\u00B5'
    , para: '\u00B6'
};


function rpEntities(s, d, x, z) {
    if (z) {
        return xharsQuot[z] || '\x01';
    };

    if (d) {
        return String.fromCodePoint(d);
    };

    return String.fromCodePoint(parseInt(x, 16));
};

function unEntities(s, i) {
    s = String(s);
    if (s.length > 3 && s.indexOf('&') !== -1) {
        if (s.indexOf('&gt;') !== -1) s = s.replace(/&gt;/g, '>');
        if (s.indexOf('&lt;') !== -1) s = s.replace(/&lt;/g, '<');
        if (s.indexOf('&quot;') !== -1) s = s.replace(/&quot;/g, '"');

        if (s.indexOf('&') !== -1) {
            s = s.replace(/&#(\d+);|&#x([0123456789abcdef]+);|&(\w+);/ig, rpEntities);
        };
    };

    return s;
};


EasySAXParser.prototype.allowedAngularAttributeChars = function(w) {
    if (!this.angularSyntax) {
        return false;
    } else {
        return (
            w === 40 || // (
            w === 41 || // )
            w === 91 || // [
            w === 93 || // ]
            w === 94 || // ^
            w === 35    // #
        );
    }
};

	/*
		парсит атрибуты по требованию. Важно! - функция не генерирует исключения.

		если была ошибка разбора возврашается false
		если атрибутов нет и разбор удачен то возврашается true
		если есть атрибуты то возврашается обьект(хеш)
	*/

EasySAXParser.prototype.getAttrs = function() {
    if (this.attr_res !== null) {
        return this.attr_res;
    };

    /*
    if (xxtest !== u && attr_string.indexOf(xxtest) === -1) {
        / *
            // для ускорения
            if (getAttrs('html').type == 'html') {
                ...
            };
        * /
        return true;
    };
    */

    var u
    , res = {}
    , s = this.attr_string
    , i = this.attr_posstart
    , l = s.length
    , attr_list = this.hasSurmiseNS ? [] : false
    , name, value = ''
    , ok = false
    , noValueAttribute = false
    , j, w, nn, n
    , hasNewMatrix
    , alias, newalias
    ;

    aa:
    for(; i < l; i++) {
        w = s.charCodeAt(i);

        if (w===32 || (w<14 && w > 8) ) { // \f\n\r\t\v
            continue
        };

        // Check for valid attribute start char
        if ((w < 65 && !this.allowedAngularAttributeChars(w)) ||
                w > 122 || (w > 90 && w < 97 && !this.allowedAngularAttributeChars(w)) ) { // ожидаем символ
            return this.attr_res = false; // error. invalid char
        };

        for(j = i + 1; j < l; j++) { // проверяем все символы имени атрибута
            w = s.charCodeAt(j);

            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w === 46 /* https://github.com/telerik/xPlatCore/issues/179 */) {
                if (noValueAttribute) {
                    j--; //Started next attribute. Get back and break out of the loop.
                    break;
                } else {
                    continue;
                }
            };

            if (this.allowedAngularAttributeChars(w)) {
                continue;
            }

            if (w === 32 || (w > 8 && w < 14) ) {  // \f\n\r\t\v пробел
                noValueAttribute = true;
                continue;
            } else if (w === 61) { // "=" == 61
                noValueAttribute = false;
                break;
            } else {
                //console.log('error 2');
                if (!noValueAttribute)
                    return this.attr_res = false; // error. invalid char
            };

            break;
        };

        name = s.substring(i, j).trim();
        ok = true;

        if (name === 'xmlns:xmlns') {
            //console.log('error 6')
            return this.attr_res = false; // error. invalid name
        };

        w = s.charCodeAt(j+1);

        while (w = s.charCodeAt(j+1)) {
            if (w===32 || (w > 8 && w<14) ) {  // \f\n\r\t\v пробел
                j++;
            } else {
                break;
            }
        }

        if (!noValueAttribute) {
            if (w === 34) {  // '"'
                j = s.indexOf('"', i = j+2 );

            } else {
                if (w === 39) {
                    j = s.indexOf('\'', i = j+2 );

                } else {  // "'"
                    return this.attr_res = false; // error. invalid char
                };
            };
        }

        if (j === -1) {
            //console.log('error 4')
            return this.attr_res = false; // error. invalid char
        };


        if (j+1 < l && !noValueAttribute) {
            w = s.charCodeAt(j+1);

            if (w > 32 || w < 9 || (w < 32 && w > 13)) {
                // error. invalid char
                //console.log('error 5')
                return this.attr_res = false;
            };
        };


        if (noValueAttribute) {
            value = '';
        } else {
            value = s.substring(i, j);
        }

        //i = j + 1; // след. семвол уже проверен потому проверять нужно следуюший
        i = j; // след. семвол уже проверен потому проверять нужно следуюший

        if (this.isNamespace) { //
            if (this.hasSurmiseNS) {
                // есть подозрение что в атрибутах присутствует xmlns

                if (newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' && name.substr(6) ) {
                    alias = this.useNS[unEntities(value)];

                    if (alias) {
                        if (this.nsmatrix[newalias] !== alias) {
                            if (!hasNewMatrix) {
                                hasNewMatrix = true;
                                nn = {}; for (n in this.nsmatrix) nn[n] = this.nsmatrix[n];
                                this.nsmatrix = nn;
                            };

                            this.nsmatrix[newalias] = alias;
                        };
                    } else {
                        if (this.nsmatrix[newalias]) {
                            if (!hasNewMatrix) {
                                hasNewMatrix = true;
                                nn = {}; for (n in this.nsmatrix) nn[n] = this.nsmatrix[n];
                                this.nsmatrix = nn;
                            };

                            this.nsmatrix[newalias] = false;
                        };
                    };

                    res[name] = value;
                    continue;
                };

                attr_list.push(name, value);
                continue;
            };

            w = name.length;
            while(--w) {
                if (name.charCodeAt(w) === 58) { // ':'
                    if (w = this.nsmatrix[name.substring(0, w)] ) {
                        res[w + name.substr(w)] = value;
                    };
                    continue aa;

                    // 'xml:base' ???
                };
            };
        };

        res[name] = value;
        noValueAttribute = false;
    };


    if (!ok) {
        return this.attr_res = true;  // атрибутов нет, ошибок тоже нет
    };


    if (this.hasSurmiseNS)  {
        bb:

        for (i = 0, l = attr_list.length; i < l; i++) {
            name = attr_list[i++];

            w = name.length;
            while(--w) { // name.indexOf(':')
                if (name.charCodeAt(w) === 58) { // ':'
                    if (w = this.nsmatrix[name.substring(0, w)]) {
                        res[w + name.substr(w)] = attr_list[i];
                    };
                    continue bb;
                    break;
                };
            };

            res[name] = attr_list[i];
        };
    };

    return this.attr_res = res;
};


// xml - string
EasySAXParser.prototype.parse = function(xml) {
    var u
    , xml = String(xml)
    , nodestack = []
    , stacknsmatrix = []
    //, string_node
    , elem
    , tagend = false
    , tagstart = false
    , j = 0, i = 0, k = 0, len
    , x, y, q, w
    , xmlns
    , stopIndex = 0
    , stop // используется при разборе "namespace" . если встретился неизвестное пространство то события не генерируются
    , _nsmatrix
    , ok
    , pos = 0, ln = 0, lnStart = -2, lnEnd = -1
    ;

    len = xml.length;
    function getStringNode() {
        return xml.substring(i, j+1)
    };
    function findLineAndColumnFromPos() {
        while (lnStart < lnEnd && lnEnd < pos) {
            lnStart = lnEnd;
            lnEnd = xml.indexOf("\n", lnEnd + 1);
            ++ln;
        }
        return { line: ln, column: pos - lnStart };
    }
    function position(p) {
        pos = p;
        return findLineAndColumnFromPos;
    }

    while(j !== -1) {
        stop = stopIndex > 0;

        if (xml.charCodeAt(j) === 60) { // "<"
            i = j;
        } else {
            i = xml.indexOf('<', j);
        };

        if (i === -1) { // конец разбора

            if (nodestack.length) {
                this.onError('end file', position(j));
                return;
            };

            return;
        };

        if (j !== i && !stop) {
            ok = this.onTextNode(xml.substring(j, i), unEntities, position(j));
            if (ok === false) return;
        };

        w = xml.charCodeAt(i+1);

        if (w === 33) { // "!"
            w = xml.charCodeAt(i+2);
            if (w === 91 && xml.substr(i+3, 6) === 'CDATA[') { // 91 == "["
                j = xml.indexOf(']]>', i);
                if (j === -1) {
                    this.onError('cdata', position(i));
                    return;
                };

                //x = xml.substring(i+9, j);
                if (!stop) {
                    ok = this.onCDATA(xml.substring(i+9, j), false, position(i));
                    if (ok === false) return;
                };

                j += 3;
                continue;
            };

            if (w === 45 && xml.charCodeAt(i+3) === 45) { // 45 == "-"
                j = xml.indexOf('-->', i);
                if (j === -1) {
                    this.onError('expected -->', position(i));
                    return;
                };


                if (this.is_onComment && !stop) {
                    ok = this.onComment(xml.substring(i+4, j), unEntities, position(i));
                    if (ok === false) return;
                };

                j += 3;
                continue;
            };

            j = xml.indexOf('>', i+1);
            if (j === -1) {
                this.onError('expected ">"', position(i + 1));
                return;
            };

            if (this.is_onAttention && !stop) {
                ok = this.onAttention(xml.substring(i, j+1), unEntities, position(i));
                if (ok === false) return;
            };

            j += 1;
            continue;

        } else {
            if (w === 63) { // "?"
                j = xml.indexOf('?>', i);
                if (j === -1) { // error
                    this.onError('...?>', position(i));
                    return;
                };

                if (this.is_onQuestion) {
                    ok = this.onQuestion(xml.substring(i, j+2), position(i));
                    if (ok === false) return;
                };

                j += 2;
                continue;
            };
        };

        var inside=false;
        for (k=i,j=-1;k<len;k++) {
            var c = xml.charCodeAt(k);
            if (!inside) {

                if (c === 34) { // '"'
                    inside = c;
                }
                else if (c === 39) { // "'"
                    inside = c;
                }
                else if (c === 62) { // <
                    j = k; break;
                }
            } else {
                if (c === inside) { inside = false; }
            }
        }

        if (j == -1) { // error
            this.onError('...>', position(i + 1));
            return;
        };

        this.attr_res = true; // атрибутов нет

        //if (xml.charCodeAt(i+1) === 47) { // </...
        if (w === 47) { // </...
            tagstart = false;
            tagend = true;

            // проверяем что должен быть закрыт тотже тег что и открывался
            x = elem = nodestack.pop();
            q = i + 2 + x.length;

            //console.log()
            if (xml.substring(i+2, q) !== x) {
                this.onError('close tagname', position(i + 2));
                return;
            };

            // проверим что в закрываюшем теге нет лишнего
            for(; q < j; q++) {
                w = xml.charCodeAt(q);

                if (w===32 || (w > 8 && w<14) ) {  // \f\n\r\t\v пробел
                    continue;
                };

                this.onError('close tag', position(i + 2));
                return;
            };

        } else {
            if (xml.charCodeAt(j-1) ===  47) { // .../>
                x = elem = xml.substring(i+1, j-1);

                tagstart = true;
                tagend = true;
            } else {
                x = elem = xml.substring(i+1, j);

                tagstart = true;
                tagend = false;
            };

            if ( !(w > 96  && w < 123 || w > 64 && w <91) ) {
                this.onError('first char nodeName', position(i + 1));
                return;
            };

            for(q = 1, y = x.length; q < y; q++) {
                w = x.charCodeAt(q);

                if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w === 46 /* https://github.com/telerik/xPlatCore/issues/179 */) {
                    continue;
                };

                if (w===32 || (w<14 && w > 8)) { // \f\n\r\t\v пробел
                    elem = x.substring(0, q)
                    this.attr_res = null; // возможно есть атирибуты
                    break;
                };

                this.onError('invalid nodeName', position(i + 1));
                return;
            };

            if (!tagend) {
                nodestack.push(elem);
            };
        };


        if (this.isNamespace) {
            if (stop) {
                if (tagend) {
                    if (!tagstart) {
                        if (--stopIndex === 0) {
                            this.nsmatrix = stacknsmatrix.pop();
                        };
                    };

                } else {
                    stopIndex += 1;
                };


                j += 1;
                continue;
            };

            _nsmatrix = this.nsmatrix;

            if (!tagend) {
                stacknsmatrix.push(this.nsmatrix);

                if (this.attr_res !== true) {
                    if (this.hasSurmiseNS = x.indexOf('xmlns', q) !== -1) {
                        this.attr_string = x;
                        this.attr_posstart = q;

                        this.getAttrs();

                        this.hasSurmiseNS = false;
                    };
                };
            };


            w = elem.indexOf(':');
            if (w !== -1) {
                xmlns = this.nsmatrix[elem.substring(0, w)];
                elem = elem.substr(w+1);

            } else {
                xmlns = this.nsmatrix.xmlns;
            };

            if (!xmlns) {
                if (tagend) {
                    if (tagstart) {
                        this.nsmatrix = _nsmatrix;
                    } else {
                        this.nsmatrix = stacknsmatrix.pop();
                    };
                } else {
                    stopIndex = 1; // первый элемент для которого не определено пространство имен
                    this.attr_res = true;
                };

                j += 1;
                continue;
            };

            elem = xmlns + ':' + elem;
        };

        //string_node = xml.substring(i, j+1); // текст ноды как есть

        if (tagstart) { // is_onStartNode
            this.attr_string = x;
            this.attr_posstart = q;

            var that = this;
            ok = this.onStartNode(elem, function() { return that.getAttrs() }, unEntities, tagend
                , getStringNode, position(i)
            );

            if (ok === false) {
                return;
            };

            this.attr_res = true;
        };

        if (tagend) {
            ok = this.onEndNode(elem, unEntities, tagstart
                , getStringNode, position(i)
            );

            if (ok === false) {
                return;
            };

            if (this.isNamespace) {
                if (tagstart) {
                    this.nsmatrix = _nsmatrix;
                } else {
                    this.nsmatrix = stacknsmatrix.pop();
                };
            };
        };

        j += 1;
    };
};
; 
if (false ) {} 

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return stripQualifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findMatch; });
const MIN_WH = 'minWH';
const MIN_W = 'minW';
const MIN_H = 'minH';
const PRIORITY_STEP = 10000;
const minWidthHeightQualifier = {
    isMatch: function (path) {
        return new RegExp(`.${MIN_WH}\\d+`).test(path);
    },
    getMatchOccurences: function (path) {
        return path.match(new RegExp(`.${MIN_WH}\\d+`, 'g'));
    },
    getMatchValue(value, context) {
        const numVal = parseInt(value.substr(MIN_WH.length + 1));
        if (isNaN(numVal)) {
            return -1;
        }
        const actualLength = Math.min(context.width, context.height);
        if (actualLength < numVal) {
            return -1;
        }
        return PRIORITY_STEP - (actualLength - numVal);
    },
};
const minWidthQualifier = {
    isMatch: function (path) {
        return new RegExp(`.${MIN_W}\\d+`).test(path) && !new RegExp(`.${MIN_WH}\\d+`).test(path);
    },
    getMatchOccurences: function (path) {
        return path.match(new RegExp(`.${MIN_W}\\d+`, 'g'));
    },
    getMatchValue(value, context) {
        const numVal = parseInt(value.substr(MIN_W.length + 1));
        if (isNaN(numVal)) {
            return -1;
        }
        const actualWidth = context.width;
        if (actualWidth < numVal) {
            return -1;
        }
        return PRIORITY_STEP - (actualWidth - numVal);
    },
};
const minHeightQualifier = {
    isMatch: function (path) {
        return new RegExp(`.${MIN_H}\\d+`).test(path) && !new RegExp(`.${MIN_WH}\\d+`).test(path);
    },
    getMatchOccurences: function (path) {
        return path.match(new RegExp(`.${MIN_H}\\d+`, 'g'));
    },
    getMatchValue(value, context) {
        const numVal = parseInt(value.substr(MIN_H.length + 1));
        if (isNaN(numVal)) {
            return -1;
        }
        const actualHeight = context.height;
        if (actualHeight < numVal) {
            return -1;
        }
        return PRIORITY_STEP - (actualHeight - numVal);
    },
};
const platformQualifier = {
    isMatch: function (path) {
        return path.includes('.android') || path.includes('.ios');
    },
    getMatchOccurences: function (path) {
        return path.match(new RegExp('\\.android|\\.ios', 'g'));
    },
    getMatchValue(value, context) {
        const val = value.substr(1);
        return val === context.os.toLowerCase() ? 1 : -1;
    },
};
const orientationQualifier = {
    isMatch: function (path) {
        return path.includes('.land') || path.includes('.port');
    },
    getMatchOccurences: function (path) {
        return path.match(new RegExp('\\.land|\\.port', 'g'));
    },
    getMatchValue(value, context) {
        const val = value.substr(1);
        const isLandscape = context.width > context.height ? 1 : -1;
        return val === 'land' ? isLandscape : -isLandscape;
    },
};
// List of supported qualifiers ordered by priority
const supportedQualifiers = [minWidthHeightQualifier, minWidthQualifier, minHeightQualifier, orientationQualifier, platformQualifier];
function checkQualifiers(path, context) {
    let result = 0;
    for (let i = 0; i < supportedQualifiers.length; i++) {
        let qualifier = supportedQualifiers[i];
        if (qualifier.isMatch(path)) {
            let occurences = qualifier.getMatchOccurences(path);
            // Always get the last qualifier among identical occurences
            result = qualifier.getMatchValue(occurences[occurences.length - 1], context);
            if (result < 0) {
                // Non of the supported qualifiers matched this or the match was not satisfied
                return -1;
            }
            result += (supportedQualifiers.length - i) * PRIORITY_STEP;
            return result;
        }
    }
    return result;
}
function stripQualifiers(path) {
    // Strip qualifiers from path if any
    for (let i = 0; i < supportedQualifiers.length; i++) {
        let qualifier = supportedQualifiers[i];
        if (qualifier.isMatch(path)) {
            let occurences = qualifier.getMatchOccurences(path);
            for (let j = 0; j < occurences.length; j++) {
                path = path.replace(occurences[j], '');
            }
        }
    }
    return path;
}
function findMatch(path, ext, candidates, context) {
    let fullPath = ext ? path + ext : path;
    let bestValue = -1;
    let result = null;
    for (let i = 0; i < candidates.length; i++) {
        const filePath = candidates[i];
        // Check if candidate is correct for given path
        const cleanFilePath = stripQualifiers(filePath);
        if (cleanFilePath !== fullPath) {
            continue;
        }
        const value = checkQualifiers(filePath, context);
        if (value >= 0 && value > bestValue) {
            bestValue = value;
            result = candidates[i];
        }
    }
    return result;
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {


exports.parse = parse;

function parse(str) {
  return new Parser(str).parse();
}

function Parser(str) {
  this.str = str;
}

Parser.prototype.skip = function(m){
  this.str = this.str.slice(m[0].length);
};

Parser.prototype.comma = function(){
  var m = /^, */.exec(this.str);
  if (!m) return;
  this.skip(m);
  return { type: 'comma', string: ',' };
};

Parser.prototype.ident = function(){
  var m = /^([\w-]+) */.exec(this.str);
  if (!m) return;
  this.skip(m);
  return {
    type: 'ident',
    string: m[1]
  }
};

Parser.prototype.int = function(){
  var m = /^(([-\+]?\d+)(\S+)?) */.exec(this.str);
  if (!m) return;
  this.skip(m);
  var n = ~~m[2];
  var u = m[3];

  return {
    type: 'number',
    string: m[1],
    unit: u || '',
    value: n
  }
};

Parser.prototype.float = function(){
  var m = /^(((?:[-\+]?\d+)?\.\d+)(\S+)?) */.exec(this.str);
  if (!m) return;
  this.skip(m);
  var n = parseFloat(m[2]);
  var u = m[3];

  return {
    type: 'number',
    string: m[1],
    unit: u || '',
    value: n
  }
};

Parser.prototype.number = function(){
  return this.float() || this.int();
};

Parser.prototype.double = function(){
  var m = /^"([^"]*)" */.exec(this.str);
  if (!m) return m;
  this.skip(m);
  return {
    type: 'string',
    quote: '"',
    string: '"' + m[1] + '"',
    value: m[1]
  }
};

Parser.prototype.single = function(){
  var m = /^'([^']*)' */.exec(this.str);
  if (!m) return m;
  this.skip(m);
  return {
    type: 'string',
    quote: "'",
    string: "'" + m[1] + "'",
    value: m[1]
  }
};

Parser.prototype.string = function(){
  return this.single() || this.double();
};


Parser.prototype.value = function(){
  return this.number()
    || this.ident()
    || this.string()
    || this.comma();
};

Parser.prototype.parse = function(){
  var vals = [];

  while (this.str.length) {
    var obj = this.value();
    if (!obj) throw new Error('failed to parse near `' + this.str.slice(0, 10) + '...`');
    vals.push(obj);
  }

  return vals;
};
; 
if (false ) {} 

/***/ }),
/* 107 */,
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flip = flip;

var _convert = __webpack_require__(302);

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reduce(node, precision) {
  if (node.type === "MathExpression") return reduceMathExpression(node, precision);

  return node;
}

function isEqual(left, right) {
  return left.type === right.type && left.value === right.value;
}

function isValueType(type) {
  switch (type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
    case 'EmValue':
    case 'ExValue':
    case 'ChValue':
    case 'RemValue':
    case 'VhValue':
    case 'VwValue':
    case 'VminValue':
    case 'VmaxValue':
    case 'PercentageValue':
    case 'Value':
      return true;
  }
  return false;
}

function convertMathExpression(node, precision) {
  var nodes = (0, _convert2.default)(node.left, node.right, precision);
  var left = reduce(nodes.left, precision);
  var right = reduce(nodes.right, precision);

  if (left.type === "MathExpression" && right.type === "MathExpression") {

    if (left.operator === '/' && right.operator === '*' || left.operator === '-' && right.operator === '+' || left.operator === '*' && right.operator === '/' || left.operator === '+' && right.operator === '-') {

      if (isEqual(left.right, right.right)) nodes = (0, _convert2.default)(left.left, right.left, precision);else if (isEqual(left.right, right.left)) nodes = (0, _convert2.default)(left.left, right.right, precision);

      left = reduce(nodes.left, precision);
      right = reduce(nodes.right, precision);
    }
  }

  node.left = left;
  node.right = right;
  return node;
}

function flip(operator) {
  return operator === '+' ? '-' : '+';
}

function flipValue(node) {
  if (isValueType(node.type)) node.value = -node.value;else if (node.type == 'MathExpression') {
    node.left = flipValue(node.left);
    node.right = flipValue(node.right);
  }
  return node;
}

function reduceAddSubExpression(node, precision) {
  var _node = node,
      left = _node.left,
      right = _node.right,
      op = _node.operator;


  if (left.type === 'CssVariable' || right.type === 'CssVariable') return node;

  // something + 0 => something
  // something - 0 => something
  if (right.value === 0) return left;

  // 0 + something => something
  if (left.value === 0 && op === "+") return right;

  // 0 - something => -something
  if (left.value === 0 && op === "-") return flipValue(right);

  // value + value
  // value - value
  if (left.type === right.type && isValueType(left.type)) {
    node = Object.assign({}, left);
    if (op === "+") node.value = left.value + right.value;else node.value = left.value - right.value;
  }

  // value <op> (expr)
  if (isValueType(left.type) && (right.operator === '+' || right.operator === '-') && right.type === 'MathExpression') {
    // value + (value + something) => (value + value) + something
    // value + (value - something) => (value + value) - something
    // value - (value + something) => (value - value) - something
    // value - (value - something) => (value - value) + something
    if (left.type === right.left.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: 'MathExpression',
        operator: op,
        left: left,
        right: right.left
      }, precision);
      node.right = right.right;
      node.operator = op === '-' ? flip(right.operator) : right.operator;
      return reduce(node, precision);
    }
    // value + (something + value) => (value + value) + something
    // value + (something - value) => (value - value) + something
    // value - (something + value) => (value - value) - something
    // value - (something - value) => (value + value) - something
    else if (left.type === right.right.type) {
        node = Object.assign({}, node);
        node.left = reduce({
          type: 'MathExpression',
          operator: op === '-' ? flip(right.operator) : right.operator,
          left: left,
          right: right.right
        }, precision);
        node.right = right.left;
        return reduce(node, precision);
      }
  }

  // (expr) <op> value
  if (left.type === 'MathExpression' && (left.operator === '+' || left.operator === '-') && isValueType(right.type)) {
    // (value + something) + value => (value + value) + something
    // (value - something) + value => (value + value) - something
    // (value + something) - value => (value - value) + something
    // (value - something) - value => (value - value) - something
    if (right.type === left.left.type) {
      node = Object.assign({}, left);
      node.left = reduce({
        type: 'MathExpression',
        operator: op,
        left: left.left,
        right: right
      }, precision);
      return reduce(node, precision);
    }
    // (something + value) + value => something + (value + value)
    // (something - value1) + value2 => something - (value2 - value1)
    // (something + value) - value => something + (value - value)
    // (something - value) - value => something - (value + value)
    else if (right.type === left.right.type) {
        node = Object.assign({}, left);
        if (left.operator === '-') {
          node.right = reduce({
            type: 'MathExpression',
            operator: op === '-' ? '+' : '-',
            left: right,
            right: left.right
          }, precision);
          node.operator = op === '-' ? '-' : '+';
        } else {
          node.right = reduce({
            type: 'MathExpression',
            operator: op,
            left: left.right,
            right: right
          }, precision);
        }
        if (node.right.value < 0) {
          node.right.value *= -1;
          node.operator = node.operator === '-' ? '+' : '-';
        }
        return reduce(node, precision);
      }
  }
  return node;
}

function reduceDivisionExpression(node, precision) {
  if (!isValueType(node.right.type)) return node;

  if (node.right.type !== 'Value') throw new Error('Cannot divide by "' + node.right.unit + '", number expected');

  if (node.right.value === 0) throw new Error('Cannot divide by zero');

  // (expr) / value
  if (node.left.type === 'MathExpression') {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value /= node.right.value;
      node.left.right.value /= node.right.value;
      return reduce(node.left, precision);
    }
    return node;
  }
  // something / value
  else if (isValueType(node.left.type)) {
      node.left.value /= node.right.value;
      return node.left;
    }
  return node;
}

function reduceMultiplicationExpression(node) {
  // (expr) * value
  if (node.left.type === 'MathExpression' && node.right.type === 'Value') {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value *= node.right.value;
      node.left.right.value *= node.right.value;
      return node.left;
    }
  }
  // something * value
  else if (isValueType(node.left.type) && node.right.type === 'Value') {
      node.left.value *= node.right.value;
      return node.left;
    }
    // value * (expr)
    else if (node.left.type === 'Value' && node.right.type === 'MathExpression') {
        if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {
          node.right.left.value *= node.left.value;
          node.right.right.value *= node.left.value;
          return node.right;
        }
      }
      // value * something
      else if (node.left.type === 'Value' && isValueType(node.right.type)) {
          node.right.value *= node.left.value;
          return node.right;
        }
  return node;
}

function reduceMathExpression(node, precision) {
  node = convertMathExpression(node, precision);

  switch (node.operator) {
    case "+":
    case "-":
      return reduceAddSubExpression(node, precision);
    case "/":
      return reduceDivisionExpression(node, precision);
    case "*":
      return reduceMultiplicationExpression(node);
  }
  return node;
}

exports.default = reduce;; 
if (false ) {} 

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var createCustomError = __webpack_require__(91);
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

var SyntaxError = function(message, source, offset, line, column) {
    var error = createCustomError('SyntaxError', message);

    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

module.exports = SyntaxError;
; 
if (false ) {} 

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var EOF = 0;

// https://drafts.csswg.org/css-syntax-3/
// § 4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit(code) {
    return (
        isDigit(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace(code) {
    return isNewline(code) || code === 0x0020 || code === 0x0009;
}

// § 4.3.8. Check if two code points are a valid escape
function isValidEscape(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline(second) || second === EOF) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

// § 4.3.9. Check if three code points would start an identifier
function isIdentifierStart(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            isValidEscape(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape(first, second);
    }

    // anything else
    // Return false.
    return false;
}

// § 4.3.10. Check if three code points would start a number
function isNumberStart(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit(second) ? 2 : 0;
    }

    // digit
    if (isDigit(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
//
// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
var CATEGORY = new Array(0x80);
charCodeCategory.Eof = 0x80;
charCodeCategory.WhiteSpace = 0x82;
charCodeCategory.Digit = 0x83;
charCodeCategory.NameStart = 0x84;
charCodeCategory.NonPrintable = 0x85;

for (var i = 0; i < CATEGORY.length; i++) {
    switch (true) {
        case isWhiteSpace(i):
            CATEGORY[i] = charCodeCategory.WhiteSpace;
            break;

        case isDigit(i):
            CATEGORY[i] = charCodeCategory.Digit;
            break;

        case isNameStart(i):
            CATEGORY[i] = charCodeCategory.NameStart;
            break;

        case isNonPrintable(i):
            CATEGORY[i] = charCodeCategory.NonPrintable;
            break;

        default:
            CATEGORY[i] = i || charCodeCategory.Eof;
    }
}

function charCodeCategory(code) {
    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
};

module.exports = {
    isDigit: isDigit,
    isHexDigit: isHexDigit,
    isUppercaseLetter: isUppercaseLetter,
    isLowercaseLetter: isLowercaseLetter,
    isLetter: isLetter,
    isNonAscii: isNonAscii,
    isNameStart: isNameStart,
    isName: isName,
    isNonPrintable: isNonPrintable,
    isNewline: isNewline,
    isWhiteSpace: isWhiteSpace,
    isValidEscape: isValidEscape,
    isIdentifierStart: isIdentifierStart,
    isNumberStart: isNumberStart,

    isBOM: isBOM,
    charCodeCategory: charCodeCategory
};
; 
if (false ) {} 

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var createCustomError = __webpack_require__(91);
var generate = __webpack_require__(92);

function fromMatchResult(matchResult) {
    var tokens = matchResult.tokens;
    var longestMatch = matchResult.longestMatch;
    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
    var mismatchOffset = -1;
    var entries = 0;
    var css = '';

    for (var i = 0; i < tokens.length; i++) {
        if (i === longestMatch) {
            mismatchOffset = css.length;
        }

        if (node !== null && tokens[i].node === node) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += tokens[i].value;
    }

    return {
        node: node,
        css: css,
        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
        last: node === null || entries > 1
    };
}

function getLocation(node, point) {
    var loc = node && node.loc && node.loc[point];

    if (loc) {
        return {
            offset: loc.offset,
            line: loc.line,
            column: loc.column
        };
    }

    return null;
}

var SyntaxReferenceError = function(type, referenceName) {
    var error = createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

var MatchError = function(message, syntax, node, matchResult) {
    var error = createCustomError('SyntaxMatchError', message);
    var details = fromMatchResult(matchResult);
    var mismatchOffset = details.mismatchOffset || 0;
    var badNode = details.node || node;
    var end = getLocation(badNode, 'end');
    var start = details.last ? end : getLocation(badNode, 'start');
    var css = details.css;

    error.rawMessage = message;
    error.syntax = syntax ? generate(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.loc = {
        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
        start: start,
        end: end
    };
    error.line = start ? start.line : undefined;
    error.column = start ? start.column : undefined;
    error.offset = start ? start.offset : undefined;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (error.css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    return error;
};

module.exports = {
    SyntaxReferenceError: SyntaxReferenceError,
    MatchError: MatchError
};
; 
if (false ) {} 

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var MIN_SIZE = 16 * 1024;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

module.exports = function adoptBuffer(buffer, size) {
    if (buffer === null || buffer.length < size) {
        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
};
; 
if (false ) {} 

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var createCustomError = __webpack_require__(91);

module.exports = function SyntaxError(message, input, offset) {
    var error = createCustomError('SyntaxError', message);

    error.input = input;
    error.offset = offset;
    error.rawMessage = message;
    error.message = error.rawMessage + '\n' +
        '  ' + error.input + '\n' +
        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

    return error;
};
; 
if (false ) {} 

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

module.exports = function(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    var enter = noop;
    var leave = noop;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
    }

    if (enter === noop && leave === noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node, context);
};
; 
if (false ) {} 

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(94);

var MATCH = { type: 'Match' };
var MISMATCH = { type: 'Mismatch' };
var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
var LEFTPARENTHESIS = 40;  // (
var RIGHTPARENTHESIS = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match: match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ':
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            var result = MATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH
                );
            };

            return result;

        case '|':
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            var result = MISMATCH;
            var map = null;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map: map
                            },
                            MATCH,
                            result
                        );
                    }

                    if (map !== null) {
                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH,
                    result
                );
            };

            return result;

        case '&&':
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            var result = MISMATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;

        case '||':
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;
    }
}

function buildMultiplierMatchGraph(node) {
    var result = MATCH;
    var matchTerm = buildMatchGraph(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH
        );

        result.then = createCondition(
            MATCH,
            MATCH,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH,
                    MATCH,
                    result
                ),
                MISMATCH
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH,
            MATCH,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH
            );
        }
    }

    return result;
}

function buildMatchGraph(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group':
            var result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraph),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY,
                    MISMATCH
                );
            }

            return result;

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

module.exports = {
    MATCH: MATCH,
    MISMATCH: MISMATCH,
    DISALLOW_EMPTY: DISALLOW_EMPTY,
    buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === 'string') {
            syntaxTree = parse(syntaxTree);
        }

        return {
            type: 'MatchGraph',
            match: buildMatchGraph(syntaxTree),
            syntax: ref || null,
            source: syntaxTree
        };
    }
};
; 
if (false ) {} 

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var cmpChar = __webpack_require__(16).cmpChar;
var cmpStr = __webpack_require__(16).cmpStr;
var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var STRING = TYPE.String;
var NUMBER = TYPE.Number;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var HASH = TYPE.Hash;
var DIMENSION = TYPE.Dimension;
var PERCENTAGE = TYPE.Percentage;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var COMMA = TYPE.Comma;
var DELIM = TYPE.Delim;
var NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)
var ASTERISK = 0x002A;    // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)
var U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

module.exports = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case HASH:
            return this.Hash();

        case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING:
            return this.String();

        case DIMENSION:
            return this.Dimension();

        case PERCENTAGE:
            return this.Percentage();

        case NUMBER:
            return this.Number();

        case FUNCTION:
            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case URL:
            return this.Url();

        case IDENT:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            if (code === SOLIDUS ||
                code === ASTERISK ||
                code === PLUSSIGN ||
                code === HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === NUMBERSIGN) {
                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
            }

            break;
    }
};
; 
if (false ) {} 

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: function selectorList() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var ALLOW_OF_CLAUSE = true;

module.exports = {
    parse: function nthWithOfClause() {
        return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var DISALLOW_OF_CLAUSE = false;

module.exports = {
    parse: function nth() {
        return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iOSNativeHelper", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["m"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layout", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["s"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatchToMainThread", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMainThread", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["q"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RESOURCE_PREFIX", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FILE_PREFIX", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "escapeRegexSymbols", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertString", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModuleName", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFileOrResourcePath", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["o"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFontIconURI", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDataURI", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["n"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeSort", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["v"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["u"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasDuplicates", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eliminateDuplicates", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "executeOnMainThread", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["j"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mainThreadify", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["t"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Source", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "openFile", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["w"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GC", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "releaseNativeObject", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["y"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "openUrl", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["x"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRealDevice", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["r"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ad", function() { return _index__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/**
 * A lot of plugins still used utils/utils
 * Left here for convenience (over time can eventually remove these)
 */

//# sourceMappingURL=utils.ios.js.map; 
if (false ) {} 

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**********************************************************************************
 * (c) 2016-2020, Master Technology
 * Licensed under the MIT license or contact me for a Support or Commercial License
 *
 * I do contract work in most languages, so let me solve your problems!
 *
 * Any questions please feel free to email me or put a issue up on the github repo
 * Version 2.5.0                                      Nathan@master-technology.com
 *********************************************************************************/


/* jshint camelcase: false */
/* global global, require, UIDevice, UIDeviceOrientation, UIView, getElementsByTagName, android */

const application = __webpack_require__(30);
const viewbase = __webpack_require__(15);
const enums = __webpack_require__(32);
const frame = __webpack_require__(12);
const Page = __webpack_require__(84).Page;

// Load the helper plugins
__webpack_require__(412);

let allowRotation = true, forceRotation = false, fullScreen = false, abHidden=false, displayedWarning=false;
let orientation = { };
let orientationAppliers = [];

module.exports = orientation;

/**
 * Function to add a new orientation applier callback
 */
orientation.addOrientationApplier = function(newOrientationApplier) {
    if (!newOrientationApplier) return;

    const existingApplier = orientationAppliers.find(function(oa) { return oa === newOrientationApplier; });
    if (existingApplier) return;

    orientationAppliers.push(newOrientationApplier);
};

/**
 * Function to remove an orientation applier callback
 */
orientation.removeOrientationApplier = function(orientationApplier) {
    if (!orientationApplier) return;

    orientationAppliers = orientationAppliers.filter(function (oa) { return oa !== orientationApplier; });
};

orientation.getRotationLocked = function() { return !allowRotation; };


/**
 * Helper function hooked to the Application to get the current orientation
 */
if (global.android) {
	orientation.getOrientation = function () {
        const context = getContext();

        // These both lie on Tablets, The orientation is opposite, so it is safer to use .orientation value
        // context.getSystemService("window").getDefaultDisplay().getOrientation();
        // context.getSystemService("window").getDefaultDisplay().getRotation();

        const currentOrientation = getContext().getResources().getConfiguration().orientation;

        switch (currentOrientation) {
            case 2: /* LANDSCAPE */
                return enums.DeviceOrientation.landscape;
            case 1: /* PORTRAIT */
                return enums.DeviceOrientation.portrait;
            default:
                break;
        }


        // If for some reason the orientation code above doesn't figure it out; we use sizes
        const metrics = new android.util.DisplayMetrics();
        context.getSystemService(android.content.Context.WINDOW_SERVICE).getDefaultDisplay().getRealMetrics(metrics);
        if (metrics.widthPixels > metrics.heightPixels) {
            return enums.DeviceOrientation.landscape;
        }
        return enums.DeviceOrientation.portrait;

    };

	orientation.enableRotation = function() {
		if (!application.android || !application.android.foregroundActivity) {
			setTimeout(orientation.enableRotation, 100);
			return;
		}

		const activity = application.android.foregroundActivity;
		activity.setRequestedOrientation(13);  // SCREEN_ORIENTATION_FULL_USER = 13
		allowRotation = true;
	};

	orientation.disableRotation = function() {
		if (!application.android || !application.android.foregroundActivity) {
			setTimeout(orientation.disableRotation, 100);
			return;
		}

		const activity = application.android.foregroundActivity;
        activity.setRequestedOrientation(14); // SCREEN_ORIENTATION_LOCKED = 14
		allowRotation = false;
	};

	orientation.setOrientation = function(value, animation) {
		if (!application.android || !application.android.foregroundActivity) {
			setTimeout(function() { orientation.setOrientation(value, animation); }, 100);
			return;
		}

		const activity = application.android.foregroundActivity;

		const val = value.toLowerCase();
		let newOrientation;
		switch (val) {
			case 'landscape':
				newOrientation = 6; // SCREEN_ORIENTATION_SENSOR_LANDSCAPE = 6
                break;

			case 'landscaperight':
				newOrientation = 0; // SCREEN_ORIENTATION_LANDSCAPE = 0
				break;

			case 'landscapeleft':
				newOrientation = 8; // SCREEN_ORIENTATION_REVERSE_LANDSCAPE = 9
				break;

			case 'portrait':
			default:
				newOrientation = 1; // SCREEN_ORIENTATION_PORTRAIT = 1
				break;
		}
		activity.setRequestedOrientation(newOrientation);
		allowRotation = false;

		// Animation: https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#ROTATION_ANIMATION_JUMPCUT
		// and https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#rotationAnimation

	};

	orientation.setFullScreen = function(value) {

            const View = android.view.View;
            const WindowManager = android.view.WindowManager;
            const window = application.android.startActivity.getWindow();

            fullScreen = !!value;

            if (fullScreen) {
                window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
                window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                        | View.SYSTEM_UI_FLAG_FULLSCREEN
                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY );
            } else {
                    window.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
                    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
            }
/*
            if (fullScreen) {
                if (!topmost().currentPage.actionBarHidden && !abHidden) {
                    abHidden = true;
                    topmost().currentPage.actionBarHidden = true;
                }
            } else if (abHidden) {
                abHidden = false;
                topmost().currentPage.actionBarHidden = false;
            }
*/
    };

} else if (global.NSObject && global.UIDevice) {

	setupiOSController();
	orientation.getOrientation = function () {
		const device = UIDevice.currentDevice;

		switch (device.orientation) {
			case UIDeviceOrientation.UIDeviceOrientationLandscapeRight:
			case UIDeviceOrientation.UIDeviceOrientationLandscapeLeft:
				return enums.DeviceOrientation.landscape;
			case UIDeviceOrientation.UIDeviceOrientationPortraitUpsideDown:
			case UIDeviceOrientation.UIDeviceOrientationPortrait:
				return enums.DeviceOrientation.portrait;
			default:
				// Since we have a up/Down orientation, we need to see what the statusbar is set to to get the actual current device orientation
				const appOrientation = UIApplication.sharedApplication.statusBarOrientation;
				if (appOrientation === 1 || appOrientation === 2) { return enums.DeviceOrientation.portrait; }
				else { return enums.DeviceOrientation.landscape; }
		}
	};

	orientation.setOrientation = function(value, animation) {
		let newOrientation, val = value.toLowerCase();
		if (val === 'landscape' || val === 'landscaperight') {
			newOrientation = NSNumber.numberWithInt(UIInterfaceOrientationLandscapeRight);
		} else if (val === 'landscapeleft') {
			newOrientation = NSNumber.numberWithInt(UIInterfaceOrientationLandscapeLeft);
		} else {
			newOrientation = NSNumber.numberWithInt(UIInterfaceOrientationPortrait);
		}
		const device = UIDevice.currentDevice;
		if (animation === false) {
			UIView.setAnimationsEnabled(false);
		}
		allowRotation = false; // disable rotations...

		forceRotation = true;
		const currentOrientation = device.orientation;
		// We have to swap to a different orientation FIRST, if the current orientation matches

		// This code seems to be now broken on iPAD's under the new OS versions, we are disabling but commenting it because
		// see https://git.proplugins.org/proplugins/nativescript-orientation/issues/1
		// this code was needed in the past, so we are just commenting it out in case we can figure out what instances this was actually needed.
		/*		if (newOrientation === currentOrientation) {
			let tempOrientation = newOrientation-1;
			if (tempOrientation < 1) { tempOrientation += 2; }
			device.setValueForKey(tempOrientation, "orientation");
		} */


		device.setValueForKey(newOrientation, "orientation");
		forceRotation = false;


		if (animation === false) {
			UIView.setAnimationsEnabled(true);
		}
	};

	orientation.enableRotation = function() { allowRotation = true; };

	orientation.disableRotation = function() { allowRotation = false; };

	orientation.setFullScreen = function(setFullScreen) {
	    fullScreen = !!setFullScreen;
	    UIApplication.sharedApplication.setStatusBarHiddenWithAnimation(fullScreen, UIStatusBarAnimation.Slide);
    };

	let resetLandscapedLock = false;
	application.on('suspend', function() {
		if (allowRotation === false && orientation.getOrientation() === 'landscape') {
			allowRotation = true;
			resetLandscapedLock = true;
		}
	});

	application.on('resume', function() {
		if (resetLandscapedLock) {
			resetLandscapedLock = false;
			orientation.setOrientation('landscape',false);
		}
	});


}

// Depreciated; but supported for backwards compatibility
application.getOrientation = orientation.getOrientation;


/**
 * Searchs for a prototype in the prototype chain
 * @param source - Source element
 * @param name - the name of the element
 * @returns {*}
 */
function findRootPrototype(source, name) {
	let proto = source;
	do {
		proto = Object.getPrototypeOf(proto);
	} while (proto !== null && !proto.hasOwnProperty(name) );
	return proto;
}

/**
 * Sets up the iOS Controller configuration
 */
function setupiOSController() {
	const curFrame = topmost();
	if (!curFrame) {
		setTimeout(setupiOSController, 100);
		return;
	}

	try {

		const app = curFrame.ios.controller;
		const proto = findRootPrototype(app, "shouldAutorotate");
		if (proto ===  null) {
			console.log("Unable to find rotations system, disabling orientation system.");
			return;
		}
		Object.defineProperty(proto, "shouldAutorotate", {
			get: function() {
				//console.log("Should rotate", forceRotation, allowRotation);
				return forceRotation || allowRotation;
			}, enumerable: true, configurable: true
		});
	} catch (err) {
		console.log("Unable to setup Rotation",err);
	}
}

/**
 * Helper function to look for children that have refresh (i.e. like ListView's) and call their refresh since the
 * CSS changes will probably impact them
 * @param child
 * @returns {boolean}
 */
function resetChildrenRefreshes(child) {
	if (typeof child.refresh === 'function') {
		child.refresh();
	}
	return true;
}

/**
 * Function that does the majority of the work
 * @param page
 * @param args
 */
const applyOrientationToPage = function(page, args){
	let currentOrientation = orientation.getOrientation();
	if (!displayedWarning) {
		console.warn("[nativescript-orientation] .landscape rule is depreciated; use .ns-landscape instead.")
		displayedWarning=true;
	}

	// If somehow we didn't get the orientation we don't do anything!
	if (!currentOrientation) return;

	// Check what the current rotation vs the existing page rotation is
	const isLandscape = currentOrientation === enums.DeviceOrientation.landscape;
	if (!args || !args.force) {
		const containsLandScape = page.classList.contains("landscape");

		// No need to run the swap if it already has the correct orientation
		if (isLandscape === containsLandScape) { return; }
	}

	// Change Orientation
	page.classList.toggle('landscape', isLandscape);

	// Unfortunately there is a bug in the NS CSS parser, so we have to work around it
	let i;
	if (page.classList.contains('android')) {
		for (i=0;i<page.classList.length;i++) {
			if (page.classList[i].indexOf('android') === 0) {
				if (page.classList[i].indexOf('.') >= 0) { continue; }
				page.classList.toggle(page.classList[i]+".landscape", isLandscape);
			}
		}
	} else if (page.classList.contains('ios')) {
		for (i=0;i<page.classList.length;i++) {
			if (page.classList[i].indexOf('ios') === 0) {
				if (page.classList[i].indexOf('.') >= 0) { continue; }
				page.classList.toggle(page.classList[i]+".landscape", isLandscape);
			}
		}
	} else if (page.classList.contains('windows')) {
		page.classList.toggle('windows.landscape', isLandscape);
	}
	// --- End NS Bug Patch ---

    // _refreshCSS will verify against the Scope to make sure all the correct styles are
    // applied. If they are already applied, it will short circuit and not
    // do anything more.
    if (typeof page._refreshCss === 'function') {
	    // TNS 3.2-
        page._refreshCss();
    } else {
	    // TNS 3.3+
	    page._onCssStateChange();
    }

	if (args != null) {
		viewbase.eachDescendant(page, resetChildrenRefreshes);
	}
	if (page.exports && typeof page.exports.orientation === "function") {
		page.exports.orientation({landscape: isLandscape, object: page});
	}

	callOrientationAppliers(page, isLandscape);
};

/**
 * This handles an Orientation change event
 * @param args
 */
function handleOrientationChange(args) {
	// If the topmost frame doesn't exist we can't do anything...
	if (!topmost()) { return; }
	const currentPage = topmost().currentPage;

	if (currentPage) {
		applyOrientationToPage(currentPage, args);
	}
}

function handleNavigatingTo(args) {
    const targetPage = args.object;
	if (targetPage){
		applyOrientationToPage(targetPage, {force: true});
	}
}

function callOrientationAppliers(page, isLandscape) {
    if (!orientationAppliers || orientationAppliers.length <= 0) { return; }

    for (let i=0;i<orientationAppliers.length;i++) {
    	orientationAppliers[i]({landscape: isLandscape, object: page});
	}
}

function getContext() {
	let ctx = java.lang.Class.forName("android.app.AppGlobals").getMethod("getInitialApplication", null).invoke(null, null);
	if (ctx) { return ctx; }

	return java.lang.Class.forName("android.app.ActivityThread").getMethod("currentApplication", null).invoke(null, null);
}

/**
 * Deal with NS 6.x "warning" changes
 * @returns {*}
 */
function topmost() {
	return frame.Frame && frame.Frame.topmost ? frame.Frame.topmost() : frame.topmost();
}


// Setup Events
console.log(Page.navigatingToEvent)
Page.on(Page.navigatingToEvent, handleNavigatingTo);
application.on(application.orientationChangedEvent, handleOrientationChange);

; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(21);
var frame = __webpack_require__(12);

var _determineAvailability = function () {
  var isSimulator = NSProcessInfo.processInfo.environment.objectForKey("SIMULATOR_DEVICE_NAME") !== null;

  if (isSimulator) {
    console.log("Email is not available on the Simulator");
  }

  return !isSimulator && MFMailComposeViewController.canSendMail();
};

exports.available = function () {
  return new Promise(function (resolve, reject) {
    try {
      resolve(_determineAvailability());
    } catch (ex) {
      console.log("Error in email.available: " + ex);
      reject(ex);
    }
  });
};

exports.compose = function (arg) {
  return new Promise(function (resolve, reject) {
    try {

      if (!_determineAvailability()) {
        reject("No mail available");
        return;
      }

      var topMostFrame = frame.topmost();
      if (topMostFrame) {
        var viewController = topMostFrame.currentPage && topMostFrame.currentPage.ios;
        if (viewController) {
          while (viewController.parentViewController) {
            viewController = viewController.parentViewController;
          }
          while (viewController.presentedViewController) {
            viewController = viewController.presentedViewController;
          }
        }
      }

      var mail = MFMailComposeViewController.new();

      var message = arg.body;
      if (message) {
        var messageAsNSString = NSString.stringWithString(message);
        var isHTML = messageAsNSString.rangeOfStringOptions("<[^>]+>", NSRegularExpressionSearch).location !== NSNotFound;
        mail.setMessageBodyIsHTML(arg.body, isHTML);
      }
      mail.setSubject(arg.subject);
      mail.setToRecipients(arg.to);
      mail.setCcRecipients(arg.cc);
      mail.setBccRecipients(arg.bcc);

      if (arg.attachments) {
        for (var a in arg.attachments) {
          var attachment = arg.attachments[a];
          var path = attachment.path;
          var data = _getDataForAttachmentPath(path);
          if (data === null) {
            reject("File not found for path: " + path);
            return;
          } else if (!attachment.fileName) {
            console.log("attachment.fileName is mandatory");
          } else if (!attachment.mimeType) {
            console.log("attachment.mimeType is mandatory");
          } else {
            mail.addAttachmentDataMimeTypeFileName(
                data, attachment.mimeType, attachment.fileName);
          }
        }
      }

      // Assign first to local variable, otherwise it will be garbage collected since delegate is weak reference.
      var delegate = MFMailComposeViewControllerDelegateImpl.new().initWithCallback(function (result, error) {
        // invoke the callback / promise
        resolve(result === MFMailComposeResult.Sent);
        // close the mail
        viewController.dismissViewControllerAnimatedCompletion(true, null);
        // release the delegate instance
        CFRelease(delegate);
      });

      // retain the delegate because the mailComposeDelegate property won't do it for us
      CFRetain(delegate);

      mail.mailComposeDelegate = delegate;

      viewController.presentViewControllerAnimatedCompletion(mail, true, null);

    } catch (ex) {
      console.log("Error in email.compose: " + ex);
      reject(ex);
    }
  });
};

function _getDataForAttachmentPath(path) {
  var data = null;
  if (path.indexOf("file:///") === 0) {
    data = _dataForAbsolutePath(path);
  } else if (path.indexOf("file://") === 0) {
    data = _dataForAsset(path);
  } else if (path.indexOf("base64:") === 0) {
    data = _dataFromBase64(path);
  } else {
    var fileManager = NSFileManager.defaultManager;
    if (fileManager.fileExistsAtPath(path)) {
      data = fileManager.contentsAtPath(path);
    }
  }
  return data;
}

function _dataFromBase64(base64String) {
  base64String = base64String.substring(base64String.indexOf("://") + 3);
  return NSData.alloc().initWithBase64EncodedStringOptions(base64String, 0);
}

function _dataForAsset(path) {
  path = path.replace("file://", "/");

  if (!fs.File.exists(path)) {
    console.log("File does not exist: " + path);
    return null;
  }

  var localFile = fs.File.fromPath(path);
  return localFile.readSync(function (e) {
    error = e;
  });
}

function _dataForAbsolutePath(path) {
  var fileManager = NSFileManager.defaultManager;
  var absPath = path.replace("file://", "");

  if (!fileManager.fileExistsAtPath(absPath)) {
    console.log("File not found: " + absPath);
    return null;
  }

  return fileManager.contentsAtPath(absPath);
}

var MFMailComposeViewControllerDelegateImpl = (function (_super) {
  __extends(MFMailComposeViewControllerDelegateImpl, _super);

  function MFMailComposeViewControllerDelegateImpl() {
    _super.apply(this, arguments);
  }

  MFMailComposeViewControllerDelegateImpl.new = function () {
    return _super.new.call(this);
  };
  MFMailComposeViewControllerDelegateImpl.prototype.initWithCallback = function (callback) {
    this._callback = callback;
    return this;
  };
  MFMailComposeViewControllerDelegateImpl.prototype.mailComposeControllerDidFinishWithResultError = function (controller, result, error) {
    this._callback(result, error);
  };
  MFMailComposeViewControllerDelegateImpl.ObjCProtocols = [MFMailComposeViewControllerDelegate];
  return MFMailComposeViewControllerDelegateImpl;
})(NSObject);
; 
if (false ) {} 

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dial", function() { return dial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sms", function() { return sms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestCallPermission", function() { return requestCallPermission; });
// @ts-check
/// <reference path="./node_modules/tns-platform-declarations/ios.d.ts" />

var frameModule = __webpack_require__(12);
// @ts-ignore
var CustomMFMessageComposeViewControllerDelegate = NSObject.extend(
  {
    initWithResolveReject: function (resolve, reject) {
      var self = this.super.init();
      if (self) {
        this.resolve = resolve;
        this.reject = reject;
      }
      return self;
    },
    messageComposeViewControllerDidFinishWithResult: function (
      controller,
      result
    ) {
      controller.dismissModalViewControllerAnimated(true);

      if (result === MessageComposeResult.Cancelled) {
        this.resolve({
          response: 'cancelled',
        });
      } else if (result === MessageComposeResult.Sent) {
        this.resolve({
          response: 'success',
        });
      } else {
        this.resolve({
          response: 'failed',
        });
      }
      CFRelease(controller.messageComposeDelegate);
    },
  },
  {
    name: 'CustomMFMessageComposeViewControllerDelegate',
    protocols: [MFMessageComposeViewControllerDelegate],
  }
);

function dial(telNum, prompt) {
  var sURL = 'tel://';

  if (prompt) {
    sURL = 'telprompt:';
  }

  var url = NSURL.URLWithString(sURL + telNum);

  if (UIApplication.sharedApplication.canOpenURL(url)) {
    UIApplication.sharedApplication.openURL(url);
    return true;
  } else {
    //alert("Unable to dial");
    return false;
  }
}

function sms(smsNum, messageText) {
  return new Promise(function (resolve, reject) {
    if (!Array.isArray(smsNum)) {
      smsNum = [smsNum];
    }

    var page = frameModule.topmost().ios.controller;
    var controller = MFMessageComposeViewController.alloc().init();
    var delegate = CustomMFMessageComposeViewControllerDelegate.alloc().initWithResolveReject(
      resolve,
      reject
    );

    CFRetain(delegate);
    controller.messageComposeDelegate = delegate;

    if (MFMessageComposeViewController.canSendText()) {
      controller.body = messageText;
      controller.recipients = smsNum;
      page.presentModalViewControllerAnimated(controller, true);
    } else {
      reject('Cannot Send SMS!');
    }
  });
}

function requestCallPermission(explanation) {
  return new Promise(function (resolve) {
    resolve('N/A');
  });
}
; 
if (false ) {} 

/***/ }),
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcssValueParser = __webpack_require__(296);

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _parser = __webpack_require__(301);

var _reducer = __webpack_require__(108);

var _reducer2 = _interopRequireDefault(_reducer);

var _stringifier = __webpack_require__(304);

var _stringifier2 = _interopRequireDefault(_stringifier);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
var MATCH_CALC = /((?:\-[a-z]+\-)?calc)/;

exports.default = function (value) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  return (0, _postcssValueParser2.default)(value).walk(function (node) {
    // skip anything which isn't a calc() function
    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) return;

    // stringify calc expression and produce an AST
    var contents = _postcssValueParser2.default.stringify(node.nodes);

    // skip constant() and env()
    if (contents.indexOf('constant') >= 0 || contents.indexOf('env') >= 0) return;

    var ast = _parser.parser.parse(contents);

    // reduce AST to its simplest form, that is, either to a single value
    // or a simplified calc expression
    var reducedAst = (0, _reducer2.default)(ast, precision);

    // stringify AST and write it back
    node.type = 'word';
    node.value = (0, _stringifier2.default)(node.value, reducedAst, precision);
  }, true).toString();
};

module.exports = exports['default'];; 
if (false ) {} 

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(305);
; 
if (false ) {} 

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssTreeParse = void 0;
var css_tree_1 = __webpack_require__(306);
function mapSelectors(selector) {
    if (!selector) {
        return [];
    }
    return selector.split(/\s*(?![^(]*\)),\s*/).map(function (s) { return s.replace(/\u200C/g, ','); });
}
function mapPosition(node, css) {
    var res = {
        start: {
            line: node.loc.start.line,
            column: node.loc.start.column,
        },
        end: {
            line: node.loc.end.line,
            column: node.loc.end.column,
        },
        content: css,
    };
    if (node.loc.source && node.loc.source !== '<unknown>') {
        res.source = node.loc.source;
    }
    return res;
}
function transformAst(node, css, type) {
    if (type === void 0) { type = null; }
    if (!node) {
        return;
    }
    if (node.type === 'StyleSheet') {
        return {
            type: 'stylesheet',
            stylesheet: {
                rules: node.children
                    .map(function (child) { return transformAst(child, css); })
                    .filter(function (child) { return child !== null; })
                    .toArray(),
                parsingErrors: [],
            },
        };
    }
    if (node.type === 'Atrule') {
        var atrule = {
            type: node.name,
        };
        if (node.name === 'supports' || node.name === 'media') {
            atrule[node.name] = node.prelude.value;
            atrule.rules = transformAst(node.block, css);
        }
        else if (node.name === 'page') {
            atrule.selectors = node.prelude ? mapSelectors(node.prelude.value) : [];
            atrule.declarations = transformAst(node.block, css);
        }
        else if (node.name === 'document') {
            atrule.document = node.prelude ? node.prelude.value : '';
            atrule.vendor = '';
            atrule.rules = transformAst(node.block, css);
        }
        else if (node.name === 'font-face') {
            atrule.declarations = transformAst(node.block, css);
        }
        else if (node.name === 'import' || node.name === 'charset' || node.name === 'namespace') {
            atrule[node.name] = node.prelude ? node.prelude.value : '';
        }
        else if (node.name === 'keyframes') {
            atrule.name = node.prelude ? node.prelude.value : '';
            atrule.keyframes = transformAst(node.block, css, 'keyframe');
            atrule.vendor = undefined;
        }
        else {
            atrule.rules = transformAst(node.block, css);
        }
        atrule.position = mapPosition(node, css);
        return atrule;
    }
    if (node.type === 'Block') {
        return node.children
            .map(function (child) { return transformAst(child, css, type); })
            .filter(function (child) { return child !== null; })
            .toArray();
    }
    if (node.type === 'Rule') {
        var value = node.prelude.value;
        var res = {
            type: type != null ? type : 'rule',
            declarations: transformAst(node.block, css),
            position: mapPosition(node, css),
        };
        if (type === 'keyframe') {
            res.values = mapSelectors(value);
        }
        else {
            res.selectors = mapSelectors(value);
        }
        return res;
    }
    if (node.type === 'Comment') {
        return {
            type: 'comment',
            comment: node.value,
            position: mapPosition(node, css),
        };
    }
    if (node.type === 'Declaration') {
        return {
            type: 'declaration',
            property: node.property,
            value: node.value.value ? node.value.value.trim() : '',
            position: mapPosition(node, css),
        };
    }
    if (node.type === 'Raw') {
        return null;
    }
    throw Error("Unknown node type " + node.type);
}
function cssTreeParse(css, source) {
    var errors = [];
    var ast = css_tree_1.parse(css, {
        parseValue: false,
        parseAtrulePrelude: false,
        parseRulePrelude: false,
        positions: true,
        filename: source,
        onParseError: function (error) {
            errors.push(source + ":" + error.line + ":" + error.column + ": " + error.formattedMessage);
        },
    });
    if (errors.length > 0) {
        throw new Error(errors[0]);
    }
    return transformAst(ast, css);
}
exports.cssTreeParse = cssTreeParse;
//# sourceMappingURL=css-tree-parser.js.map; 
if (false ) {} 

/***/ }),
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const loadCss = __webpack_require__(294);

module.exports = function() {
    loadCss(function() {
        const appCssContext = __webpack_require__(120);
        global.registerWebpackModules(appCssContext);
    });
}
; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function (loadModuleFn) {
    const nsCore = __webpack_require__(29);
    __webpack_require__(50);

    loadModuleFn();

    nsCore.Application.loadAppCss();
}
; 
if (false ) {} 

/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}
; 
if (false ) {} 

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(297);
var walk = __webpack_require__(298);
var stringify = __webpack_require__(299);

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = __webpack_require__(300);

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;
; 
if (false ) {} 

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next, quote, prev, token, escape, escapePos, whitespacePos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash && value.charCodeAt(next + 1) !== star)
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);

      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };

      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(pos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (pos !== whitespacePos + 1) {
          token.nodes = [
            {
              type: "word",
              sourceIndex: pos,
              value: value.slice(pos, whitespacePos + 1)
            }
          ];
        } else {
          token.nodes = [];
        }
        if (token.unclosed && whitespacePos + 1 !== next) {
          token.after = "";
          token.nodes.push({
            type: "space",
            sourceIndex: whitespacePos + 1,
            value: value.slice(whitespacePos + 1, next)
          });
        } else {
          token.after = value.slice(whitespacePos + 1, next);
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }

  return stack[0].nodes;
};
; 
if (false ) {} 

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};
; 
if (false ) {} 

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;
; 
if (false ) {} 

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var dotted = false;
  var sciPos = -1;
  var containsNumber = false;
  var code;

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code >= 48 && code <= 57) {
      containsNumber = true;
    } else if (code === exp || code === EXP) {
      if (sciPos > -1) {
        break;
      }
      sciPos = pos;
    } else if (code === dot) {
      if (dotted) {
        break;
      }
      dotted = true;
    } else if (code === plus || code === minus) {
      if (pos !== 0) {
        break;
      }
    } else {
      break;
    }

    pos += 1;
  }

  if (sciPos + 1 === pos) pos--;

  return containsNumber
    ? {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      }
    : false;
};
; 
if (false ) {} 

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {


/* parser generated by jison 0.6.1-215 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var parser = (function () {


// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';




        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. ["classic","merge"]
    //   test-compile action mode: ........ "parser:*,lexer:*"
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "$accept": 0,
  "$end": 1,
  "ADD": 3,
  "ANGLE": 14,
  "CHS": 20,
  "CSS_VAR": 12,
  "DIV": 6,
  "EMS": 18,
  "EOF": 1,
  "EXS": 19,
  "FREQ": 16,
  "LENGTH": 13,
  "LPAREN": 7,
  "MUL": 5,
  "NESTED_CALC": 9,
  "NUMBER": 11,
  "PERCENTAGE": 26,
  "PREFIX": 10,
  "REMS": 21,
  "RES": 17,
  "RPAREN": 8,
  "SUB": 4,
  "TIME": 15,
  "VHS": 22,
  "VMAXS": 25,
  "VMINS": 24,
  "VWS": 23,
  "css_value": 31,
  "css_variable": 30,
  "error": 2,
  "expression": 27,
  "math_expression": 28,
  "value": 29
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ADD",
  4: "SUB",
  5: "MUL",
  6: "DIV",
  7: "LPAREN",
  8: "RPAREN",
  9: "NESTED_CALC",
  10: "PREFIX",
  11: "NUMBER",
  12: "CSS_VAR",
  13: "LENGTH",
  14: "ANGLE",
  15: "TIME",
  16: "FREQ",
  17: "RES",
  18: "EMS",
  19: "EXS",
  20: "CHS",
  21: "REMS",
  22: "VHS",
  23: "VWS",
  24: "VMINS",
  25: "VMAXS",
  26: "PERCENTAGE"
},
TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0,      // INTERNAL USE ONLY
    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        }
        else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [
                this.state_descriptions_[state]
            ];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
productions_: bp({
  pop: u([
  27,
  s,
  [28, 10],
  29,
  29,
  30,
  s,
  [31, 15]
]),
  rule: u([
  2,
  s,
  [3, 5],
  4,
  7,
  s,
  [1, 4],
  2,
  s,
  [1, 15],
  2
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : expression $end */

    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    expression : math_expression EOF */

    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)
    
    
    return yyvstack[yysp - 1];
    break;

case 2:
    /*! Production::    math_expression : math_expression ADD math_expression */
case 3:
    /*! Production::    math_expression : math_expression SUB math_expression */
case 4:
    /*! Production::    math_expression : math_expression MUL math_expression */
case 5:
    /*! Production::    math_expression : math_expression DIV math_expression */

    this.$ = { type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
    break;

case 6:
    /*! Production::    math_expression : LPAREN math_expression RPAREN */
case 7:
    /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */
case 8:
    /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */

    this.$ = yyvstack[yysp - 1];
    break;

case 9:
    /*! Production::    math_expression : css_variable */
case 10:
    /*! Production::    math_expression : css_value */
case 11:
    /*! Production::    math_expression : value */

    this.$ = yyvstack[yysp];
    break;

case 12:
    /*! Production::    value : NUMBER */

    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) };
    break;

case 13:
    /*! Production::    value : SUB NUMBER */

    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) * -1 };
    break;

case 14:
    /*! Production::    css_variable : CSS_VAR */

    this.$ = { type: 'CssVariable', value: yyvstack[yysp] };
    break;

case 15:
    /*! Production::    css_value : LENGTH */

    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 16:
    /*! Production::    css_value : ANGLE */

    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 17:
    /*! Production::    css_value : TIME */

    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 18:
    /*! Production::    css_value : FREQ */

    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 19:
    /*! Production::    css_value : RES */

    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 20:
    /*! Production::    css_value : EMS */

    this.$ = { type: 'EmValue', value: parseFloat(yyvstack[yysp]), unit: 'em' };
    break;

case 21:
    /*! Production::    css_value : EXS */

    this.$ = { type: 'ExValue', value: parseFloat(yyvstack[yysp]), unit: 'ex' };
    break;

case 22:
    /*! Production::    css_value : CHS */

    this.$ = { type: 'ChValue', value: parseFloat(yyvstack[yysp]), unit: 'ch' };
    break;

case 23:
    /*! Production::    css_value : REMS */

    this.$ = { type: 'RemValue', value: parseFloat(yyvstack[yysp]), unit: 'rem' };
    break;

case 24:
    /*! Production::    css_value : VHS */

    this.$ = { type: 'VhValue', value: parseFloat(yyvstack[yysp]), unit: 'vh' };
    break;

case 25:
    /*! Production::    css_value : VWS */

    this.$ = { type: 'VwValue', value: parseFloat(yyvstack[yysp]), unit: 'vw' };
    break;

case 26:
    /*! Production::    css_value : VMINS */

    this.$ = { type: 'VminValue', value: parseFloat(yyvstack[yysp]), unit: 'vmin' };
    break;

case 27:
    /*! Production::    css_value : VMAXS */

    this.$ = { type: 'VmaxValue', value: parseFloat(yyvstack[yysp]), unit: 'vmax' };
    break;

case 28:
    /*! Production::    css_value : PERCENTAGE */

    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%' };
    break;

case 29:
    /*! Production::    css_value : SUB css_value */

    var prev = yyvstack[yysp]; prev.value *= -1; this.$ = prev;
    break;

}
},
table: bt({
  len: u([
  24,
  1,
  5,
  23,
  1,
  18,
  s,
  [0, 20],
  s,
  [23, 4],
  c,
  [28, 3],
  0,
  0,
  16,
  6,
  6,
  s,
  [0, 3],
  5,
  1,
  0,
  1,
  23,
  5,
  0
]),
  symbol: u([
  4,
  7,
  9,
  s,
  [11, 21, 1],
  1,
  1,
  s,
  [3, 4, 1],
  c,
  [30, 19],
  c,
  [29, 4],
  7,
  4,
  10,
  11,
  c,
  [22, 14],
  31,
  c,
  [42, 23],
  c,
  [23, 69],
  c,
  [138, 4],
  8,
  c,
  [51, 24],
  4,
  c,
  [137, 15],
  c,
  [184, 5],
  8,
  c,
  [6, 6],
  c,
  [5, 5],
  9,
  7,
  c,
  [87, 28]
]),
  type: u([
  s,
  [2, 19],
  s,
  [0, 5],
  1,
  s,
  [2, 24],
  s,
  [0, 4],
  c,
  [22, 19],
  c,
  [42, 41],
  c,
  [23, 70],
  c,
  [28, 25],
  c,
  [45, 25],
  c,
  [59, 23]
]),
  state: u([
  1,
  2,
  8,
  6,
  7,
  30,
  c,
  [4, 3],
  33,
  36,
  c,
  [5, 3],
  37,
  c,
  [4, 3],
  38,
  c,
  [4, 3],
  39,
  c,
  [4, 3],
  41,
  c,
  [21, 4],
  46,
  c,
  [5, 3]
]),
  mode: u([
  s,
  [1, 177],
  s,
  [2, 3],
  c,
  [5, 5],
  c,
  [6, 4],
  s,
  [1, 31]
]),
  goto: u([
  5,
  3,
  4,
  24,
  s,
  [9, 15, 1],
  s,
  [25, 5, 1],
  c,
  [24, 19],
  31,
  35,
  32,
  34,
  c,
  [18, 14],
  c,
  [37, 19],
  c,
  [19, 57],
  c,
  [117, 4],
  40,
  c,
  [24, 19],
  42,
  35,
  c,
  [16, 14],
  s,
  [2, 3],
  28,
  29,
  2,
  s,
  [3, 3],
  28,
  29,
  3,
  c,
  [52, 4],
  43,
  44,
  45,
  c,
  [78, 23],
  47
])
}),
defaultActions: bda({
  idx: u([
  s,
  [6, 20, 1],
  33,
  34,
  38,
  39,
  40,
  43,
  47
]),
  goto: u([
  9,
  10,
  11,
  s,
  [14, 15, 1],
  12,
  1,
  29,
  13,
  s,
  [4, 5, 1]
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 48 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
        // this initial `setInput()` call: hence we can now check and decide
        // whether we'll go with the standard, slower, lex() API or the
        // `fast_lex()` one:
        if (typeof lexer.canIUse === 'function') {
            var lexerInfo = lexer.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === 'function') {
                lex = fastLex;
            }
        } 



        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;

                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;




                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




                continue;

            // reduce:
            case 2:



                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, newState, sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;

                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                if (sp !== -2) {
                    retval = true;
                    // Return the `$accept` rule's `$$` result, if available.
                    //
                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                    // default, action):
                    //
                    //     $accept: <startSymbol> $end
                    //                  %{ $$ = $1; @$ = @1; %}
                    //
                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                    //
                    // In code:
                    //
                    //                  %{
                    //                      @$ = @1;            // if location tracking support is included
                    //                      if (typeof $1 !== 'undefined')
                    //                          return $1;
                    //                      else
                    //                          return true;           // the default parse result if the rule actions don't produce anything
                    //                  %}
                    sp--;
                    if (typeof vstack[sp] !== 'undefined') {
                        retval = vstack[sp];
                    }
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }

        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
        retval = false;
        r = this.parseError(p.errStr, p, this.JisonParserError);
        if (typeof r !== 'undefined') {
            retval = r;
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;
/* lexer generated by jison-lex 0.6.1-215 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... false
//   location assignment: ............. false
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
      msg = '' + msg;

      // heuristic to determine if the error message already contains a (partial) source code dump
      // as produced by either `showPosition()` or `prettyPrintRange()`:
      if (show_input_position == undefined) {
        show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
      }

      if (this.yylloc && show_input_position) {
        if (typeof this.prettyPrintRange === 'function') {
          var pretty_src = this.prettyPrintRange(this.yylloc);

          if (!/\n\s*$/.test(msg)) {
            msg += '\n';
          }

          msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
        } else if (typeof this.showPosition === 'function') {
          var pos_str = this.showPosition();

          if (pos_str) {
            if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
              msg += '\n' + pos_str;
            } else {
              msg += pos_str;
            }
          }
        }
      }

      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.yylloc) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;

        // Get last entirely matched line into the `pre_lines[]` array's
        // last index slot; we don't mind when other previously 
        // matched lines end up in the array too. 
        var pre = this.match;

        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.yylloc) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
     * it MAY be NULL) and you MUST have a valid location info object anyway:
     * then we take the given context of the `preceding` and `following` locations, IFF those are available,
     * and reconstruct the `actual` location info from those.
     * If this fails, the heuristic is to take the `current` location, IFF available.
     * If this fails as well, we assume the sought location is at/around the current lexer position
     * and then produce that one as a response. DO NOTE that these heuristic/derived location info
     * values MAY be inaccurate!
     *
     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
     * 
     * @public
     * @this {RegExpLexer}
     */
    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
      var loc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      if (actual) {
        loc.first_line = actual.first_line | 0;
        loc.last_line = actual.last_line | 0;
        loc.first_column = actual.first_column | 0;
        loc.last_column = actual.last_column | 0;

        if (actual.range) {
          loc.range[0] = actual.range[0] | 0;
          loc.range[1] = actual.range[1] | 0;
        }
      }

      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
        // plan B: heuristic using preceding and following:
        if (loc.first_line <= 0 && preceding) {
          loc.first_line = preceding.last_line | 0;
          loc.first_column = preceding.last_column | 0;

          if (preceding.range) {
            loc.range[0] = actual.range[1] | 0;
          }
        }

        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
          loc.last_line = following.first_line | 0;
          loc.last_column = following.first_column | 0;

          if (following.range) {
            loc.range[1] = actual.range[0] | 0;
          }
        }

        // plan C?: see if the 'current' location is useful/sane too:
        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
          loc.first_line = current.first_line | 0;
          loc.first_column = current.first_column | 0;

          if (current.range) {
            loc.range[0] = current.range[0] | 0;
          }
        }

        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
          loc.last_line = current.last_line | 0;
          loc.last_column = current.last_column | 0;

          if (current.range) {
            loc.range[1] = current.range[1] | 0;
          }
        }
      }

      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
      // or plan D heuristics to produce a 'sensible' last_line value:
      if (loc.last_line <= 0) {
        if (loc.first_line <= 0) {
          loc.first_line = this.yylloc.first_line;
          loc.last_line = this.yylloc.last_line;
          loc.first_column = this.yylloc.first_column;
          loc.last_column = this.yylloc.last_column;
          loc.range[0] = this.yylloc.range[0];
          loc.range[1] = this.yylloc.range[1];
        } else {
          loc.last_line = this.yylloc.last_line;
          loc.last_column = this.yylloc.last_column;
          loc.range[1] = this.yylloc.range[1];
        }
      }

      if (loc.first_line <= 0) {
        loc.first_line = loc.last_line;
        loc.first_column = 0;  // loc.last_column; 
        loc.range[1] = loc.range[0];
      }

      if (loc.first_column < 0) {
        loc.first_column = 0;
      }

      if (loc.last_column < 0) {
        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);
      }

      return loc;
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));
      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');
        var offset = 2 + 1;
        var len = 0;

        if (lno === loc.first_line) {
          offset += loc.first_column;

          len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );
        } else if (lno === loc.last_line) {
          len = Math.max(2, loc.last_column + 1);
        } else if (lno > loc.first_line && lno < loc.last_line) {
          len = Math.max(2, line.length + 1);
        }

        if (len) {
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.',
          this.options.lexerErrorsAreRecoverable
        );

        var pendingInput = this._input;
        var activeCondition = this.topState();
        var conditionStackDepth = this.conditionStack.length;
        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
          // has not consumed/modified any pending input or changed state in the error handler:
          if (!this.matches && // and make sure the input has been modified/consumed ...
          pendingInput === this._input && // ...or the lexer state has been modified significantly enough
          // to merit a non-consuming error handling action right now.
          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.pre_lex === 'function') {
        r = this.pre_lex.call(this, 0);
      }

      if (typeof this.options.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.pre_lex.call(this, r) || r;
      }

      if (this.yy && typeof this.yy.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.pre_lex.call(this, r) || r;
      }

      while (!r) {
        r = this.next();
      }

      if (this.yy && typeof this.yy.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.post_lex.call(this, r) || r;
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      if (typeof this.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
     * `pre_lex()` nor any of the `post_lex()` callbacks.
     * 
     * @public
     * @this {RegExpLexer}
     */
    fastLex: function lexer_fastLex() {
      var r;

      while (!r) {
        r = this.next();
      }

      return r;
    },

    /**
     * return info about the lexer state that can help a parser or other lexer API user to use the
     * most efficient means available. This API is provided to aid run-time performance for larger
     * systems which employ this lexer.
     * 
     * @public
     * @this {RegExpLexer}
     */
    canIUse: function lexer_canIUse() {
      var rv = {
        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
      };

      return rv;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      trackPosition: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: INITIAL */
        /*! Rule::       \s+ */
        /* skip whitespace */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       \* */
      1: 5,

      /*! Conditions:: INITIAL */
      /*! Rule::       \/ */
      2: 6,

      /*! Conditions:: INITIAL */
      /*! Rule::       \+ */
      3: 3,

      /*! Conditions:: INITIAL */
      /*! Rule::       - */
      4: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)px\b */
      5: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)cm\b */
      6: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)mm\b */
      7: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)in\b */
      8: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pt\b */
      9: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pc\b */
      10: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)deg\b */
      11: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)grad\b */
      12: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rad\b */
      13: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)turn\b */
      14: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)s\b */
      15: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ms\b */
      16: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz\b */
      17: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)kHz\b */
      18: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpi\b */
      19: 17,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpcm\b */
      20: 17,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dppx\b */
      21: 17,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)em\b */
      22: 18,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ex\b */
      23: 19,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ch\b */
      24: 20,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rem\b */
      25: 21,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vw\b */
      26: 23,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vh\b */
      27: 22,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmin\b */
      28: 24,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmax\b */
      29: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)% */
      30: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)\b */
      31: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (calc) */
      32: 9,

      /*! Conditions:: INITIAL */
      /*! Rule::       (var\([^\)]*\)) */
      33: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([a-z]+) */
      34: 10,

      /*! Conditions:: INITIAL */
      /*! Rule::       \( */
      35: 7,

      /*! Conditions:: INITIAL */
      /*! Rule::       \) */
      36: 8,

      /*! Conditions:: INITIAL */
      /*! Rule::       $ */
      37: 1
    },

    rules: [
      /*  0: */  /^(?:\s+)/,
      /*  1: */  /^(?:\*)/,
      /*  2: */  /^(?:\/)/,
      /*  3: */  /^(?:\+)/,
      /*  4: */  /^(?:-)/,
      /*  5: */  /^(?:(\d+(\.\d*)?|\.\d+)px\b)/,
      /*  6: */  /^(?:(\d+(\.\d*)?|\.\d+)cm\b)/,
      /*  7: */  /^(?:(\d+(\.\d*)?|\.\d+)mm\b)/,
      /*  8: */  /^(?:(\d+(\.\d*)?|\.\d+)in\b)/,
      /*  9: */  /^(?:(\d+(\.\d*)?|\.\d+)pt\b)/,
      /* 10: */  /^(?:(\d+(\.\d*)?|\.\d+)pc\b)/,
      /* 11: */  /^(?:(\d+(\.\d*)?|\.\d+)deg\b)/,
      /* 12: */  /^(?:(\d+(\.\d*)?|\.\d+)grad\b)/,
      /* 13: */  /^(?:(\d+(\.\d*)?|\.\d+)rad\b)/,
      /* 14: */  /^(?:(\d+(\.\d*)?|\.\d+)turn\b)/,
      /* 15: */  /^(?:(\d+(\.\d*)?|\.\d+)s\b)/,
      /* 16: */  /^(?:(\d+(\.\d*)?|\.\d+)ms\b)/,
      /* 17: */  /^(?:(\d+(\.\d*)?|\.\d+)Hz\b)/,
      /* 18: */  /^(?:(\d+(\.\d*)?|\.\d+)kHz\b)/,
      /* 19: */  /^(?:(\d+(\.\d*)?|\.\d+)dpi\b)/,
      /* 20: */  /^(?:(\d+(\.\d*)?|\.\d+)dpcm\b)/,
      /* 21: */  /^(?:(\d+(\.\d*)?|\.\d+)dppx\b)/,
      /* 22: */  /^(?:(\d+(\.\d*)?|\.\d+)em\b)/,
      /* 23: */  /^(?:(\d+(\.\d*)?|\.\d+)ex\b)/,
      /* 24: */  /^(?:(\d+(\.\d*)?|\.\d+)ch\b)/,
      /* 25: */  /^(?:(\d+(\.\d*)?|\.\d+)rem\b)/,
      /* 26: */  /^(?:(\d+(\.\d*)?|\.\d+)vw\b)/,
      /* 27: */  /^(?:(\d+(\.\d*)?|\.\d+)vh\b)/,
      /* 28: */  /^(?:(\d+(\.\d*)?|\.\d+)vmin\b)/,
      /* 29: */  /^(?:(\d+(\.\d*)?|\.\d+)vmax\b)/,
      /* 30: */  /^(?:(\d+(\.\d*)?|\.\d+)%)/,
      /* 31: */  /^(?:(\d+(\.\d*)?|\.\d+)\b)/,
      /* 32: */  /^(?:(calc))/,
      /* 33: */  /^(?:(var\([^)]*\)))/,
      /* 34: */  /^(?:([a-z]+))/,
      /* 35: */  /^(?:\()/,
      /* 36: */  /^(?:\))/,
      /* 37: */  /^(?:$)/
    ],

    conditions: {
      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;



function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (true) {
  exports.parser = parser;
  exports.Parser = parser.Parser;
  exports.parse = function () {
    return parser.parse.apply(parser, arguments);
  };
  
}
; 
if (false ) {} 

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cssUnitConverter = __webpack_require__(303);

var _cssUnitConverter2 = _interopRequireDefault(_cssUnitConverter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function convertNodes(left, right, precision) {
  switch (left.type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
      return convertAbsoluteLength(left, right, precision);
    default:
      return { left: left, right: right };
  }
}

function convertAbsoluteLength(left, right, precision) {
  if (right.type === left.type) {
    right = {
      type: left.type,
      value: (0, _cssUnitConverter2.default)(right.value, right.unit, left.unit, precision),
      unit: left.unit
    };
  }
  return { left: left, right: right };
}

exports.default = convertNodes;
module.exports = exports['default'];; 
if (false ) {} 

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = {
    // length
    'px': {
        'px': 1,
        'cm': 96.0/2.54,
        'mm': 96.0/25.4,
        'in': 96,
        'pt': 96.0/72.0,
        'pc': 16
    },
    'cm': {
        'px': 2.54/96.0,
        'cm': 1,
        'mm': 0.1,
        'in': 2.54,
        'pt': 2.54/72.0,
        'pc': 2.54/6.0
    },
    'mm': {
        'px': 25.4/96.0,
        'cm': 10,
        'mm': 1,
        'in': 25.4,
        'pt': 25.4/72.0,
        'pc': 25.4/6.0
    },
    'in': {
        'px': 1.0/96.0,
        'cm': 1.0/2.54,
        'mm': 1.0/25.4,
        'in': 1,
        'pt': 1.0/72.0,
        'pc': 1.0/6.0
    },
    'pt': {
        'px': 0.75,
        'cm': 72.0/2.54,
        'mm': 72.0/25.4,
        'in': 72,
        'pt': 1,
        'pc': 12
    },
    'pc': {
        'px': 6.0/96.0,
        'cm': 6.0/2.54,
        'mm': 6.0/25.4,
        'in': 6,
        'pt': 6.0/72.0,
        'pc': 1
    },
    // angle
    'deg': {
        'deg': 1,
        'grad': 0.9,
        'rad': 180/Math.PI,
        'turn': 360
    },
    'grad': {
        'deg': 400/360,
        'grad': 1,
        'rad': 200/Math.PI,
        'turn': 400
    },
    'rad': {
        'deg': Math.PI/180,
        'grad': Math.PI/200,
        'rad': 1,
        'turn': Math.PI*2
    },
    'turn': {
        'deg': 1/360,
        'grad': 1/400,
        'rad': 0.5/Math.PI,
        'turn': 1
    },
    // time
    's': {
        's': 1,
        'ms': 1/1000
    },
    'ms': {
        's': 1000,
        'ms': 1
    },
    // frequency
    'Hz': {
        'Hz': 1,
        'kHz': 1000
    },
    'kHz': {
        'Hz': 1/1000,
        'kHz': 1
    },
    // resolution
    'dpi': {
        'dpi': 1,
        'dpcm': 1.0/2.54,
        'dppx': 1/96
    },
    'dpcm': {
        'dpi': 2.54,
        'dpcm': 1,
        'dppx': 2.54/96.0
    },
    'dppx': {
        'dpi': 96,
        'dpcm': 96.0/2.54,
        'dppx': 1
    }
};

module.exports = function (value, sourceUnit, targetUnit, precision) {
    if (!conversions.hasOwnProperty(targetUnit))
        throw new Error("Cannot convert to " + targetUnit);

    if (!conversions[targetUnit].hasOwnProperty(sourceUnit))
        throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
    
    var converted = conversions[targetUnit][sourceUnit] * value;
    
    if (precision !== false) {
        precision = Math.pow(10, parseInt(precision) || 5);
        return Math.round(converted * precision) / precision;
    }
    
    return converted;
};
; 
if (false ) {} 

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (calc, node, precision) {
  var str = stringify(node, precision);

  if (node.type === "MathExpression") {
    // if calc expression couldn't be resolved to a single value, re-wrap it as
    // a calc()
    str = calc + "(" + str + ")";
  }
  return str;
};

var _reducer = __webpack_require__(108);

var order = {
  "*": 0,
  "/": 0,
  "+": 1,
  "-": 1
};

function round(value, prec) {
  if (prec !== false) {
    var precision = Math.pow(10, prec);
    return Math.round(value * precision) / precision;
  }
  return value;
}

function stringify(node, prec) {
  switch (node.type) {
    case "MathExpression":
      {
        var left = node.left,
            right = node.right,
            op = node.operator;

        var str = "";

        if (left.type === 'MathExpression' && order[op] < order[left.operator]) str += "(" + stringify(left, prec) + ")";else str += stringify(left, prec);

        str += " " + node.operator + " ";

        if (right.type === 'MathExpression' && order[op] < order[right.operator]) str += "(" + stringify(right, prec) + ")";else if (right.type === 'MathExpression' && op === "-" && ["+", "-"].includes(right.operator)) {
          // fix #52 : a-(b+c) = a-b-c
          right.operator = (0, _reducer.flip)(right.operator);
          str += stringify(right, prec);
        } else str += stringify(right, prec);

        return str;
      }
    case "Value":
      return round(node.value, prec);
    case 'CssVariable':
      return node.value;
    default:
      return round(node.value, prec) + node.unit;
  }
}

module.exports = exports["default"];; 
if (false ) {} 

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g

module.exports = function(css, options){
  options = options || {};

  /**
   * Positional.
   */

  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    var lines = str.match(/\n/g);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf('\n');
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   */

  function position() {
    var start = { line: lineno, column: column };
    return function(node){
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node
   */

  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string
   */

  Position.prototype.content = css;

  /**
   * Error `msg`.
   */

  var errorsList = [];

  function error(msg) {
    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }

  /**
   * Parse stylesheet.
   */

  function stylesheet() {
    var rulesList = rules();

    return {
      type: 'stylesheet',
      stylesheet: {
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }

  /**
   * Opening brace.
   */

  function open() {
    return match(/^{\s*/);
  }

  /**
   * Closing brace.
   */

  function close() {
    return match(/^}/);
  }

  /**
   * Parse ruleset.
   */

  function rules() {
    var node;
    var rules = [];
    whitespace();
    comments(rules);
    while (css.length && css.charAt(0) != '}' && (node = atrule() || rule())) {
      if (node !== false) {
        rules.push(node);
        comments(rules);
      }
    }
    return rules;
  }

  /**
   * Match `re` and return captures.
   */

  function match(re) {
    var m = re.exec(css);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */

  function whitespace() {
    match(/^\s*/);
  }

  /**
   * Parse comments;
   */

  function comments(rules) {
    var c;
    rules = rules || [];
    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   */

  function comment() {
    var pos = position();
    if ('/' != css.charAt(0) || '*' != css.charAt(1)) return;

    var i = 2;
    while ("" != css.charAt(i) && ('*' != css.charAt(i) || '/' != css.charAt(i + 1))) ++i;
    i += 2;

    if ("" === css.charAt(i-1)) {
      return error('End of comment missing');
    }

    var str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;

    return pos({
      type: 'comment',
      comment: str
    });
  }

  /**
   * Parse selector.
   */

  function selector() {
    var m = match(/^([^{]+)/);
    if (!m) return;
    /* @fix Remove all comments from selectors
     * http://ostermiller.org/findcomment.html */
    return trim(m[0])
      .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
      .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m) {
        return m.replace(/,/g, '\u200C');
      })
      .split(/\s*(?![^(]*\)),\s*/)
      .map(function(s) {
        return s.replace(/\u200C/g, ',');
      });
  }

  /**
   * Parse declaration.
   */

  function declaration() {
    var pos = position();

    // prop
    var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop) return;
    prop = trim(prop[0]);

    // :
    if (!match(/^:\s*/)) return error("property missing ':'");

    // val
    var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);

    var ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    });

    // ;
    match(/^[;\s]*/);

    return ret;
  }

  /**
   * Parse declarations.
   */

  function declarations() {
    var decls = [];

    if (!open()) return error("missing '{'");
    comments(decls);

    // declarations
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) return error("missing '}'");
    return decls;
  }

  /**
   * Parse keyframe.
   */

  function keyframe() {
    var m;
    var vals = [];
    var pos = position();

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) return;

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }

  /**
   * Parse keyframes.
   */

  function atkeyframes() {
    var pos = position();
    var m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) return;
    var vendor = m[1];

    // identifier
    var m = match(/^([-\w]+)\s*/);
    if (!m) return error("@keyframes missing name");
    var name = m[1];

    if (!open()) return error("@keyframes missing '{'");

    var frame;
    var frames = comments();
    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) return error("@keyframes missing '}'");

    return pos({
      type: 'keyframes',
      name: name,
      vendor: vendor,
      keyframes: frames
    });
  }

  /**
   * Parse supports.
   */

  function atsupports() {
    var pos = position();
    var m = match(/^@supports *([^{]+)/);

    if (!m) return;
    var supports = trim(m[1]);

    if (!open()) return error("@supports missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@supports missing '}'");

    return pos({
      type: 'supports',
      supports: supports,
      rules: style
    });
  }

  /**
   * Parse host.
   */

  function athost() {
    var pos = position();
    var m = match(/^@host\s*/);

    if (!m) return;

    if (!open()) return error("@host missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@host missing '}'");

    return pos({
      type: 'host',
      rules: style
    });
  }

  /**
   * Parse media.
   */

  function atmedia() {
    var pos = position();
    var m = match(/^@media *([^{]+)/);

    if (!m) return;
    var media = trim(m[1]);

    if (!open()) return error("@media missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@media missing '}'");

    return pos({
      type: 'media',
      media: media,
      rules: style
    });
  }


  /**
   * Parse custom-media.
   */

  function atcustommedia() {
    var pos = position();
    var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (!m) return;

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }

  /**
   * Parse paged media.
   */

  function atpage() {
    var pos = position();
    var m = match(/^@page */);
    if (!m) return;

    var sel = selector() || [];

    if (!open()) return error("@page missing '{'");
    var decls = comments();

    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) return error("@page missing '}'");

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }

  /**
   * Parse document.
   */

  function atdocument() {
    var pos = position();
    var m = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m) return;

    var vendor = trim(m[1]);
    var doc = trim(m[2]);

    if (!open()) return error("@document missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@document missing '}'");

    return pos({
      type: 'document',
      document: doc,
      vendor: vendor,
      rules: style
    });
  }

  /**
   * Parse font-face.
   */

  function atfontface() {
    var pos = position();
    var m = match(/^@font-face\s*/);
    if (!m) return;

    if (!open()) return error("@font-face missing '{'");
    var decls = comments();

    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) return error("@font-face missing '}'");

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }

  /**
   * Parse import
   */

  var atimport = _compileAtrule('import');

  /**
   * Parse charset
   */

  var atcharset = _compileAtrule('charset');

  /**
   * Parse namespace
   */

  var atnamespace = _compileAtrule('namespace');

  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    var re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function() {
      var pos = position();
      var m = match(re);
      if (!m) return;
      var ret = { type: name };
      ret[name] = m[1].trim();
      return pos(ret);
    }
  }

  /**
   * Parse at rule.
   */

  function atrule() {
    if (css[0] != '@') return;

    return atkeyframes()
      || atmedia()
      || atcustommedia()
      || atsupports()
      || atimport()
      || atcharset()
      || atnamespace()
      || atdocument()
      || atpage()
      || athost()
      || atfontface();
  }

  /**
   * Parse rule.
   */

  function rule() {
    var pos = position();
    var sel = selector();

    if (!sel) return error('selector missing');
    comments();

    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
};

/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}

/**
 * Adds non-enumerable parent node reference to each node.
 */

function addParent(obj, parent) {
  var isNode = obj && typeof obj.type === 'string';
  var childParent = isNode ? obj : parent;

  for (var k in obj) {
    var value = obj[k];
    if (Array.isArray(value)) {
      value.forEach(function(v) { addParent(v, childParent); });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}
; 
if (false ) {} 

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(307);
; 
if (false ) {} 

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
            dest[key] = src[key];
        }
    }

    return dest;
}

module.exports = __webpack_require__(308).create(
    merge(
        __webpack_require__(334),
        __webpack_require__(379),
        __webpack_require__(403)
    )
);
module.exports.version = __webpack_require__(404).version;
; 
if (false ) {} 

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(67);
var SyntaxError = __webpack_require__(109);
var TokenStream = __webpack_require__(81);
var Lexer = __webpack_require__(309);
var definitionSyntax = __webpack_require__(319);
var tokenize = __webpack_require__(16);
var createParser = __webpack_require__(320);
var createGenerator = __webpack_require__(323);
var createConvertor = __webpack_require__(330);
var createWalker = __webpack_require__(331);
var clone = __webpack_require__(332);
var names = __webpack_require__(93);
var mix = __webpack_require__(333);

function createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);

    var syntax = {
        List: List,
        SyntaxError: SyntaxError,
        TokenStream: TokenStream,
        Lexer: Lexer,

        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,

        definitionSyntax: definitionSyntax,
        lexer: null,
        createLexer: function(config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
        },

        tokenize: tokenize,
        parse: parse,
        walk: walk,
        generate: generate,

        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        clone: clone,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,

        createSyntax: function(config) {
            return createSyntax(mix({}, config));
        },
        fork: function(extension) {
            var base = mix({}, config); // copy of config
            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
};

exports.create = function(config) {
    return createSyntax(mix({}, config));
};
; 
if (false ) {} 

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var SyntaxReferenceError = __webpack_require__(111).SyntaxReferenceError;
var MatchError = __webpack_require__(111).MatchError;
var names = __webpack_require__(93);
var generic = __webpack_require__(310);
var parse = __webpack_require__(94);
var generate = __webpack_require__(92);
var walk = __webpack_require__(114);
var prepareTokens = __webpack_require__(314);
var buildMatchGraph = __webpack_require__(115).buildMatchGraph;
var matchAsTree = __webpack_require__(315).matchAsTree;
var trace = __webpack_require__(316);
var search = __webpack_require__(317);
var getStructureFromConfig = __webpack_require__(318).getStructureFromConfig;
var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

function dumpMapSyntax(map, compact, syntaxAsAst) {
    var result = {};

    for (var name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate(map[name].syntax, { compact: compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(match, error, iterations) {
    return {
        matched: match,
        iterations: iterations,
        error: error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
    };
}

function matchSyntax(lexer, syntax, value, useCommon) {
    var tokens = prepareTokens(value, lexer.syntax);
    var result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    }

    if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new MatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

var Lexer = function(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.atrules = {};
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.atrules) {
            for (var name in config.atrules) {
                this.addAtrule_(name, config.atrules[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
};

Lexer.prototype = {
    structure: {},
    checkStructure: function(ast) {
        function collectWarning(node, message) {
            warns.push({
                node: node,
                message: message
            });
        }

        var structure = this.structure;
        var warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    },

    createDescriptor: function(syntax, type, name) {
        var ref = {
            type: type,
            name: name
        };
        var descriptor = {
            type: type,
            name: name,
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get: function() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get: function() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    },
    addAtrule_: function(name, syntax) {
        this.atrules[name] = {
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce((res, name) => {
                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
                    return res;
                }, {})
                : null
        };
    },
    addProperty_: function(name, syntax) {
        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function(name, syntax) {
        this.types[name] = this.createDescriptor(syntax, 'Type', name);

        if (syntax === generic['-ms-legacy-expression']) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
    },

    matchAtrulePrelude: function(atruleName, prelude) {
        var atrule = names.keyword(atruleName);

        var atrulePreludeSyntax = atrule.vendor
            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
            : this.getAtrulePrelude(atrule.name);

        if (!atrulePreludeSyntax) {
            if (atrule.basename in this.atrules) {
                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
            }

            return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule', atruleName));
        }

        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
    },
    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
        var atrule = names.keyword(atruleName);
        var descriptor = names.keyword(descriptorName);

        var atruleEntry = atrule.vendor
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        if (!atruleEntry) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule', atruleName));
        }

        if (!atruleEntry.descriptors) {
            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
        }

        var atruleDescriptorSyntax = descriptor.vendor
            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
            : atruleEntry.descriptors[descriptor.name];

        if (!atruleDescriptorSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName));
        }

        return matchSyntax(this, atruleDescriptorSyntax, value, true);
    },
    matchDeclaration: function(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    },
    matchProperty: function(propertyName, value) {
        var property = names.property(propertyName);

        // don't match syntax for a custom property
        if (property.custom) {
            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
        }

        var propertySyntax = property.vendor
            ? this.getProperty(property.name) || this.getProperty(property.basename)
            : this.getProperty(property.name);

        if (!propertySyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));
        }

        return matchSyntax(this, propertySyntax, value, true);
    },
    matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    },
    match: function(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    },

    findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function(ast, type, name) {
        var result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: function(declaration) {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
        });

        return result;
    },

    getAtrulePrelude: function(atruleName) {
        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
    },
    getAtruleDescriptor: function(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    },
    getProperty: function(name) {
        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
    },
    getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },

    validate: function() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
                return broken[name];
            }

            broken[name] = false;
            if (descriptor.syntax !== null) {
                walk(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken[name] = true;
                    }
                }, this);
            }
        }

        var brokenTypes = {};
        var brokenProperties = {};

        for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
        });

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    },
    dump: function(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    },
    toString: function() {
        return JSON.stringify(this.dump());
    }
};

module.exports = Lexer;
; 
if (false ) {} 

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

var tokenizer = __webpack_require__(16);
var isIdentifierStart = tokenizer.isIdentifierStart;
var isHexDigit = tokenizer.isHexDigit;
var isDigit = tokenizer.isDigit;
var cmpStr = tokenizer.cmpStr;
var consumeNumber = tokenizer.consumeNumber;
var TYPE = tokenizer.TYPE;
var anPlusB = __webpack_require__(311);
var urange = __webpack_require__(312);

var cssWideKeywords = ['unset', 'initial', 'inherit'];
var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

// https://www.w3.org/TR/css-values-3/#lengths
var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
};

var TIME = {
    's': true,
    'ms': true
};

var FREQUENCY = {
    'hz': true,
    'khz': true
};

// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
};

// https://drafts.csswg.org/css-grid/#fr-unit
var FLEX = {
    'fr': true
};

// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
var DECIBEL = {
    'db': true
};

// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
var SEMITONES = {
    'st': true
};

// safe char code getter
function charCode(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (var i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        isDigit(str.charCodeAt(offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        var num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        if (opts.min !== null && num < opts.min) {
            return true;
        }

        if (opts.max !== null && num > opts.max) {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    var startIdx = token.index;
    var length = 0;

    // balanced token consuming
    do {
        length++;

        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

function func(name) {
    name = name + '(';

    return function(token, getNextToken) {
        if (token !== null && eqStr(token.value, name)) {
            return consumeFunction(token, getNextToken);
        }

        return 0;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== TYPE.Ident) {
        return 0;
    }

    var name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, cssWideKeywords)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
    // in that property’s value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== TYPE.Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== TYPE.Hash) {
        return 0;
    }

    var length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (var i = 1; i < length; i++) {
        if (!isHexDigit(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== TYPE.Hash) {
        return 0;
    }

    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var length = 0;
    var level = 0;
    var startIdx = token.index;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE.BadString:
            case TYPE.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                level--;
                break;

            // ... or top-level <semicolon-token> tokens
            case TYPE.Semicolon:
                if (level === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case TYPE.Delim:
                if (token.value === '!' && level === 0) {
                    break scan;
                }

                break;

            case TYPE.Function:
            case TYPE.LeftParenthesis:
            case TYPE.LeftSquareBracket:
            case TYPE.LeftCurlyBracket:
                level++;
                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var startIdx = token.index;
    var length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE.BadString:
            case TYPE.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    return function(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Dimension) {
            return 0;
        }

        var numberEnd = consumeNumber(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// §5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== TYPE.Percentage) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === TYPE.Number) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

// § 5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    var numberEnd = consumeNumber(token.value, 0);
    var isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// §5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== TYPE.Number) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!isDigit(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

module.exports = {
    // token types
    'ident-token': tokenType(TYPE.Ident),
    'function-token': tokenType(TYPE.Function),
    'at-keyword-token': tokenType(TYPE.AtKeyword),
    'hash-token': tokenType(TYPE.Hash),
    'string-token': tokenType(TYPE.String),
    'bad-string-token': tokenType(TYPE.BadString),
    'url-token': tokenType(TYPE.Url),
    'bad-url-token': tokenType(TYPE.BadUrl),
    'delim-token': tokenType(TYPE.Delim),
    'number-token': tokenType(TYPE.Number),
    'percentage-token': tokenType(TYPE.Percentage),
    'dimension-token': tokenType(TYPE.Dimension),
    'whitespace-token': tokenType(TYPE.WhiteSpace),
    'CDO-token': tokenType(TYPE.CDO),
    'CDC-token': tokenType(TYPE.CDC),
    'colon-token': tokenType(TYPE.Colon),
    'semicolon-token': tokenType(TYPE.Semicolon),
    'comma-token': tokenType(TYPE.Comma),
    '[-token': tokenType(TYPE.LeftSquareBracket),
    ']-token': tokenType(TYPE.RightSquareBracket),
    '(-token': tokenType(TYPE.LeftParenthesis),
    ')-token': tokenType(TYPE.RightParenthesis),
    '{-token': tokenType(TYPE.LeftCurlyBracket),
    '}-token': tokenType(TYPE.RightCurlyBracket),

    // token type aliases
    'string': tokenType(TYPE.String),
    'ident': tokenType(TYPE.Ident),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': anPlusB,
    'urange': urange,
    'declaration-value': declarationValue,
    'any-value': anyValue,

    // dimensions
    'dimension': calc(dimension(null)),
    'angle': calc(dimension(ANGLE)),
    'decibel': calc(dimension(DECIBEL)),
    'frequency': calc(dimension(FREQUENCY)),
    'flex': calc(dimension(FLEX)),
    'length': calc(zero(dimension(LENGTH))),
    'resolution': calc(dimension(RESOLUTION)),
    'semitones': calc(dimension(SEMITONES)),
    'time': calc(dimension(TIME)),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer),

    // old IE stuff
    '-ms-legacy-expression': func('expression')
};
; 
if (false ) {} 

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var isDigit = __webpack_require__(16).isDigit;
var cmpChar = __webpack_require__(16).cmpChar;
var TYPE = __webpack_require__(16).TYPE;

var DELIM = TYPE.Delim;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function isDelim(token, code) {
    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    var code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB(token, offset_, getNextToken) {
    var sign = false;
    var offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== NUMBER) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null && token.type !== NUMBER) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        var code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
module.exports = function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    var offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === NUMBER) {
        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
        // expect 1st char is N
        if (!cmpChar(token.value, 1, N)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                    return 0;
                }

                return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
        // just ignore a plus
        if (token.type !== IDENT) {
            token = getNextToken(++offset);
        }

        if (token === null || !cmpChar(token.value, 0, N)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                    return 0;
                }

                return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === DIMENSION) {
        var code = token.value.charCodeAt(0);
        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;

        for (var i = sign; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!cmpChar(token.value, i, N)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
        }
    }

    return 0;
};
; 
if (false ) {} 

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var isHexDigit = __webpack_require__(16).isHexDigit;
var cmpChar = __webpack_require__(16).cmpChar;
var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var DELIM = TYPE.Delim;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
}

function startsWith(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
        var code = token.value.charCodeAt(pos);

        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
                return 6; // dissallow following question marks
            }

            return 0; // dash at the ending of a hex sequence is not allowed
        }

        if (!isHexDigit(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        };
    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
module.exports = function urange(token, getNextToken) {
    var length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === IDENT) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (isDelim(token, QUESTIONMARK)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === NUMBER) {
        if (!startsWith(token, PLUSSIGN)) {
            return 0;
        }

        var consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === DIMENSION || token.type === NUMBER) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === DIMENSION) {
        if (!startsWith(token, PLUSSIGN)) {
            return 0;
        }

        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
};
; 
if (false ) {} 

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var SyntaxError = __webpack_require__(113);

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;

var Tokenizer = function(str) {
    this.str = str;
    this.pos = 0;
};

Tokenizer.prototype = {
    charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    },
    charCode: function() {
        return this.charCodeAt(this.pos);
    },
    nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
    },
    nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    },
    findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
                break;
            }
        }

        return pos;
    },
    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    },
    peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    },
    error: function(message) {
        throw new SyntaxError(message, this.str, this.pos);
    }
};

module.exports = Tokenizer;
; 
if (false ) {} 

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var tokenize = __webpack_require__(16);
var TokenStream = __webpack_require__(81);
var tokenStream = new TokenStream();
var astToTokens = {
    decorator: function(handlers) {
        var curNode = null;
        var prev = { len: 0, node: null };
        var nodes = [prev];
        var buffer = '';

        return {
            children: handlers.children,
            node: function(node) {
                var tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            chunk: function(chunk) {
                buffer += chunk;
                if (prev.node !== curNode) {
                    nodes.push({
                        len: chunk.length,
                        node: curNode
                    });
                } else {
                    prev.len += chunk.length;
                }
            },
            result: function() {
                return prepareTokens(buffer, nodes);
            }
        };
    }
};

function prepareTokens(str, nodes) {
    var tokens = [];
    var nodesOffset = 0;
    var nodesIndex = 0;
    var currentNode = nodes ? nodes[nodesIndex].node : null;

    tokenize(str, tokenStream);

    while (!tokenStream.eof) {
        if (nodes) {
            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
                nodesOffset += nodes[nodesIndex++].len;
                currentNode = nodes[nodesIndex].node;
            }
        }

        tokens.push({
            type: tokenStream.tokenType,
            value: tokenStream.getTokenValue(),
            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
            node: currentNode
        });
        tokenStream.next();
        // console.log({ ...tokens[tokens.length - 1], node: undefined });
    }

    return tokens;
}

module.exports = function(value, syntax) {
    if (typeof value === 'string') {
        return prepareTokens(value, null);
    }

    return syntax.generate(value, astToTokens);
};
; 
if (false ) {} 

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var matchGraph = __webpack_require__(115);
var MATCH = matchGraph.MATCH;
var MISMATCH = matchGraph.MISMATCH;
var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
var TYPE = __webpack_require__(82).TYPE;

var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;

var EXIT_REASON_MATCH = 'Match';
var EXIT_REASON_MISMATCH = 'Mismatch';
var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

var ITERATION_LIMIT = 15000;
var totalIterationCount = 0;

function reverseList(list) {
    var prev = null;
    var next = null;
    var item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (var i = 0; i < testStr.length; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== TYPE.Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE.Comma ||
        token.type === TYPE.Function ||
        token.type === TYPE.LeftParenthesis ||
        token.type === TYPE.LeftSquareBracket ||
        token.type === TYPE.LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE.RightParenthesis ||
        token.type === TYPE.RightSquareBracket ||
        token.type === TYPE.RightCurlyBracket ||
        token.type === TYPE.Delim
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
    }

    function getNextToken(offset) {
        var nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            thenStack: thenStack,
            tokenIndex: tokenIndex,
            prev: prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token: token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    var syntaxStack = null;
    var thenStack = null;
    var elseStack = null;

    // null – stashing allowed, nothing stashed
    // false – stashing disabled, nothing stashed
    // anithing else – fail stashable syntaxes, some syntax stashed
    var syntaxStash = null;

    var iterationCount = 0; // count iterations and prevent infinite loop
    var exitReason = null;

    var token = null;
    var tokenIndex = -1;
    var longestMatch = 0;
    var matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     var result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = MISMATCH;
                        break;
                    } else {
                        state = MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer':
                var terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    var matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    var name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (hasOwnProperty.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'Generic':
                var opts = syntaxStack !== null ? syntaxStack.opts : null;
                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            case 'Type':
            case 'Property':
                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    var lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;

            case 'Keyword':
                var name = state.name;

                if (token !== null) {
                    var keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = MATCH;
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === TYPE.Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            case 'String':
                var string = '';

                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    totalIterationCount += iterationCount;

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens: tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch: longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        var item = reverseList(matchResult.match).prev;

        matchResult.match = [];

        while (item !== null) {
            switch (item.type) {
                case STUB:
                    break;

                case OPEN_SYNTAX:
                case CLOSE_SYNTAX:
                    matchResult.match.push({
                        type: item.type,
                        syntax: item.syntax
                    });
                    break;

                default:
                    matchResult.match.push({
                        token: item.token.value,
                        node: item.token.node
                    });
                    break;
            }

            item = item.prev;
        }
    }

    return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    var item = matchResult.match;
    var host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    var hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

module.exports = {
    matchAsList: matchAsList,
    matchAsTree: matchAsTree,
    getTotalIterationCount: function() {
        return totalIterationCount;
    }
};
; 
if (false ) {} 

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (var i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    var result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

function isType(node, type) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Type' && matchNode.name === type;
    });
}

function isProperty(node, property) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Property' && matchNode.name === property;
    });
}

function isKeyword(node) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Keyword';
    });
}

module.exports = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
};
; 
if (false ) {} 

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(67);

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    var nodes = new List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes: nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    var fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

module.exports = {
    matchFragments: matchFragments
};
; 
if (false ) {} 

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(67);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (var key in node) {
            var valid = true;

            if (hasOwnProperty.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                    var fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (var key in fields) {
            if (hasOwnProperty.call(fields, key) &&
                hasOwnProperty.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
        type: String,
        loc: true
    };
    var docs = {
        type: '"' + name + '"'
    };

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs: docs,
        check: createNodeStructureChecker(name, fields)
    };
}

module.exports = {
    getStructureFromConfig: function(config) {
        var structure = {};

        if (config.node) {
            for (var name in config.node) {
                if (hasOwnProperty.call(config.node, name)) {
                    var nodeType = config.node[name];

                    if (nodeType.structure) {
                        structure[name] = processStructure(name, nodeType);
                    } else {
                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
                    }
                }
            }
        }

        return structure;
    }
};
; 
if (false ) {} 

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    SyntaxError: __webpack_require__(113),
    parse: __webpack_require__(94),
    generate: __webpack_require__(92),
    walk: __webpack_require__(114)
};
; 
if (false ) {} 

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var OffsetToLocation = __webpack_require__(321);
var SyntaxError = __webpack_require__(109);
var TokenStream = __webpack_require__(81);
var List = __webpack_require__(67);
var tokenize = __webpack_require__(16);
var constants = __webpack_require__(82);
var { findWhiteSpaceStart, cmpStr } = __webpack_require__(76);
var sequence = __webpack_require__(322);
var noop = function() {};

var TYPE = constants.TYPE;
var NAME = constants.NAME;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var HASH = TYPE.Hash;
var PERCENTAGE = TYPE.Percentage;
var NUMBER = TYPE.Number;
var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)
var NULL = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

module.exports = function createParser(config) {
    var parser = {
        scanner: new TokenStream(),
        locationMap: new OffsetToLocation(),

        filename: '<unknown>',
        needPositions: false,
        onParseError: noop,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        createList: function() {
            return new List();
        },
        createSingleNodeList: function(node) {
            return new List().appendData(node);
        },
        getFirstListNode: function(list) {
            return list && list.first();
        },
        getLastListNode: function(list) {
            return list.last();
        },

        parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (this.onParseErrorThrow) {
                    throw e;
                }

                var fallbackNode = fallback.call(this, startToken);

                this.onParseErrorThrow = true;
                this.onParseError(e, fallbackNode);
                this.onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType: function(offset) {
            do {
                var type = this.scanner.lookupType(offset++);
                if (type !== WHITESPACE) {
                    return type;
                }
            } while (type !== NULL);

            return NULL;
        },

        eat: function(tokenType) {
            if (this.scanner.tokenType !== tokenType) {
                var offset = this.scanner.tokenStart;
                var message = NAME[tokenType] + ' is expected';

                // tweak message and offset
                switch (tokenType) {
                    case IDENT:
                        // when identifier is expected but there is a function or url
                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
                            offset = this.scanner.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case HASH:
                        if (this.scanner.isDelim(NUMBERSIGN)) {
                            this.scanner.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case PERCENTAGE:
                        if (this.scanner.tokenType === NUMBER) {
                            offset = this.scanner.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;

                    default:
                        // when test type is part of another token show error for current position + 1
                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                            offset = offset + 1;
                        }
                }

                this.error(message, offset);
            }

            this.scanner.next();
        },

        consume: function(tokenType) {
            var value = this.scanner.getTokenValue();

            this.eat(tokenType);

            return value;
        },
        consumeFunctionName: function() {
            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

            this.eat(FUNCTION);

            return name;
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.locationMap.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                var head = this.getFirstListNode(list);
                var tail = this.getLastListNode(list);
                return this.locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        },

        error: function(message, offset) {
            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
                ? this.locationMap.getLocation(offset)
                : this.scanner.eof
                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))
                    : this.locationMap.getLocation(this.scanner.tokenStart);

            throw new SyntaxError(
                message || 'Unexpected input',
                this.scanner.source,
                location.offset,
                location.line,
                location.column
            );
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var onComment = options.onComment;
        var ast;

        tokenize(source, parser.scanner);
        parser.locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.scanner.forEachToken((type, start, end) => {
                if (type === COMMENT) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.error();
        }

        return ast;
    };
};
; 
if (false ) {} 

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var adoptBuffer = __webpack_require__(112);
var isBOM = __webpack_require__(16).isBOM;

var N = 10;
var F = 12;
var R = 13;

function computeLinesAndColumns(host, source) {
    var sourceLength = source.length;
    var lines = adoptBuffer(host.lines, sourceLength); // +1
    var line = host.startLine;
    var columns = adoptBuffer(host.columns, sourceLength);
    var column = host.startColumn;
    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

    for (var i = startOffset; i < sourceLength; i++) { // -1
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    host.lines = lines;
    host.columns = columns;
}

var OffsetToLocation = function() {
    this.lines = null;
    this.columns = null;
    this.linesAndColumnsComputed = false;
};

OffsetToLocation.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        this.source = source;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAndColumnsComputed = false;
    },

    ensureLinesAndColumnsComputed: function() {
        if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
        }
    },
    getLocation: function(offset, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },
    getLocationRange: function(start, end, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
};

module.exports = OffsetToLocation;
; 
if (false ) {} 

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

module.exports = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT:
                this.scanner.next();
                continue;

            case WHITESPACE:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.push(context.space);
            context.space = null;
        }

        children.push(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};
; 
if (false ) {} 

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var sourceMap = __webpack_require__(324);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
        list.forEach(this.node, this);
    } else {
        list.forEach(function(node) {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        }, this);
    }
}

module.exports = function createGenerator(config) {
    function processNode(node) {
        if (hasOwnProperty.call(types, node.type)) {
            types[node.type].call(this, node);
        } else {
            throw new Error('Unknown node type: ' + node.type);
        }
    }

    var types = {};

    if (config.node) {
        for (var name in config.node) {
            types[name] = config.node[name].generate;
        }
    }

    return function(node, options) {
        var buffer = '';
        var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
                buffer += chunk;
            },
            result: function() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap(handlers);
            }
        }

        handlers.node(node);

        return handlers.result();
    };
};
; 
if (false ) {} 

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var SourceMapGenerator = __webpack_require__(325).SourceMapGenerator;
var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
};

module.exports = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
        line: 1,
        column: 0
    };
    var original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: activatedGenerated
    };

    var handlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original: original,
                    generated: generated
                });
            }
        }

        handlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    var handlersChunk = handlers.chunk;
    handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        handlersChunk(chunk);
    };

    var handlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: handlersResult(),
            map: map
        };
    };

    return handlers;
};
; 
if (false ) {} 

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(326);
var util = __webpack_require__(95);
var ArraySet = __webpack_require__(328).ArraySet;
var MappingList = __webpack_require__(329).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;
; 
if (false ) {} 

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(327);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
; 
if (false ) {} 

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};
; 
if (false ) {} 

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(95);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;
; 
if (false ) {} 

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(95);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;
; 
if (false ) {} 

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(67);

module.exports = function createConvertors(walk) {
    return {
        fromPlainObject: function(ast) {
            walk(ast, {
                enter: function(node) {
                    if (node.children && node.children instanceof List === false) {
                        node.children = new List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject: function(ast) {
            walk(ast, {
                leave: function(node) {
                    if (node.children && node.children instanceof List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};
; 
if (false ) {} 

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        }

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
        if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    var fields = config.fields.slice();
    var contextName = config.context;
    var useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        var prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    var breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
            DeclarationList: iterators.DeclarationList
        }
    };
}

module.exports = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};
    var breakWalk = Symbol('break-walk');
    var skipNode = Symbol('skip-node');

    for (var name in types) {
        if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    var walk = function(root, options) {
        function walkNode(node, item, list) {
            var enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                debugger;
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            break: breakWalk,
            skip: skipNode,

            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        var found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        var found = null;

        walk(ast, {
            reverse: true,
            enter: function(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        var found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
};
; 
if (false ) {} 

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(67);

module.exports = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};
; 
if (false ) {} 

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var shape = {
    generic: true,
    types: {},
    atrules: {},
    properties: {},
    parseContext: {},
    scope: {},
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
    return value && value.constructor === Object;
}

function copy(value) {
    if (isObject(value)) {
        return Object.assign({}, value);
    } else {
        return value;
    }
}
function extend(dest, src) {
    for (var key in src) {
        if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
                extend(dest[key], copy(src[key]));
            } else {
                dest[key] = copy(src[key]);
            }
        }
    }
}

function mix(dest, src, shape) {
    for (var key in shape) {
        if (hasOwnProperty.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty.call(src, key)) {
                    dest[key] = copy(src[key]);
                }
            }
        } else if (shape[key]) {
            if (isObject(shape[key])) {
                var res = {};
                extend(res, dest[key]);
                extend(res, src[key]);
                dest[key] = res;
            } else if (Array.isArray(shape[key])) {
                var res = {};
                var innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});
                for (var name in dest[key]) {
                    if (hasOwnProperty.call(dest[key], name)) {
                        res[name] = {};
                        if (dest[key] && dest[key][name]) {
                            mix(res[name], dest[key][name], innerShape);
                        }
                    }
                }
                for (var name in src[key]) {
                    if (hasOwnProperty.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }
                        if (src[key] && src[key][name]) {
                            mix(res[name], src[key][name], innerShape);
                        }
                    }
                }
                dest[key] = res;
            }
        }
    }
    return dest;
}

module.exports = function(dest, src) {
    return mix(dest, src, shape);
};
; 
if (false ) {} 

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

var data = __webpack_require__(335);

module.exports = {
    generic: true,
    types: data.types,
    atrules: data.atrules,
    properties: data.properties,
    node: __webpack_require__(96)
};
; 
if (false ) {} 

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var mdnAtrules = __webpack_require__(336);
var mdnProperties = __webpack_require__(337);
var mdnSyntaxes = __webpack_require__(338);
var patch = __webpack_require__(339);

function preprocessAtrules(dict) {
    var result = Object.create(null);

    for (var atruleName in dict) {
        var atrule = dict[atruleName];
        var descriptors = null;

        if (atrule.descriptors) {
            descriptors = Object.create(null);

            for (var descriptor in atrule.descriptors) {
                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
        }

        result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
        };
    }

    return result;
}

function buildDictionary(dict, patchDict) {
    var result = {};

    // copy all syntaxes for an original dict
    for (var key in dict) {
        result[key] = dict[key].syntax;
    }

    // apply a patch
    for (var key in patchDict) {
        if (key in dict) {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax;
            } else {
                delete result[key];
            }
        } else {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax;
            }
        }
    }

    return result;
}

module.exports = {
    types: buildDictionary(mdnSyntaxes, patch.syntaxes),
    atrules: preprocessAtrules(mdnAtrules),
    properties: buildDictionary(mdnProperties, patch.properties)
};
; 
if (false ) {} 

/***/ }),
/* 336 */
/***/ (function(module) {

module.exports = JSON.parse("{\"@charset\":{\"syntax\":\"@charset \\\"<charset>\\\";\",\"groups\":[\"CSS Charsets\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@charset\"},\"@counter-style\":{\"syntax\":\"@counter-style <counter-style-name> {\\n  [ system: <counter-system>; ] ||\\n  [ symbols: <counter-symbols>; ] ||\\n  [ additive-symbols: <additive-symbols>; ] ||\\n  [ negative: <negative-symbol>; ] ||\\n  [ prefix: <prefix>; ] ||\\n  [ suffix: <suffix>; ] ||\\n  [ range: <range>; ] ||\\n  [ pad: <padding>; ] ||\\n  [ speak-as: <speak-as>; ] ||\\n  [ fallback: <counter-style-name>; ]\\n}\",\"interfaces\":[\"CSSCounterStyleRule\"],\"groups\":[\"CSS Counter Styles\"],\"descriptors\":{\"additive-symbols\":{\"syntax\":\"[ <integer> && <symbol> ]#\",\"media\":\"all\",\"initial\":\"N/A\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"fallback\":{\"syntax\":\"<counter-style-name>\",\"media\":\"all\",\"initial\":\"decimal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"negative\":{\"syntax\":\"<symbol> <symbol>?\",\"media\":\"all\",\"initial\":\"\\\"-\\\" hyphen-minus\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"pad\":{\"syntax\":\"<integer> && <symbol>\",\"media\":\"all\",\"initial\":\"0 \\\"\\\"\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"prefix\":{\"syntax\":\"<symbol>\",\"media\":\"all\",\"initial\":\"\\\"\\\"\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"range\":{\"syntax\":\"[ [ <integer> | infinite ]{2} ]# | auto\",\"media\":\"all\",\"initial\":\"auto\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"speak-as\":{\"syntax\":\"auto | bullets | numbers | words | spell-out | <counter-style-name>\",\"media\":\"all\",\"initial\":\"auto\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"suffix\":{\"syntax\":\"<symbol>\",\"media\":\"all\",\"initial\":\"\\\". \\\"\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"symbols\":{\"syntax\":\"<symbol>+\",\"media\":\"all\",\"initial\":\"N/A\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"system\":{\"syntax\":\"cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]\",\"media\":\"all\",\"initial\":\"symbolic\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"}},\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@counter-style\"},\"@document\":{\"syntax\":\"@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\\n  <group-rule-body>\\n}\",\"interfaces\":[\"CSSGroupingRule\",\"CSSConditionRule\"],\"groups\":[\"CSS Conditional Rules\"],\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@document\"},\"@font-face\":{\"syntax\":\"@font-face {\\n  [ font-family: <family-name>; ] ||\\n  [ src: <src>; ] ||\\n  [ unicode-range: <unicode-range>; ] ||\\n  [ font-variant: <font-variant>; ] ||\\n  [ font-feature-settings: <font-feature-settings>; ] ||\\n  [ font-variation-settings: <font-variation-settings>; ] ||\\n  [ font-stretch: <font-stretch>; ] ||\\n  [ font-weight: <font-weight>; ] ||\\n  [ font-style: <font-style>; ]\\n}\",\"interfaces\":[\"CSSFontFaceRule\"],\"groups\":[\"CSS Fonts\"],\"descriptors\":{\"font-display\":{\"syntax\":\"[ auto | block | swap | fallback | optional ]\",\"media\":\"visual\",\"percentages\":\"no\",\"initial\":\"auto\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\"},\"font-family\":{\"syntax\":\"<family-name>\",\"media\":\"all\",\"initial\":\"n/a (required)\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"font-feature-settings\":{\"syntax\":\"normal | <feature-tag-value>#\",\"media\":\"all\",\"initial\":\"normal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"font-variation-settings\":{\"syntax\":\"normal | [ <string> <number> ]#\",\"media\":\"all\",\"initial\":\"normal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"font-stretch\":{\"syntax\":\"<font-stretch-absolute>{1,2}\",\"media\":\"all\",\"initial\":\"normal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"font-style\":{\"syntax\":\"normal | italic | oblique <angle>{0,2}\",\"media\":\"all\",\"initial\":\"normal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"font-weight\":{\"syntax\":\"<font-weight-absolute>{1,2}\",\"media\":\"all\",\"initial\":\"normal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"font-variant\":{\"syntax\":\"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]\",\"media\":\"all\",\"initial\":\"normal\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"src\":{\"syntax\":\"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#\",\"media\":\"all\",\"initial\":\"n/a (required)\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"unicode-range\":{\"syntax\":\"<unicode-range>#\",\"media\":\"all\",\"initial\":\"U+0-10FFFF\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"}},\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@font-face\"},\"@font-feature-values\":{\"syntax\":\"@font-feature-values <family-name># {\\n  <feature-value-block-list>\\n}\",\"interfaces\":[\"CSSFontFeatureValuesRule\"],\"groups\":[\"CSS Fonts\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@font-feature-values\"},\"@import\":{\"syntax\":\"@import [ <string> | <url> ] [ <media-query-list> ]?;\",\"groups\":[\"Media Queries\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@import\"},\"@keyframes\":{\"syntax\":\"@keyframes <keyframes-name> {\\n  <keyframe-block-list>\\n}\",\"interfaces\":[\"CSSKeyframeRule\",\"CSSKeyframesRule\"],\"groups\":[\"CSS Animations\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@keyframes\"},\"@media\":{\"syntax\":\"@media <media-query-list> {\\n  <group-rule-body>\\n}\",\"interfaces\":[\"CSSGroupingRule\",\"CSSConditionRule\",\"CSSMediaRule\",\"CSSCustomMediaRule\"],\"groups\":[\"CSS Conditional Rules\",\"Media Queries\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@media\"},\"@namespace\":{\"syntax\":\"@namespace <namespace-prefix>? [ <string> | <url> ];\",\"groups\":[\"CSS Namespaces\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@namespace\"},\"@page\":{\"syntax\":\"@page <page-selector-list> {\\n  <page-body>\\n}\",\"interfaces\":[\"CSSPageRule\"],\"groups\":[\"CSS Pages\"],\"descriptors\":{\"bleed\":{\"syntax\":\"auto | <length>\",\"media\":[\"visual\",\"paged\"],\"initial\":\"auto\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"marks\":{\"syntax\":\"none | [ crop || cross ]\",\"media\":[\"visual\",\"paged\"],\"initial\":\"none\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"size\":{\"syntax\":\"<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]\",\"media\":[\"visual\",\"paged\"],\"initial\":\"auto\",\"percentages\":\"no\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"orderOfAppearance\",\"status\":\"standard\"}},\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@page\"},\"@supports\":{\"syntax\":\"@supports <supports-condition> {\\n  <group-rule-body>\\n}\",\"interfaces\":[\"CSSGroupingRule\",\"CSSConditionRule\",\"CSSSupportsRule\"],\"groups\":[\"CSS Conditional Rules\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@supports\"},\"@viewport\":{\"syntax\":\"@viewport {\\n  <group-rule-body>\\n}\",\"interfaces\":[\"CSSViewportRule\"],\"groups\":[\"CSS Device Adaptation\"],\"descriptors\":{\"height\":{\"syntax\":\"<viewport-length>{1,2}\",\"media\":[\"visual\",\"continuous\"],\"initial\":[\"min-height\",\"max-height\"],\"percentages\":[\"min-height\",\"max-height\"],\"computed\":[\"min-height\",\"max-height\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"max-height\":{\"syntax\":\"<viewport-length>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"referToHeightOfInitialViewport\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"max-width\":{\"syntax\":\"<viewport-length>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"referToWidthOfInitialViewport\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"max-zoom\":{\"syntax\":\"auto | <number> | <percentage>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"the zoom factor itself\",\"computed\":\"autoNonNegativeOrPercentage\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"min-height\":{\"syntax\":\"<viewport-length>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"referToHeightOfInitialViewport\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"min-width\":{\"syntax\":\"<viewport-length>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"referToWidthOfInitialViewport\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"min-zoom\":{\"syntax\":\"auto | <number> | <percentage>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"the zoom factor itself\",\"computed\":\"autoNonNegativeOrPercentage\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"orientation\":{\"syntax\":\"auto | portrait | landscape\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"referToSizeOfBoundingBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"user-zoom\":{\"syntax\":\"zoom | fixed\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"zoom\",\"percentages\":\"referToSizeOfBoundingBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"viewport-fit\":{\"syntax\":\"auto | contain | cover\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"no\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\"},\"width\":{\"syntax\":\"<viewport-length>{1,2}\",\"media\":[\"visual\",\"continuous\"],\"initial\":[\"min-width\",\"max-width\"],\"percentages\":[\"min-width\",\"max-width\"],\"computed\":[\"min-width\",\"max-width\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\"},\"zoom\":{\"syntax\":\"auto | <number> | <percentage>\",\"media\":[\"visual\",\"continuous\"],\"initial\":\"auto\",\"percentages\":\"the zoom factor itself\",\"computed\":\"autoNonNegativeOrPercentage\",\"order\":\"uniqueOrder\",\"status\":\"standard\"}},\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/@viewport\"}}");

/***/ }),
/* 337 */
/***/ (function(module) {

module.exports = JSON.parse("{\"--*\":{\"syntax\":\"<declaration-value>\",\"media\":\"all\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Variables\"],\"initial\":\"seeProse\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedWithVarsSubstituted\",\"order\":\"perGrammar\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/--*\"},\"-ms-accelerator\":{\"syntax\":\"false | true\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"false\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator\"},\"-ms-block-progression\":{\"syntax\":\"tb | rl | bt | lr\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"tb\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression\"},\"-ms-content-zoom-chaining\":{\"syntax\":\"none | chained\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining\"},\"-ms-content-zooming\":{\"syntax\":\"none | zoom\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"zoomForTheTopLevelNoneForTheRest\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming\"},\"-ms-content-zoom-limit\":{\"syntax\":\"<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":[\"-ms-content-zoom-limit-max\",\"-ms-content-zoom-limit-min\"],\"groups\":[\"Microsoft Extensions\"],\"initial\":[\"-ms-content-zoom-limit-max\",\"-ms-content-zoom-limit-min\"],\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":[\"-ms-content-zoom-limit-max\",\"-ms-content-zoom-limit-min\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit\"},\"-ms-content-zoom-limit-max\":{\"syntax\":\"<percentage>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"maxZoomFactor\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"400%\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max\"},\"-ms-content-zoom-limit-min\":{\"syntax\":\"<percentage>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"minZoomFactor\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"100%\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min\"},\"-ms-content-zoom-snap\":{\"syntax\":\"<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":[\"-ms-content-zoom-snap-type\",\"-ms-content-zoom-snap-points\"],\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":[\"-ms-content-zoom-snap-type\",\"-ms-content-zoom-snap-points\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap\"},\"-ms-content-zoom-snap-points\":{\"syntax\":\"snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"snapInterval(0%, 100%)\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points\"},\"-ms-content-zoom-snap-type\":{\"syntax\":\"none | proximity | mandatory\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type\"},\"-ms-filter\":{\"syntax\":\"<string>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"\\\"\\\"\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-filter\"},\"-ms-flow-from\":{\"syntax\":\"[ none | <custom-ident> ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"nonReplacedElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from\"},\"-ms-flow-into\":{\"syntax\":\"[ none | <custom-ident> ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"iframeElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into\"},\"-ms-grid-columns\":{\"syntax\":\"none | <track-list> | <auto-track-list>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"simpleListOfLpcDifferenceLpc\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"none\",\"appliesto\":\"gridContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns\"},\"-ms-grid-rows\":{\"syntax\":\"none | <track-list> | <auto-track-list>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"simpleListOfLpcDifferenceLpc\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"none\",\"appliesto\":\"gridContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows\"},\"-ms-high-contrast-adjust\":{\"syntax\":\"auto | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust\"},\"-ms-hyphenate-limit-chars\":{\"syntax\":\"auto | <integer>{1,3}\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars\"},\"-ms-hyphenate-limit-lines\":{\"syntax\":\"no-limit | <integer>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"no-limit\",\"appliesto\":\"blockContainerElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines\"},\"-ms-hyphenate-limit-zone\":{\"syntax\":\"<percentage> | <length>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"referToLineBoxWidth\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"0\",\"appliesto\":\"blockContainerElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone\"},\"-ms-ime-align\":{\"syntax\":\"auto | after\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align\"},\"-ms-overflow-style\":{\"syntax\":\"auto | none | scrollbar | -ms-autohiding-scrollbar\",\"media\":\"interactive\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style\"},\"-ms-scrollbar-3dlight-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"dependsOnUserAgent\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color\"},\"-ms-scrollbar-arrow-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"ButtonText\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color\"},\"-ms-scrollbar-base-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"dependsOnUserAgent\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color\"},\"-ms-scrollbar-darkshadow-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"ThreeDDarkShadow\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color\"},\"-ms-scrollbar-face-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"ThreeDFace\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color\"},\"-ms-scrollbar-highlight-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"ThreeDHighlight\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color\"},\"-ms-scrollbar-shadow-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"ThreeDDarkShadow\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color\"},\"-ms-scrollbar-track-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"Scrollbar\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color\"},\"-ms-scroll-chaining\":{\"syntax\":\"chained | none\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"chained\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining\"},\"-ms-scroll-limit\":{\"syntax\":\"<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":[\"-ms-scroll-limit-x-min\",\"-ms-scroll-limit-y-min\",\"-ms-scroll-limit-x-max\",\"-ms-scroll-limit-y-max\"],\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":[\"-ms-scroll-limit-x-min\",\"-ms-scroll-limit-y-min\",\"-ms-scroll-limit-x-max\",\"-ms-scroll-limit-y-max\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit\"},\"-ms-scroll-limit-x-max\":{\"syntax\":\"auto | <length>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max\"},\"-ms-scroll-limit-x-min\":{\"syntax\":\"<length>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"0\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min\"},\"-ms-scroll-limit-y-max\":{\"syntax\":\"auto | <length>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max\"},\"-ms-scroll-limit-y-min\":{\"syntax\":\"<length>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"0\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min\"},\"-ms-scroll-rails\":{\"syntax\":\"none | railed\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"railed\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails\"},\"-ms-scroll-snap-points-x\":{\"syntax\":\"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"snapInterval(0px, 100%)\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x\"},\"-ms-scroll-snap-points-y\":{\"syntax\":\"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"snapInterval(0px, 100%)\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y\"},\"-ms-scroll-snap-type\":{\"syntax\":\"none | proximity | mandatory\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type\"},\"-ms-scroll-snap-x\":{\"syntax\":\"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":[\"-ms-scroll-snap-type\",\"-ms-scroll-snap-points-x\"],\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":[\"-ms-scroll-snap-type\",\"-ms-scroll-snap-points-x\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x\"},\"-ms-scroll-snap-y\":{\"syntax\":\"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":[\"-ms-scroll-snap-type\",\"-ms-scroll-snap-points-y\"],\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":[\"-ms-scroll-snap-type\",\"-ms-scroll-snap-points-y\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y\"},\"-ms-scroll-translation\":{\"syntax\":\"none | vertical-to-horizontal\",\"media\":\"interactive\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation\"},\"-ms-text-autospace\":{\"syntax\":\"none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace\"},\"-ms-touch-select\":{\"syntax\":\"grippers | none\",\"media\":\"interactive\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"grippers\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select\"},\"-ms-user-select\":{\"syntax\":\"none | element | text\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"text\",\"appliesto\":\"nonReplacedElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-user-select\"},\"-ms-wrap-flow\":{\"syntax\":\"auto | both | start | end | maximum | clear\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"auto\",\"appliesto\":\"blockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow\"},\"-ms-wrap-margin\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"0\",\"appliesto\":\"exclusionElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin\"},\"-ms-wrap-through\":{\"syntax\":\"wrap | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"wrap\",\"appliesto\":\"blockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through\"},\"-moz-appearance\":{\"syntax\":\"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"noneButOverriddenInUserAgentCSS\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/appearance\"},\"-moz-binding\":{\"syntax\":\"<url> | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElementsExceptGeneratedContentOrPseudoElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-binding\"},\"-moz-border-bottom-colors\":{\"syntax\":\"<color>+ | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors\"},\"-moz-border-left-colors\":{\"syntax\":\"<color>+ | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors\"},\"-moz-border-right-colors\":{\"syntax\":\"<color>+ | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors\"},\"-moz-border-top-colors\":{\"syntax\":\"<color>+ | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors\"},\"-moz-context-properties\":{\"syntax\":\"none | [ fill | fill-opacity | stroke | stroke-opacity ]#\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElementsThatCanReferenceImages\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties\"},\"-moz-float-edge\":{\"syntax\":\"border-box | content-box | margin-box | padding-box\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"content-box\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge\"},\"-moz-force-broken-image-icon\":{\"syntax\":\"<integer [0,1]>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"0\",\"appliesto\":\"images\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon\"},\"-moz-image-region\":{\"syntax\":\"<shape> | auto\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"auto\",\"appliesto\":\"xulImageElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-image-region\"},\"-moz-orient\":{\"syntax\":\"inline | block | horizontal | vertical\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"inline\",\"appliesto\":\"anyElementEffectOnProgressAndMeter\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-orient\"},\"-moz-outline-radius\":{\"syntax\":\"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"-moz-outline-radius-topleft\",\"-moz-outline-radius-topright\",\"-moz-outline-radius-bottomright\",\"-moz-outline-radius-bottomleft\"],\"percentages\":[\"-moz-outline-radius-topleft\",\"-moz-outline-radius-topright\",\"-moz-outline-radius-bottomright\",\"-moz-outline-radius-bottomleft\"],\"groups\":[\"Mozilla Extensions\"],\"initial\":[\"-moz-outline-radius-topleft\",\"-moz-outline-radius-topright\",\"-moz-outline-radius-bottomright\",\"-moz-outline-radius-bottomleft\"],\"appliesto\":\"allElements\",\"computed\":[\"-moz-outline-radius-topleft\",\"-moz-outline-radius-topright\",\"-moz-outline-radius-bottomright\",\"-moz-outline-radius-bottomleft\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius\"},\"-moz-outline-radius-bottomleft\":{\"syntax\":\"<outline-radius>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft\"},\"-moz-outline-radius-bottomright\":{\"syntax\":\"<outline-radius>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright\"},\"-moz-outline-radius-topleft\":{\"syntax\":\"<outline-radius>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft\"},\"-moz-outline-radius-topright\":{\"syntax\":\"<outline-radius>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright\"},\"-moz-stack-sizing\":{\"syntax\":\"ignore | stretch-to-fit\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"stretch-to-fit\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing\"},\"-moz-text-blink\":{\"syntax\":\"none | blink\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink\"},\"-moz-user-focus\":{\"syntax\":\"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus\"},\"-moz-user-input\":{\"syntax\":\"auto | none | enabled | disabled\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-user-input\"},\"-moz-user-modify\":{\"syntax\":\"read-only | read-write | write-only\",\"media\":\"interactive\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"read-only\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify\"},\"-moz-window-dragging\":{\"syntax\":\"drag | no-drag\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"drag\",\"appliesto\":\"allElementsCreatingNativeWindows\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging\"},\"-moz-window-shadow\":{\"syntax\":\"default | menu | tooltip | sheet | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"default\",\"appliesto\":\"allElementsCreatingNativeWindows\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow\"},\"-webkit-appearance\":{\"syntax\":\"none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"noneButOverriddenInUserAgentCSS\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/appearance\"},\"-webkit-border-before\":{\"syntax\":\"<'border-width'> || <'border-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":[\"-webkit-border-before-width\"],\"groups\":[\"WebKit Extensions\"],\"initial\":[\"border-width\",\"border-style\",\"color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-width\",\"border-style\",\"color\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before\"},\"-webkit-border-before-color\":{\"syntax\":\"<'color'>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\"},\"-webkit-border-before-style\":{\"syntax\":\"<'border-style'>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\"},\"-webkit-border-before-width\":{\"syntax\":\"<'border-width'>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\"},\"-webkit-box-reflect\":{\"syntax\":\"[ above | below | right | left ]? <length>? <image>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect\"},\"-webkit-line-clamp\":{\"syntax\":\"none | <integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\",\"CSS Overflow\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp\"},\"-webkit-mask\":{\"syntax\":\"[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":[\"-webkit-mask-image\",\"-webkit-mask-repeat\",\"-webkit-mask-attachment\",\"-webkit-mask-position\",\"-webkit-mask-origin\",\"-webkit-mask-clip\"],\"appliesto\":\"allElements\",\"computed\":[\"-webkit-mask-image\",\"-webkit-mask-repeat\",\"-webkit-mask-attachment\",\"-webkit-mask-position\",\"-webkit-mask-origin\",\"-webkit-mask-clip\"],\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask\"},\"-webkit-mask-attachment\":{\"syntax\":\"<attachment>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"scroll\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment\"},\"-webkit-mask-clip\":{\"syntax\":\"[ <box> | border | padding | content | text ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"border\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-clip\"},\"-webkit-mask-composite\":{\"syntax\":\"<composite-style>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"source-over\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite\"},\"-webkit-mask-image\":{\"syntax\":\"<mask-reference>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"absoluteURIOrNone\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-image\"},\"-webkit-mask-origin\":{\"syntax\":\"[ <box> | border | padding | content ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"padding\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-origin\"},\"-webkit-mask-position\":{\"syntax\":\"<position>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToSizeOfElement\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"0% 0%\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOrPercentage\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-position\"},\"-webkit-mask-position-x\":{\"syntax\":\"[ <length-percentage> | left | center | right ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToSizeOfElement\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"0%\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOrPercentage\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x\"},\"-webkit-mask-position-y\":{\"syntax\":\"[ <length-percentage> | top | center | bottom ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToSizeOfElement\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"0%\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOrPercentage\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y\"},\"-webkit-mask-repeat\":{\"syntax\":\"<repeat-style>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"repeat\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-repeat\"},\"-webkit-mask-repeat-x\":{\"syntax\":\"repeat | no-repeat | space | round\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"repeat\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x\"},\"-webkit-mask-repeat-y\":{\"syntax\":\"repeat | no-repeat | space | round\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"repeat\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOrPercentage\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y\"},\"-webkit-mask-size\":{\"syntax\":\"<bg-size>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"relativeToBackgroundPositioningArea\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"auto auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-size\"},\"-webkit-overflow-scrolling\":{\"syntax\":\"auto | touch\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"auto\",\"appliesto\":\"scrollingBoxes\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling\"},\"-webkit-tap-highlight-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"black\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color\"},\"-webkit-text-fill-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color\"},\"-webkit-text-stroke\":{\"syntax\":\"<length> || <color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":[\"-webkit-text-stroke-width\",\"-webkit-text-stroke-color\"],\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":[\"-webkit-text-stroke-width\",\"-webkit-text-stroke-color\"],\"appliesto\":\"allElements\",\"computed\":[\"-webkit-text-stroke-width\",\"-webkit-text-stroke-color\"],\"order\":\"canonicalOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke\"},\"-webkit-text-stroke-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color\"},\"-webkit-text-stroke-width\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width\"},\"-webkit-touch-callout\":{\"syntax\":\"default | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"default\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout\"},\"-webkit-user-modify\":{\"syntax\":\"read-only | read-write | read-write-plaintext-only\",\"media\":\"interactive\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"WebKit Extensions\"],\"initial\":\"read-only\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\"},\"align-content\":{\"syntax\":\"normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"normal\",\"appliesto\":\"multilineFlexContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/align-content\"},\"align-items\":{\"syntax\":\"normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/align-items\"},\"align-self\":{\"syntax\":\"auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"auto\",\"appliesto\":\"flexItemsGridItemsAndAbsolutelyPositionedBoxes\",\"computed\":\"autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/align-self\"},\"all\":{\"syntax\":\"initial | inherit | unset | revert\",\"media\":\"noPracticalMedia\",\"inherited\":false,\"animationType\":\"eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection\",\"percentages\":\"no\",\"groups\":[\"CSS Miscellaneous\"],\"initial\":\"noPracticalInitialValue\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedAppliesToEachProperty\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/all\"},\"animation\":{\"syntax\":\"<single-animation>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":[\"animation-name\",\"animation-duration\",\"animation-timing-function\",\"animation-delay\",\"animation-iteration-count\",\"animation-direction\",\"animation-fill-mode\",\"animation-play-state\"],\"appliesto\":\"allElementsAndPseudos\",\"computed\":[\"animation-name\",\"animation-duration\",\"animation-timing-function\",\"animation-delay\",\"animation-direction\",\"animation-iteration-count\",\"animation-fill-mode\",\"animation-play-state\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation\"},\"animation-delay\":{\"syntax\":\"<time>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"0s\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-delay\"},\"animation-direction\":{\"syntax\":\"<single-animation-direction>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"normal\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-direction\"},\"animation-duration\":{\"syntax\":\"<time>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"0s\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-duration\"},\"animation-fill-mode\":{\"syntax\":\"<single-animation-fill-mode>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"none\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode\"},\"animation-iteration-count\":{\"syntax\":\"<single-animation-iteration-count>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"1\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count\"},\"animation-name\":{\"syntax\":\"[ none | <keyframes-name> ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"none\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-name\"},\"animation-play-state\":{\"syntax\":\"<single-animation-play-state>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"running\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-play-state\"},\"animation-timing-function\":{\"syntax\":\"<timing-function>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Animations\"],\"initial\":\"ease\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/animation-timing-function\"},\"appearance\":{\"syntax\":\"none | auto | textfield | menulist-button | <compat-auto>\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/appearance\"},\"aspect-ratio\":{\"syntax\":\"auto | <ratio>\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"auto\",\"appliesto\":\"allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/aspect-ratio\"},\"azimuth\":{\"syntax\":\"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards\",\"media\":\"aural\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Speech\"],\"initial\":\"center\",\"appliesto\":\"allElements\",\"computed\":\"normalizedAngle\",\"order\":\"orderOfAppearance\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/azimuth\"},\"backdrop-filter\":{\"syntax\":\"none | <filter-function-list>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"filterList\",\"percentages\":\"no\",\"groups\":[\"Filter Effects\"],\"initial\":\"none\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/backdrop-filter\"},\"backface-visibility\":{\"syntax\":\"visible | hidden\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transforms\"],\"initial\":\"visible\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/backface-visibility\"},\"background\":{\"syntax\":\"[ <bg-layer> , ]* <final-bg-layer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"background-color\",\"background-image\",\"background-clip\",\"background-position\",\"background-size\",\"background-repeat\",\"background-attachment\"],\"percentages\":[\"background-position\",\"background-size\"],\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"background-image\",\"background-position\",\"background-size\",\"background-repeat\",\"background-origin\",\"background-clip\",\"background-attachment\",\"background-color\"],\"appliesto\":\"allElements\",\"computed\":[\"background-image\",\"background-position\",\"background-size\",\"background-repeat\",\"background-origin\",\"background-clip\",\"background-attachment\",\"background-color\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background\"},\"background-attachment\":{\"syntax\":\"<attachment>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"scroll\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-attachment\"},\"background-blend-mode\":{\"syntax\":\"<blend-mode>#\",\"media\":\"none\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Compositing and Blending\"],\"initial\":\"normal\",\"appliesto\":\"allElementsSVGContainerGraphicsAndGraphicsReferencingElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-blend-mode\"},\"background-clip\":{\"syntax\":\"<box>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"border-box\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-clip\"},\"background-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"transparent\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-color\"},\"background-image\":{\"syntax\":\"<bg-image>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedURLsAbsolute\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-image\"},\"background-origin\":{\"syntax\":\"<box>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"padding-box\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-origin\"},\"background-position\":{\"syntax\":\"<bg-position>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"repeatableListOfSimpleListOfLpc\",\"percentages\":\"referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"0% 0%\",\"appliesto\":\"allElements\",\"computed\":\"listEachItemTwoKeywordsOriginOffsets\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-position\"},\"background-position-x\":{\"syntax\":\"[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"left\",\"appliesto\":\"allElements\",\"computed\":\"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-position-x\"},\"background-position-y\":{\"syntax\":\"[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"top\",\"appliesto\":\"allElements\",\"computed\":\"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-position-y\"},\"background-repeat\":{\"syntax\":\"<repeat-style>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"repeat\",\"appliesto\":\"allElements\",\"computed\":\"listEachItemHasTwoKeywordsOnePerDimension\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-repeat\"},\"background-size\":{\"syntax\":\"<bg-size>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"repeatableListOfSimpleListOfLpc\",\"percentages\":\"relativeToBackgroundPositioningArea\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"auto auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/background-size\"},\"block-overflow\":{\"syntax\":\"clip | ellipsis | <string>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"clip\",\"appliesto\":\"blockContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"experimental\"},\"block-size\":{\"syntax\":\"<'width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"blockSizeOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"sameAsWidthAndHeight\",\"computed\":\"sameAsWidthAndHeight\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/block-size\"},\"border\":{\"syntax\":\"<line-width> || <line-style> || <color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-color\",\"border-style\",\"border-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-width\",\"border-style\",\"border-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-width\",\"border-style\",\"border-color\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border\"},\"border-block\":{\"syntax\":\"<'border-top-width'> || <'border-top-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block\"},\"border-block-color\":{\"syntax\":\"<'border-top-color'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-color\"},\"border-block-style\":{\"syntax\":\"<'border-top-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-style\"},\"border-block-width\":{\"syntax\":\"<'border-top-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-width\"},\"border-block-end\":{\"syntax\":\"<'border-top-width'> || <'border-top-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-block-end-color\",\"border-block-end-style\",\"border-block-end-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-end\"},\"border-block-end-color\":{\"syntax\":\"<'border-top-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-end-color\"},\"border-block-end-style\":{\"syntax\":\"<'border-top-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-end-style\"},\"border-block-end-width\":{\"syntax\":\"<'border-top-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-end-width\"},\"border-block-start\":{\"syntax\":\"<'border-top-width'> || <'border-top-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-block-start-color\",\"border-block-start-style\",\"border-block-start-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":[\"border-width\",\"border-style\",\"color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-width\",\"border-style\",\"border-block-start-color\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-start\"},\"border-block-start-color\":{\"syntax\":\"<'border-top-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-start-color\"},\"border-block-start-style\":{\"syntax\":\"<'border-top-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-start-style\"},\"border-block-start-width\":{\"syntax\":\"<'border-top-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-block-start-width\"},\"border-bottom\":{\"syntax\":\"<line-width> || <line-style> || <color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-bottom-color\",\"border-bottom-style\",\"border-bottom-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-bottom-width\",\"border-bottom-style\",\"border-bottom-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-bottom-width\",\"border-bottom-style\",\"border-bottom-color\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-bottom\"},\"border-bottom-color\":{\"syntax\":\"<'border-top-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-bottom-color\"},\"border-bottom-left-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius\"},\"border-bottom-right-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius\"},\"border-bottom-style\":{\"syntax\":\"<line-style>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-bottom-style\"},\"border-bottom-width\":{\"syntax\":\"<line-width>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOr0IfBorderBottomStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-bottom-width\"},\"border-collapse\":{\"syntax\":\"collapse | separate\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Table\"],\"initial\":\"separate\",\"appliesto\":\"tableElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-collapse\"},\"border-color\":{\"syntax\":\"<color>{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-bottom-color\",\"border-left-color\",\"border-right-color\",\"border-top-color\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-top-color\",\"border-right-color\",\"border-bottom-color\",\"border-left-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-bottom-color\",\"border-left-color\",\"border-right-color\",\"border-top-color\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-color\"},\"border-end-end-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius\"},\"border-end-start-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius\"},\"border-image\":{\"syntax\":\"<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":[\"border-image-slice\",\"border-image-width\"],\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-image-source\",\"border-image-slice\",\"border-image-width\",\"border-image-outset\",\"border-image-repeat\"],\"appliesto\":\"allElementsExceptTableElementsWhenCollapse\",\"computed\":[\"border-image-outset\",\"border-image-repeat\",\"border-image-slice\",\"border-image-source\",\"border-image-width\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-image\"},\"border-image-outset\":{\"syntax\":\"[ <length> | <number> ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptTableElementsWhenCollapse\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-image-outset\"},\"border-image-repeat\":{\"syntax\":\"[ stretch | repeat | round | space ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"stretch\",\"appliesto\":\"allElementsExceptTableElementsWhenCollapse\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-image-repeat\"},\"border-image-slice\":{\"syntax\":\"<number-percentage>{1,4} && fill?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"referToSizeOfBorderImage\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"100%\",\"appliesto\":\"allElementsExceptTableElementsWhenCollapse\",\"computed\":\"oneToFourPercentagesOrAbsoluteLengthsPlusFill\",\"order\":\"percentagesOrLengthsFollowedByFill\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-image-slice\"},\"border-image-source\":{\"syntax\":\"none | <image>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElementsExceptTableElementsWhenCollapse\",\"computed\":\"noneOrImageWithAbsoluteURI\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-image-source\"},\"border-image-width\":{\"syntax\":\"[ <length-percentage> | <number> | auto ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"referToWidthOrHeightOfBorderImageArea\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"1\",\"appliesto\":\"allElementsExceptTableElementsWhenCollapse\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-image-width\"},\"border-inline\":{\"syntax\":\"<'border-top-width'> || <'border-top-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline\"},\"border-inline-end\":{\"syntax\":\"<'border-top-width'> || <'border-top-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-inline-end-color\",\"border-inline-end-style\",\"border-inline-end-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":[\"border-width\",\"border-style\",\"color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-width\",\"border-style\",\"border-inline-end-color\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-end\"},\"border-inline-color\":{\"syntax\":\"<'border-top-color'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-color\"},\"border-inline-style\":{\"syntax\":\"<'border-top-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-style\"},\"border-inline-width\":{\"syntax\":\"<'border-top-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-width\"},\"border-inline-end-color\":{\"syntax\":\"<'border-top-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color\"},\"border-inline-end-style\":{\"syntax\":\"<'border-top-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style\"},\"border-inline-end-width\":{\"syntax\":\"<'border-top-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width\"},\"border-inline-start\":{\"syntax\":\"<'border-top-width'> || <'border-top-style'> || <'color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-inline-start-color\",\"border-inline-start-style\",\"border-inline-start-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":[\"border-width\",\"border-style\",\"color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-width\",\"border-style\",\"border-inline-start-color\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-start\"},\"border-inline-start-color\":{\"syntax\":\"<'border-top-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color\"},\"border-inline-start-style\":{\"syntax\":\"<'border-top-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style\"},\"border-inline-start-width\":{\"syntax\":\"<'border-top-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthZeroIfBorderStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width\"},\"border-left\":{\"syntax\":\"<line-width> || <line-style> || <color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-left-color\",\"border-left-style\",\"border-left-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-left-width\",\"border-left-style\",\"border-left-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-left-width\",\"border-left-style\",\"border-left-color\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-left\"},\"border-left-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-left-color\"},\"border-left-style\":{\"syntax\":\"<line-style>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-left-style\"},\"border-left-width\":{\"syntax\":\"<line-width>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOr0IfBorderLeftStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-left-width\"},\"border-radius\":{\"syntax\":\"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-top-left-radius\",\"border-top-right-radius\",\"border-bottom-right-radius\",\"border-bottom-left-radius\"],\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-top-left-radius\",\"border-top-right-radius\",\"border-bottom-right-radius\",\"border-bottom-left-radius\"],\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":[\"border-bottom-left-radius\",\"border-bottom-right-radius\",\"border-top-left-radius\",\"border-top-right-radius\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-radius\"},\"border-right\":{\"syntax\":\"<line-width> || <line-style> || <color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-right-color\",\"border-right-style\",\"border-right-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-right-width\",\"border-right-style\",\"border-right-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-right-width\",\"border-right-style\",\"border-right-color\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-right\"},\"border-right-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-right-color\"},\"border-right-style\":{\"syntax\":\"<line-style>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-right-style\"},\"border-right-width\":{\"syntax\":\"<line-width>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOr0IfBorderRightStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-right-width\"},\"border-spacing\":{\"syntax\":\"<length> <length>?\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Table\"],\"initial\":\"0\",\"appliesto\":\"tableElements\",\"computed\":\"twoAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-spacing\"},\"border-start-end-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius\"},\"border-start-start-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius\"},\"border-style\":{\"syntax\":\"<line-style>{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-top-style\",\"border-right-style\",\"border-bottom-style\",\"border-left-style\"],\"appliesto\":\"allElements\",\"computed\":[\"border-bottom-style\",\"border-left-style\",\"border-right-style\",\"border-top-style\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-style\"},\"border-top\":{\"syntax\":\"<line-width> || <line-style> || <color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-top-color\",\"border-top-style\",\"border-top-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"appliesto\":\"allElements\",\"computed\":[\"border-top-width\",\"border-top-style\",\"border-top-color\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-top\"},\"border-top-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-top-color\"},\"border-top-left-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius\"},\"border-top-right-radius\":{\"syntax\":\"<length-percentage>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfBorderBox\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"0\",\"appliesto\":\"allElementsUAsNotRequiredWhenCollapse\",\"computed\":\"twoAbsoluteLengthOrPercentages\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius\"},\"border-top-style\":{\"syntax\":\"<line-style>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-top-style\"},\"border-top-width\":{\"syntax\":\"<line-width>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOr0IfBorderTopStyleNoneOrHidden\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-top-width\"},\"border-width\":{\"syntax\":\"<line-width>{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"border-bottom-width\",\"border-left-width\",\"border-right-width\",\"border-top-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":[\"border-top-width\",\"border-right-width\",\"border-bottom-width\",\"border-left-width\"],\"appliesto\":\"allElements\",\"computed\":[\"border-bottom-width\",\"border-left-width\",\"border-right-width\",\"border-top-width\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/border-width\"},\"bottom\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToContainingBlockHeight\",\"groups\":[\"CSS Positioning\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/bottom\"},\"box-align\":{\"syntax\":\"start | center | end | baseline | stretch\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"stretch\",\"appliesto\":\"elementsWithDisplayBoxOrInlineBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-align\"},\"box-decoration-break\":{\"syntax\":\"slice | clone\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fragmentation\"],\"initial\":\"slice\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-decoration-break\"},\"box-direction\":{\"syntax\":\"normal | reverse | inherit\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"normal\",\"appliesto\":\"elementsWithDisplayBoxOrInlineBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-direction\"},\"box-flex\":{\"syntax\":\"<number>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"0\",\"appliesto\":\"directChildrenOfElementsWithDisplayMozBoxMozInlineBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-flex\"},\"box-flex-group\":{\"syntax\":\"<integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"1\",\"appliesto\":\"inFlowChildrenOfBoxElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-flex-group\"},\"box-lines\":{\"syntax\":\"single | multiple\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"single\",\"appliesto\":\"boxElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-lines\"},\"box-ordinal-group\":{\"syntax\":\"<integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"1\",\"appliesto\":\"childrenOfBoxElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group\"},\"box-orient\":{\"syntax\":\"horizontal | vertical | inline-axis | block-axis | inherit\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"inlineAxisHorizontalInXUL\",\"appliesto\":\"elementsWithDisplayBoxOrInlineBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-orient\"},\"box-pack\":{\"syntax\":\"start | center | end | justify\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\",\"WebKit Extensions\"],\"initial\":\"start\",\"appliesto\":\"elementsWithDisplayMozBoxMozInlineBox\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-pack\"},\"box-shadow\":{\"syntax\":\"none | <shadow>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"shadowList\",\"percentages\":\"no\",\"groups\":[\"CSS Backgrounds and Borders\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthsSpecifiedColorAsSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-shadow\"},\"box-sizing\":{\"syntax\":\"content-box | border-box\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"content-box\",\"appliesto\":\"allElementsAcceptingWidthOrHeight\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/box-sizing\"},\"break-after\":{\"syntax\":\"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fragmentation\"],\"initial\":\"auto\",\"appliesto\":\"blockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/break-after\"},\"break-before\":{\"syntax\":\"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fragmentation\"],\"initial\":\"auto\",\"appliesto\":\"blockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/break-before\"},\"break-inside\":{\"syntax\":\"auto | avoid | avoid-page | avoid-column | avoid-region\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fragmentation\"],\"initial\":\"auto\",\"appliesto\":\"blockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/break-inside\"},\"caption-side\":{\"syntax\":\"top | bottom | block-start | block-end | inline-start | inline-end\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Table\"],\"initial\":\"top\",\"appliesto\":\"tableCaptionElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/caption-side\"},\"caret-color\":{\"syntax\":\"auto | <color>\",\"media\":\"interactive\",\"inherited\":true,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asAutoOrColor\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/caret-color\"},\"clear\":{\"syntax\":\"none | left | right | both | inline-start | inline-end\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Positioning\"],\"initial\":\"none\",\"appliesto\":\"blockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/clear\"},\"clip\":{\"syntax\":\"<shape> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"rectangle\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"auto\",\"appliesto\":\"absolutelyPositionedElements\",\"computed\":\"autoOrRectangle\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/clip\"},\"clip-path\":{\"syntax\":\"<clip-source> | [ <basic-shape> || <geometry-box> ] | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"basicShapeOtherwiseNo\",\"percentages\":\"referToReferenceBoxWhenSpecifiedOtherwiseBorderBox\",\"groups\":[\"CSS Masking\"],\"initial\":\"none\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecifiedURLsAbsolute\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/clip-path\"},\"color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Color\"],\"initial\":\"variesFromBrowserToBrowser\",\"appliesto\":\"allElements\",\"computed\":\"translucentValuesRGBAOtherwiseRGB\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/color\"},\"color-adjust\":{\"syntax\":\"economy | exact\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Color\"],\"initial\":\"economy\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/color-adjust\"},\"column-count\":{\"syntax\":\"<integer> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"integer\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"auto\",\"appliesto\":\"blockContainersExceptTableWrappers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-count\"},\"column-fill\":{\"syntax\":\"auto | balance | balance-all\",\"media\":\"visualInContinuousMediaNoEffectInOverflowColumns\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"balance\",\"appliesto\":\"multicolElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-fill\"},\"column-gap\":{\"syntax\":\"normal | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"normal\",\"appliesto\":\"multiColumnElementsFlexContainersGridContainers\",\"computed\":\"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-gap\"},\"column-rule\":{\"syntax\":\"<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"column-rule-color\",\"column-rule-style\",\"column-rule-width\"],\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":[\"column-rule-width\",\"column-rule-style\",\"column-rule-color\"],\"appliesto\":\"multicolElements\",\"computed\":[\"column-rule-color\",\"column-rule-style\",\"column-rule-width\"],\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-rule\"},\"column-rule-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"currentcolor\",\"appliesto\":\"multicolElements\",\"computed\":\"computedColor\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-rule-color\"},\"column-rule-style\":{\"syntax\":\"<'border-style'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"none\",\"appliesto\":\"multicolElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-rule-style\"},\"column-rule-width\":{\"syntax\":\"<'border-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"medium\",\"appliesto\":\"multicolElements\",\"computed\":\"absoluteLength0IfColumnRuleStyleNoneOrHidden\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-rule-width\"},\"column-span\":{\"syntax\":\"none | all\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"none\",\"appliesto\":\"inFlowBlockLevelElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-span\"},\"column-width\":{\"syntax\":\"<length> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":\"auto\",\"appliesto\":\"blockContainersExceptTableWrappers\",\"computed\":\"absoluteLengthZeroOrLarger\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-width\"},\"columns\":{\"syntax\":\"<'column-width'> || <'column-count'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"column-width\",\"column-count\"],\"percentages\":\"no\",\"groups\":[\"CSS Columns\"],\"initial\":[\"column-width\",\"column-count\"],\"appliesto\":\"blockContainersExceptTableWrappers\",\"computed\":[\"column-width\",\"column-count\"],\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/columns\"},\"contain\":{\"syntax\":\"none | strict | content | [ size || layout || style || paint ]\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Containment\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/contain\"},\"content\":{\"syntax\":\"normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Generated Content\"],\"initial\":\"normal\",\"appliesto\":\"beforeAndAfterPseudos\",\"computed\":\"normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/content\"},\"counter-increment\":{\"syntax\":\"[ <custom-ident> <integer>? ]+ | none\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Counter Styles\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/counter-increment\"},\"counter-reset\":{\"syntax\":\"[ <custom-ident> <integer>? ]+ | none\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Counter Styles\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/counter-reset\"},\"counter-set\":{\"syntax\":\"[ <custom-ident> <integer>? ]+ | none\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Counter Styles\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/counter-set\"},\"cursor\":{\"syntax\":\"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]\",\"media\":[\"visual\",\"interactive\"],\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedURLsAbsolute\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/cursor\"},\"direction\":{\"syntax\":\"ltr | rtl\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Writing Modes\"],\"initial\":\"ltr\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/direction\"},\"display\":{\"syntax\":\"[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Display\"],\"initial\":\"inline\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/display\"},\"empty-cells\":{\"syntax\":\"show | hide\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Table\"],\"initial\":\"show\",\"appliesto\":\"tableCellElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/empty-cells\"},\"filter\":{\"syntax\":\"none | <filter-function-list>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"filterList\",\"percentages\":\"no\",\"groups\":[\"Filter Effects\"],\"initial\":\"none\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/filter\"},\"flex\":{\"syntax\":\"none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"flex-grow\",\"flex-shrink\",\"flex-basis\"],\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":[\"flex-grow\",\"flex-shrink\",\"flex-basis\"],\"appliesto\":\"flexItemsAndInFlowPseudos\",\"computed\":[\"flex-grow\",\"flex-shrink\",\"flex-basis\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex\"},\"flex-basis\":{\"syntax\":\"content | <'width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToFlexContainersInnerMainSize\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":\"auto\",\"appliesto\":\"flexItemsAndInFlowPseudos\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"lengthOrPercentageBeforeKeywordIfBothPresent\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex-basis\"},\"flex-direction\":{\"syntax\":\"row | row-reverse | column | column-reverse\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":\"row\",\"appliesto\":\"flexContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex-direction\"},\"flex-flow\":{\"syntax\":\"<'flex-direction'> || <'flex-wrap'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":[\"flex-direction\",\"flex-wrap\"],\"appliesto\":\"flexContainers\",\"computed\":[\"flex-direction\",\"flex-wrap\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex-flow\"},\"flex-grow\":{\"syntax\":\"<number>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"number\",\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":\"0\",\"appliesto\":\"flexItemsAndInFlowPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex-grow\"},\"flex-shrink\":{\"syntax\":\"<number>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"number\",\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":\"1\",\"appliesto\":\"flexItemsAndInFlowPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex-shrink\"},\"flex-wrap\":{\"syntax\":\"nowrap | wrap | wrap-reverse\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":\"nowrap\",\"appliesto\":\"flexContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/flex-wrap\"},\"float\":{\"syntax\":\"left | right | none | inline-start | inline-end\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Positioning\"],\"initial\":\"none\",\"appliesto\":\"allElementsNoEffectIfDisplayNone\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/float\"},\"font\":{\"syntax\":\"[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar\",\"media\":\"visual\",\"inherited\":true,\"animationType\":[\"font-style\",\"font-variant\",\"font-weight\",\"font-stretch\",\"font-size\",\"line-height\",\"font-family\"],\"percentages\":[\"font-size\",\"line-height\"],\"groups\":[\"CSS Fonts\"],\"initial\":[\"font-style\",\"font-variant\",\"font-weight\",\"font-stretch\",\"font-size\",\"line-height\",\"font-family\"],\"appliesto\":\"allElements\",\"computed\":[\"font-style\",\"font-variant\",\"font-weight\",\"font-stretch\",\"font-size\",\"line-height\",\"font-family\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font\"},\"font-family\":{\"syntax\":\"[ <family-name> | <generic-family> ]#\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"dependsOnUserAgent\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-family\"},\"font-feature-settings\":{\"syntax\":\"normal | <feature-tag-value>#\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-feature-settings\"},\"font-kerning\":{\"syntax\":\"auto | normal | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-kerning\"},\"font-language-override\":{\"syntax\":\"normal | <string>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-language-override\"},\"font-optical-sizing\":{\"syntax\":\"auto | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing\"},\"font-variation-settings\":{\"syntax\":\"normal | [ <string> <number> ]#\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"transform\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variation-settings\"},\"font-size\":{\"syntax\":\"<absolute-size> | <relative-size> | <length-percentage>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"length\",\"percentages\":\"referToParentElementsFontSize\",\"groups\":[\"CSS Fonts\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-size\"},\"font-size-adjust\":{\"syntax\":\"none | <number>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"number\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-size-adjust\"},\"font-smooth\":{\"syntax\":\"auto | never | always | <absolute-size> | <length>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-smooth\"},\"font-stretch\":{\"syntax\":\"<font-stretch-absolute>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"fontStretch\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-stretch\"},\"font-style\":{\"syntax\":\"normal | italic | oblique <angle>?\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-style\"},\"font-synthesis\":{\"syntax\":\"none | [ weight || style ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"weight style\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-synthesis\"},\"font-variant\":{\"syntax\":\"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant\"},\"font-variant-alternates\":{\"syntax\":\"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates\"},\"font-variant-caps\":{\"syntax\":\"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant-caps\"},\"font-variant-east-asian\":{\"syntax\":\"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian\"},\"font-variant-ligatures\":{\"syntax\":\"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures\"},\"font-variant-numeric\":{\"syntax\":\"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric\"},\"font-variant-position\":{\"syntax\":\"normal | sub | super\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-variant-position\"},\"font-weight\":{\"syntax\":\"<font-weight-absolute> | bolder | lighter\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"fontWeight\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"keywordOrNumericalValueBolderLighterTransformedToRealValue\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/font-weight\"},\"gap\":{\"syntax\":\"<'row-gap'> <'column-gap'>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"row-gap\",\"column-gap\"],\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":[\"row-gap\",\"column-gap\"],\"appliesto\":\"multiColumnElementsFlexContainersGridContainers\",\"computed\":[\"row-gap\",\"column-gap\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/gap\"},\"grid\":{\"syntax\":\"<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":[\"grid-template-rows\",\"grid-template-columns\",\"grid-auto-rows\",\"grid-auto-columns\"],\"groups\":[\"CSS Grid Layout\"],\"initial\":[\"grid-template-rows\",\"grid-template-columns\",\"grid-template-areas\",\"grid-auto-rows\",\"grid-auto-columns\",\"grid-auto-flow\",\"grid-column-gap\",\"grid-row-gap\",\"column-gap\",\"row-gap\"],\"appliesto\":\"gridContainers\",\"computed\":[\"grid-template-rows\",\"grid-template-columns\",\"grid-template-areas\",\"grid-auto-rows\",\"grid-auto-columns\",\"grid-auto-flow\",\"grid-column-gap\",\"grid-row-gap\",\"column-gap\",\"row-gap\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid\"},\"grid-area\":{\"syntax\":\"<grid-line> [ / <grid-line> ]{0,3}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":[\"grid-row-start\",\"grid-column-start\",\"grid-row-end\",\"grid-column-end\"],\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":[\"grid-row-start\",\"grid-column-start\",\"grid-row-end\",\"grid-column-end\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-area\"},\"grid-auto-columns\":{\"syntax\":\"<track-size>+\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"auto\",\"appliesto\":\"gridContainers\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns\"},\"grid-auto-flow\":{\"syntax\":\"[ row | column ] || dense\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"row\",\"appliesto\":\"gridContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow\"},\"grid-auto-rows\":{\"syntax\":\"<track-size>+\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"auto\",\"appliesto\":\"gridContainers\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows\"},\"grid-column\":{\"syntax\":\"<grid-line> [ / <grid-line> ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":[\"grid-column-start\",\"grid-column-end\"],\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":[\"grid-column-start\",\"grid-column-end\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-column\"},\"grid-column-end\":{\"syntax\":\"<grid-line>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"auto\",\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-column-end\"},\"grid-column-gap\":{\"syntax\":\"<length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"0\",\"appliesto\":\"gridContainers\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/column-gap\"},\"grid-column-start\":{\"syntax\":\"<grid-line>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"auto\",\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-column-start\"},\"grid-gap\":{\"syntax\":\"<'grid-row-gap'> <'grid-column-gap'>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"grid-row-gap\",\"grid-column-gap\"],\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":[\"grid-row-gap\",\"grid-column-gap\"],\"appliesto\":\"gridContainers\",\"computed\":[\"grid-row-gap\",\"grid-column-gap\"],\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/gap\"},\"grid-row\":{\"syntax\":\"<grid-line> [ / <grid-line> ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":[\"grid-row-start\",\"grid-row-end\"],\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":[\"grid-row-start\",\"grid-row-end\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-row\"},\"grid-row-end\":{\"syntax\":\"<grid-line>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"auto\",\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-row-end\"},\"grid-row-gap\":{\"syntax\":\"<length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"0\",\"appliesto\":\"gridContainers\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/row-gap\"},\"grid-row-start\":{\"syntax\":\"<grid-line>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"auto\",\"appliesto\":\"gridItemsAndBoxesWithinGridContainer\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-row-start\"},\"grid-template\":{\"syntax\":\"none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":[\"grid-template-columns\",\"grid-template-rows\"],\"groups\":[\"CSS Grid Layout\"],\"initial\":[\"grid-template-columns\",\"grid-template-rows\",\"grid-template-areas\"],\"appliesto\":\"gridContainers\",\"computed\":[\"grid-template-columns\",\"grid-template-rows\",\"grid-template-areas\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-template\"},\"grid-template-areas\":{\"syntax\":\"none | <string>+\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"none\",\"appliesto\":\"gridContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-template-areas\"},\"grid-template-columns\":{\"syntax\":\"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"simpleListOfLpcDifferenceLpc\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"none\",\"appliesto\":\"gridContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-template-columns\"},\"grid-template-rows\":{\"syntax\":\"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"simpleListOfLpcDifferenceLpc\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Grid Layout\"],\"initial\":\"none\",\"appliesto\":\"gridContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/grid-template-rows\"},\"hanging-punctuation\":{\"syntax\":\"none | [ first || [ force-end | allow-end ] || last ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation\"},\"height\":{\"syntax\":\"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"allElementsButNonReplacedAndTableColumns\",\"computed\":\"percentageAutoOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/height\"},\"hyphens\":{\"syntax\":\"none | manual | auto\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"manual\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/hyphens\"},\"image-orientation\":{\"syntax\":\"from-image | <angle> | [ <angle>? flip ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Images\"],\"initial\":\"0deg\",\"appliesto\":\"allElements\",\"computed\":\"angleRoundedToNextQuarter\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/image-orientation\"},\"image-rendering\":{\"syntax\":\"auto | crisp-edges | pixelated\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Images\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/image-rendering\"},\"image-resolution\":{\"syntax\":\"[ from-image || <resolution> ] && snap?\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Images\"],\"initial\":\"1dppx\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedWithExceptionOfResolution\",\"order\":\"uniqueOrder\",\"status\":\"experimental\"},\"ime-mode\":{\"syntax\":\"auto | normal | active | inactive | disabled\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"auto\",\"appliesto\":\"textFields\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/ime-mode\"},\"initial-letter\":{\"syntax\":\"normal | [ <number> <integer>? ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Inline\"],\"initial\":\"normal\",\"appliesto\":\"firstLetterPseudoElementsAndInlineLevelFirstChildren\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/initial-letter\"},\"initial-letter-align\":{\"syntax\":\"[ auto | alphabetic | hanging | ideographic ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Inline\"],\"initial\":\"auto\",\"appliesto\":\"firstLetterPseudoElementsAndInlineLevelFirstChildren\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/initial-letter-align\"},\"inline-size\":{\"syntax\":\"<'width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"inlineSizeOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"sameAsWidthAndHeight\",\"computed\":\"sameAsWidthAndHeight\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inline-size\"},\"inset\":{\"syntax\":\"<'top'>{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalHeightOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset\"},\"inset-block\":{\"syntax\":\"<'top'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalHeightOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset-block\"},\"inset-block-end\":{\"syntax\":\"<'top'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalHeightOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset-block-end\"},\"inset-block-start\":{\"syntax\":\"<'top'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalHeightOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset-block-start\"},\"inset-inline\":{\"syntax\":\"<'top'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset-inline\"},\"inset-inline-end\":{\"syntax\":\"<'top'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset-inline-end\"},\"inset-inline-start\":{\"syntax\":\"<'top'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"sameAsBoxOffsets\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/inset-inline-start\"},\"isolation\":{\"syntax\":\"auto | isolate\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Compositing and Blending\"],\"initial\":\"auto\",\"appliesto\":\"allElementsSVGContainerGraphicsAndGraphicsReferencingElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/isolation\"},\"justify-content\":{\"syntax\":\"normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"normal\",\"appliesto\":\"flexContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/justify-content\"},\"justify-items\":{\"syntax\":\"normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"legacy\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/justify-items\"},\"justify-self\":{\"syntax\":\"auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"auto\",\"appliesto\":\"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/justify-self\"},\"left\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Positioning\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/left\"},\"letter-spacing\":{\"syntax\":\"normal | <length>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"optimumValueOfAbsoluteLengthOrNormal\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/letter-spacing\"},\"line-break\":{\"syntax\":\"auto | loose | normal | strict | anywhere\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/line-break\"},\"line-clamp\":{\"syntax\":\"none | <integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"integer\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"none\",\"appliesto\":\"blockContainersExceptMultiColumnContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"experimental\"},\"line-height\":{\"syntax\":\"normal | <number> | <length> | <percentage>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"numberOrLength\",\"percentages\":\"referToElementFontSize\",\"groups\":[\"CSS Fonts\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLengthOrAsSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/line-height\"},\"line-height-step\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fonts\"],\"initial\":\"0\",\"appliesto\":\"blockContainers\",\"computed\":\"absoluteLength\",\"order\":\"perGrammar\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/line-height-step\"},\"list-style\":{\"syntax\":\"<'list-style-type'> || <'list-style-position'> || <'list-style-image'>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Lists and Counters\"],\"initial\":[\"list-style-type\",\"list-style-position\",\"list-style-image\"],\"appliesto\":\"listItems\",\"computed\":[\"list-style-image\",\"list-style-position\",\"list-style-type\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/list-style\"},\"list-style-image\":{\"syntax\":\"<url> | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Lists and Counters\"],\"initial\":\"none\",\"appliesto\":\"listItems\",\"computed\":\"noneOrImageWithAbsoluteURI\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/list-style-image\"},\"list-style-position\":{\"syntax\":\"inside | outside\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Lists and Counters\"],\"initial\":\"outside\",\"appliesto\":\"listItems\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/list-style-position\"},\"list-style-type\":{\"syntax\":\"<counter-style> | <string> | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Lists and Counters\"],\"initial\":\"disc\",\"appliesto\":\"listItems\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/list-style-type\"},\"margin\":{\"syntax\":\"[ <length> | <percentage> | auto ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":[\"margin-bottom\",\"margin-left\",\"margin-right\",\"margin-top\"],\"appliesto\":\"allElementsExceptTableDisplayTypes\",\"computed\":[\"margin-bottom\",\"margin-left\",\"margin-right\",\"margin-top\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin\"},\"margin-block\":{\"syntax\":\"<'margin-left'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"dependsOnLayoutModel\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsMargin\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-block\"},\"margin-block-end\":{\"syntax\":\"<'margin-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"dependsOnLayoutModel\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsMargin\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-block-end\"},\"margin-block-start\":{\"syntax\":\"<'margin-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"dependsOnLayoutModel\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsMargin\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-block-start\"},\"margin-bottom\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-bottom\"},\"margin-inline\":{\"syntax\":\"<'margin-left'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"dependsOnLayoutModel\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsMargin\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-inline\"},\"margin-inline-end\":{\"syntax\":\"<'margin-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"dependsOnLayoutModel\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsMargin\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-inline-end\"},\"margin-inline-start\":{\"syntax\":\"<'margin-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"dependsOnLayoutModel\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsMargin\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-inline-start\"},\"margin-left\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-left\"},\"margin-right\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-right\"},\"margin-top\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-top\"},\"margin-trim\":{\"syntax\":\"none | in-flow | all\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"none\",\"appliesto\":\"blockContainersAndMultiColumnContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/margin-trim\"},\"mask\":{\"syntax\":\"<mask-layer>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"mask-image\",\"mask-mode\",\"mask-repeat\",\"mask-position\",\"mask-clip\",\"mask-origin\",\"mask-size\",\"mask-composite\"],\"percentages\":[\"mask-position\"],\"groups\":[\"CSS Masking\"],\"initial\":[\"mask-image\",\"mask-mode\",\"mask-repeat\",\"mask-position\",\"mask-clip\",\"mask-origin\",\"mask-size\",\"mask-composite\"],\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":[\"mask-image\",\"mask-mode\",\"mask-repeat\",\"mask-position\",\"mask-clip\",\"mask-origin\",\"mask-size\",\"mask-composite\"],\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask\"},\"mask-border\":{\"syntax\":\"<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"mask-border-mode\",\"mask-border-outset\",\"mask-border-repeat\",\"mask-border-slice\",\"mask-border-source\",\"mask-border-width\"],\"percentages\":[\"mask-border-slice\",\"mask-border-width\"],\"groups\":[\"CSS Masking\"],\"initial\":[\"mask-border-mode\",\"mask-border-outset\",\"mask-border-repeat\",\"mask-border-slice\",\"mask-border-source\",\"mask-border-width\"],\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":[\"mask-border-mode\",\"mask-border-outset\",\"mask-border-repeat\",\"mask-border-slice\",\"mask-border-source\",\"mask-border-width\"],\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border\"},\"mask-border-mode\":{\"syntax\":\"luminance | alpha\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"alpha\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border-mode\"},\"mask-border-outset\":{\"syntax\":\"[ <length> | <number> ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"0\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border-outset\"},\"mask-border-repeat\":{\"syntax\":\"[ stretch | repeat | round | space ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"stretch\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat\"},\"mask-border-slice\":{\"syntax\":\"<number-percentage>{1,4} fill?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"referToSizeOfMaskBorderImage\",\"groups\":[\"CSS Masking\"],\"initial\":\"0\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border-slice\"},\"mask-border-source\":{\"syntax\":\"none | <image>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"none\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecifiedURLsAbsolute\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border-source\"},\"mask-border-width\":{\"syntax\":\"[ <length-percentage> | <number> | auto ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"relativeToMaskBorderImageArea\",\"groups\":[\"CSS Masking\"],\"initial\":\"auto\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-border-width\"},\"mask-clip\":{\"syntax\":\"[ <geometry-box> | no-clip ]#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"border-box\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-clip\"},\"mask-composite\":{\"syntax\":\"<compositing-operator>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"add\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-composite\"},\"mask-image\":{\"syntax\":\"<mask-reference>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"none\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecifiedURLsAbsolute\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-image\"},\"mask-mode\":{\"syntax\":\"<masking-mode>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"match-source\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-mode\"},\"mask-origin\":{\"syntax\":\"<geometry-box>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"border-box\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-origin\"},\"mask-position\":{\"syntax\":\"<position>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"repeatableListOfSimpleListOfLpc\",\"percentages\":\"referToSizeOfMaskPaintingArea\",\"groups\":[\"CSS Masking\"],\"initial\":\"center\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"consistsOfTwoKeywordsForOriginAndOffsets\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-position\"},\"mask-repeat\":{\"syntax\":\"<repeat-style>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"no-repeat\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"consistsOfTwoDimensionKeywords\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-repeat\"},\"mask-size\":{\"syntax\":\"<bg-size>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"repeatableListOfSimpleListOfLpc\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"auto\",\"appliesto\":\"allElementsSVGContainerElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-size\"},\"mask-type\":{\"syntax\":\"luminance | alpha\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Masking\"],\"initial\":\"luminance\",\"appliesto\":\"maskElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mask-type\"},\"max-block-size\":{\"syntax\":\"<'max-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"blockSizeOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsWidthAndHeight\",\"computed\":\"sameAsMaxWidthAndMaxHeight\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/max-block-size\"},\"max-height\":{\"syntax\":\"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"regardingHeightOfGeneratedBoxContainingBlockPercentagesNone\",\"groups\":[\"CSS Box Model\"],\"initial\":\"none\",\"appliesto\":\"allElementsButNonReplacedAndTableColumns\",\"computed\":\"percentageAsSpecifiedAbsoluteLengthOrNone\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/max-height\"},\"max-inline-size\":{\"syntax\":\"<'max-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"inlineSizeOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsWidthAndHeight\",\"computed\":\"sameAsMaxWidthAndMaxHeight\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/max-inline-size\"},\"max-lines\":{\"syntax\":\"none | <integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"integer\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"none\",\"appliesto\":\"blockContainersExceptMultiColumnContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"experimental\"},\"max-width\":{\"syntax\":\"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"none\",\"appliesto\":\"allElementsButNonReplacedAndTableRows\",\"computed\":\"percentageAsSpecifiedAbsoluteLengthOrNone\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/max-width\"},\"min-block-size\":{\"syntax\":\"<'min-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"blockSizeOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsWidthAndHeight\",\"computed\":\"sameAsMinWidthAndMinHeight\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/min-block-size\"},\"min-height\":{\"syntax\":\"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"regardingHeightOfGeneratedBoxContainingBlockPercentages0\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"allElementsButNonReplacedAndTableColumns\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/min-height\"},\"min-inline-size\":{\"syntax\":\"<'min-width'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"inlineSizeOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"sameAsWidthAndHeight\",\"computed\":\"sameAsMinWidthAndMinHeight\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/min-inline-size\"},\"min-width\":{\"syntax\":\"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"allElementsButNonReplacedAndTableRows\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/min-width\"},\"mix-blend-mode\":{\"syntax\":\"<blend-mode>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Compositing and Blending\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode\"},\"object-fit\":{\"syntax\":\"fill | contain | cover | none | scale-down\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Images\"],\"initial\":\"fill\",\"appliesto\":\"replacedElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/object-fit\"},\"object-position\":{\"syntax\":\"<position>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"repeatableListOfSimpleListOfLpc\",\"percentages\":\"referToWidthAndHeightOfElement\",\"groups\":[\"CSS Images\"],\"initial\":\"50% 50%\",\"appliesto\":\"replacedElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/object-position\"},\"offset\":{\"syntax\":\"[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"offset-position\",\"offset-path\",\"offset-distance\",\"offset-anchor\",\"offset-rotate\"],\"percentages\":[\"offset-position\",\"offset-distance\",\"offset-anchor\"],\"groups\":[\"CSS Motion Path\"],\"initial\":[\"offset-position\",\"offset-path\",\"offset-distance\",\"offset-anchor\",\"offset-rotate\"],\"appliesto\":\"transformableElements\",\"computed\":[\"offset-position\",\"offset-path\",\"offset-distance\",\"offset-anchor\",\"offset-rotate\"],\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/offset\"},\"offset-anchor\":{\"syntax\":\"auto | <position>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"position\",\"percentages\":\"relativeToWidthAndHeight\",\"groups\":[\"CSS Motion Path\"],\"initial\":\"auto\",\"appliesto\":\"transformableElements\",\"computed\":\"forLengthAbsoluteValueOtherwisePercentage\",\"order\":\"perGrammar\",\"status\":\"standard\"},\"offset-distance\":{\"syntax\":\"<length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToTotalPathLength\",\"groups\":[\"CSS Motion Path\"],\"initial\":\"0\",\"appliesto\":\"transformableElements\",\"computed\":\"forLengthAbsoluteValueOtherwisePercentage\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/offset-distance\"},\"offset-path\":{\"syntax\":\"none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"angleOrBasicShapeOrPath\",\"percentages\":\"no\",\"groups\":[\"CSS Motion Path\"],\"initial\":\"none\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/offset-path\"},\"offset-position\":{\"syntax\":\"auto | <position>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"position\",\"percentages\":\"referToSizeOfContainingBlock\",\"groups\":[\"CSS Motion Path\"],\"initial\":\"auto\",\"appliesto\":\"transformableElements\",\"computed\":\"forLengthAbsoluteValueOtherwisePercentage\",\"order\":\"perGrammar\",\"status\":\"experimental\"},\"offset-rotate\":{\"syntax\":\"[ auto | reverse ] || <angle>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"angleOrBasicShapeOrPath\",\"percentages\":\"no\",\"groups\":[\"CSS Motion Path\"],\"initial\":\"auto\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/offset-rotate\"},\"opacity\":{\"syntax\":\"<alpha-value>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"number\",\"percentages\":\"no\",\"groups\":[\"CSS Color\"],\"initial\":\"1.0\",\"appliesto\":\"allElements\",\"computed\":\"specifiedValueClipped0To1\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/opacity\"},\"order\":{\"syntax\":\"<integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"integer\",\"percentages\":\"no\",\"groups\":[\"CSS Flexible Box Layout\"],\"initial\":\"0\",\"appliesto\":\"flexItemsGridItemsAbsolutelyPositionedContainerChildren\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/order\"},\"orphans\":{\"syntax\":\"<integer>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fragmentation\"],\"initial\":\"2\",\"appliesto\":\"blockContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/orphans\"},\"outline\":{\"syntax\":\"[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]\",\"media\":[\"visual\",\"interactive\"],\"inherited\":false,\"animationType\":[\"outline-color\",\"outline-width\",\"outline-style\"],\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":[\"outline-color\",\"outline-style\",\"outline-width\"],\"appliesto\":\"allElements\",\"computed\":[\"outline-color\",\"outline-width\",\"outline-style\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/outline\"},\"outline-color\":{\"syntax\":\"<color> | invert\",\"media\":[\"visual\",\"interactive\"],\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"invertOrCurrentColor\",\"appliesto\":\"allElements\",\"computed\":\"invertForTranslucentColorRGBAOtherwiseRGB\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/outline-color\"},\"outline-offset\":{\"syntax\":\"<length>\",\"media\":[\"visual\",\"interactive\"],\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/outline-offset\"},\"outline-style\":{\"syntax\":\"auto | <'border-style'>\",\"media\":[\"visual\",\"interactive\"],\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/outline-style\"},\"outline-width\":{\"syntax\":\"<line-width>\",\"media\":[\"visual\",\"interactive\"],\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"medium\",\"appliesto\":\"allElements\",\"computed\":\"absoluteLength0ForNone\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/outline-width\"},\"overflow\":{\"syntax\":\"[ visible | hidden | clip | scroll | auto ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"visible\",\"appliesto\":\"blockContainersFlexContainersGridContainers\",\"computed\":[\"overflow-x\",\"overflow-y\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overflow\"},\"overflow-anchor\":{\"syntax\":\"auto | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Anchoring\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\"},\"overflow-block\":{\"syntax\":\"visible | hidden | clip | scroll | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"auto\",\"appliesto\":\"blockContainersFlexContainersGridContainers\",\"computed\":\"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent\",\"order\":\"perGrammar\",\"status\":\"standard\"},\"overflow-clip-box\":{\"syntax\":\"padding-box | content-box\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Mozilla Extensions\"],\"initial\":\"padding-box\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box\"},\"overflow-inline\":{\"syntax\":\"visible | hidden | clip | scroll | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"auto\",\"appliesto\":\"blockContainersFlexContainersGridContainers\",\"computed\":\"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent\",\"order\":\"perGrammar\",\"status\":\"standard\"},\"overflow-wrap\":{\"syntax\":\"normal | break-word | anywhere\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"nonReplacedInlineElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap\"},\"overflow-x\":{\"syntax\":\"visible | hidden | clip | scroll | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"visible\",\"appliesto\":\"blockContainersFlexContainersGridContainers\",\"computed\":\"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overflow-x\"},\"overflow-y\":{\"syntax\":\"visible | hidden | clip | scroll | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Overflow\"],\"initial\":\"visible\",\"appliesto\":\"blockContainersFlexContainersGridContainers\",\"computed\":\"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overflow-y\"},\"overscroll-behavior\":{\"syntax\":\"[ contain | none | auto ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior\"},\"overscroll-behavior-block\":{\"syntax\":\"contain | none | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block\"},\"overscroll-behavior-inline\":{\"syntax\":\"contain | none | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline\"},\"overscroll-behavior-x\":{\"syntax\":\"contain | none | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x\"},\"overscroll-behavior-y\":{\"syntax\":\"contain | none | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"nonReplacedBlockAndInlineBlockElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y\"},\"padding\":{\"syntax\":\"[ <length> | <percentage> ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":[\"padding-bottom\",\"padding-left\",\"padding-right\",\"padding-top\"],\"appliesto\":\"allElementsExceptInternalTableDisplayTypes\",\"computed\":[\"padding-bottom\",\"padding-left\",\"padding-right\",\"padding-top\"],\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding\"},\"padding-block\":{\"syntax\":\"<'padding-left'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-block\"},\"padding-block-end\":{\"syntax\":\"<'padding-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-block-end\"},\"padding-block-start\":{\"syntax\":\"<'padding-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-block-start\"},\"padding-bottom\":{\"syntax\":\"<length> | <percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptInternalTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-bottom\"},\"padding-inline\":{\"syntax\":\"<'padding-left'>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-inline\"},\"padding-inline-end\":{\"syntax\":\"<'padding-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-inline-end\"},\"padding-inline-start\":{\"syntax\":\"<'padding-left'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"logicalWidthOfContainingBlock\",\"groups\":[\"CSS Logical Properties\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-inline-start\"},\"padding-left\":{\"syntax\":\"<length> | <percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptInternalTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-left\"},\"padding-right\":{\"syntax\":\"<length> | <percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptInternalTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-right\"},\"padding-top\":{\"syntax\":\"<length> | <percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"0\",\"appliesto\":\"allElementsExceptInternalTableDisplayTypes\",\"computed\":\"percentageAsSpecifiedOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/padding-top\"},\"page-break-after\":{\"syntax\":\"auto | always | avoid | left | right | recto | verso\",\"media\":[\"visual\",\"paged\"],\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Pages\"],\"initial\":\"auto\",\"appliesto\":\"blockElementsInNormalFlow\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/page-break-after\"},\"page-break-before\":{\"syntax\":\"auto | always | avoid | left | right | recto | verso\",\"media\":[\"visual\",\"paged\"],\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Pages\"],\"initial\":\"auto\",\"appliesto\":\"blockElementsInNormalFlow\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/page-break-before\"},\"page-break-inside\":{\"syntax\":\"auto | avoid\",\"media\":[\"visual\",\"paged\"],\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Pages\"],\"initial\":\"auto\",\"appliesto\":\"blockElementsInNormalFlow\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/page-break-inside\"},\"paint-order\":{\"syntax\":\"normal | [ fill || stroke || markers ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"textElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/paint-order\"},\"perspective\":{\"syntax\":\"none | <length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Transforms\"],\"initial\":\"none\",\"appliesto\":\"transformableElements\",\"computed\":\"absoluteLengthOrNone\",\"order\":\"uniqueOrder\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/perspective\"},\"perspective-origin\":{\"syntax\":\"<position>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"simpleListOfLpc\",\"percentages\":\"referToSizeOfBoundingBox\",\"groups\":[\"CSS Transforms\"],\"initial\":\"50% 50%\",\"appliesto\":\"transformableElements\",\"computed\":\"forLengthAbsoluteValueOtherwisePercentage\",\"order\":\"oneOrTwoValuesLengthAbsoluteKeywordsPercentages\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/perspective-origin\"},\"place-content\":{\"syntax\":\"<'align-content'> <'justify-content'>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"normal\",\"appliesto\":\"multilineFlexContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/place-content\"},\"place-items\":{\"syntax\":\"<'align-items'> <'justify-items'>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":[\"align-items\",\"justify-items\"],\"appliesto\":\"allElements\",\"computed\":[\"align-items\",\"justify-items\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/place-items\"},\"place-self\":{\"syntax\":\"<'align-self'> <'justify-self'>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Box Alignment\"],\"initial\":[\"align-self\",\"justify-self\"],\"appliesto\":\"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems\",\"computed\":[\"align-self\",\"justify-self\"],\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/place-self\"},\"pointer-events\":{\"syntax\":\"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Pointer Events\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/pointer-events\"},\"position\":{\"syntax\":\"static | relative | absolute | sticky | fixed\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Positioning\"],\"initial\":\"static\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/position\"},\"quotes\":{\"syntax\":\"none | auto | [ <string> <string> ]+\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Generated Content\"],\"initial\":\"dependsOnUserAgent\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/quotes\"},\"resize\":{\"syntax\":\"none | both | horizontal | vertical | block | inline\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"none\",\"appliesto\":\"elementsWithOverflowNotVisibleAndReplacedElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/resize\"},\"right\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Positioning\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/right\"},\"rotate\":{\"syntax\":\"none | <angle> | [ x | y | z | <number>{3} ] && <angle>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"transform\",\"percentages\":\"no\",\"groups\":[\"CSS Transforms\"],\"initial\":\"none\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/rotate\"},\"row-gap\":{\"syntax\":\"normal | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToDimensionOfContentArea\",\"groups\":[\"CSS Box Alignment\"],\"initial\":\"normal\",\"appliesto\":\"multiColumnElementsFlexContainersGridContainers\",\"computed\":\"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/row-gap\"},\"ruby-align\":{\"syntax\":\"start | center | space-between | space-around\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Ruby\"],\"initial\":\"space-around\",\"appliesto\":\"rubyBasesAnnotationsBaseAnnotationContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/ruby-align\"},\"ruby-merge\":{\"syntax\":\"separate | collapse | auto\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Ruby\"],\"initial\":\"separate\",\"appliesto\":\"rubyAnnotationsContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\"},\"ruby-position\":{\"syntax\":\"over | under | inter-character\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Ruby\"],\"initial\":\"over\",\"appliesto\":\"rubyAnnotationsContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/ruby-position\"},\"scale\":{\"syntax\":\"none | <number>{1,3}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"transform\",\"percentages\":\"no\",\"groups\":[\"CSS Transforms\"],\"initial\":\"none\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scale\"},\"scrollbar-color\":{\"syntax\":\"auto | dark | light | <color>{2}\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Scrollbars\"],\"initial\":\"auto\",\"appliesto\":\"scrollingBoxes\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scrollbar-color\"},\"scrollbar-width\":{\"syntax\":\"auto | thin | none\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scrollbars\"],\"initial\":\"auto\",\"appliesto\":\"scrollingBoxes\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scrollbar-width\"},\"scroll-behavior\":{\"syntax\":\"auto | smooth\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSSOM View\"],\"initial\":\"auto\",\"appliesto\":\"scrollingBoxes\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-behavior\"},\"scroll-margin\":{\"syntax\":\"<length>{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin\"},\"scroll-margin-block\":{\"syntax\":\"<length>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block\"},\"scroll-margin-block-start\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start\"},\"scroll-margin-block-end\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end\"},\"scroll-margin-bottom\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom\"},\"scroll-margin-inline\":{\"syntax\":\"<length>{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline\"},\"scroll-margin-inline-start\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start\"},\"scroll-margin-inline-end\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end\"},\"scroll-margin-left\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left\"},\"scroll-margin-right\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right\"},\"scroll-margin-top\":{\"syntax\":\"<length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top\"},\"scroll-padding\":{\"syntax\":\"[ auto | <length-percentage> ]{1,4}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding\"},\"scroll-padding-block\":{\"syntax\":\"[ auto | <length-percentage> ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block\"},\"scroll-padding-block-start\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start\"},\"scroll-padding-block-end\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end\"},\"scroll-padding-bottom\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom\"},\"scroll-padding-inline\":{\"syntax\":\"[ auto | <length-percentage> ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline\"},\"scroll-padding-inline-start\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start\"},\"scroll-padding-inline-end\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end\"},\"scroll-padding-left\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left\"},\"scroll-padding-right\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right\"},\"scroll-padding-top\":{\"syntax\":\"auto | <length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"relativeToTheScrollContainersScrollport\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"auto\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top\"},\"scroll-snap-align\":{\"syntax\":\"[ none | start | end | center ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align\"},\"scroll-snap-coordinate\":{\"syntax\":\"none | <position>#\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"position\",\"percentages\":\"referToBorderBox\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate\"},\"scroll-snap-destination\":{\"syntax\":\"<position>\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"position\",\"percentages\":\"relativeToScrollContainerPaddingBoxAxis\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"0px 0px\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination\"},\"scroll-snap-points-x\":{\"syntax\":\"none | repeat( <length-percentage> )\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"relativeToScrollContainerPaddingBoxAxis\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x\"},\"scroll-snap-points-y\":{\"syntax\":\"none | repeat( <length-percentage> )\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"relativeToScrollContainerPaddingBoxAxis\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y\"},\"scroll-snap-stop\":{\"syntax\":\"normal | always\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop\"},\"scroll-snap-type\":{\"syntax\":\"none | [ x | y | block | inline | both ] [ mandatory | proximity ]?\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type\"},\"scroll-snap-type-x\":{\"syntax\":\"none | mandatory | proximity\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x\"},\"scroll-snap-type-y\":{\"syntax\":\"none | mandatory | proximity\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Scroll Snap\"],\"initial\":\"none\",\"appliesto\":\"scrollContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"obsolete\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y\"},\"shape-image-threshold\":{\"syntax\":\"<alpha-value>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"number\",\"percentages\":\"no\",\"groups\":[\"CSS Shapes\"],\"initial\":\"0.0\",\"appliesto\":\"floats\",\"computed\":\"specifiedValueNumberClipped0To1\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold\"},\"shape-margin\":{\"syntax\":\"<length-percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Shapes\"],\"initial\":\"0\",\"appliesto\":\"floats\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/shape-margin\"},\"shape-outside\":{\"syntax\":\"none | <shape-box> || <basic-shape> | <image>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"basicShapeOtherwiseNo\",\"percentages\":\"no\",\"groups\":[\"CSS Shapes\"],\"initial\":\"none\",\"appliesto\":\"floats\",\"computed\":\"asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/shape-outside\"},\"tab-size\":{\"syntax\":\"<integer> | <length>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"length\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"8\",\"appliesto\":\"blockContainers\",\"computed\":\"specifiedIntegerOrAbsoluteLength\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/tab-size\"},\"table-layout\":{\"syntax\":\"auto | fixed\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Table\"],\"initial\":\"auto\",\"appliesto\":\"tableElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/table-layout\"},\"text-align\":{\"syntax\":\"start | end | left | right | center | justify | match-parent\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"startOrNamelessValueIfLTRRightIfRTL\",\"appliesto\":\"blockContainers\",\"computed\":\"asSpecifiedExceptMatchParent\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-align\"},\"text-align-last\":{\"syntax\":\"auto | start | end | left | right | center | justify\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"auto\",\"appliesto\":\"blockContainers\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-align-last\"},\"text-combine-upright\":{\"syntax\":\"none | all | [ digits <integer>? ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"notAnimatable\",\"percentages\":\"no\",\"groups\":[\"CSS Writing Modes\"],\"initial\":\"none\",\"appliesto\":\"nonReplacedInlineElements\",\"computed\":\"keywordPlusIntegerIfDigits\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-combine-upright\"},\"text-decoration\":{\"syntax\":\"<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"text-decoration-color\",\"text-decoration-style\",\"text-decoration-line\",\"text-decoration-thickness\"],\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":[\"text-decoration-color\",\"text-decoration-style\",\"text-decoration-line\"],\"appliesto\":\"allElements\",\"computed\":[\"text-decoration-line\",\"text-decoration-style\",\"text-decoration-color\",\"text-decoration-thickness\"],\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration\"},\"text-decoration-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration-color\"},\"text-decoration-line\":{\"syntax\":\"none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration-line\"},\"text-decoration-skip\":{\"syntax\":\"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"objects\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip\"},\"text-decoration-skip-ink\":{\"syntax\":\"auto | all | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink\"},\"text-decoration-style\":{\"syntax\":\"solid | double | dotted | dashed | wavy\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"solid\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration-style\"},\"text-decoration-thickness\":{\"syntax\":\"auto | from-font | <length> | <percentage> \",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"byComputedValueType\",\"percentages\":\"referToElementFontSize\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness\"},\"text-emphasis\":{\"syntax\":\"<'text-emphasis-style'> || <'text-emphasis-color'>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":[\"text-emphasis-color\",\"text-emphasis-style\"],\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":[\"text-emphasis-style\",\"text-emphasis-color\"],\"appliesto\":\"allElements\",\"computed\":[\"text-emphasis-style\",\"text-emphasis-color\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-emphasis\"},\"text-emphasis-color\":{\"syntax\":\"<color>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"color\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"currentcolor\",\"appliesto\":\"allElements\",\"computed\":\"computedColor\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color\"},\"text-emphasis-position\":{\"syntax\":\"[ over | under ] && [ right | left ]\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"over right\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position\"},\"text-emphasis-style\":{\"syntax\":\"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style\"},\"text-indent\":{\"syntax\":\"<length-percentage> && hanging? && each-line?\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Text\"],\"initial\":\"0\",\"appliesto\":\"blockContainers\",\"computed\":\"percentageOrAbsoluteLengthPlusKeywords\",\"order\":\"lengthOrPercentageBeforeKeywords\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-indent\"},\"text-justify\":{\"syntax\":\"auto | inter-character | inter-word | none\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"auto\",\"appliesto\":\"inlineLevelAndTableCellElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-justify\"},\"text-orientation\":{\"syntax\":\"mixed | upright | sideways\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Writing Modes\"],\"initial\":\"mixed\",\"appliesto\":\"allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-orientation\"},\"text-overflow\":{\"syntax\":\"[ clip | ellipsis | <string> ]{1,2}\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"clip\",\"appliesto\":\"blockContainerElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-overflow\"},\"text-rendering\":{\"syntax\":\"auto | optimizeSpeed | optimizeLegibility | geometricPrecision\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Miscellaneous\"],\"initial\":\"auto\",\"appliesto\":\"textElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-rendering\"},\"text-shadow\":{\"syntax\":\"none | <shadow-t>#\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"shadowList\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"colorPlusThreeAbsoluteLengths\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-shadow\"},\"text-size-adjust\":{\"syntax\":\"none | auto | <percentage>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"referToSizeOfFont\",\"groups\":[\"CSS Text\"],\"initial\":\"autoForSmartphoneBrowsersSupportingInflation\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"experimental\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-size-adjust\"},\"text-transform\":{\"syntax\":\"none | capitalize | uppercase | lowercase | full-width | full-size-kana\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"none\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-transform\"},\"text-underline-offset\":{\"syntax\":\"auto | <length> | <percentage> \",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"byComputedValueType\",\"percentages\":\"referToElementFontSize\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-underline-offset\"},\"text-underline-position\":{\"syntax\":\"auto | from-font | [ under || [ left | right ] ]\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text Decoration\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/text-underline-position\"},\"top\":{\"syntax\":\"<length> | <percentage> | auto\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToContainingBlockHeight\",\"groups\":[\"CSS Positioning\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/top\"},\"touch-action\":{\"syntax\":\"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"Pointer Events\"],\"initial\":\"auto\",\"appliesto\":\"allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/touch-action\"},\"transform\":{\"syntax\":\"none | <transform-list>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"transform\",\"percentages\":\"referToSizeOfBoundingBox\",\"groups\":[\"CSS Transforms\"],\"initial\":\"none\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"uniqueOrder\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transform\"},\"transform-box\":{\"syntax\":\"content-box | border-box | fill-box | stroke-box | view-box\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transforms\"],\"initial\":\"view-box\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transform-box\"},\"transform-origin\":{\"syntax\":\"[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"simpleListOfLpc\",\"percentages\":\"referToSizeOfBoundingBox\",\"groups\":[\"CSS Transforms\"],\"initial\":\"50% 50% 0\",\"appliesto\":\"transformableElements\",\"computed\":\"forLengthAbsoluteValueOtherwisePercentage\",\"order\":\"oneOrTwoValuesLengthAbsoluteKeywordsPercentages\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transform-origin\"},\"transform-style\":{\"syntax\":\"flat | preserve-3d\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transforms\"],\"initial\":\"flat\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transform-style\"},\"transition\":{\"syntax\":\"<single-transition>#\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transitions\"],\"initial\":[\"transition-delay\",\"transition-duration\",\"transition-property\",\"transition-timing-function\"],\"appliesto\":\"allElementsAndPseudos\",\"computed\":[\"transition-delay\",\"transition-duration\",\"transition-property\",\"transition-timing-function\"],\"order\":\"orderOfAppearance\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transition\"},\"transition-delay\":{\"syntax\":\"<time>#\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transitions\"],\"initial\":\"0s\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transition-delay\"},\"transition-duration\":{\"syntax\":\"<time>#\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transitions\"],\"initial\":\"0s\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transition-duration\"},\"transition-property\":{\"syntax\":\"none | <single-transition-property>#\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transitions\"],\"initial\":\"all\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transition-property\"},\"transition-timing-function\":{\"syntax\":\"<timing-function>#\",\"media\":\"interactive\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Transitions\"],\"initial\":\"ease\",\"appliesto\":\"allElementsAndPseudos\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/transition-timing-function\"},\"translate\":{\"syntax\":\"none | <length-percentage> [ <length-percentage> <length>? ]?\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"transform\",\"percentages\":\"referToSizeOfBoundingBox\",\"groups\":[\"CSS Transforms\"],\"initial\":\"none\",\"appliesto\":\"transformableElements\",\"computed\":\"asSpecifiedRelativeToAbsoluteLengths\",\"order\":\"perGrammar\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/translate\"},\"unicode-bidi\":{\"syntax\":\"normal | embed | isolate | bidi-override | isolate-override | plaintext\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Writing Modes\"],\"initial\":\"normal\",\"appliesto\":\"allElementsSomeValuesNoEffectOnNonInlineElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/unicode-bidi\"},\"user-select\":{\"syntax\":\"auto | text | none | contain | all\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Basic User Interface\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/user-select\"},\"vertical-align\":{\"syntax\":\"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"length\",\"percentages\":\"referToLineHeight\",\"groups\":[\"CSS Table\"],\"initial\":\"baseline\",\"appliesto\":\"inlineLevelAndTableCellElements\",\"computed\":\"absoluteLengthOrKeyword\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/vertical-align\"},\"visibility\":{\"syntax\":\"visible | hidden | collapse\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"visibility\",\"percentages\":\"no\",\"groups\":[\"CSS Box Model\"],\"initial\":\"visible\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/visibility\"},\"white-space\":{\"syntax\":\"normal | pre | nowrap | pre-wrap | pre-line | break-spaces\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/white-space\"},\"widows\":{\"syntax\":\"<integer>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Fragmentation\"],\"initial\":\"2\",\"appliesto\":\"blockContainerElements\",\"computed\":\"asSpecified\",\"order\":\"perGrammar\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/widows\"},\"width\":{\"syntax\":\"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"lpc\",\"percentages\":\"referToWidthOfContainingBlock\",\"groups\":[\"CSS Box Model\"],\"initial\":\"auto\",\"appliesto\":\"allElementsButNonReplacedAndTableRows\",\"computed\":\"percentageAutoOrAbsoluteLength\",\"order\":\"lengthOrPercentageBeforeKeywordIfBothPresent\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/width\"},\"will-change\":{\"syntax\":\"auto | <animateable-feature>#\",\"media\":\"all\",\"inherited\":false,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Will Change\"],\"initial\":\"auto\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/will-change\"},\"word-break\":{\"syntax\":\"normal | break-all | keep-all | break-word\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/word-break\"},\"word-spacing\":{\"syntax\":\"normal | <length-percentage>\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"length\",\"percentages\":\"referToWidthOfAffectedGlyph\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal\",\"order\":\"uniqueOrder\",\"alsoAppliesTo\":[\"::first-letter\",\"::first-line\",\"::placeholder\"],\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/word-spacing\"},\"word-wrap\":{\"syntax\":\"normal | break-word\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Text\"],\"initial\":\"normal\",\"appliesto\":\"nonReplacedInlineElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap\"},\"writing-mode\":{\"syntax\":\"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr\",\"media\":\"visual\",\"inherited\":true,\"animationType\":\"discrete\",\"percentages\":\"no\",\"groups\":[\"CSS Writing Modes\"],\"initial\":\"horizontal-tb\",\"appliesto\":\"allElementsExceptTableRowColumnGroupsTableRowsColumns\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/writing-mode\"},\"z-index\":{\"syntax\":\"auto | <integer>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"integer\",\"percentages\":\"no\",\"groups\":[\"CSS Positioning\"],\"initial\":\"auto\",\"appliesto\":\"positionedElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"stacking\":true,\"status\":\"standard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/z-index\"},\"zoom\":{\"syntax\":\"normal | reset | <number> | <percentage>\",\"media\":\"visual\",\"inherited\":false,\"animationType\":\"integer\",\"percentages\":\"no\",\"groups\":[\"Microsoft Extensions\"],\"initial\":\"normal\",\"appliesto\":\"allElements\",\"computed\":\"asSpecified\",\"order\":\"uniqueOrder\",\"status\":\"nonstandard\",\"mdn_url\":\"https://developer.mozilla.org/docs/Web/CSS/zoom\"}}");

/***/ }),
/* 338 */
/***/ (function(module) {

module.exports = JSON.parse("{\"absolute-size\":{\"syntax\":\"xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large\"},\"alpha-value\":{\"syntax\":\"<number> | <percentage>\"},\"angle-percentage\":{\"syntax\":\"<angle> | <percentage>\"},\"angular-color-hint\":{\"syntax\":\"<angle-percentage>\"},\"angular-color-stop\":{\"syntax\":\"<color> && <color-stop-angle>?\"},\"angular-color-stop-list\":{\"syntax\":\"[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>\"},\"animateable-feature\":{\"syntax\":\"scroll-position | contents | <custom-ident>\"},\"attachment\":{\"syntax\":\"scroll | fixed | local\"},\"attr()\":{\"syntax\":\"attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )\"},\"attr-matcher\":{\"syntax\":\"[ '~' | '|' | '^' | '$' | '*' ]? '='\"},\"attr-modifier\":{\"syntax\":\"i | s\"},\"attribute-selector\":{\"syntax\":\"'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\"},\"auto-repeat\":{\"syntax\":\"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )\"},\"auto-track-list\":{\"syntax\":\"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?\"},\"baseline-position\":{\"syntax\":\"[ first | last ]? baseline\"},\"basic-shape\":{\"syntax\":\"<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>\"},\"bg-image\":{\"syntax\":\"none | <image>\"},\"bg-layer\":{\"syntax\":\"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>\"},\"bg-position\":{\"syntax\":\"[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]\"},\"bg-size\":{\"syntax\":\"[ <length-percentage> | auto ]{1,2} | cover | contain\"},\"blur()\":{\"syntax\":\"blur( <length> )\"},\"blend-mode\":{\"syntax\":\"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity\"},\"box\":{\"syntax\":\"border-box | padding-box | content-box\"},\"brightness()\":{\"syntax\":\"brightness( <number-percentage> )\"},\"calc()\":{\"syntax\":\"calc( <calc-sum> )\"},\"calc-sum\":{\"syntax\":\"<calc-product> [ [ '+' | '-' ] <calc-product> ]*\"},\"calc-product\":{\"syntax\":\"<calc-value> [ '*' <calc-value> | '/' <number> ]*\"},\"calc-value\":{\"syntax\":\"<number> | <dimension> | <percentage> | ( <calc-sum> )\"},\"cf-final-image\":{\"syntax\":\"<image> | <color>\"},\"cf-mixing-image\":{\"syntax\":\"<percentage>? && <image>\"},\"circle()\":{\"syntax\":\"circle( [ <shape-radius> ]? [ at <position> ]? )\"},\"clamp()\":{\"syntax\":\"clamp( <calc-sum>#{3} )\"},\"class-selector\":{\"syntax\":\"'.' <ident-token>\"},\"clip-source\":{\"syntax\":\"<url>\"},\"color\":{\"syntax\":\"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>\"},\"color-stop\":{\"syntax\":\"<color-stop-length> | <color-stop-angle>\"},\"color-stop-angle\":{\"syntax\":\"<angle-percentage>{1,2}\"},\"color-stop-length\":{\"syntax\":\"<length-percentage>{1,2}\"},\"color-stop-list\":{\"syntax\":\"[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>\"},\"combinator\":{\"syntax\":\"'>' | '+' | '~' | [ '||' ]\"},\"common-lig-values\":{\"syntax\":\"[ common-ligatures | no-common-ligatures ]\"},\"compat-auto\":{\"syntax\":\"searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button\"},\"composite-style\":{\"syntax\":\"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor\"},\"compositing-operator\":{\"syntax\":\"add | subtract | intersect | exclude\"},\"compound-selector\":{\"syntax\":\"[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!\"},\"compound-selector-list\":{\"syntax\":\"<compound-selector>#\"},\"complex-selector\":{\"syntax\":\"<compound-selector> [ <combinator>? <compound-selector> ]*\"},\"complex-selector-list\":{\"syntax\":\"<complex-selector>#\"},\"conic-gradient()\":{\"syntax\":\"conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )\"},\"contextual-alt-values\":{\"syntax\":\"[ contextual | no-contextual ]\"},\"content-distribution\":{\"syntax\":\"space-between | space-around | space-evenly | stretch\"},\"content-list\":{\"syntax\":\"[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+\"},\"content-position\":{\"syntax\":\"center | start | end | flex-start | flex-end\"},\"content-replacement\":{\"syntax\":\"<image>\"},\"contrast()\":{\"syntax\":\"contrast( [ <number-percentage> ] )\"},\"counter()\":{\"syntax\":\"counter( <custom-ident>, <counter-style>? )\"},\"counter-style\":{\"syntax\":\"<counter-style-name> | symbols()\"},\"counter-style-name\":{\"syntax\":\"<custom-ident>\"},\"counters()\":{\"syntax\":\"counters( <custom-ident>, <string>, <counter-style>? )\"},\"cross-fade()\":{\"syntax\":\"cross-fade( <cf-mixing-image> , <cf-final-image>? )\"},\"cubic-bezier-timing-function\":{\"syntax\":\"ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)\"},\"deprecated-system-color\":{\"syntax\":\"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText\"},\"discretionary-lig-values\":{\"syntax\":\"[ discretionary-ligatures | no-discretionary-ligatures ]\"},\"display-box\":{\"syntax\":\"contents | none\"},\"display-inside\":{\"syntax\":\"flow | flow-root | table | flex | grid | ruby\"},\"display-internal\":{\"syntax\":\"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container\"},\"display-legacy\":{\"syntax\":\"inline-block | inline-list-item | inline-table | inline-flex | inline-grid\"},\"display-listitem\":{\"syntax\":\"<display-outside>? && [ flow | flow-root ]? && list-item\"},\"display-outside\":{\"syntax\":\"block | inline | run-in\"},\"drop-shadow()\":{\"syntax\":\"drop-shadow( <length>{2,3} <color>? )\"},\"east-asian-variant-values\":{\"syntax\":\"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]\"},\"east-asian-width-values\":{\"syntax\":\"[ full-width | proportional-width ]\"},\"element()\":{\"syntax\":\"element( <id-selector> )\"},\"ellipse()\":{\"syntax\":\"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )\"},\"ending-shape\":{\"syntax\":\"circle | ellipse\"},\"env()\":{\"syntax\":\"env( <custom-ident> , <declaration-value>? )\"},\"explicit-track-list\":{\"syntax\":\"[ <line-names>? <track-size> ]+ <line-names>?\"},\"family-name\":{\"syntax\":\"<string> | <custom-ident>+\"},\"feature-tag-value\":{\"syntax\":\"<string> [ <integer> | on | off ]?\"},\"feature-type\":{\"syntax\":\"@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation\"},\"feature-value-block\":{\"syntax\":\"<feature-type> '{' <feature-value-declaration-list> '}'\"},\"feature-value-block-list\":{\"syntax\":\"<feature-value-block>+\"},\"feature-value-declaration\":{\"syntax\":\"<custom-ident>: <integer>+;\"},\"feature-value-declaration-list\":{\"syntax\":\"<feature-value-declaration>\"},\"feature-value-name\":{\"syntax\":\"<custom-ident>\"},\"fill-rule\":{\"syntax\":\"nonzero | evenodd\"},\"filter-function\":{\"syntax\":\"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>\"},\"filter-function-list\":{\"syntax\":\"[ <filter-function> | <url> ]+\"},\"final-bg-layer\":{\"syntax\":\"<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>\"},\"fit-content()\":{\"syntax\":\"fit-content( [ <length> | <percentage> ] )\"},\"fixed-breadth\":{\"syntax\":\"<length-percentage>\"},\"fixed-repeat\":{\"syntax\":\"repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )\"},\"fixed-size\":{\"syntax\":\"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )\"},\"font-stretch-absolute\":{\"syntax\":\"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>\"},\"font-variant-css21\":{\"syntax\":\"[ normal | small-caps ]\"},\"font-weight-absolute\":{\"syntax\":\"normal | bold | <number [1,1000]>\"},\"frequency-percentage\":{\"syntax\":\"<frequency> | <percentage>\"},\"general-enclosed\":{\"syntax\":\"[ <function-token> <any-value> ) ] | ( <ident> <any-value> )\"},\"generic-family\":{\"syntax\":\"serif | sans-serif | cursive | fantasy | monospace\"},\"generic-name\":{\"syntax\":\"serif | sans-serif | cursive | fantasy | monospace\"},\"geometry-box\":{\"syntax\":\"<shape-box> | fill-box | stroke-box | view-box\"},\"gradient\":{\"syntax\":\"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>\"},\"grayscale()\":{\"syntax\":\"grayscale( <number-percentage> )\"},\"grid-line\":{\"syntax\":\"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]\"},\"historical-lig-values\":{\"syntax\":\"[ historical-ligatures | no-historical-ligatures ]\"},\"hsl()\":{\"syntax\":\"hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )\"},\"hsla()\":{\"syntax\":\"hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )\"},\"hue\":{\"syntax\":\"<number> | <angle>\"},\"hue-rotate()\":{\"syntax\":\"hue-rotate( <angle> )\"},\"id-selector\":{\"syntax\":\"<hash-token>\"},\"image\":{\"syntax\":\"<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>\"},\"image()\":{\"syntax\":\"image( <image-tags>? [ <image-src>? , <color>? ]! )\"},\"image-set()\":{\"syntax\":\"image-set( <image-set-option># )\"},\"image-set-option\":{\"syntax\":\"[ <image> | <string> ] <resolution>\"},\"image-src\":{\"syntax\":\"<url> | <string>\"},\"image-tags\":{\"syntax\":\"ltr | rtl\"},\"inflexible-breadth\":{\"syntax\":\"<length> | <percentage> | min-content | max-content | auto\"},\"inset()\":{\"syntax\":\"inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )\"},\"invert()\":{\"syntax\":\"invert( <number-percentage> )\"},\"keyframes-name\":{\"syntax\":\"<custom-ident> | <string>\"},\"keyframe-block\":{\"syntax\":\"<keyframe-selector># {\\n  <declaration-list>\\n}\"},\"keyframe-block-list\":{\"syntax\":\"<keyframe-block>+\"},\"keyframe-selector\":{\"syntax\":\"from | to | <percentage>\"},\"leader()\":{\"syntax\":\"leader( <leader-type> )\"},\"leader-type\":{\"syntax\":\"dotted | solid | space | <string>\"},\"length-percentage\":{\"syntax\":\"<length> | <percentage>\"},\"line-names\":{\"syntax\":\"'[' <custom-ident>* ']'\"},\"line-name-list\":{\"syntax\":\"[ <line-names> | <name-repeat> ]+\"},\"line-style\":{\"syntax\":\"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\"},\"line-width\":{\"syntax\":\"<length> | thin | medium | thick\"},\"linear-color-hint\":{\"syntax\":\"<length-percentage>\"},\"linear-color-stop\":{\"syntax\":\"<color> <color-stop-length>?\"},\"linear-gradient()\":{\"syntax\":\"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )\"},\"mask-layer\":{\"syntax\":\"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>\"},\"mask-position\":{\"syntax\":\"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?\"},\"mask-reference\":{\"syntax\":\"none | <image> | <mask-source>\"},\"mask-source\":{\"syntax\":\"<url>\"},\"masking-mode\":{\"syntax\":\"alpha | luminance | match-source\"},\"matrix()\":{\"syntax\":\"matrix( <number>#{6} )\"},\"matrix3d()\":{\"syntax\":\"matrix3d( <number>#{16} )\"},\"max()\":{\"syntax\":\"max( <calc-sum># )\"},\"media-and\":{\"syntax\":\"<media-in-parens> [ and <media-in-parens> ]+\"},\"media-condition\":{\"syntax\":\"<media-not> | <media-and> | <media-or> | <media-in-parens>\"},\"media-condition-without-or\":{\"syntax\":\"<media-not> | <media-and> | <media-in-parens>\"},\"media-feature\":{\"syntax\":\"( [ <mf-plain> | <mf-boolean> | <mf-range> ] )\"},\"media-in-parens\":{\"syntax\":\"( <media-condition> ) | <media-feature> | <general-enclosed>\"},\"media-not\":{\"syntax\":\"not <media-in-parens>\"},\"media-or\":{\"syntax\":\"<media-in-parens> [ or <media-in-parens> ]+\"},\"media-query\":{\"syntax\":\"<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?\"},\"media-query-list\":{\"syntax\":\"<media-query>#\"},\"media-type\":{\"syntax\":\"<ident>\"},\"mf-boolean\":{\"syntax\":\"<mf-name>\"},\"mf-name\":{\"syntax\":\"<ident>\"},\"mf-plain\":{\"syntax\":\"<mf-name> : <mf-value>\"},\"mf-range\":{\"syntax\":\"<mf-name> [ '<' | '>' ]? '='? <mf-value>\\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>\"},\"mf-value\":{\"syntax\":\"<number> | <dimension> | <ident> | <ratio>\"},\"min()\":{\"syntax\":\"min( <calc-sum># )\"},\"minmax()\":{\"syntax\":\"minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )\"},\"named-color\":{\"syntax\":\"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen\"},\"namespace-prefix\":{\"syntax\":\"<ident>\"},\"ns-prefix\":{\"syntax\":\"[ <ident-token> | '*' ]? '|'\"},\"number-percentage\":{\"syntax\":\"<number> | <percentage>\"},\"numeric-figure-values\":{\"syntax\":\"[ lining-nums | oldstyle-nums ]\"},\"numeric-fraction-values\":{\"syntax\":\"[ diagonal-fractions | stacked-fractions ]\"},\"numeric-spacing-values\":{\"syntax\":\"[ proportional-nums | tabular-nums ]\"},\"nth\":{\"syntax\":\"<an-plus-b> | even | odd\"},\"opacity()\":{\"syntax\":\"opacity( [ <number-percentage> ] )\"},\"overflow-position\":{\"syntax\":\"unsafe | safe\"},\"outline-radius\":{\"syntax\":\"<length> | <percentage>\"},\"page-body\":{\"syntax\":\"<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>\"},\"page-margin-box\":{\"syntax\":\"<page-margin-box-type> '{' <declaration-list> '}'\"},\"page-margin-box-type\":{\"syntax\":\"@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom\"},\"page-selector-list\":{\"syntax\":\"[ <page-selector># ]?\"},\"page-selector\":{\"syntax\":\"<pseudo-page>+ | <ident> <pseudo-page>*\"},\"path()\":{\"syntax\":\"path( [ <fill-rule>, ]? <string> )\"},\"paint()\":{\"syntax\":\"paint( <ident>, <declaration-value>? )\"},\"perspective()\":{\"syntax\":\"perspective( <length> )\"},\"polygon()\":{\"syntax\":\"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )\"},\"position\":{\"syntax\":\"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]\"},\"pseudo-class-selector\":{\"syntax\":\"':' <ident-token> | ':' <function-token> <any-value> ')'\"},\"pseudo-element-selector\":{\"syntax\":\"':' <pseudo-class-selector>\"},\"pseudo-page\":{\"syntax\":\": [ left | right | first | blank ]\"},\"quote\":{\"syntax\":\"open-quote | close-quote | no-open-quote | no-close-quote\"},\"radial-gradient()\":{\"syntax\":\"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )\"},\"relative-selector\":{\"syntax\":\"<combinator>? <complex-selector>\"},\"relative-selector-list\":{\"syntax\":\"<relative-selector>#\"},\"relative-size\":{\"syntax\":\"larger | smaller\"},\"repeat-style\":{\"syntax\":\"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}\"},\"repeating-linear-gradient()\":{\"syntax\":\"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )\"},\"repeating-radial-gradient()\":{\"syntax\":\"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )\"},\"rgb()\":{\"syntax\":\"rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )\"},\"rgba()\":{\"syntax\":\"rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )\"},\"rotate()\":{\"syntax\":\"rotate( [ <angle> | <zero> ] )\"},\"rotate3d()\":{\"syntax\":\"rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )\"},\"rotateX()\":{\"syntax\":\"rotateX( [ <angle> | <zero> ] )\"},\"rotateY()\":{\"syntax\":\"rotateY( [ <angle> | <zero> ] )\"},\"rotateZ()\":{\"syntax\":\"rotateZ( [ <angle> | <zero> ] )\"},\"saturate()\":{\"syntax\":\"saturate( <number-percentage> )\"},\"scale()\":{\"syntax\":\"scale( <number> , <number>? )\"},\"scale3d()\":{\"syntax\":\"scale3d( <number> , <number> , <number> )\"},\"scaleX()\":{\"syntax\":\"scaleX( <number> )\"},\"scaleY()\":{\"syntax\":\"scaleY( <number> )\"},\"scaleZ()\":{\"syntax\":\"scaleZ( <number> )\"},\"self-position\":{\"syntax\":\"center | start | end | self-start | self-end | flex-start | flex-end\"},\"shape-radius\":{\"syntax\":\"<length-percentage> | closest-side | farthest-side\"},\"skew()\":{\"syntax\":\"skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )\"},\"skewX()\":{\"syntax\":\"skewX( [ <angle> | <zero> ] )\"},\"skewY()\":{\"syntax\":\"skewY( [ <angle> | <zero> ] )\"},\"sepia()\":{\"syntax\":\"sepia( <number-percentage> )\"},\"shadow\":{\"syntax\":\"inset? && <length>{2,4} && <color>?\"},\"shadow-t\":{\"syntax\":\"[ <length>{2,3} && <color>? ]\"},\"shape\":{\"syntax\":\"rect(<top>, <right>, <bottom>, <left>)\"},\"shape-box\":{\"syntax\":\"<box> | margin-box\"},\"side-or-corner\":{\"syntax\":\"[ left | right ] || [ top | bottom ]\"},\"single-animation\":{\"syntax\":\"<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]\"},\"single-animation-direction\":{\"syntax\":\"normal | reverse | alternate | alternate-reverse\"},\"single-animation-fill-mode\":{\"syntax\":\"none | forwards | backwards | both\"},\"single-animation-iteration-count\":{\"syntax\":\"infinite | <number>\"},\"single-animation-play-state\":{\"syntax\":\"running | paused\"},\"single-transition\":{\"syntax\":\"[ none | <single-transition-property> ] || <time> || <timing-function> || <time>\"},\"single-transition-property\":{\"syntax\":\"all | <custom-ident>\"},\"size\":{\"syntax\":\"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}\"},\"step-position\":{\"syntax\":\"jump-start | jump-end | jump-none | jump-both | start | end\"},\"step-timing-function\":{\"syntax\":\"step-start | step-end | steps(<integer>[, <step-position>]?)\"},\"subclass-selector\":{\"syntax\":\"<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>\"},\"supports-condition\":{\"syntax\":\"not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*\"},\"supports-in-parens\":{\"syntax\":\"( <supports-condition> ) | <supports-feature> | <general-enclosed>\"},\"supports-feature\":{\"syntax\":\"<supports-decl> | <supports-selector-fn>\"},\"supports-decl\":{\"syntax\":\"( <declaration> )\"},\"supports-selector-fn\":{\"syntax\":\"selector( <complex-selector> )\"},\"symbol\":{\"syntax\":\"<string> | <image> | <custom-ident>\"},\"target\":{\"syntax\":\"<target-counter()> | <target-counters()> | <target-text()>\"},\"target-counter()\":{\"syntax\":\"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )\"},\"target-counters()\":{\"syntax\":\"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )\"},\"target-text()\":{\"syntax\":\"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )\"},\"time-percentage\":{\"syntax\":\"<time> | <percentage>\"},\"timing-function\":{\"syntax\":\"linear | <cubic-bezier-timing-function> | <step-timing-function>\"},\"track-breadth\":{\"syntax\":\"<length-percentage> | <flex> | min-content | max-content | auto\"},\"track-list\":{\"syntax\":\"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?\"},\"track-repeat\":{\"syntax\":\"repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )\"},\"track-size\":{\"syntax\":\"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )\"},\"transform-function\":{\"syntax\":\"<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>\"},\"transform-list\":{\"syntax\":\"<transform-function>+\"},\"translate()\":{\"syntax\":\"translate( <length-percentage> , <length-percentage>? )\"},\"translate3d()\":{\"syntax\":\"translate3d( <length-percentage> , <length-percentage> , <length> )\"},\"translateX()\":{\"syntax\":\"translateX( <length-percentage> )\"},\"translateY()\":{\"syntax\":\"translateY( <length-percentage> )\"},\"translateZ()\":{\"syntax\":\"translateZ( <length> )\"},\"type-or-unit\":{\"syntax\":\"string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %\"},\"type-selector\":{\"syntax\":\"<wq-name> | <ns-prefix>? '*'\"},\"var()\":{\"syntax\":\"var( <custom-property-name> , <declaration-value>? )\"},\"viewport-length\":{\"syntax\":\"auto | <length-percentage>\"},\"wq-name\":{\"syntax\":\"<ns-prefix>? <ident-token>\"}}");

/***/ }),
/* 339 */
/***/ (function(module) {

module.exports = JSON.parse("{\"properties\":{\"-moz-background-clip\":{\"comment\":\"deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip\",\"syntax\":\"padding | border\"},\"-moz-border-radius-bottomleft\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius\",\"syntax\":\"<'border-bottom-left-radius'>\"},\"-moz-border-radius-bottomright\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius\",\"syntax\":\"<'border-bottom-right-radius'>\"},\"-moz-border-radius-topleft\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius\",\"syntax\":\"<'border-top-left-radius'>\"},\"-moz-border-radius-topright\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius\",\"syntax\":\"<'border-bottom-right-radius'>\"},\"-moz-control-character-visibility\":{\"comment\":\"firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588\",\"syntax\":\"visible | hidden\"},\"-moz-osx-font-smoothing\":{\"comment\":\"misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\",\"syntax\":\"auto | grayscale\"},\"-moz-user-select\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select\",\"syntax\":\"none | text | all | -moz-none\"},\"-ms-flex-align\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align\",\"syntax\":\"start | end | center | baseline | stretch\"},\"-ms-flex-item-align\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align\",\"syntax\":\"auto | start | end | center | baseline | stretch\"},\"-ms-flex-line-pack\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack\",\"syntax\":\"start | end | center | justify | distribute | stretch\"},\"-ms-flex-negative\":{\"comment\":\"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\"syntax\":\"<'flex-shrink'>\"},\"-ms-flex-pack\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack\",\"syntax\":\"start | end | center | justify | distribute\"},\"-ms-flex-order\":{\"comment\":\"misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx\",\"syntax\":\"<integer>\"},\"-ms-flex-positive\":{\"comment\":\"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\"syntax\":\"<'flex-grow'>\"},\"-ms-flex-preferred-size\":{\"comment\":\"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\"syntax\":\"<'flex-basis'>\"},\"-ms-interpolation-mode\":{\"comment\":\"https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx\",\"syntax\":\"nearest-neighbor | bicubic\"},\"-ms-grid-column-align\":{\"comment\":\"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx\",\"syntax\":\"start | end | center | stretch\"},\"-ms-grid-row-align\":{\"comment\":\"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx\",\"syntax\":\"start | end | center | stretch\"},\"-ms-hyphenate-limit-last\":{\"comment\":\"misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits\",\"syntax\":\"none | always | column | page | spread\"},\"-webkit-appearance\":{\"comment\":\"webkit specific keywords\",\"references\":[\"http://css-infos.net/property/-webkit-appearance\"],\"syntax\":\"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button\"},\"-webkit-background-clip\":{\"comment\":\"https://developer.mozilla.org/en/docs/Web/CSS/background-clip\",\"syntax\":\"[ <box> | border | padding | content | text ]#\"},\"-webkit-column-break-after\":{\"comment\":\"added, http://help.dottoro.com/lcrthhhv.php\",\"syntax\":\"always | auto | avoid\"},\"-webkit-column-break-before\":{\"comment\":\"added, http://help.dottoro.com/lcxquvkf.php\",\"syntax\":\"always | auto | avoid\"},\"-webkit-column-break-inside\":{\"comment\":\"added, http://help.dottoro.com/lclhnthl.php\",\"syntax\":\"always | auto | avoid\"},\"-webkit-font-smoothing\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\",\"syntax\":\"auto | none | antialiased | subpixel-antialiased\"},\"-webkit-mask-box-image\":{\"comment\":\"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image\",\"syntax\":\"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?\"},\"-webkit-print-color-adjust\":{\"comment\":\"missed\",\"references\":[\"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust\"],\"syntax\":\"economy | exact\"},\"-webkit-text-security\":{\"comment\":\"missed; http://help.dottoro.com/lcbkewgt.php\",\"syntax\":\"none | circle | disc | square\"},\"-webkit-user-drag\":{\"comment\":\"missed; http://help.dottoro.com/lcbixvwm.php\",\"syntax\":\"none | element | auto\"},\"-webkit-user-select\":{\"comment\":\"auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select\",\"syntax\":\"auto | none | text | all\"},\"alignment-baseline\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty\"],\"syntax\":\"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical\"},\"baseline-shift\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty\"],\"syntax\":\"baseline | sub | super | <svg-length>\"},\"behavior\":{\"comment\":\"added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx\",\"syntax\":\"<url>+\"},\"clip-rule\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty\"],\"syntax\":\"nonzero | evenodd\"},\"cue\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<'cue-before'> <'cue-after'>?\"},\"cue-after\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<url> <decibel>? | none\"},\"cue-before\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<url> <decibel>? | none\"},\"cursor\":{\"comment\":\"added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out\",\"references\":[\"https://www.sitepoint.com/css3-cursor-styles/\"],\"syntax\":\"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]\"},\"display\":{\"comment\":\"extended with -ms-flexbox\",\"syntax\":\"[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy> | <-non-standard-display>\"},\"position\":{\"comment\":\"extended with -webkit-sticky\",\"syntax\":\"static | relative | absolute | sticky | fixed | -webkit-sticky\"},\"dominant-baseline\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty\"],\"syntax\":\"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\"},\"image-rendering\":{\"comment\":\"extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality\",\"references\":[\"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering\",\"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty\"],\"syntax\":\"auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>\"},\"fill\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#FillProperty\"],\"syntax\":\"<paint>\"},\"fill-opacity\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#FillProperty\"],\"syntax\":\"<number-zero-one>\"},\"fill-rule\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#FillProperty\"],\"syntax\":\"nonzero | evenodd\"},\"filter\":{\"comment\":\"extend with IE legacy syntaxes\",\"syntax\":\"none | <filter-function-list> | <-ms-filter-function-list>\"},\"glyph-orientation-horizontal\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty\"],\"syntax\":\"<angle>\"},\"glyph-orientation-vertical\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty\"],\"syntax\":\"<angle>\"},\"kerning\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#KerningProperty\"],\"syntax\":\"auto | <svg-length>\"},\"letter-spacing\":{\"comment\":\"fix syntax <length> -> <length-percentage>\",\"references\":[\"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing\"],\"syntax\":\"normal | <length-percentage>\"},\"marker\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"marker-end\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"marker-mid\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"marker-start\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"max-width\":{\"comment\":\"fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width\",\"syntax\":\"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>\"},\"max-height\":{\"comment\":\"fix auto -> none (https://github.com/mdn/data/pull/431)\",\"syntax\":\"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)\"},\"min-width\":{\"comment\":\"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width\",\"syntax\":\"auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>\"},\"overflow\":{\"comment\":\"extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\",\"syntax\":\"[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>\"},\"pause\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<'pause-before'> <'pause-after'>?\"},\"pause-after\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"pause-before\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"rest\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<'rest-before'> <'rest-after'>?\"},\"rest-after\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"rest-before\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"shape-rendering\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert\"],\"syntax\":\"auto | optimizeSpeed | crispEdges | geometricPrecision\"},\"src\":{\"comment\":\"added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src\",\"syntax\":\"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#\"},\"speak\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"auto | none | normal\"},\"speak-as\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]\"},\"stroke\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<paint>\"},\"stroke-dasharray\":{\"comment\":\"added SVG property; a list of comma and/or white space separated <length>s and <percentage>s\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"none | [ <svg-length>+ ]#\"},\"stroke-dashoffset\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<svg-length>\"},\"stroke-linecap\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"butt | round | square\"},\"stroke-linejoin\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"miter | round | bevel\"},\"stroke-miterlimit\":{\"comment\":\"added SVG property (<miterlimit> = <number-one-or-greater>) \",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<number-one-or-greater>\"},\"stroke-opacity\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<number-zero-one>\"},\"stroke-width\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<svg-length>\"},\"text-anchor\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties\"],\"syntax\":\"start | middle | end\"},\"unicode-bidi\":{\"comment\":\"added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi\",\"syntax\":\"normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate\"},\"unicode-range\":{\"comment\":\"added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range\",\"syntax\":\"<urange>#\"},\"voice-balance\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<number> | left | center | right | leftwards | rightwards\"},\"voice-duration\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"auto | <time>\"},\"voice-family\":{\"comment\":\"<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve\"},\"voice-pitch\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\"},\"voice-range\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\"},\"voice-rate\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>\"},\"voice-stress\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"normal | strong | moderate | none | reduced\"},\"voice-volume\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]\"},\"writing-mode\":{\"comment\":\"extend with SVG keywords\",\"syntax\":\"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>\"}},\"syntaxes\":{\"-legacy-gradient\":{\"comment\":\"added collection of legacy gradient syntaxes\",\"syntax\":\"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>\"},\"-legacy-linear-gradient\":{\"comment\":\"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\"syntax\":\"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )\"},\"-legacy-repeating-linear-gradient\":{\"comment\":\"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\"syntax\":\"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )\"},\"-legacy-linear-gradient-arguments\":{\"comment\":\"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\"syntax\":\"[ <angle> | <side-or-corner> ]? , <color-stop-list>\"},\"-legacy-radial-gradient\":{\"comment\":\"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\"syntax\":\"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )\"},\"-legacy-repeating-radial-gradient\":{\"comment\":\"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\"syntax\":\"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )\"},\"-legacy-radial-gradient-arguments\":{\"comment\":\"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\"syntax\":\"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>\"},\"-legacy-radial-gradient-size\":{\"comment\":\"before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize\",\"syntax\":\"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover\"},\"-legacy-radial-gradient-shape\":{\"comment\":\"define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape\",\"syntax\":\"circle | ellipse\"},\"-non-standard-font\":{\"comment\":\"non standard fonts\",\"references\":[\"https://webkit.org/blog/3709/using-the-system-font-in-web-content/\"],\"syntax\":\"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body\"},\"-non-standard-color\":{\"comment\":\"non standard colors\",\"references\":[\"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html\",\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions\"],\"syntax\":\"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text\"},\"-non-standard-image-rendering\":{\"comment\":\"non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html\",\"syntax\":\"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast\"},\"-non-standard-overflow\":{\"comment\":\"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\",\"syntax\":\"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable\"},\"-non-standard-width\":{\"comment\":\"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width\",\"syntax\":\"fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content\"},\"-webkit-gradient()\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )\",\"syntax\":\"-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )\"},\"-webkit-gradient-color-stop\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )\"},\"-webkit-gradient-point\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]\"},\"-webkit-gradient-radius\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"<length> | <percentage>\"},\"-webkit-gradient-type\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"linear | radial\"},\"-webkit-mask-box-repeat\":{\"comment\":\"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image\",\"syntax\":\"repeat | stretch | round\"},\"-webkit-mask-clip-style\":{\"comment\":\"missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working\",\"syntax\":\"border | border-box | padding | padding-box | content | content-box | text\"},\"-ms-filter-function-list\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"<-ms-filter-function>+\"},\"-ms-filter-function\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"<-ms-filter-function-progid> | <-ms-filter-function-legacy>\"},\"-ms-filter-function-progid\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]\"},\"-ms-filter-function-legacy\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"<ident-token> | <function-token> <any-value>? )\"},\"-ms-filter\":{\"syntax\":\"<string>\"},\"age\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#voice-family\",\"syntax\":\"child | young | old\"},\"attr-name\":{\"syntax\":\"<wq-name>\"},\"attr-fallback\":{\"syntax\":\"<any-value>\"},\"border-radius\":{\"comment\":\"missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius\",\"syntax\":\"<length-percentage>{1,2}\"},\"bottom\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"content-list\":{\"comment\":\"missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)\",\"syntax\":\"[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+\"},\"element()\":{\"comment\":\"https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation\",\"syntax\":\"element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )\"},\"generic-voice\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#voice-family\",\"syntax\":\"[ <age>? <gender> <integer>? ]\"},\"gender\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#voice-family\",\"syntax\":\"male | female | neutral\"},\"generic-family\":{\"comment\":\"added -apple-system\",\"references\":[\"https://webkit.org/blog/3709/using-the-system-font-in-web-content/\"],\"syntax\":\"serif | sans-serif | cursive | fantasy | monospace | -apple-system\"},\"gradient\":{\"comment\":\"added legacy syntaxes support\",\"syntax\":\"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>\"},\"left\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"mask-image\":{\"comment\":\"missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image\",\"syntax\":\"<mask-reference>#\"},\"name-repeat\":{\"comment\":\"missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat\",\"syntax\":\"repeat( [ <positive-integer> | auto-fill ], <line-names>+)\"},\"named-color\":{\"comment\":\"added non standard color names\",\"syntax\":\"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>\"},\"paint\":{\"comment\":\"used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint\",\"syntax\":\"none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke\"},\"ratio\":{\"comment\":\"missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio\",\"syntax\":\"<integer> / <integer>\"},\"right\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"shape\":{\"comment\":\"missed spaces in function body and add backwards compatible syntax\",\"syntax\":\"rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )\"},\"svg-length\":{\"comment\":\"All coordinates and lengths in SVG can be specified with or without a unit identifier\",\"references\":[\"https://www.w3.org/TR/SVG11/coords.html#Units\"],\"syntax\":\"<percentage> | <length> | <number>\"},\"svg-writing-mode\":{\"comment\":\"SVG specific keywords (deprecated for CSS)\",\"references\":[\"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode\",\"https://www.w3.org/TR/SVG/text.html#WritingModeProperty\"],\"syntax\":\"lr-tb | rl-tb | tb-rl | lr | rl | tb\"},\"top\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"track-group\":{\"comment\":\"used by old grid-columns and grid-rows syntax v0\",\"syntax\":\"'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>\"},\"track-list-v0\":{\"comment\":\"used by old grid-columns and grid-rows syntax v0\",\"syntax\":\"[ <string>* <track-group> <string>* ]+ | none\"},\"track-minmax\":{\"comment\":\"used by old grid-columns and grid-rows syntax v0\",\"syntax\":\"minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content\"},\"x\":{\"comment\":\"missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor\",\"syntax\":\"<number>\"},\"y\":{\"comment\":\"missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor\",\"syntax\":\"<number>\"},\"declaration\":{\"comment\":\"missed, restored by https://drafts.csswg.org/css-syntax\",\"syntax\":\"<ident-token> : <declaration-value>? [ '!' important ]?\"},\"declaration-list\":{\"comment\":\"missed, restored by https://drafts.csswg.org/css-syntax\",\"syntax\":\"[ <declaration>? ';' ]* <declaration>?\"},\"url\":{\"comment\":\"https://drafts.csswg.org/css-values-4/#urls\",\"syntax\":\"url( <string> <url-modifier>* ) | <url-token>\"},\"url-modifier\":{\"comment\":\"https://drafts.csswg.org/css-values-4/#typedef-url-modifier\",\"syntax\":\"<ident> | <function-token> <any-value> )\"},\"number-zero-one\":{\"syntax\":\"<number [0,1]>\"},\"number-one-or-greater\":{\"syntax\":\"<number [1,∞]>\"},\"positive-integer\":{\"syntax\":\"<integer [0,∞]>\"},\"-non-standard-display\":{\"syntax\":\"-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box\"}}}");

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

var cmpChar = __webpack_require__(16).cmpChar;
var isDigit = __webpack_require__(16).isDigit;
var TYPE = __webpack_require__(16).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
    var pos = this.scanner.tokenStart + offset;
    var code = this.scanner.source.charCodeAt(pos);

    if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.scanner.tokenEnd; pos++) {
        if (!isDigit(this.scanner.source.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
        var msg = '';

        switch (code) {
            case N:
                msg = 'N is expected';
                break;
            case HYPHENMINUS:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.scanner.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
    var offset = 0;
    var sign = 0;
    var type = this.scanner.tokenType;

    while (type === WHITESPACE || type === COMMENT) {
        type = this.scanner.lookupType(++offset);
    }

    if (type !== NUMBER) {
        if (this.scanner.isDelim(PLUSSIGN, offset) ||
            this.scanner.isDelim(HYPHENMINUS, offset)) {
            sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;

            do {
                type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE || type === COMMENT);

            if (type !== NUMBER) {
                this.scanner.skip(offset);
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.scanner.skip(offset);
    }

    if (sign === 0) {
        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS ? '-' + this.consume(NUMBER) : this.consume(NUMBER);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
module.exports = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        /* eslint-disable brace-style*/
        var start = this.scanner.tokenStart;
        var a = null;
        var b = null;

        // <integer>
        if (this.scanner.tokenType === NUMBER) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(NUMBER);
        }

        // -n
        // -n <signed-integer>
        // -n ['+' | '-'] <signless-integer>
        // -n- <signless-integer>
        // <dashndashdigit-ident>
        else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
            a = '-1';

            expectCharCode.call(this, 1, N);

            switch (this.scanner.getTokenLength()) {
                // -n
                // -n <signed-integer>
                // -n ['+' | '-'] <signless-integer>
                case 2:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // -n- <signless-integer>
                case 3:
                    expectCharCode.call(this, 2, HYPHENMINUS);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER);
                    break;

                // <dashndashdigit-ident>
                default:
                    expectCharCode.call(this, 2, HYPHENMINUS);
                    checkInteger.call(this, 3, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + 2);
            }
        }

        // '+'? n
        // '+'? n <signed-integer>
        // '+'? n ['+' | '-'] <signless-integer>
        // '+'? n- <signless-integer>
        // '+'? <ndashdigit-ident>
        else if (this.scanner.tokenType === IDENT || (this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT)) {
            var sign = 0;
            a = '1';

            // just ignore a plus
            if (this.scanner.isDelim(PLUSSIGN)) {
                sign = 1;
                this.scanner.next();
            }

            expectCharCode.call(this, 0, N);

            switch (this.scanner.getTokenLength()) {
                // '+'? n
                // '+'? n <signed-integer>
                // '+'? n ['+' | '-'] <signless-integer>
                case 1:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // '+'? n- <signless-integer>
                case 2:
                    expectCharCode.call(this, 1, HYPHENMINUS);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER);
                    break;

                // '+'? <ndashdigit-ident>
                default:
                    expectCharCode.call(this, 1, HYPHENMINUS);
                    checkInteger.call(this, 2, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + sign + 1);
            }
        }

        // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (this.scanner.tokenType === DIMENSION) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN || code === HYPHENMINUS;

            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
                if (!isDigit(this.scanner.source.charCodeAt(i))) {
                    break;
                }
            }

            if (i === this.scanner.tokenStart + sign) {
                this.error('Integer is expected', this.scanner.tokenStart + sign);
            }

            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i);

            // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>
            if (i + 1 === this.scanner.tokenEnd) {
                this.scanner.next();
                b = consumeB.call(this);
            } else {
                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);

                // <ndash-dimension> <signless-integer>
                if (i + 2 === this.scanner.tokenEnd) {
                    this.scanner.next();
                    this.scanner.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = '-' + this.consume(NUMBER);
                }
                // <ndashdigit-dimension>
                else {
                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                    this.scanner.next();
                    b = this.scanner.substrToCursor(i + 1);
                }
            }
        } else {
            this.error();
        }

        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
            a = a.substr(1);
        }

        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
            b = b.substr(1);
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, this.scanner.tokenStart),
            a: a,
            b: b
        };
    },
    generate: function(node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            this.chunk(
                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    this.chunk(b.charAt(0));
                    this.chunk(b.substr(1));
                } else {
                    this.chunk('+');
                    this.chunk(b);
                }
            }
        } else {
            this.chunk(String(node.b));
        }
    }
};
; 
if (false ) {} 

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;
var rawMode = __webpack_require__(62).mode;

var ATKEYWORD = TYPE.AtKeyword;
var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
            return true;
        }

        if (type === LEFTCURLYBRACKET ||
            type === ATKEYWORD) {
            return false;
        }
    }

    return false;
}

module.exports = {
    name: 'Atrule',
    structure: {
        name: String,
        prelude: ['AtrulePrelude', 'Raw', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;

        this.eat(ATKEYWORD);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        // parse prelude
        if (this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            if (this.parseAtrulePrelude) {
                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

                // turn empty AtrulePrelude into null
                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
                    prelude = null;
                }
            } else {
                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
            }

            this.scanner.skipSC();
        }

        switch (this.scanner.tokenType) {
            case SEMICOLON:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET:
                if (this.atrule.hasOwnProperty(nameLowerCase) &&
                    typeof this.atrule[nameLowerCase].block === 'function') {
                    block = this.atrule[nameLowerCase].block.call(this);
                } else {
                    // TODO: should consume block content as Raw?
                    block = this.Block(isDeclarationBlockAtrule.call(this));
                }

                break;
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.chunk('@');
        this.chunk(node.name);

        if (node.prelude !== null) {
            this.chunk(' ');
            this.node(node.prelude);
        }

        if (node.block) {
            this.node(node.block);
        } else {
            this.chunk(';');
        }
    },
    walkContext: 'atrule'
};
; 
if (false ) {} 

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

module.exports = {
    name: 'AtrulePrelude',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;

        if (name !== null) {
            name = name.toLowerCase();
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === 'function') {
            // custom consumer
            children = this.atrule[name].prelude.call(this);
        } else {
            // default consumer
            children = this.readSequence(this.scope.AtrulePrelude);
        }

        this.scanner.skipSC();

        if (this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            this.error('Semicolon or block is expected');
        }

        if (children === null) {
            children = this.createList();
        }

        return {
            type: 'AtrulePrelude',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'atrulePrelude'
};
; 
if (false ) {} 

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var STRING = TYPE.String;
var COLON = TYPE.Colon;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
var ASTERISK = 0x002A;         // U+002A ASTERISK (*)
var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
var VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)
var TILDE = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.scanner.eof) {
        this.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdent = false;
    var checkColon = true;

    if (this.scanner.isDelim(ASTERISK)) {
        expectIdent = true;
        checkColon = false;
        this.scanner.next();
    } else if (!this.scanner.isDelim(VERTICALLINE)) {
        this.eat(IDENT);
    }

    if (this.scanner.isDelim(VERTICALLINE)) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
            this.scanner.next();
            this.eat(IDENT);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON) {
        this.scanner.next();
        this.eat(IDENT);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var code = this.scanner.source.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN &&        // $=
        code !== ASTERISK &&          // *=
        code !== VERTICALLINE         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.scanner.next();

    if (code !== EQUALSSIGN) {
        if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.scanner.next();
    }

    return this.scanner.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
module.exports = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.eat(LEFTSQUAREBRACKET);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENT) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENT) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.eat(RIGHTSQUAREBRACKET);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(node) {
        var flagsPrefix = ' ';

        this.chunk('[');
        this.node(node.name);

        if (node.matcher !== null) {
            this.chunk(node.matcher);

            if (node.value !== null) {
                this.node(node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
        }

        this.chunk(']');
    }
};
; 
if (false ) {} 

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;
var rawMode = __webpack_require__(62).mode;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;
var ATKEYWORD = TYPE.AtKeyword;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, rawMode.semicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON) {
        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON) {
        this.scanner.next();
    }

    return node;
}

module.exports = {
    name: 'Block',
    structure: {
        children: [[
            'Atrule',
            'Rule',
            'Declaration'
        ]]
    },
    parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

        var start = this.scanner.tokenStart;
        var children = this.createList();

        this.eat(LEFTCURLYBRACKET);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                    break scan;

                case WHITESPACE:
                case COMMENT:
                    this.scanner.next();
                    break;

                case ATKEYWORD:
                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                    break;

                default:
                    children.push(consumer.call(this));
            }
        }

        if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('{');
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
        this.chunk('}');
    },
    walkContext: 'block'
};
; 
if (false ) {} 

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

module.exports = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTSQUAREBRACKET);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET);
        }

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('[');
        this.children(node);
        this.chunk(']');
    }
};
; 
if (false ) {} 

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var CDC = __webpack_require__(16).TYPE.CDC;

module.exports = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDC); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('-->');
    }
};
; 
if (false ) {} 

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var CDO = __webpack_require__(16).TYPE.CDO;

module.exports = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDO); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('<!--');
    }
};
; 
if (false ) {} 

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

// '.' ident
module.exports = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        if (!this.scanner.isDelim(FULLSTOP)) {
            this.error('Full stop is expected');
        }

        this.scanner.next();

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.consume(IDENT)
        };
    },
    generate: function(node) {
        this.chunk('.');
        this.chunk(node.name);
    }
};
; 
if (false ) {} 

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
var TILDE = 0x007E;           // U+007E TILDE (~)

// + | > | ~ | /deep/
module.exports = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

        switch (code) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
                this.scanner.next();
                break;

            case SOLIDUS:
                this.scanner.next();

                if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, 'deep') === false) {
                    this.error('Identifier `deep` is expected');
                }

                this.scanner.next();

                if (!this.scanner.isDelim(SOLIDUS)) {
                    this.error('Solidus is expected');
                }

                this.scanner.next();
                break;

            default:
                this.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};
; 
if (false ) {} 

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var COMMENT = TYPE.Comment;
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

// '/*' .* '*/'
module.exports = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        this.eat(COMMENT);

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
            end -= 2;
        }

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(node) {
        this.chunk('/*');
        this.chunk(node.value);
        this.chunk('*/');
    }
};
; 
if (false ) {} 

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var isCustomProperty = __webpack_require__(93).isCustomProperty;
var TYPE = __webpack_require__(16).TYPE;
var rawMode = __webpack_require__(62).mode;

var IDENT = TYPE.Ident;
var HASH = TYPE.Hash;
var COLON = TYPE.Colon;
var SEMICOLON = TYPE.Semicolon;
var DELIM = TYPE.Delim;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)
var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
var DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
var AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
}

function consumeValue() {
    var startValueToken = this.scanner.tokenIndex;
    var value = this.Value();

    if (value.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== SEMICOLON &&
        this.scanner.isDelim(EXCLAMATIONMARK) === false &&
        this.scanner.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

module.exports = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.tokenIndex;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;

        this.scanner.skipSC();
        this.eat(COLON);

        if (!customProperty) {
            this.scanner.skipSC();
        }

        if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
            value = consumeRaw.call(this, this.scanner.tokenIndex);
        }

        if (this.scanner.isDelim(EXCLAMATIONMARK)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
        }

        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram

        if (this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON &&
            this.scanner.isBalanceEdge(startToken) === false) {
            this.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(node) {
        this.chunk(node.property);
        this.chunk(':');
        this.node(node.value);

        if (node.important) {
            this.chunk(node.important === true ? '!important' : '!' + node.important);
        }
    },
    walkContext: 'declaration'
};

function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0;

    // hacks
    if (this.scanner.tokenType === DELIM) {
        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK:
            case DOLLARSIGN:
            case PLUSSIGN:
            case NUMBERSIGN:
            case AMPERSAND:
                this.scanner.next();
                break;

            // TODO: not sure we should support this hack
            case SOLIDUS:
                this.scanner.next();
                if (this.scanner.isDelim(SOLIDUS)) {
                    this.scanner.next();
                }
                break;
        }
    }

    if (prefix) {
        this.scanner.skip(prefix);
    }

    if (this.scanner.tokenType === HASH) {
        this.eat(HASH);
    } else {
        this.eat(IDENT);
    }

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(DELIM);
    this.scanner.skipSC();

    var important = this.consume(IDENT);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}
; 
if (false ) {} 

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;
var rawMode = __webpack_require__(62).mode;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;

function consumeRaw(startToken) {
    return this.Raw(startToken, rawMode.semicolonIncluded, true);
}

module.exports = {
    name: 'DeclarationList',
    structure: {
        children: [[
            'Declaration'
        ]]
    },
    parse: function() {
        var children = this.createList();

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                case COMMENT:
                case SEMICOLON:
                    this.scanner.next();
                    break;

                default:
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
    }
};
; 
if (false ) {} 

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var consumeNumber = __webpack_require__(76).consumeNumber;
var TYPE = __webpack_require__(16).TYPE;

var DIMENSION = TYPE.Dimension;

module.exports = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);

        this.eat(DIMENSION);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
    }
};
; 
if (false ) {} 

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// <function-token> <sequence> )
module.exports = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(node.name);
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    },
    walkContext: 'function'
};
; 
if (false ) {} 

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var HASH = TYPE.Hash;

// '#' ident
module.exports = {
    name: 'Hash',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(HASH);

        return {
            type: 'Hash',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.value);
    }
};
; 
if (false ) {} 

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;

module.exports = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.consume(IDENT)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};
; 
if (false ) {} 

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var HASH = TYPE.Hash;

// <hash-token>
module.exports = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // TODO: check value is an ident
        this.eat(HASH);

        return {
            type: 'IdSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.name);
    }
};
; 
if (false ) {} 

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var COLON = TYPE.Colon;
var DELIM = TYPE.Delim;

module.exports = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();

        name = this.consume(IDENT);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.eat(COLON);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER:
                    if (this.lookupNonWSType(1) === DELIM) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case DIMENSION:
                    value = this.Dimension();
                    break;

                case IDENT:
                    value = this.Identifier();

                    break;

                default:
                    this.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.eat(RIGHTPARENTHESIS);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.chunk(node.name);
        if (node.value !== null) {
            this.chunk(':');
            this.node(node.value);
        }
        this.chunk(')');
    }
};
; 
if (false ) {} 

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    name: 'MediaQuery',
    structure: {
        children: [[
            'Identifier',
            'MediaFeature',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = this.createList();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT:
                    this.scanner.next();
                    continue;

                case WHITESPACE:
                    space = this.WhiteSpace();
                    continue;

                case IDENT:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.push(space);
                space = null;
            }

            children.push(child);
        }

        if (child === null) {
            this.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};
; 
if (false ) {} 

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var COMMA = __webpack_require__(16).TYPE.Comma;

module.exports = {
    name: 'MediaQueryList',
    structure: {
        children: [[
            'MediaQuery'
        ]]
    },
    parse: function(relative) {
        var children = this.createList();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    }
};
; 
if (false ) {} 

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = this.getLastListNode(selector.children).loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
            this.chunk(' of ');
            this.node(node.selector);
        }
    }
};
; 
if (false ) {} 

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

var NUMBER = __webpack_require__(16).TYPE.Number;

module.exports = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(NUMBER)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};
; 
if (false ) {} 

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

// '/' | '*' | ',' | ':' | '+' | '-'
module.exports = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};
; 
if (false ) {} 

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

module.exports = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTPARENTHESIS);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    }
};
; 
if (false ) {} 

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var consumeNumber = __webpack_require__(76).consumeNumber;
var TYPE = __webpack_require__(16).TYPE;

var PERCENTAGE = TYPE.Percentage;

module.exports = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);

        this.eat(PERCENTAGE);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk('%');
    }
};
; 
if (false ) {} 

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// : [ <ident> | <function-token> <any-value>? ) ]
module.exports = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS);
        } else {
            name = this.consume(IDENT);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(':');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};
; 
if (false ) {} 

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// :: [ <ident> | <function-token> <any-value>? ) ]
module.exports = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON);
        this.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS);
        } else {
            name = this.consume(IDENT);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk('::');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};
; 
if (false ) {} 

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

var isDigit = __webpack_require__(16).isDigit;
var TYPE = __webpack_require__(16).TYPE;

var NUMBER = TYPE.Number;
var DELIM = TYPE.Delim;
var SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)
var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
    this.scanner.skipWS();

    var value = this.consume(NUMBER);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isDigit(code) && code !== FULLSTOP) {
            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
module.exports = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber.call(this);
        var right;

        this.scanner.skipWS();

        if (!this.scanner.isDelim(SOLIDUS)) {
            this.error('Solidus is expected');
        }
        this.eat(DELIM);
        right = consumeNumber.call(this);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(node) {
        this.chunk(node.left);
        this.chunk('/');
        this.chunk(node.right);
    }
};
; 
if (false ) {} 

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;
var rawMode = __webpack_require__(62).mode;

var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, rawMode.leftCurlyBracket, true);
}

function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.error();
    }

    return prelude;
}

module.exports = {
    name: 'Rule',
    structure: {
        prelude: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.tokenIndex;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;

        if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
            prelude = consumeRaw.call(this, startToken);
        }

        block = this.Block(true);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
    },
    walkContext: 'rule'
};
; 
if (false ) {} 

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (this.getFirstListNode(children) === null) {
            this.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};
; 
if (false ) {} 

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var COMMA = TYPE.Comma;

module.exports = {
    name: 'SelectorList',
    structure: {
        children: [[
            'Selector',
            'Raw'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            children.push(this.Selector());

            if (this.scanner.tokenType === COMMA) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    },
    walkContext: 'selector'
};
; 
if (false ) {} 

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

var STRING = __webpack_require__(16).TYPE.String;

module.exports = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(STRING)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};
; 
if (false ) {} 

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var ATKEYWORD = TYPE.AtKeyword;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw(startToken) {
    return this.Raw(startToken, null, false);
}

module.exports = {
    name: 'StyleSheet',
    structure: {
        children: [[
            'Comment',
            'CDO',
            'CDC',
            'Atrule',
            'Rule',
            'Raw'
        ]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                    this.scanner.next();
                    continue;

                case COMMENT:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO: // <!--
                    child = this.CDO();
                    break;

                case CDC: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // §2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATKEYWORD:
                    child = this.parseWithFallback(this.Atrule, consumeRaw);
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw);
            }

            children.push(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'stylesheet'
};
; 
if (false ) {} 

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var IDENT = TYPE.Ident;
var ASTERISK = 0x002A;     // U+002A ASTERISK (*)
var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENT &&
        this.scanner.isDelim(ASTERISK) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
module.exports = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.isDelim(VERTICALLINE)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.isDelim(VERTICALLINE)) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};
; 
if (false ) {} 

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

var isHexDigit = __webpack_require__(16).isHexDigit;
var cmpChar = __webpack_require__(16).cmpChar;
var TYPE = __webpack_require__(16).TYPE;
var NAME = __webpack_require__(16).NAME;

var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function eatHexSequence(offset, allowDash) {
    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
        var code = this.scanner.source.charCodeAt(pos);

        if (code === HYPHENMINUS && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
                this.error();
            }

            return -1;
        }

        if (!isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        };
    }

    this.scanner.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    var count = 0;

    while (this.scanner.isDelim(QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.scanner.next();
    }
}

function startsWith(code) {
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
        this.error(NAME[code] + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    var hexLength = 0;

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (this.scanner.isDelim(PLUSSIGN)) {
        this.scanner.next();

        if (this.scanner.tokenType === IDENT) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
        }

        if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
        }

        this.error('Hex digit or question mark is expected');
        return;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (this.scanner.tokenType === NUMBER) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);

        if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
        }

        if (this.scanner.tokenType === DIMENSION ||
            this.scanner.tokenType === NUMBER) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            return;
        }

        return;
    }

    // u <dimension-token> '?'*
    if (this.scanner.tokenType === DIMENSION) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);

        if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
        }

        return;
    }

    this.error();
}

module.exports = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // U or u
        if (!cmpChar(this.scanner.source, start, U)) {
            this.error('U is expected');
        }

        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
            this.error('Plus sign is expected');
        }

        this.scanner.next();
        scanUnicodeRange.call(this);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};
; 
if (false ) {} 

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

var isWhiteSpace = __webpack_require__(16).isWhiteSpace;
var cmpStr = __webpack_require__(16).cmpStr;
var TYPE = __webpack_require__(16).TYPE;

var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// <url-token> | <function-token> <string> )
module.exports = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        switch (this.scanner.tokenType) {
            case URL:
                var rawStart = start + 4;
                var rawEnd = this.scanner.tokenEnd - 1;

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
                    rawStart++;
                }

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
                    rawEnd--;
                }

                value = {
                    type: 'Raw',
                    loc: this.getLocation(rawStart, rawEnd),
                    value: this.scanner.source.substring(rawStart, rawEnd)
                };

                this.eat(URL);
                break;

            case FUNCTION:
                if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
                    this.error('Function name must be `url`');
                }

                this.eat(FUNCTION);
                this.scanner.skipSC();
                value = this.String();
                this.scanner.skipSC();
                this.eat(RIGHTPARENTHESIS);
                break;

            default:
                this.error('Url or Function is expected');
        }

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(node) {
        this.chunk('url');
        this.chunk('(');
        this.node(node.value);
        this.chunk(')');
    }
};
; 
if (false ) {} 

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};
; 
if (false ) {} 

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var WHITESPACE = __webpack_require__(16).TYPE.WhiteSpace;
var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

module.exports = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.eat(WHITESPACE);
        return SPACE;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.consume(WHITESPACE)
        // };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};
; 
if (false ) {} 

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: __webpack_require__(380),
    atrule: __webpack_require__(386),
    pseudo: __webpack_require__(392),
    node: __webpack_require__(96)
};
; 
if (false ) {} 

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    AtrulePrelude: __webpack_require__(381),
    Selector: __webpack_require__(382),
    Value: __webpack_require__(383)
};
; 
if (false ) {} 

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    getNode: __webpack_require__(116)
};
; 
if (false ) {} 

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var DELIM = TYPE.Delim;
var IDENT = TYPE.Ident;
var DIMENSION = TYPE.Dimension;
var PERCENTAGE = TYPE.Percentage;
var NUMBER = TYPE.Number;
var HASH = TYPE.Hash;
var COLON = TYPE.Colon;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
var FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
var VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
var TILDE = 0x007E;           // U+007E TILDE (~)

function getNode(context) {
    switch (this.scanner.tokenType) {
        case LEFTSQUAREBRACKET:
            return this.AttributeSelector();

        case HASH:
            return this.IdSelector();

        case COLON:
            if (this.scanner.lookupType(1) === COLON) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENT:
            return this.TypeSelector();

        case NUMBER:
        case PERCENTAGE:
            return this.Percentage();

        case DIMENSION:
            // throws when .123ident
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
                this.error('Identifier is expected', this.scanner.tokenStart + 1);
            }
            break;

        case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            switch (code) {
                case PLUSSIGN:
                case GREATERTHANSIGN:
                case TILDE:
                    context.space = null;
                    context.ignoreWSAfter = true;
                    return this.Combinator();

                case SOLIDUS:  // /deep/
                    return this.Combinator();

                case FULLSTOP:
                    return this.ClassSelector();

                case ASTERISK:
                case VERTICALLINE:
                    return this.TypeSelector();

                case NUMBERSIGN:
                    return this.IdSelector();
            }

            break;
    }
};

module.exports = {
    getNode: getNode
};
; 
if (false ) {} 

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    getNode: __webpack_require__(116),
    'expression': __webpack_require__(384),
    'var': __webpack_require__(385)
};
; 
if (false ) {} 

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

// legacy IE function
// expression( <any-value> )
module.exports = function() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
};
; 
if (false ) {} 

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;
var rawMode = __webpack_require__(62).mode;

var COMMA = TYPE.Comma;

// var( <ident> , <value>? )
module.exports = function() {
    var children = this.createList();

    this.scanner.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());
        children.push(this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false)
        );
    }

    return children;
};
; 
if (false ) {} 

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    'font-face': __webpack_require__(387),
    'import': __webpack_require__(388),
    'media': __webpack_require__(389),
    'page': __webpack_require__(390),
    'supports': __webpack_require__(391)
};
; 
if (false ) {} 

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: {
        prelude: null,
        block: function() {
            return this.Block(true);
        }
    }
};
; 
if (false ) {} 

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var STRING = TYPE.String;
var IDENT = TYPE.Ident;
var URL = TYPE.Url;
var FUNCTION = TYPE.Function;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    parse: {
        prelude: function() {
            var children = this.createList();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING:
                    children.push(this.String());
                    break;

                case URL:
                case FUNCTION:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === IDENT ||
                this.lookupNonWSType(0) === LEFTPARENTHESIS) {
                children.push(this.WhiteSpace());
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};
; 
if (false ) {} 

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(false);
        }
    }
};
; 
if (false ) {} 

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(true);
        }
    }
};
; 
if (false ) {} 

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(16).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
}

function parentheses() {
    this.scanner.skipSC();

    if (this.scanner.tokenType === IDENT &&
        this.lookupNonWSType(1) === COLON) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = this.createList();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE:
                space = this.WhiteSpace();
                continue;

            case COMMENT:
                this.scanner.next();
                continue;

            case FUNCTION:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case IDENT:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.push(space);
            space = null;
        }

        children.push(child);
    }

    return children;
}

module.exports = {
    parse: {
        prelude: function() {
            var children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(false);
        }
    }
};
; 
if (false ) {} 

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    'dir': __webpack_require__(393),
    'has': __webpack_require__(394),
    'lang': __webpack_require__(395),
    'matches': __webpack_require__(396),
    'not': __webpack_require__(397),
    'nth-child': __webpack_require__(398),
    'nth-last-child': __webpack_require__(399),
    'nth-last-of-type': __webpack_require__(400),
    'nth-of-type': __webpack_require__(401),
    'slotted': __webpack_require__(402)
};
; 
if (false ) {} 

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(117);
; 
if (false ) {} 

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(117);
; 
if (false ) {} 

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(118);
; 
if (false ) {} 

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(118);
; 
if (false ) {} 

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(119);
; 
if (false ) {} 

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(119);
; 
if (false ) {} 

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parse: function compoundSelector() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};
; 
if (false ) {} 

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    node: __webpack_require__(96)
};
; 
if (false ) {} 

/***/ }),
/* 404 */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"css-tree@^1.0.0-alpha.39\",\"_id\":\"css-tree@1.0.0\",\"_inBundle\":false,\"_integrity\":\"sha512-CdVYz/Yuqw0VdKhXPBIgi8DO3NicJVYZNWeX9XcIuSp9ZoFT5IcleVRW07O5rMjdcx1mb+MEJPknTTEW7DdsYw==\",\"_location\":\"/css-tree\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"css-tree@^1.0.0-alpha.39\",\"name\":\"css-tree\",\"escapedName\":\"css-tree\",\"rawSpec\":\"^1.0.0-alpha.39\",\"saveSpec\":null,\"fetchSpec\":\"^1.0.0-alpha.39\"},\"_requiredBy\":[\"/@nativescript/core\"],\"_resolved\":\"https://registry.npmjs.org/css-tree/-/css-tree-1.0.0.tgz\",\"_shasum\":\"21993fa270d742642a90409a2c0cb3ac0298adf6\",\"_spec\":\"css-tree@^1.0.0-alpha.39\",\"_where\":\"/Users/pci/Documents/ProMo/node_modules/@nativescript/core\",\"author\":{\"name\":\"Roman Dvornov\",\"email\":\"rdvornov@gmail.com\",\"url\":\"https://github.com/lahmatiy\"},\"bugs\":{\"url\":\"https://github.com/csstree/csstree/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"mdn-data\":\"2.0.12\",\"source-map\":\"^0.6.1\"},\"deprecated\":false,\"description\":\"A tool set for CSS: fast detailed parser (CSS → AST), walker (AST traversal), generator (AST → CSS) and lexer (validation and matching) based on specs and browser implementations\",\"devDependencies\":{\"@rollup/plugin-commonjs\":\"^11.0.2\",\"@rollup/plugin-json\":\"^4.0.2\",\"@rollup/plugin-node-resolve\":\"^7.1.1\",\"coveralls\":\"^3.0.9\",\"eslint\":\"^6.8.0\",\"json-to-ast\":\"^2.1.0\",\"mocha\":\"^5.2.0\",\"nyc\":\"^14.1.1\",\"rollup\":\"^1.32.1\",\"rollup-plugin-terser\":\"^5.3.0\"},\"engines\":{\"node\":\">=8.0.0\"},\"files\":[\"data\",\"dist\",\"lib\"],\"homepage\":\"https://github.com/csstree/csstree#readme\",\"jsdelivr\":\"dist/csstree.min.js\",\"keywords\":[\"css\",\"ast\",\"tokenizer\",\"parser\",\"walker\",\"lexer\",\"generator\",\"utils\",\"syntax\",\"validation\"],\"license\":\"MIT\",\"main\":\"lib/index.js\",\"name\":\"css-tree\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/csstree/csstree.git\"},\"scripts\":{\"build\":\"rollup --config\",\"coverage\":\"nyc npm test\",\"coveralls\":\"nyc report --reporter=text-lcov | coveralls\",\"hydrogen\":\"node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null\",\"lint\":\"eslint data lib scripts test && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint\",\"lint-and-test\":\"npm run lint && npm test\",\"prepublishOnly\":\"npm run build\",\"review:syntax-patch\":\"node scripts/review-syntax-patch\",\"test\":\"mocha --reporter progress\",\"travis\":\"nyc npm run lint-and-test && npm run coveralls\",\"update:docs\":\"node scripts/update-docs\"},\"unpkg\":\"dist/csstree.min.js\",\"version\":\"1.0.0\"}");

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (global) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        Messages,
        source,
        index,
        length,
        delegate,
        lookahead,
        state;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        ArrayExpression: 'ArrayExpression',
        BinaryExpression: 'BinaryExpression',
        CallExpression: 'CallExpression',
        ConditionalExpression: 'ConditionalExpression',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        Identifier: 'Identifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ThisExpression: 'ThisExpression',
        UnaryExpression: 'UnaryExpression'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared'
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122);          // a..z
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57);           // 0..9
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        return (id === 'this')
    }

    // 7.4 Comments

    function skipWhitespace() {
        while (index < length && isWhiteSpace(source.charCodeAt(index))) {
            ++index;
        }
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        id = getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2;

        switch (code) {

            // Check for most common single-character punctuators.
            case 46:   // . dot
            case 40:   // ( open bracket
            case 41:   // ) close bracket
            case 59:   // ; semicolon
            case 44:   // , comma
            case 123:  // { open curly brace
            case 125:  // } close curly brace
            case 91:   // [
            case 93:   // ]
            case 58:   // :
            case 63:   // ?
                ++index;
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    range: [start, index]
                };

            default:
                code2 = source.charCodeAt(index + 1);

                // '=' (char #61) marks an assignment or comparison operator.
                if (code2 === 61) {
                    switch (code) {
                        case 37:  // %
                        case 38:  // &
                        case 42:  // *:
                        case 43:  // +
                        case 45:  // -
                        case 47:  // /
                        case 60:  // <
                        case 62:  // >
                        case 124: // |
                            index += 2;
                            return {
                                type: Token.Punctuator,
                                value: String.fromCharCode(code) + String.fromCharCode(code2),
                                range: [start, index]
                            };

                        case 33: // !
                        case 61: // =
                            index += 2;

                            // !== and ===
                            if (source.charCodeAt(index) === 61) {
                                ++index;
                            }
                            return {
                                type: Token.Punctuator,
                                value: source.slice(start, index),
                                range: [start, index]
                            };
                        default:
                            break;
                    }
                }
                break;
        }

        // Peek more characters.

        ch2 = source[index + 1];

        // Other 2-character punctuators: && ||

        if (ch1 === ch2 && ('&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals
    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;

                        default:
                            str += ch;
                            break;
                    }
                } else {
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch;

        skipWhitespace();

        if (index >= length) {
            return {
                type: Token.EOF,
                range: [index, index]
            };
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            return scanStringLiteral();
        }

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];

        lookahead = advance();

        index = token.range[1];

        return token;
    }

    function peek() {
        var pos;

        pos = index;
        lookahead = advance();
        index = pos;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        error = new Error(msg);
        error.index = index;
        error.description = msg;
        throw error;
    }

    // Throw an exception because of the token.

    function throwUnexpected(token) {
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        skipWhitespace();

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parseObjectPropertyKey() {
        var token;

        skipWhitespace();
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            return delegate.createLiteral(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key;

        token = lookahead;
        skipWhitespace();

        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        }

        key = parseObjectPropertyKey();
        expect(':');
        return delegate.createProperty('init', key, parseExpression());
    }

    function parseObjectInitialiser() {
        var properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty());

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr;

        if (match('(')) {
            return parseGroupExpression();
        }

        type = lookahead.type;

        if (type === Token.Identifier) {
            expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('[')) {
            expr = parseArrayInitialiser();
        } else if (match('{')) {
            expr = parseObjectInitialiser();
        }

        if (expr) {
            return expr;
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token;

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, args, property;

        expr = parsePrimaryExpression();

        while (true) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else {
                break;
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    var parsePostfixExpression = parseLeftHandSideExpression;

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('+') || match('-') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            throwError({}, Messages.UnexpectedToken);
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
            case '||':
                prec = 1;
                break;

            case '&&':
                prec = 2;
                break;

            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;

            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;

            case 'in':
                prec = 7;
                break;

            case '+':
            case '-':
                prec = 9;
                break;

            case '*':
            case '/':
            case '%':
                prec = 11;
                break;

            default:
                break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, stack, right, operator, left, i;

        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, consequent, alternate;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            consequent = parseConditionalExpression();
            expect(':');
            alternate = parseConditionalExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // Simplification since we do not support AssignmentExpression.
    var parseExpression = parseConditionalExpression;

    // Polymer Syntax extensions

    // Filter ::
    //   Identifier
    //   Identifier "(" ")"
    //   Identifier "(" FilterArguments ")"

    function parseFilter() {
        var identifier, args;

        identifier = lex();

        if (identifier.type !== Token.Identifier) {
            throwUnexpected(identifier);
        }

        args = match('(') ? parseArguments() : [];

        return delegate.createFilter(identifier.value, args);
    }

    // Filters ::
    //   "|" Filter
    //   Filters "|" Filter

    function parseFilters() {
        while (match('|')) {
            lex();
            parseFilter();
        }
    }

    // TopLevel ::
    //   LabelledExpressions
    //   AsExpression
    //   InExpression
    //   FilterExpression

    // AsExpression ::
    //   FilterExpression as Identifier

    // InExpression ::
    //   Identifier, Identifier in FilterExpression
    //   Identifier in FilterExpression

    // FilterExpression ::
    //   Expression
    //   Expression Filters

    function parseTopLevel() {
        skipWhitespace();
        peek();

        var expr = parseExpression();
        if (expr) {
            if (lookahead.value === ',' || lookahead.value == 'in' &&
                       expr.type === Syntax.Identifier) {
                parseInExpression(expr);
            } else {
                parseFilters();
                if (lookahead.value === 'as') {
                    parseAsExpression(expr);
                } else {
                    delegate.createTopLevel(expr);
                }
            }
        }

        if (lookahead.type !== Token.EOF) {
            throwUnexpected(lookahead);
        }
    }

    function parseAsExpression(expr) {
        lex();  // as
        var identifier = lex().value;
        delegate.createAsExpression(expr, identifier);
    }

    function parseInExpression(identifier) {
        var indexName;
        if (lookahead.value === ',') {
            lex();
            if (lookahead.type !== Token.Identifier)
                throwUnexpected(lookahead);
            indexName = lex().value;
        }

        lex();  // in
        var expr = parseExpression();
        parseFilters();
        delegate.createInExpression(identifier.name, indexName, expr);
    }

    function parse(code, inDelegate) {
        delegate = inDelegate;
        source = code;
        index = 0;
        length = source.length;
        lookahead = null;
        state = {
            labelSet: {}
        };

        return parseTopLevel();
    }

    global.esprima = {
        parse: parse
    };
})(module.exports);; 
if (false ) {} 

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */



function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
        return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {
        return false;
    }

    try {
        var f = new Function('', 'return true;');
        return f();
    } catch (ex) {
        return false;
    }
}

var hasEval = detectEval();

function isIndex(s) {
    return +s === s >>> 0 && s !== '';
}

function toNumber(s) {
    return +s;
}

function isObject(obj) {
    return obj === Object(obj);
}

var numberIsNaN = Number.isNaN || function (value) {
    return typeof value === 'number' && isNaN(value);
}

function areSameValue(left, right) {
    if (left === right)
        return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
        return true;

    return left !== left && right !== right;
}

var createObject = ('__proto__' in {}) ?
  function (obj) { return obj; } :
  function (obj) {
      var proto = obj.__proto__;
      if (!proto)
          return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function (name) {
          Object.defineProperty(newObject, name,
                               Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
  };

var identStart = '[\$_a-zA-Z]';
var identPart = '[\$_a-zA-Z0-9]';
var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

function getPathCharType(char) {
    if (char === undefined)
        return 'eof';

    var code = char.charCodeAt(0);

    switch (code) {
        case 0x5B: // [
        case 0x5D: // ]
        case 0x2E: // .
        case 0x22: // "
        case 0x27: // '
        case 0x30: // 0
            return char;

        case 0x5F: // _
        case 0x24: // $
            return 'ident';

        case 0x20: // Space
        case 0x09: // Tab
        case 0x0A: // Newline
        case 0x0D: // Return
        case 0xA0:  // No-break space
        case 0xFEFF:  // Byte Order Mark
        case 0x2028:  // Line Separator
        case 0x2029:  // Paragraph Separator
            return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
        return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
        return 'number';

    return 'else';
}

var pathStateMachine = {
    'beforePath': {
        'ws': ['beforePath'],
        'ident': ['inIdent', 'append'],
        '[': ['beforeElement'],
        'eof': ['afterPath']
    },

    'inPath': {
        'ws': ['inPath'],
        '.': ['beforeIdent'],
        '[': ['beforeElement'],
        'eof': ['afterPath']
    },

    'beforeIdent': {
        'ws': ['beforeIdent'],
        'ident': ['inIdent', 'append']
    },

    'inIdent': {
        'ident': ['inIdent', 'append'],
        '0': ['inIdent', 'append'],
        'number': ['inIdent', 'append'],
        'ws': ['inPath', 'push'],
        '.': ['beforeIdent', 'push'],
        '[': ['beforeElement', 'push'],
        'eof': ['afterPath', 'push']
    },

    'beforeElement': {
        'ws': ['beforeElement'],
        '0': ['afterZero', 'append'],
        'number': ['inIndex', 'append'],
        "'": ['inSingleQuote', 'append', ''],
        '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
        'ws': ['afterElement', 'push'],
        ']': ['inPath', 'push']
    },

    'inIndex': {
        '0': ['inIndex', 'append'],
        'number': ['inIndex', 'append'],
        'ws': ['afterElement'],
        ']': ['inPath', 'push']
    },

    'inSingleQuote': {
        "'": ['afterElement'],
        'eof': ['error'],
        'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
        '"': ['afterElement'],
        'eof': ['error'],
        'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
        'ws': ['afterElement'],
        ']': ['inPath', 'push']
    }
}

function noop() { }

function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
        push: function () {
            if (key === undefined)
                return;

            keys.push(key);
            key = undefined;
        },

        append: function () {
            if (key === undefined)
                key = newChar
            else
                key += newChar;
        }
    };

    function maybeUnescapeQuote() {
        if (index >= path.length)
            return;

        var nextChar = path[index + 1];
        if ((mode == 'inSingleQuote' && nextChar == "'") ||
            (mode == 'inDoubleQuote' && nextChar == '"')) {
            index++;
            newChar = nextChar;
            actions.append();
            return true;
        }
    }

    while (mode) {
        index++;
        c = path[index];

        if (c == '\\' && maybeUnescapeQuote(mode))
            continue;

        type = getPathCharType(c);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap['else'] || 'error';

        if (transition == 'error')
            return; // parse error;

        mode = transition[0];
        action = actions[transition[1]] || noop;
        newChar = transition[2] === undefined ? c : transition[2];
        action();

        if (mode === 'afterPath') {
            return keys;
        }
    }

    return; // parse error
}

function isIdent(s) {
    return identRegExp.test(s);
}

var constructorIsPrivate = {};

function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
        throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
        this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
        this.getValueFrom = this.compiledGetValueFromFn();
    }
}

// TODO(rafaelw): Make simple LRU cache
var pathCache = {};

function getPath(pathString) {
    if (pathString instanceof Path)
        return pathString;

    if (pathString == null || pathString.length == 0)
        pathString = '';

    if (typeof pathString != 'string') {
        if (isIndex(pathString.length)) {
            // Constructed with array-like (pre-parsed) keys
            return new Path(pathString, constructorIsPrivate);
        }

        pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
        return path;

    var parts = parsePath(pathString);
    if (!parts)
        return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
}

Path.get = getPath;

function formatAccessor(key) {
    if (isIndex(key)) {
        return '[' + key + ']';
    } else {
        return '["' + key.replace(/"/g, '\\"') + '"]';
    }
}

Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function () {
        var pathString = '';
        for (var i = 0; i < this.length; i++) {
            var key = this[i];
            if (isIdent(key)) {
                pathString += i ? '.' + key : key;
            } else {
                pathString += formatAccessor(key);
            }
        }

        return pathString;
    },

    getValueFrom: function (obj, directObserver) {
        for (var i = 0; i < this.length; i++) {
            if (obj == null)
                return;
            obj = obj[this[i]];
        }
        return obj;
    },

    iterateObjects: function (obj, observe) {
        for (var i = 0; i < this.length; i++) {
            if (i)
                obj = obj[this[i - 1]];
            if (!isObject(obj))
                return;
            observe(obj, this[i]);
        }
    },

    compiledGetValueFromFn: function () {
        var str = '';
        var pathString = 'obj';
        str += 'if (obj != null';
        var i = 0;
        var key;
        for (; i < (this.length - 1) ; i++) {
            key = this[i];
            pathString += isIdent(key) ? '.' + key : formatAccessor(key);
            str += ' &&\n     ' + pathString + ' != null';
        }
        str += ')\n';

        var key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);

        str += '  return ' + pathString + ';\nelse\n  return undefined;';
        return new Function('obj', str);
    },

    setValueFrom: function (obj, value) {
        if (!this.length)
            return false;

        for (var i = 0; i < this.length - 1; i++) {
            if (!isObject(obj))
                return false;
            obj = obj[this[i]];
        }

        if (!isObject(obj))
            return false;

        obj[this[i]] = value;
        return true;
    }
});

var invalidPath = new Path('', constructorIsPrivate);
invalidPath.valid = false;
invalidPath.getValueFrom = invalidPath.setValueFrom = function () { };

exports.Path = Path;
; 
if (false ) {} 

/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XMLHttpRequest", function() { return XMLHttpRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormData", function() { return FormData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Blob", function() { return Blob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "File", function() { return File; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileReader", function() { return FileReader; });
/* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);


var XMLHttpRequestResponseType;
(function (XMLHttpRequestResponseType) {
    XMLHttpRequestResponseType.empty = '';
    XMLHttpRequestResponseType.text = 'text';
    XMLHttpRequestResponseType.json = 'json';
    XMLHttpRequestResponseType.blob = 'blob';
    XMLHttpRequestResponseType.arraybuffer = 'arraybuffer';
})(XMLHttpRequestResponseType || (XMLHttpRequestResponseType = {}));
class XMLHttpRequest {
    constructor() {
        this.UNSENT = 0;
        this.OPENED = 1;
        this.HEADERS_RECEIVED = 2;
        this.LOADING = 3;
        this.DONE = 4;
        this._responseType = '';
        this._listeners = new Map();
        this._readyState = this.UNSENT;
    }
    get upload() {
        return this;
    }
    get readyState() {
        return this._readyState;
    }
    get responseType() {
        return this._responseType;
    }
    set responseType(value) {
        if (value === XMLHttpRequestResponseType.empty || value in XMLHttpRequestResponseType) {
            this._responseType = value;
        }
        else {
            throw new Error(`Response type of '${value}' not supported.`);
        }
    }
    get responseText() {
        if (this._responseType !== XMLHttpRequestResponseType.empty && this._responseType !== XMLHttpRequestResponseType.text) {
            throw new Error("Failed to read the 'responseText' property from 'XMLHttpRequest': " + "The value is only accessible if the object's 'responseType' is '' or 'text' " + `(was '${this._responseType}').`);
        }
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "g"](this._responseTextReader)) {
            return this._responseTextReader();
        }
        return '';
    }
    get response() {
        if (this._responseType === XMLHttpRequestResponseType.empty || this._responseType === XMLHttpRequestResponseType.text) {
            if (this._readyState !== this.LOADING && this._readyState !== this.DONE) {
                return '';
            }
            else {
                return this._response;
            }
        }
        else {
            if (this._readyState !== this.DONE) {
                return null;
            }
            else {
                return this._response;
            }
        }
    }
    get status() {
        return this._status;
    }
    get statusText() {
        if (this._readyState === this.UNSENT || this._readyState === this.OPENED || this._errorFlag) {
            return '';
        }
        return statuses[this._status];
    }
    _loadResponse(r) {
        this._status = r.statusCode;
        this._headers = r.headers;
        this._setReadyState(this.HEADERS_RECEIVED);
        this._setReadyState(this.LOADING);
        this._responseTextReader = () => r.content.toString();
        const contentType = this.getResponseHeader('Content-Type');
        const mimeType = (contentType && contentType.toLowerCase()) || 'text/xml';
        const finalMimeType = this._overrideMimeType || mimeType;
        if (this._responseType === XMLHttpRequestResponseType.json) {
            this._response = r.content.toJSON();
        }
        else if (this._responseType === XMLHttpRequestResponseType.text || this._responseType === XMLHttpRequestResponseType.empty) {
            this._response = this.responseText;
        }
        else if (this._responseType === XMLHttpRequestResponseType.arraybuffer) {
            this._response = r.content.toArrayBuffer();
        }
        else if (this._responseType === XMLHttpRequestResponseType.blob) {
            this._response = new Blob([r.content.toArrayBuffer()], {
                type: finalMimeType,
            });
        }
        this.emitEvent('progress');
        this._sendFlag = false;
        this._setReadyState(this.DONE);
    }
    emitEvent(eventName, ...args) {
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "g"](this['on' + eventName])) {
            this['on' + eventName](...args);
        }
        let handlers = this._listeners.get(eventName) || [];
        handlers.forEach((handler) => {
            handler(...args);
        });
    }
    _setReadyState(value) {
        if (this._readyState !== value) {
            this._readyState = value;
            this.emitEvent('readystatechange');
        }
        if (this._readyState === this.DONE) {
            this.emitEvent('load');
            this.emitEvent('loadend');
        }
    }
    _setRequestError(eventName, error) {
        this._readyState = this.DONE;
        this._response = error;
        this.emitEvent('readystatechange');
        this.emitEvent(eventName, error);
        this.emitEvent('loadend');
    }
    addEventListener(eventName, handler) {
        if (['abort', 'error', 'load', 'loadend', 'loadstart', 'progress', 'readystatechange'].indexOf(eventName) === -1) {
            throw new Error('Event not supported: ' + eventName);
        }
        let handlers = this._listeners.get(eventName) || [];
        handlers.push(handler);
        this._listeners.set(eventName, handlers);
    }
    removeEventListener(eventName, toDetach) {
        let handlers = this._listeners.get(eventName) || [];
        handlers = handlers.filter((handler) => handler !== toDetach);
        this._listeners.set(eventName, handlers);
    }
    open(method, url, async, user, password) {
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](method) && _utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](url)) {
            this._options = { url: url, method: method };
            this._options.headers = {};
            if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](user)) {
                this._options.headers['user'] = user;
            }
            if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](password)) {
                this._options.headers['password'] = password;
            }
            this._setReadyState(this.OPENED);
        }
    }
    abort() {
        this._response = null;
        this._responseTextReader = null;
        this._headers = null;
        this._status = null;
        if ((this._readyState === this.OPENED && this._sendFlag) || this._readyState === this.HEADERS_RECEIVED || this._readyState === this.LOADING) {
            this._errorFlag = true;
            this._sendFlag = false;
            this._setRequestError('abort');
        }
        if (this._readyState === this.DONE) {
            this._readyState = this.UNSENT;
        }
    }
    send(data) {
        this._errorFlag = false;
        this._response = null;
        this._responseTextReader = null;
        this._headers = null;
        this._status = null;
        if (this._readyState !== this.OPENED || this._sendFlag) {
            throw new Error("Failed to execute 'send' on 'XMLHttpRequest': " + "The object's state must be OPENED.");
        }
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](data) && this._options.method !== 'GET') {
            //The Android Java HTTP lib throws an exception if we provide a
            //a request body for GET requests, so we avoid doing that.
            //Browser implementations silently ignore it as well.
            this._options.content = data;
        }
        else if (data instanceof FormData) {
            this._options.content = data.toString();
        }
        else if (data instanceof Blob) {
            this.setRequestHeader('Content-Type', data.type);
            this._options.content = Blob.InternalAccessor.getBuffer(data);
        }
        else if (data instanceof ArrayBuffer) {
            this._options.content = data;
        }
        this._sendFlag = true;
        this.emitEvent('loadstart');
        _http__WEBPACK_IMPORTED_MODULE_0__["request"](this._options)
            .then((r) => {
            if (!this._errorFlag && this._sendFlag) {
                this._loadResponse(r);
            }
        })
            .catch((e) => {
            this._errorFlag = true;
            this._sendFlag = false;
            this._setRequestError('error', e);
        });
    }
    setRequestHeader(header, value) {
        if (this._readyState !== this.OPENED || this._sendFlag) {
            throw new Error("Failed to execute 'setRequestHeader' on 'XMLHttpRequest': " + "The object's state must be OPENED.");
        }
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](header) && _utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](value)) {
            this._options.headers[header] = value;
        }
    }
    getAllResponseHeaders() {
        if (this._readyState < 2 || this._errorFlag) {
            return '';
        }
        let result = '';
        for (let i in this._headers) {
            result += i + ': ' + this._headers[i] + '\r\n';
        }
        return result.substr(0, result.length - 2);
    }
    getResponseHeader(header) {
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isString */ "k"](header) && this._readyState > 1 && this._headers && !this._errorFlag) {
            header = header.toLowerCase();
            for (let i in this._headers) {
                if (i.toLowerCase() === header) {
                    return this._headers[i];
                }
            }
        }
        return null;
    }
    overrideMimeType(mime) {
        if (this._readyState === this.LOADING || this._readyState === this.DONE) {
            throw new Error("Failed to execute 'overrideMimeType' on 'XMLHttpRequest': " + 'MimeType cannot be overridden when the state is LOADING or DONE.');
        }
        this._overrideMimeType = mime;
    }
}
const statuses = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non - Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Large',
    414: 'Request - URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Requested Range Not Satisfiable',
    417: 'Expectation Failed',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
};
class FormData {
    constructor() {
        this._data = new Map();
    }
    append(name, value) {
        this._data.set(name, value);
    }
    toString() {
        let arr = new Array();
        this._data.forEach(function (value, name, map) {
            arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`);
        });
        return arr.join('&');
    }
}
class Blob {
    constructor(chunks = [], opts = {}) {
        this[Symbol.toStringTag] = 'Blob';
        const dataChunks = [];
        for (const chunk of chunks) {
            if (chunk instanceof Blob) {
                dataChunks.push(chunk._buffer);
            }
            else if (typeof chunk === 'string') {
                const textEncoder = new TextEncoder();
                dataChunks.push(textEncoder.encode(chunk));
            }
            else if (chunk instanceof DataView) {
                dataChunks.push(new Uint8Array(chunk.buffer.slice(0)));
            }
            else if (chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk)) {
                dataChunks.push(new Uint8Array(ArrayBuffer.isView(chunk) ? chunk.buffer.slice(0) : chunk.slice(0)));
            }
            else {
                const textEncoder = new TextEncoder();
                dataChunks.push(textEncoder.encode(String(chunk)));
            }
        }
        const size = dataChunks.reduce((size, chunk) => size + chunk.byteLength, 0);
        const buffer = new Uint8Array(size);
        let offset = 0;
        for (let i = 0; i < dataChunks.length; i++) {
            const chunk = dataChunks[i];
            buffer.set(chunk, offset);
            offset += chunk.byteLength;
        }
        this._buffer = buffer;
        this._size = this._buffer.byteLength;
        this._type = opts.type || '';
        if (/[^\u0020-\u007E]/.test(this._type)) {
            this._type = '';
        }
        else {
            this._type = this._type.toLowerCase();
        }
    }
    get size() {
        return this._size;
    }
    get type() {
        return this._type;
    }
    arrayBuffer() {
        return Promise.resolve(this._buffer);
    }
    text() {
        const textDecoder = new TextDecoder();
        return Promise.resolve(textDecoder.decode(this._buffer));
    }
    slice(start, end, type) {
        const slice = this._buffer.slice(start || 0, end || this._buffer.length);
        return new Blob([slice], { type: type });
    }
    stream() {
        throw new Error('stream is currently not supported');
    }
    toString() {
        return '[object Blob]';
    }
}
// Note: only for use by XHR
Blob.InternalAccessor = class {
    static getBuffer(blob) {
        return blob._buffer;
    }
};
class File extends Blob {
    constructor(chunks, name, opts = {}) {
        super(chunks, opts);
        this[Symbol.toStringTag] = 'File';
        this._name = name.replace(/\//g, ':');
        this._lastModified = opts.lastModified ? new Date(opts.lastModified).valueOf() : Date.now();
    }
    get name() {
        return this._name;
    }
    get lastModified() {
        return this._lastModified;
    }
    toString() {
        return '[object File]';
    }
}
class FileReader {
    constructor() {
        this.EMPTY = 0;
        this.LOADING = 1;
        this.DONE = 2;
        this._listeners = new Map();
        this[Symbol.toStringTag] = 'FileReader';
        //
    }
    get readyState() {
        return this._readyState;
    }
    get result() {
        return this._result;
    }
    _array2base64(input) {
        var byteToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    }
    _read(blob, kind) {
        if (!(blob instanceof Blob)) {
            throw new TypeError(`Failed to execute '${kind}' on 'FileReader': parameter 1 is not of type 'Blob'.`);
        }
        this._result = '';
        setTimeout(() => {
            this._readyState = this.LOADING;
            this.emitEvent('load');
            this.emitEvent('loadend');
        });
    }
    emitEvent(eventName, ...args) {
        if (_utils_types__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "g"](this['on' + eventName])) {
            this['on' + eventName](...args);
        }
        let handlers = this._listeners.get(eventName) || [];
        handlers.forEach((handler) => {
            handler(...args);
        });
    }
    addEventListener(eventName, handler) {
        if (['abort', 'error', 'load', 'loadend', 'loadstart', 'progress'].indexOf(eventName) === -1) {
            throw new Error('Event not supported: ' + eventName);
        }
        let handlers = this._listeners.get(eventName) || [];
        handlers.push(handler);
        this._listeners.set(eventName, handlers);
    }
    removeEventListener(eventName, toDetach) {
        let handlers = this._listeners.get(eventName) || [];
        handlers = handlers.filter((handler) => handler !== toDetach);
        this._listeners.set(eventName, handlers);
    }
    readAsDataURL(blob) {
        this._read(blob, 'readAsDataURL');
        this._result = `data:${blob.type};base64,${this._array2base64(Blob.InternalAccessor.getBuffer(blob))}`;
    }
    readAsText(blob) {
        this._read(blob, 'readAsText');
        const textDecoder = new TextDecoder();
        this._result = textDecoder.decode(Blob.InternalAccessor.getBuffer(blob));
    }
    readAsArrayBuffer(blob) {
        this._read(blob, 'readAsArrayBuffer');
        this._result = Blob.InternalAccessor.getBuffer(blob).buffer.slice(0);
    }
    abort() {
        //
    }
    toString() {
        return '[object FileReader]';
    }
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function () {
    "use strict";

    var support = {
        searchParams: "URLSearchParams" in global,
        iterable: "Symbol" in global && "iterator" in Symbol,
        blob:
            "FileReader" in global &&
            "Blob" in global &&
            (function () {
                try {
                    new Blob();
                    return true;
                } catch (e) {
                    return false;
                }
            })(),
        formData: "FormData" in global,
        arrayBuffer: "ArrayBuffer" in global
    };

    function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
    }

    if (support.arrayBuffer) {
        var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
        ];

        var isArrayBufferView =
            ArrayBuffer.isView ||
            function (obj) {
                return (
                    obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                );
            };
    }

    function normalizeName(name) {
        if (typeof name !== "string") {
            name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
    }

    function normalizeValue(value) {
        if (typeof value !== "string") {
            value = String(value);
        }
        return value;
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
        var iterator = {
            next: function () {
                var value = items.shift();
                return { done: value === undefined, value: value };
            }
        };

        if (support.iterable) {
            iterator[Symbol.iterator] = function () {
                return iterator;
            };
        }

        return iterator;
    }

    function Headers(headers) {
        this.map = {};

        if (headers instanceof Headers) {
            headers.forEach(function (value, name) {
                this.append(name, value);
            }, this);
        } else if (Array.isArray(headers)) {
            headers.forEach(function (header) {
                this.append(header[0], header[1]);
            }, this);
        } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function (name) {
                this.append(name, headers[name]);
            }, this);
        }
    }

    Headers.prototype.append = function (name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
    };

    Headers.prototype["delete"] = function (name) {
        delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function (name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
    };

    Headers.prototype.has = function (name) {
        return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function (name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
    };

    Headers.prototype.forEach = function (callback, thisArg) {
        for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
            }
        }
    };

    Headers.prototype.keys = function () {
        var items = [];
        this.forEach(function (value, name) {
            items.push(name);
        });
        return iteratorFor(items);
    };

    Headers.prototype.values = function () {
        var items = [];
        this.forEach(function (value) {
            items.push(value);
        });
        return iteratorFor(items);
    };

    Headers.prototype.entries = function () {
        var items = [];
        this.forEach(function (value, name) {
            items.push([name, value]);
        });
        return iteratorFor(items);
    };

    if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
        if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
        return new Promise(function (resolve, reject) {
            reader.onload = function () {
                resolve(reader.result);
            };
            reader.onerror = function () {
                reject(reader.error);
            };
        });
    }

    function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
    }

    function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
    }

    function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);

        for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
    }

    function bufferClone(buf) {
        if (buf.slice) {
            return buf.slice(0);
        } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
        }
    }

    function Body() {
        this.bodyUsed = false;

        this._initBody = function (body) {
            this._bodyInit = body;
            if (!body) {
                this._bodyText = "";
            } else if (typeof body === "string") {
                this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
            } else if (
                support.searchParams &&
                URLSearchParams.prototype.isPrototypeOf(body)
            ) {
                this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                // IE 10-11 can't handle a DataView body.
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (
                support.arrayBuffer &&
                (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))
            ) {
                this._bodyArrayBuffer = bufferClone(body);
            } else {
                this._bodyText = body = Object.prototype.toString.call(body);
            }

            if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                    this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set("content-type", this._bodyBlob.type);
                } else if (
                    support.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(body)
                ) {
                    this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                    );
                }
            }
        };

        if (support.blob) {
            this.blob = function () {
                var rejected = consumed(this);
                if (rejected) {
                    return rejected;
                }

                if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                    throw new Error("could not read FormData body as blob");
                } else {
                    return Promise.resolve(new Blob([this._bodyText]));
                }
            };

            this.arrayBuffer = function () {
                if (this._bodyArrayBuffer) {
                    return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                }
            };
        }

        this.text = function () {
            var rejected = consumed(this);
            if (rejected) {
                return rejected;
            }

            if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
            } else {
                return Promise.resolve(this._bodyText);
            }
        };

        if (support.formData) {
            this.formData = function () {
                return this.text().then(decode);
            };
        }

        this.json = function () {
            return this.text().then(JSON.parse);
        };

        return this;
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

    function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
    }

    function Request(input, options) {
        options = options || {};
        var body = options.body;

        if (input instanceof Request) {
            if (input.bodyUsed) {
                throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
                this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
            }
        } else {
            this.url = String(input);
        }

        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;

        if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
    }

    Request.prototype.clone = function () {
        return new Request(this, { body: this._bodyInit });
    };

    function decode(body) {
        var form = new FormData();
        body
            .trim()
            .split("&")
            .forEach(function (bytes) {
                if (bytes) {
                    var split = bytes.split("=");
                    var name = split.shift().replace(/\+/g, " ");
                    var value = split.join("=").replace(/\+/g, " ");
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
            });
        return form;
    }

    function parseHeaders(rawHeaders) {
        var headers = new Headers();
        // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
        // https://tools.ietf.org/html/rfc7230#section-3.2
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
                var value = parts.join(":").trim();
                headers.append(key, value);
            }
        });
        return headers;
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
        if (!options) {
            options = {};
        }

        this.type = "default";
        this.status = options.status === undefined ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function () {
        return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
        });
    };

    Response.error = function () {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function (url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
        }

        return new Response(null, { status: status, headers: { location: url } });
    };

    exports.DOMException = global.DOMException;
    try {
        new exports.DOMException();
    } catch (err) {
        exports.DOMException = function (message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
        };
        exports.DOMException.prototype = Object.create(Error.prototype);
        exports.DOMException.prototype.constructor = exports.DOMException;
    }

    function fetch(input, init) {
        return new Promise(function (resolve, reject) {
            var request = new Request(input, init);

            if (request.signal && request.signal.aborted) {
                return reject(new exports.DOMException("Aborted", "AbortError"));
            }

            var xhr = new XMLHttpRequest();

            function abortXhr() {
                xhr.abort();
            }

            xhr.onload = function () {
                var options = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url =
                    "responseURL" in xhr
                        ? xhr.responseURL
                        : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
            };

            xhr.onerror = function () {
                reject(new TypeError("Network request failed"));
            };

            xhr.ontimeout = function () {
                reject(new TypeError("Network request failed"));
            };

            xhr.onabort = function () {
                reject(new exports.DOMException("Aborted", "AbortError"));
            };

            xhr.open(request.method, request.url, true);

            if (request.credentials === "include") {
                xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
            }

            if ("responseType" in xhr && support.blob) {
                xhr.responseType = "blob";
            }

            request.headers.forEach(function (value, name) {
                xhr.setRequestHeader(name, value);
            });

            if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);

                xhr.onreadystatechange = function () {
                    // DONE (success or failure)
                    if (xhr.readyState === 4) {
                        request.signal.removeEventListener("abort", abortXhr);
                    }
                };
            }

            xhr.send(
                typeof request._bodyInit === "undefined" ? null : request._bodyInit
            );
        });
    }

    fetch.polyfill = true;

    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.fetch = fetch;

    Object.defineProperty(exports, "__esModule", { value: true });
})();
; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 409 */,
/* 410 */,
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(228);
var keychainItemIdentifier = "TouchIDKey";
var keychainItemServiceName = null;
var FingerprintAuth = (function () {
    function FingerprintAuth() {
    }
    FingerprintAuth.prototype.available = function () {
        return new Promise(function (resolve, reject) {
            try {
                var laContext = LAContext.new();
                var hasBio = laContext.canEvaluatePolicyError(1);
                resolve({
                    any: hasBio,
                    touch: hasBio && laContext.biometryType === 1,
                    face: hasBio && laContext.biometryType === 2
                });
            }
            catch (ex) {
                console.log("fingerprint-auth.available: " + ex);
                resolve({
                    any: false
                });
            }
        });
    };
    FingerprintAuth.prototype.didFingerprintDatabaseChange = function () {
        return new Promise(function (resolve, reject) {
            try {
                var laContext = LAContext.new();
                if (!laContext.canEvaluatePolicyError(1)) {
                    reject("Not available");
                    return;
                }
                if (utils_1.ios.MajorVersion < 9) {
                    resolve(false);
                    return;
                }
                var FingerprintDatabaseStateKey = "FingerprintDatabaseStateKey";
                var state = laContext.evaluatedPolicyDomainState;
                if (state !== null) {
                    var stateStr = state.base64EncodedStringWithOptions(0);
                    var storedState = NSUserDefaults.standardUserDefaults.stringForKey(FingerprintDatabaseStateKey);
                    NSUserDefaults.standardUserDefaults.setObjectForKey(stateStr, FingerprintDatabaseStateKey);
                    NSUserDefaults.standardUserDefaults.synchronize();
                    var changed = storedState !== null && stateStr !== storedState;
                    resolve(changed);
                }
            }
            catch (ex) {
                console.log("Error in fingerprint-auth.didFingerprintDatabaseChange: " + ex);
                resolve(false);
            }
        });
    };
    FingerprintAuth.prototype.verifyFingerprint = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                if (keychainItemServiceName === null) {
                    var bundleID = NSBundle.mainBundle.infoDictionary.objectForKey("CFBundleIdentifier");
                    keychainItemServiceName = bundleID + ".TouchID";
                }
                if (!FingerprintAuth.createKeyChainEntry()) {
                    _this.verifyFingerprintWithCustomFallback(options, true).then(resolve, reject);
                    return;
                }
                var query = NSMutableDictionary.alloc().init();
                query.setObjectForKey(kSecClassGenericPassword, kSecClass);
                query.setObjectForKey(keychainItemIdentifier, kSecAttrAccount);
                query.setObjectForKey(keychainItemServiceName, kSecAttrService);
                query.setObjectForKey((options !== null && options.message) || "Scan your finger", kSecUseOperationPrompt);
                var res = SecItemCopyMatching(query, null);
                if (res === 0) {
                    resolve();
                }
                else {
                    reject();
                }
            }
            catch (ex) {
                console.log("Error in fingerprint-auth.verifyFingerprint: " + ex);
                reject(ex);
            }
        });
    };
    FingerprintAuth.prototype.verifyFingerprintWithCustomFallback = function (options, usePasscodeFallback) {
        var _this = this;
        if (usePasscodeFallback === void 0) { usePasscodeFallback = false; }
        return new Promise(function (resolve, reject) {
            try {
                _this.laContext = LAContext.new();
                if (!_this.laContext.canEvaluatePolicyError(1)) {
                    reject("Not available");
                    return;
                }
                var message = (options !== null && options.message) || "Scan your finger";
                if (options !== null && options.fallbackMessage) {
                    _this.laContext.localizedFallbackTitle = options.fallbackMessage;
                }
                _this.laContext.evaluatePolicyLocalizedReasonReply(usePasscodeFallback ? 2 : 1, message, function (ok, error) {
                    if (ok) {
                        resolve();
                    }
                    else {
                        reject({
                            code: error.code,
                            message: error.localizedDescription
                        });
                    }
                });
            }
            catch (ex) {
                console.log("Error in fingerprint-auth.verifyFingerprint: " + ex);
                reject(ex);
            }
        });
    };
    FingerprintAuth.createKeyChainEntry = function () {
        var attributes = NSMutableDictionary.new();
        attributes.setObjectForKey(kSecClassGenericPassword, kSecClass);
        attributes.setObjectForKey(keychainItemIdentifier, kSecAttrAccount);
        attributes.setObjectForKey(keychainItemServiceName, kSecAttrService);
        var accessControlRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, 2, null);
        if (accessControlRef === null) {
            console.log("Can't store identifier '" + keychainItemIdentifier + "' in the KeyChain.");
            return false;
        }
        else {
            attributes.setObjectForKey(accessControlRef, kSecAttrAccessControl);
            var content = NSString.stringWithString("dummy content");
            var nsData = content.dataUsingEncoding(NSUTF8StringEncoding);
            attributes.setObjectForKey(nsData, kSecValueData);
            SecItemAdd(attributes, null);
            return true;
        }
    };
    FingerprintAuth.prototype.close = function () {
        if (this.laContext) {
            this.laContext.invalidate();
        }
    };
    return FingerprintAuth;
}());
exports.FingerprintAuth = FingerprintAuth;
; 
if (false ) {} 

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**********************************************************************************
 * (c) 2015-2020, Master Technology
 * Licensed under the MIT license or contact me for a Support or Commercial License
 *
 * I do contract work in most languages, so let me solve your problems!
 *
 * Any questions please feel free to email me or put a issue up on the github repo
 * Version 1.0.0                                      Nathan@master-technology.com
 *********************************************************************************/


/* jshint node: true, browser: true, unused: true, undef: true */
/* global global */

// Load the required modules
const viewBase = __webpack_require__(15);
const frame = __webpack_require__(12);

// global.android is already defined on android devices
// We are defining global.ios on ios devices, since the iOS team can't seem to do it.  ;-)
if (global.NSObject && global.NSString && typeof global.ios === "undefined") {
    global.ios = true;
    Object.freeze(global.ios);
}

if (!global.getElementById) {
    /***
     * Find a element by an id
     * @param id
     * @returns {ViewBase} or {undefined}
     */
    global.getElementById = function (id) {
        return getElementById(getCurrentActiveModel(), id);
    };
}

if (!viewBase.ViewBase.prototype.getElementById) {
    /***
     * Find an element by a id
     * @param id
     * @returns {ViewBase} or {undefined}
     */
    viewBase.ViewBase.prototype.getElementById = function (id) {
        return getElementById(this, id);
    };
}

if (!global.getElementsByClassName) {
    /***
     * getElementsByClassName
     * @param className - The class name
     * @returns {Array} of elements
     */
    global.getElementsByClassName = function (className) {
        return getElementsByClassName(getCurrentActiveModel(), className);
    };
}

if (!viewBase.ViewBase.prototype.getElementsByClassName) {
    /***
     * Finds all elements with the class name
     * @param className - the Class name
     * @returns {Array} of elements
     */
    viewBase.ViewBase.prototype.getElementsByClassName = function (className) {
        return getElementsByClassName(this, className);
    };
}

if (!global.getElementsByTagName) {
    /**
     * Finds all elements by a Tag name
     * @param tagName
     * @returns {Array}
     */
    global.getElementsByTagName = function (tagName) {
        return getElementsByTagName(getCurrentActiveModel(), tagName);
    };
}

if (!viewBase.ViewBase.prototype.getElementsByTagName) {
    /**
     * Finds all elements by a Tag name
     * @param tagName
     * @returns {Array}
     */
    viewBase.ViewBase.prototype.getElementsByTagName = function (tagName) {
        return getElementsByTagName(this, tagName);
    };
}

if (!viewBase.ViewBase.prototype.classList) {
    const classList = function(t) {
		let curClassList = "";

		this._resync = function () {
			if (curClassList === t.className) {
				return;
			}

			// We need to zero our length; so that we can re-add anything that exists in the parent class
			this.length = 0;
			var self = this;
			t.cssClasses.forEach(function (item) {
				self.push(item);
			});
		};

		this._update = function () {
			curClassList = this.join(" ");
			t.className = curClassList;
		};


		this._resync();
	};
    classList.prototype = [];
    classList.prototype.toString = function() {
        this._resync();
        return this.join(" ");
    };
    classList.prototype.item = function(i) {
        this._resync();
        return this[i] || null;
    };
    classList.prototype.add = function() {
        this._resync();
        let updated=false;
        for (let i=0,len=arguments.length;i<len;i++) {
            if (!this.contains(arguments[i])) {
                this.push(arguments[i]);
                updated = true;
            }
        }
        if (updated) {
            this._update();
        }
        return this;
    };
    classList.prototype.insert = function() {
        this._resync();
        let updated = false;
        for (let i=0,len=arguments.length;i<len;i++) {
            if (!this.contains(arguments[i])) {
                this.unshift(arguments[i]);
                updated = true;
            }
        }
        if (updated) {
            this._update();
        }
        return this;
    };

    classList.prototype.remove = function() {
        this._resync();
        let updated = false;
        for (let i= 0,len=arguments.length;i<len;i++) {
            let idx = this.indexOf(arguments[i]);
            if (idx >= 0) {
                this.splice(idx, 1);
                updated = true;
            }
        }
        if (updated) {
            this._update();
        }
        return this;
    };
    classList.prototype.toggle = function(val, force) {
        this._resync();
        if (this.contains(val)) {
            if (force === true) { return this; }
            return this.remove(val);
        } else {
            if (force === false) { return this; }
            return this.add(val);
        }
    };
    classList.prototype.contains = function(c) {
        return this.indexOf(c) >= 0;
    };
    const getClassList = function (val) {
        const cl = new classList(val);
        Object.defineProperty(val, "classList", { value: cl, configurable: true, enumerable: true });
        return cl;
    };
    Object.defineProperty(viewBase.ViewBase.prototype, "classList", {configurable: true, enumerable: true, get: function() { return getClassList(this); }});
}

global.runAgainstClasses = function(clsName, func) {
    runAgainstClasses(getCurrentActiveModel(), clsName, func);
};
viewBase.ViewBase.prototype.runAgainstClasses = function(clsName, func) {
    runAgainstClasses(this, clsName, func);
};

global.runAgainstTagNames = function(tagName, func) {
    runAgainstTagNames(getCurrentActiveModel(), tagName, func);
};
viewBase.ViewBase.prototype.runAgainstTagNames = function(tagName, func) {
    runAgainstTagNames(this, tagName, func);
};

global.runAgainstId = function(id, func) {
    runAgainstId(getCurrentActiveModel(), id, func);
};
viewBase.ViewBase.prototype.runAgainstId = function(id, func) {
    runAgainstId(this, id, func);
};


/*** Support routines, not publicly accessible ***/
function getElementById(v, id) {
    if (!v) {
        return undefined;
    }
    if (v.id === id) {
        return view;
    }
    let retVal=undefined;
    const viewCallBack = function (child) {
        if (child.id === id) {
            retVal = child;
            return false;
        }

        // Android patch for ListView
        if (child._realizedItems && child._realizedItems.size !== child._childrenCount) {
            for (let key in child._realizedItems) {
                if (child._realizedItems.hasOwnProperty(key)) {
                    // We return false, when we have a hit; so if we have a hit we can stop searching
                    if (!viewCallBack(child._realizedItems[key])) {
                        return false;
                    }
                }
            }
        }

        return true;
    };

    viewBase.eachDescendant(v, viewCallBack);

    if (typeof retVal === "undefined") {
        // Android patch for ListView
        if (v._realizedItems && v._realizedItems.size !== v._childrenCount) {
            for (let key in v._realizedItems) {
                if (v._realizedItems.hasOwnProperty(key)) {
                    // viewCallback will return false, if we found a match
                    if (!viewCallBack(v._realizedItems[key])) {
                        return retVal;
                    }
                }
            }
        }
    }

    return retVal;
}

function getElementsByClassName(v, clsName) {
    let retVal=[];
    if (!v) {
        return retVal;
    }

    if (v.classList.contains(clsName)) {
            retVal.push(v);
    }


    const classNameCallback = function (child) {
		if (child.classList.contains(clsName)) {
                retVal.push(child);
        }

        // Android patch for ListView
        if (child._realizedItems && child._realizedItems.size !== child._childrenCount) {
            for (let key in child._realizedItems) {
                if (child._realizedItems.hasOwnProperty(key)) {
                    classNameCallback(child._realizedItems[key]);
                }
            }
        }

        return true;
    };

    viewBase.eachDescendant(v, classNameCallback);

    // Android patch for ListView
    if (v._realizedItems && v._realizedItems.size !== v._childrenCount) {
        for (let key in v._realizedItems) {
            if (v._realizedItems.hasOwnProperty(key)) {
                classNameCallback(v._realizedItems[key]);
            }
        }
    }


    return retVal;
}

function getElementsByTagName(v, tagName) {
    // TagName is case-Insensitive
    let tagNameLC = tagName.toLowerCase();

    let retVal=[], allTags = false;
    if (!v) {
        return retVal;
    }

    if (tagName === '*') { allTags = true; }

    if (v.typeName && v.typeName.toLowerCase() === tagNameLC || allTags) {
        retVal.push(v);
    }

    let tagNameCallback = function (child) {
        if (child.typeName && child.typeName.toLowerCase() === tagNameLC || allTags) {
            retVal.push(child);
        }

        // Android patch for ListView
        if (child._realizedItems && child._realizedItems.size !== child._childrenCount) {
            for (let key in child._realizedItems) {
                if (child._realizedItems.hasOwnProperty(key)) {
                    tagNameCallback(child._realizedItems[key]);
                }
            }
        }

        return true;
    };

    viewBase.eachDescendant(v, tagNameCallback);

    // Android patch for ListView
    if (v._realizedItems && v._realizedItems.size !== v._childrenCount) {
        for (let key in v._realizedItems) {
            if (v._realizedItems.hasOwnProperty(key)) {
                tagNameCallback(v._realizedItems[key]);
            }
        }
    }

    return retVal;
}

const getCurrentActiveModel = function() {
    const topFrame = frame.Frame && frame.Frame.topmost ? frame.Frame.topmost() :  frame.topmost();
    const model = topFrame.currentPage && topFrame.currentPage.model;
    if (model) { return model; }
    return topFrame;
};

function runAgainstClasses(v, clsName, func) {
    const elements = getElementsByClassName(v, clsName);
    for (let i=0;i<elements.length;i++) {
        func(elements[i]);
    }
}

function runAgainstTagNames(v, tagName, func) {
    const elements = getElementsByTagName(v, tagName);
    for (let i=0;i<elements.length;i++) {
        func(elements[i]);
    }
}

function runAgainstId(v, id, func) {
    const element = getElementById(v, id);
    if (element) { func(element); }
}
; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 413 */,
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**********************************************************************************
 * (c) 2016-2020, Master Technology
 * Licensed under the MIT license or contact me for a Support or Commercial License
 *
 * I do contract work in most languages, so let me solve your problems!
 *
 * Any questions please feel free to email me or put a issue up on the github repo
 * Version 2.0.0                                      Nathan@master-technology.com
 *********************************************************************************/


/* jshint camelcase: false */
/* global android, NSString, nsPlatform */

const Page = __webpack_require__(84).Page;
__webpack_require__(415);

/**
 * Function that adds the proper class when we navigate to a new page
 * @param args
 */
let deviceInfo, sizeGroupings = false;
let groupings = [1280,1024,800,600,540,480,400,360,320];

const setDevice = function(args) {
    const currentPage = args.object;

    let device;
    if (!deviceInfo) {
        switch (nsPlatform.platform) {
            case nsPlatform.type.IOS:
                device = 'ios ios';
                break;

            case nsPlatform.type.ANDROID:
                device = 'android android';
                break;
        }

        const screen = nsPlatform.screen;

		if (sizeGroupings) {
			let size = (screen.width < screen.height ? screen.width : screen.height);
			let found = false;
			for (let i=0;i<groupings.length;i++) {
				if (size >= groupings[i]) {
					device += groupings[i];
					found = true;
					break;
				}
			}
			if (!found) {
				device += size;
			}
		} else {
			if (screen.width < screen.height) {
				device += screen.width;
			} else {
				device += screen.height;
			}
		}

		const deviceName = nsPlatform.device.name || '';
        // Add device name; this is use
		device += " " + deviceName.replace(/[^a-z0-9]/gmi,'').toLowerCase() + " " + nsPlatform.deviceType.toLowerCase();

		if (nsPlatform.device.notch) {
			device += " notch";
		}

		deviceInfo = device;
    } else {
        device = deviceInfo;
    }

    if (currentPage) {

        if (nsPlatform.hasSoftNav()) {
            device += " softnav";
        }

        const data = currentPage.className || '';
        if (data.length) {
            currentPage.className = data + ' ' + device;
        } else {
            currentPage.className = device;
        }
    }
};

// Setup Events
Page.on("navigatingToFirst", setDevice);
Page.on("showingModallyFirst", setDevice);

exports.sizeGroupings = function(val) {
	if (Array.isArray(val)) {
		if (val.length === 0) {
			sizeGroupings = false;
		} else {
			groupings = val.splice(0);
			groupings.sort(function (x, y) {
				if (x < y) {
					return 1;
				}
				else if (x > y) {
					return -1;
				}
				return 0;
			});
			sizeGroupings = true;
		}
	} else {
		if (sizeGroupings === !!val) {
			return;
		}
		sizeGroupings = !!val;
	}
	deviceInfo = null;
};
; 
if (false ) {} 

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**********************************************************************************
 * (c) 2016-2020, Master Technology
 * Licensed under the MIT license or contact me for a Support or Commercial License
 *
 * I do contract work in most languages, so let me solve your problems!
 *
 * Any questions please feel free to email me or put a issue up on the github repo
 * Version 1.4.12                                     Nathan@master-technology.com
 *********************************************************************************/


const appModule = __webpack_require__(30);

/* jshint camelcase: false */
/* global global, java, android, NSString, NSObject, UIScreen */
let getResolution, getDevice, getDeviceType;

if (typeof global.nsPlatform === 'undefined') {
    global.nsPlatform = {
        ios: false,
        android: false,
        type: {ANDROID: 1, IOS: 2},
        TYPE: {ANDROID: 1, IOS: 2},
        isAndroid: function() { return global.nsPlatform.android; },
        isIOS: function() { return global.nsPlatform.ios; },
        hasSoftNav: function() {
            const devInfo = getDevice();
            return (devInfo.softNav);
        },
        platform: 0,
    };
    // Screen Sizes since platforms are not accurate after a rotation event
    Object.defineProperty(global.nsPlatform, "screen", {
        get: function() { return getResolution(); }
    });
    Object.defineProperty(global.nsPlatform, "device", {
        get: function() { return getDevice(); }
    });
    Object.defineProperty(global.nsPlatform, "deviceType", {
        get: function() { return getDeviceType(); }
    });


    if (typeof java !== 'undefined' && typeof android !== 'undefined') {
        global.nsPlatform.android = true;
        global.nsPlatform.platform = global.nsPlatform.type.ANDROID;
    } else if (typeof NSString !== 'undefined' && typeof NSObject !== 'undefined') {
        global.nsPlatform.ios = true;
        global.nsPlatform.platform = global.nsPlatform.type.IOS;
    }

    // Lock the object down to prevent any changes
    Object.freeze(global.nsPlatform);
}


module.exports = global.nsPlatform;


// ---------------------------------------------------------------
// Getting android context
// ---------------------------------------------------------------
function getContext() {
    if (appModule.android.context) {
        return (appModule.android.context);
    }
    if (typeof appModule.getNativeApplication === 'function') {
        let ctx = appModule.getNativeApplication();
        if (ctx) {
            return ctx;
        }
    }

    let ctx = java.lang.Class.forName("android.app.AppGlobals").getMethod("getInitialApplication", null).invoke(null, null);
    if (ctx) { return ctx; }

    return java.lang.Class.forName("android.app.ActivityThread").getMethod("currentApplication", null).invoke(null, null);
}


if (nsPlatform.android) {
    getResolution = function(v) {
        const context = getContext();
        const metrics = new android.util.DisplayMetrics();
        if (v === false) {
            context.getSystemService(android.content.Context.WINDOW_SERVICE).getDefaultDisplay().getMetrics(metrics);
        } else {
            context.getSystemService(android.content.Context.WINDOW_SERVICE).getDefaultDisplay().getRealMetrics(metrics);
        }

        let left=0,right=0,bottom=0,top=0, detected=false;
        if (android.os.Build.VERSION.SDK_INT >= 28 /* android.os.Build.VERSION_CODES.P */) {

            // Please note; Android won't return this value until the application activity window has been attached.
            // So detected = false, until the screen is attached on android...
            const activityContext = appModule.android.foregroundActivity || appModule.android.startActivity;
            const wi = activityContext.getWindow().getDecorView().getRootWindowInsets();
            if (wi) {
                const dc = wi.getDisplayCutout();
                if (dc) {
                    top = dc.getSafeInsetTop();
                    left = dc.getSafeInsetLeft();
                    bottom = dc.getSafeInsetBottom();
                    right = dc.getSafeInsetRight();
                    detected = true;
                } else {
                    detected = false;
                    // console.log("Display cutout is invalid");
                }
            } else {
                detected = false;
                // console.log("Window is invalid!");
            }
        }

        return {
            insets: {left: left, right: right, top: top, bottom: bottom, detected: detected},
            width: parseInt(metrics.widthPixels / metrics.density,10),
            height: parseInt(metrics.heightPixels / metrics.density,10),
            scale: metrics.density,
            widthPixels: metrics.widthPixels,
            heightPixels: metrics.heightPixels
        };
    };

    let deviceInfoCache = null;
    getDevice = function() {
        if (deviceInfoCache) { return deviceInfoCache; }
        deviceInfoCache = {emulator: false, model: "emulator", name: "emulator", manufacturer: "generic", notch: false, softNav: false};
        let context = getContext();

        const res = android.os.Build.FINGERPRINT;
        if (res != null && (res.indexOf("vbox86") >= 0 || res.indexOf("generic") >= 0 || res.indexOf("sdk") >=0 )) { deviceInfoCache.emulator = true; }

        const hwres = android.os.Build.HARDWARE;
        if (hwres != null && (res.indexOf("goldfish") >= 0 || res.indexOf("ranchu") >= 0 || res.indexOf("vbox86") >= 0)) { deviceInfoCache.emulator = true; }


        deviceInfoCache.manufacturer = android.os.Build.MANUFACTURER;
        deviceInfoCache.model = android.os.Build.MODEL;

        const betterModel = android.provider.Settings.Secure.getString(context.getContentResolver(), "bluetooth_name");
        if (betterModel) { deviceInfoCache.name = betterModel.toString();}
        else deviceInfoCache.name = deviceInfoCache.model;

        // Figure out if Android has SoftNav or buttons...
        const fake = getResolution(false);
        const real = getResolution(true);
        deviceInfoCache.softNav = ((fake.widthPixels < real.widthPixels) || (fake.heightPixels < real.heightPixels));

        // Notch detection
        let statusBarHeight = 0;
        let resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android");
        if (resourceId > 0) {
            statusBarHeight = context.getResources().getDimensionPixelSize(resourceId);
            //const metrics = new android.util.DisplayMetrics();
            //context.getSystemService(android.content.Context.WINDOW_SERVICE).getDefaultDisplay().getRealMetrics(metrics);
            statusBarHeight = parseInt( (statusBarHeight / real.scale), 10);
        }
        if (statusBarHeight > 24) { deviceInfoCache.notch = true; }

        return deviceInfoCache;
    };

    let deviceTypeCache = null;
    getDeviceType = function() {
        if (deviceTypeCache) { return deviceTypeCache; }
        if (getContext().getResources().getConfiguration().smallestScreenWidthDp >= 600) {
            deviceTypeCache = "Tablet";
        } else {
            deviceTypeCache = "Phone";
        }
        return deviceTypeCache;
    };

} else if (nsPlatform.ios) {
    getResolution = function() {

        // Get Application primary window
        let window = UIApplication.sharedApplication.keyWindow;
        if (!window) {
            window = UIApplication.sharedApplication.windows[0]
        }
        let left=0,top=0,bottom=0,right=0, detected=false;
        if (window) {
            let screenDims = window.safeAreaInsets;
            if (screenDims) {
                left = screenDims.left;
                right = screenDims.right;
                top = screenDims.top;
                bottom = screenDims.bottom;
                detected = true;
            }
        }

        const screen = UIScreen.mainScreen;
        return {
            insets: {left: left, right: right, top: top, bottom: bottom, detected: detected},
            width: screen.bounds.size.width,
            height: screen.bounds.size.height,
            scale: screen.scale,
            widthPixels: screen.bounds.size.width * screen.scale,
            heightPixels: screen.bounds.size.height * screen.scale,
        };
    };

    let deviceInfoCache = null;
    getDevice = function() {
        if (deviceInfoCache) { return deviceInfoCache; }
        deviceInfoCache = {emulator: false, model: "emulator", name: "emulator", manufacturer: "Apple", notch: false, softNav: false};
        // See: https://github.com/NativeScript/ios-runtime/issues/698
        const _SYS_NAMELEN = 256;
        const buffer = interop.alloc(5 * _SYS_NAMELEN);
        uname(buffer);
        let _machine = NSString.stringWithUTF8String(buffer.add(_SYS_NAMELEN * 4)).toString();

        // Get machine name for Simulator
        if (_machine === "x86_64" || _machine === "i386") {
            deviceInfoCache.emulator = true;
            let env = NSProcessInfo.processInfo.environment;
            _machine = env.objectForKey("SIMULATOR_MODEL_IDENTIFIER");
        }
        deviceInfoCache.model = _machine;

        switch (_machine) {
            // region iPhone's
            case "iPhone1,1":
                deviceInfoCache.name = "iPhone";
                break;
            case "iPhone1,2":
                deviceInfoCache.name = "iPhone3G";
                break;
            case "iPhone2,1":
                deviceInfoCache.name = "iPhone3GS";
                break;
            case "iPhone3,1":
            case "iPhone3,2":
            case "iPhone3,3":
                deviceInfoCache.name = "iPhone4";
                break;
            case "iPhone4,1":
                deviceInfoCache.name = "iPhone4S";
                break;
            case "iPhone5,1":
            case "iPhone5,2":
                deviceInfoCache.name = "iPhone5";
                break;
            case "iPhone5,3":
            case "iPhone5,4":
                deviceInfoCache.name = "iPhone5C";
                break;
            case "iPhone6,1":
            case "iPhone6,2":
                deviceInfoCache.name = "iPhone5S";
                break;
            case "iPhone7,1":
                deviceInfoCache.name = "iPhone6Plus";
                break;
            case "iPhone7,2":
                deviceInfoCache.name = "iPhone6";
                break;
            case "iPhone8,1":
                deviceInfoCache.name = "iPhone6S";
                break;
            case "iPhone8,2":
                deviceInfoCache.name = "iPhone6SPlus";
                break;
            case "iPhone8,4":
                deviceInfoCache.name = "iPhoneSE";
                break;
            case "iPhone9,1":
            case "iPhone9,3":
                deviceInfoCache.name = "iPhone7";
                break;
            case "iPhone9,2":
            case "iPhone9,4":
                deviceInfoCache.name = "iPhone7Plus";
                break;
            case "iPhone10,1":
            case "iPhone10,4":
                deviceInfoCache.name = "iPhone8";
                break;
            case "iPhone10,2":
            case "iPhone10,5":
                deviceInfoCache.name = "iPhone8Plus";
                break;
            case "iPhone10,3":
            case "iPhone10,6":
                deviceInfoCache.name = "iPhoneX";
                deviceInfoCache.softNav = true;
                deviceInfoCache.notch = true;
                break;
            case "iPhone11,2":
                deviceInfoCache.name = "iPhoneXS";
                deviceInfoCache.softNav = true;
                deviceInfoCache.notch = true;
                break;
            case "iPhone11,4":
            case "iPhone11,6":
                deviceInfoCache.name = "iPhoneXSMax";
                deviceInfoCache.softNav = true;
                deviceInfoCache.notch = true;
                break;
            case "iPhone11,8":
                deviceInfoCache.name = "iPhoneXR";
                deviceInfoCache.notch = true;
                deviceInfoCache.softNav = true;
                break;

            case "iPhone12,1":
            case "iPhone12,2":
                deviceInfoCache.name = "iPhone11";
                deviceInfoCache.softNav = true;
                deviceInfoCache.notch = true;
                break;
            case "iPhone12,3":
            case "iPhone12,4":
                deviceInfoCache.name = "iPhone11Pro";
                deviceInfoCache.softNav = true;
                deviceInfoCache.notch = true;
                break;
            case "iPhone12,5":
            case "iPhone12,6":
                deviceInfoCache.name = "iPhone11ProMax";
                deviceInfoCache.softNav = true;
                deviceInfoCache.notch = true;
                break;

            case "iPhone12,8":
                deviceInfoCache.name = "iPhoneSE2";
                deviceInfoCache.softNav = false;
                deviceInfoCache.notch = false;
                break;
            // endregion iPhone

            /// region AppleTv
            case "AppleTV1,1":
                deviceInfoCache.name = "AppleTV";
                break;

            case 'AppleTV2,1':
                deviceInfoCache.name = 'AppleTV 2';
                break;

            case 'AppleTV3,1':
            case 'AppleTV3,2':
                deviceInfoCache.name = 'AppleTV 3';
                break;

            case "AppleTV5,3":
                    deviceInfoCache.name = "AppleTV HD";
                    break;

            case "AppleTV6,2":
                deviceInfoCache.name = "AppleTV 4K";
                break;
            /// endregion AppleTv

            /// region iPad's
            case "iPad1,1":
                deviceInfoCache.name = "iPad";
                break;
            case "iPad2,1":
            case "iPad2,2":
            case "iPad2,3":
            case "iPad2,4":
                deviceInfoCache.name = "iPad 2";
                break;
            case "iPad2,5":
            case "iPad2,6":
            case "iPad2,7":
                deviceInfoCache.name = "iPad Mini 1";
                break;
            case "iPad3,1":
            case "iPad3,2":
            case "iPad3,3":
                deviceInfoCache.name = "iPad 3";
                break;
            case "iPad3,4":
            case "iPad3,5":
            case "iPad3,6":
                deviceInfoCache.name = "iPad 4";
                break;
            case "iPad4,1":
            case "iPad4,2":
            case "iPad4,3":
                deviceInfoCache.name = "iPad Air";
                break;

            case "iPad4,4":
            case "iPad4,5":
            case "iPad4,6":
                deviceInfoCache.name = "iPad Mini 2";
                break;

            case "iPad4,7":
            case "iPad4,8":
            case "iPad4,9":
                deviceInfoCache.name = "iPad Mini 3";
                break;

            case "iPad5,1":
            case "iPad5,2":
                deviceInfoCache.name = "iPad Mini 4";
                break;

            case "iPad5,3":
            case "iPad5,4":
                deviceInfoCache.name = "iPad Air 2";
                break;

            case "iPad6,3":
            case "iPad6,4":
                deviceInfoCache.name = "iPad 9.7 Pro";
                break;

            case "iPad6,7":
            case "iPad6,8":
                deviceInfoCache.name = "iPad 12.9 Pro";
                break;

            case "iPad6,11":
            case "iPad6,12":
                deviceInfoCache.name = "iPad 5";
                break;  // 5th gen

            case "iPad7,1":
            case "iPad7,2":
                deviceInfoCache.name = "iPad 12.9 Pro 2";
                break;

            case "iPad7,3":
            case "iPad7,4":
                deviceInfoCache.name = "iPad 10.5 Pro";
                break;

            case "iPad7,5":
            case "iPad7,6":
                deviceInfoCache.name = "iPad 6"; // 6th Gen
                break;

            case "iPad7,11":
            case "iPad7,12":
                deviceInfoCache.name = "iPad 7"; // 7th Gen
                break;

            case "iPad8,1":
            case "iPad8,2":
            case "iPad8,3":
            case "iPad8,4":
                deviceInfoCache.name = "iPad 11.0 Pro";
                deviceInfoCache.softNav = true;
                break;

            case "iPad8,5":
            case "iPad8,6":
            case "iPad8,7":
            case "iPad8,8":
                deviceInfoCache.name = "iPad 12.9 Pro 3"; // 3rd Gen
                deviceInfoCache.softNav = true;
                break;

            case 'iPad8,9':
            case 'iPad8,10':
                deviceInfoCache.name = "iPad 11.0 Pro 2"; //2nd gen
                deviceInfoCache.softNav = true;
                break;

            case "iPad8,11":
            case "iPad8,12":
                deviceInfoCache.name = "iPad 12.9 Pro 4"; // 4th Gen
                deviceInfoCache.softNav = true;
                break;

            case "iPad11,1":
            case "iPad11,2":
                deviceInfoCache.name = "iPad Mini 5"; // 5th Gen
                break;

            case "iPad11,3":
            case "iPad11,4":
                deviceInfoCache.name = "iPad Air 3"; // 3rd Gen
                break;

            case "iPad11,6":
            case "iPad11,7":
                deviceInfoCache.name = "iPad 8"; // 8th Gen
                break;

            case "iPad13,1":
            case "iPad13,2":
                deviceInfoCache.name = "iPad Air 4"; // 4th Gen
                break;

            /// endregion iPad

            /// region iPod's
            case "iPod1,1":
                deviceInfoCache.name = "iPod 1G";
                break;
            case "iPod2,1":
                deviceInfoCache.name = "iPod 2G";
                break;
            case "iPod3,1":
                deviceInfoCache.name = "iPod 3G";
                break;
            case "iPod4,1":
                deviceInfoCache.name = "iPod 4G";
                break;
            case "iPod5,1":
                deviceInfoCache.name = "iPod 5G";
                break;
            case "iPod7,1":
                deviceInfoCache.name = "iPod 6G";
                break;
            case "iPod9,1":
                deviceInfoCache.name = "iPod 7G";
                break;

            // endregion

            // Since we couldn't detect the device based on device id; we will attempt to figure this out programatically
            default:
                deviceInfoCache.name = _machine;

                // Grab the screen resolution.
                let screen = getResolution();

                // If we have a left and right inset; this means the phone has a notch.
                if (screen.insets.left > 0 || screen.insets.right > 0) {
                    deviceInfoCache.notch = true;
                }

                // If we have a tob and bottom inset; this means the phone has a notch and softnav
                if (screen.insets.top > 0 && screen.insets.bottom > 0) {
                    deviceInfoCache.softNav = true;
                    deviceInfoCache.notch = true;
                }

                // If we have a bottom inset, this means we have softnav active
                if (screen.insets.bottom > 0) {
                    deviceInfoCache.softNav = true;
                }

                // If the notch/screen value was not actually detected, is not a valid cache; clear cache
                if (!screen.insets.detected) {
                    const tempInfo = deviceInfoCache;
                    deviceInfoCache = null;
                    return tempInfo;
                }

                break;
        }

        return deviceInfoCache;
    };

    getDeviceType = function() {
        if (UIDevice.currentDevice.userInterfaceIdiom === 0) {
            return "Phone";
        }
        return "Tablet";
    };
}
; 
if (false ) {} 
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 416 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetworkDomainDebugger", function() { return NetworkDomainDebugger; });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
var NetworkDomainDebugger_1;
const inspectorCommands = __webpack_require__(99);

const frameId = 'NativeScriptMainFrameIdentifier';
const loaderId = 'Loader Identifier';
const resources_datas = [];
const documentTypeByMimeType = {
    'text/xml': 'Document',
    'text/plain': 'Document',
    'text/html': 'Document',
    'application/xml': 'Document',
    'application/xhtml+xml': 'Document',
    'text/css': 'Stylesheet',
    'text/javascript': 'Script',
    'text/ecmascript': 'Script',
    'application/javascript': 'Script',
    'application/ecmascript': 'Script',
    'application/x-javascript': 'Script',
    'application/json': 'Script',
    'application/x-json': 'Script',
    'text/x-javascript': 'Script',
    'text/x-json': 'Script',
    'text/typescript': 'Script',
};
class Request {
    constructor(_networkDomainDebugger, _requestID) {
        this._networkDomainDebugger = _networkDomainDebugger;
        this._requestID = _requestID;
    }
    get mimeType() {
        return this._mimeType;
    }
    set mimeType(value) {
        if (this._mimeType !== value) {
            if (!value) {
                this._mimeType = 'text/plain';
                this._resourceType = 'Other';
                return;
            }
            this._mimeType = value;
            let resourceType = 'Other';
            if (this._mimeType in documentTypeByMimeType) {
                resourceType = documentTypeByMimeType[this._mimeType];
            }
            if (this._mimeType.indexOf('image/') !== -1) {
                resourceType = 'Image';
            }
            if (this._mimeType.indexOf('font/') !== -1) {
                resourceType = 'Font';
            }
            this._resourceType = resourceType;
        }
    }
    get requestID() {
        return this._requestID;
    }
    get hasTextContent() {
        return ['Document', 'Stylesheet', 'Script', 'XHR'].indexOf(this._resourceType) !== -1;
    }
    get data() {
        return this._data;
    }
    set data(value) {
        if (this._data !== value) {
            this._data = value;
        }
    }
    get resourceType() {
        return this._resourceType;
    }
    set resourceType(value) {
        if (this._resourceType !== value) {
            this._resourceType = value;
        }
    }
    responseReceived(response) {
        if (this._networkDomainDebugger.enabled) {
            this._networkDomainDebugger.events.responseReceived(this.requestID, frameId, loaderId, __inspectorTimestamp(), this.resourceType, response);
        }
    }
    loadingFinished() {
        if (this._networkDomainDebugger.enabled) {
            this._networkDomainDebugger.events.loadingFinished(this.requestID, __inspectorTimestamp());
        }
    }
    requestWillBeSent(request) {
        if (this._networkDomainDebugger.enabled) {
            this._networkDomainDebugger.events.requestWillBeSent(this.requestID, frameId, loaderId, request.url, request, __inspectorTimestamp(), { type: 'Script' });
        }
    }
}
let NetworkDomainDebugger = NetworkDomainDebugger_1 = class NetworkDomainDebugger {
    constructor() {
        this.events = new inspectorCommands.NetworkDomain.NetworkFrontend();
        // By default start enabled because we can miss the "enable" event when
        // running with `--debug-brk` -- the frontend will send it before we've been created
        this.enable();
    }
    get enabled() {
        return this._enabled;
    }
    /**
     * Enables network tracking, network events will now be delivered to the client.
     */
    enable() {
        if (___WEBPACK_IMPORTED_MODULE_0__[/* getNetwork */ "c"]()) {
            throw new Error('One NetworkDomainDebugger may be enabled at a time.');
        }
        else {
            ___WEBPACK_IMPORTED_MODULE_0__[/* setNetwork */ "f"](this);
        }
        this._enabled = true;
    }
    /**
     * Disables network tracking, prevents network events from being sent to the client.
     */
    disable() {
        if (___WEBPACK_IMPORTED_MODULE_0__[/* getNetwork */ "c"]() === this) {
            ___WEBPACK_IMPORTED_MODULE_0__[/* setNetwork */ "f"](null);
        }
        this._enabled = false;
    }
    /**
     * Specifies whether to always send extra HTTP headers with the requests from this page.
     */
    setExtraHTTPHeaders(params) {
        //
    }
    /**
     * Returns content served for the given request.
     */
    getResponseBody(params) {
        const resource_data = resources_datas[params.requestId];
        const body = resource_data.hasTextContent ? NSString.alloc().initWithDataEncoding(resource_data.data, 4).toString() : resource_data.data.base64EncodedStringWithOptions(0);
        if (resource_data) {
            return {
                body: body,
                base64Encoded: !resource_data.hasTextContent,
            };
        }
    }
    /**
     * Tells whether clearing browser cache is supported.
     */
    canClearBrowserCache() {
        return {
            result: false,
        };
    }
    /**
     * Clears browser cache.
     */
    clearBrowserCache() {
        //
    }
    /**
     * Tells whether clearing browser cookies is supported.
     */
    canClearBrowserCookies() {
        return {
            result: false,
        };
    }
    /**
     * Clears browser cookies.
     */
    clearBrowserCookies() {
        //
    }
    /**
     * Toggles ignoring cache for each request. If <code>true</code>, cache will not be used.
     */
    setCacheDisabled(params) {
        //
    }
    /**
     * Loads a resource in the context of a frame on the inspected page without cross origin checks.
     */
    loadResource(params) {
        let appPath = NSBundle.mainBundle.bundlePath;
        let pathUrl = params.url.replace('file://', appPath);
        let fileManager = NSFileManager.defaultManager;
        let data = fileManager.fileExistsAtPath(pathUrl) ? fileManager.contentsAtPath(pathUrl) : undefined;
        let content = data ? NSString.alloc().initWithDataEncoding(data, NSUTF8StringEncoding) : '';
        return {
            content: content.toString(),
            mimeType: 'application/octet-stream',
            status: 200,
        };
    }
    create() {
        let id = (++NetworkDomainDebugger_1.idSequence).toString();
        let resourceData = new Request(this, id);
        resources_datas[id] = resourceData;
        return resourceData;
    }
};
NetworkDomainDebugger.idSequence = 0;
NetworkDomainDebugger = NetworkDomainDebugger_1 = __decorate([
    inspectorCommands.DomainDispatcher('Network'),
    __metadata("design:paramtypes", [])
], NetworkDomainDebugger);

//# sourceMappingURL=webinspector-network.ios.js.map; 
if (false ) {} 

/***/ }),
/* 417 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMDomainDebugger", function() { return DOMDomainDebugger; });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _devtools_elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
const inspectorCommands = __webpack_require__(99);


let DOMDomainDebugger = class DOMDomainDebugger {
    constructor() {
        this.events = new inspectorCommands.DOMDomain.DOMFrontend();
        this.commands = {};
        Object(_devtools_elements__WEBPACK_IMPORTED_MODULE_1__[/* attachDOMInspectorEventCallbacks */ "c"])(this.events);
        Object(_devtools_elements__WEBPACK_IMPORTED_MODULE_1__[/* attachDOMInspectorCommandCallbacks */ "b"])(this.commands);
        // By default start enabled because we can miss the "enable event when
        // running with `--debug-brk` -- the frontend will send it before we've been created
        this.enable();
    }
    get enabled() {
        return this._enabled;
    }
    enable() {
        if (___WEBPACK_IMPORTED_MODULE_0__[/* getDOM */ "b"]()) {
            throw new Error('One DOMDomainDebugger may be enabled at a time.');
        }
        else {
            ___WEBPACK_IMPORTED_MODULE_0__[/* setDOM */ "e"](this);
        }
        this._enabled = true;
    }
    /**
     * Disables network tracking, prevents network events from being sent to the client.
     */
    disable() {
        if (___WEBPACK_IMPORTED_MODULE_0__[/* getDOM */ "b"]() === this) {
            ___WEBPACK_IMPORTED_MODULE_0__[/* setDOM */ "e"](null);
        }
        this._enabled = false;
    }
    getDocument() {
        const domNode = this.commands.getDocument();
        return { root: domNode };
    }
    removeNode(params) {
        this.commands.removeNode(params.nodeId);
    }
    setAttributeValue(params) {
        throw new Error('Method not implemented.');
    }
    setAttributesAsText(params) {
        this.commands.setAttributeAsText(params.nodeId, params.text, params.name);
    }
    removeAttribute(params) {
        throw new Error('Method not implemented.');
    }
    performSearch(params) {
        return null;
    }
    getSearchResults(params) {
        return null;
    }
    discardSearchResults(params) {
        return;
    }
    highlightNode(params) {
        return;
    }
    hideHighlight() {
        return;
    }
    resolveNode(params) {
        return null;
    }
};
DOMDomainDebugger = __decorate([
    inspectorCommands.DomainDispatcher('DOM'),
    __metadata("design:paramtypes", [])
], DOMDomainDebugger);

//# sourceMappingURL=webinspector-dom.ios.js.map; 
if (false ) {} 

/***/ }),
/* 418 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSDomainDebugger", function() { return CSSDomainDebugger; });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _devtools_elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
const inspectorCommands = __webpack_require__(99);


let CSSDomainDebugger = class CSSDomainDebugger {
    constructor() {
        this.events = new inspectorCommands.CSSDomain.CSSFrontend();
        this.commands = {};
        Object(_devtools_elements__WEBPACK_IMPORTED_MODULE_1__[/* attachCSSInspectorCommandCallbacks */ "a"])(this.commands);
        // By default start enabled because we can miss the "enable" event when
        // running with `--debug-brk` -- the frontend will send it before we've been created
        this.enable();
    }
    get enabled() {
        return this._enabled;
    }
    enable() {
        if (___WEBPACK_IMPORTED_MODULE_0__[/* getCSS */ "a"]()) {
            throw new Error('One CSSDomainDebugger may be enabled at a time.');
        }
        else {
            ___WEBPACK_IMPORTED_MODULE_0__[/* setCSS */ "d"](this);
        }
        this._enabled = true;
    }
    /**
     * Disables network tracking, prevents network events from being sent to the client.
     */
    disable() {
        if (___WEBPACK_IMPORTED_MODULE_0__[/* getCSS */ "a"]() === this) {
            ___WEBPACK_IMPORTED_MODULE_0__[/* setCSS */ "d"](null);
        }
        this._enabled = false;
    }
    getMatchedStylesForNode(params) {
        return {};
    }
    // Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by <code>nodeId</code>.
    getInlineStylesForNode(params) {
        return {};
    }
    // Returns the computed style for a DOM node identified by <code>nodeId</code>.
    getComputedStyleForNode(params) {
        return {
            computedStyle: this.commands.getComputedStylesForNode(params.nodeId),
        };
    }
    // Requests information about platform fonts which we used to render child TextNodes in the given node.
    getPlatformFontsForNode(params) {
        return {
            fonts: [
                {
                    // Font's family name reported by platform.
                    familyName: 'Standard Font',
                    // Indicates if the font was downloaded or resolved locally.
                    isCustomFont: false,
                    // Amount of glyphs that were rendered with this font.
                    glyphCount: 0,
                },
            ],
        };
    }
    // Returns the current textual content and the URL for a stylesheet.
    getStyleSheetText(params) {
        return null;
    }
};
CSSDomainDebugger = __decorate([
    inspectorCommands.DomainDispatcher('CSS'),
    __metadata("design:paramtypes", [])
], CSSDomainDebugger);

//# sourceMappingURL=webinspector-css.ios.js.map; 
if (false ) {} 

/***/ }),
/* 419 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return /* binding */ requestAnimationFrame; });
__webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return /* binding */ cancelAnimationFrame; });

// CONCATENATED MODULE: ../node_modules/@nativescript/core/fps-meter/fps-native.js
var FrameHandlerImpl = /** @class */ (function (_super) {
    __extends(FrameHandlerImpl, _super);
    function FrameHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FrameHandlerImpl.initWithOwner = function (owner) {
        var handler = FrameHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    FrameHandlerImpl.prototype.handleFrame = function (sender) {
        var owner = this._owner.get();
        if (owner) {
            owner._handleFrame(sender);
        }
    };
    FrameHandlerImpl.ObjCExposedMethods = {
        handleFrame: { returns: interop.types.void, params: [CADisplayLink] },
    };
    return FrameHandlerImpl;
}(NSObject));
class FPSCallback {
    constructor(onFrame) {
        this.onFrame = onFrame;
        this.impl = FrameHandlerImpl.initWithOwner(new WeakRef(this));
        this.displayLink = CADisplayLink.displayLinkWithTargetSelector(this.impl, 'handleFrame');
        this.displayLink.paused = true;
        this.displayLink.addToRunLoopForMode(NSRunLoop.currentRunLoop, NSDefaultRunLoopMode);
        // UIScrollView (including in UIITableView) will run a loop in UITrackingRunLoopMode during scrolling.
        // If we do not add the CADisplayLink in this mode, it would appear paused during scrolling.
        this.displayLink.addToRunLoopForMode(NSRunLoop.currentRunLoop, UITrackingRunLoopMode);
    }
    start() {
        if (this.running) {
            return;
        }
        this.running = true;
        this.displayLink.paused = false;
    }
    stop() {
        if (!this.running) {
            return;
        }
        this.displayLink.paused = true;
        this.running = false;
    }
    _handleFrame(sender) {
        if (!this.running) {
            return;
        }
        // timestamp is CFTimeInterval, which is in seconds, the onFrame callback expects millis, so multiply by 1000
        this.onFrame(sender.timestamp * 1000);
    }
}
//# sourceMappingURL=fps-native.ios.js.map; 
if (false ) {} 
// EXTERNAL MODULE: ../node_modules/@nativescript/core/profiling/index.js
var profiling = __webpack_require__(9);

// CONCATENATED MODULE: ../node_modules/@nativescript/core/animation-frame/animation-native.js

const getTimeInFrameBase = profiling["l" /* time */];
//# sourceMappingURL=animation-native.ios.js.map; 
if (false ) {} 
// CONCATENATED MODULE: ../node_modules/@nativescript/core/animation-frame/index.js


let animationId = 0;
let nextFrameAnimationCallbacks = {};
let shouldStop = true;
let inAnimationFrame = false;
let fpsCallback;
let lastFrameTime = 0;
function getNewId() {
    return animationId++;
}
function ensureNative() {
    if (fpsCallback) {
        return;
    }
    fpsCallback = new FPSCallback(doFrame);
}
function doFrame(currentTimeMillis) {
    lastFrameTime = currentTimeMillis;
    shouldStop = true;
    const thisFrameCbs = nextFrameAnimationCallbacks;
    nextFrameAnimationCallbacks = {};
    inAnimationFrame = true;
    for (const animationId in thisFrameCbs) {
        if (thisFrameCbs[animationId]) {
            thisFrameCbs[animationId](lastFrameTime);
        }
    }
    inAnimationFrame = false;
    if (shouldStop) {
        fpsCallback.stop(); // TODO: check performance without stopping to allow consistent frame times
    }
}
function requestAnimationFrame(cb) {
    if (!inAnimationFrame) {
        inAnimationFrame = true;
        zonedCallback(cb)(getTimeInFrameBase()); // TODO: store and use lastFrameTime
        inAnimationFrame = false;
        return getNewId();
    }
    ensureNative();
    const animId = getNewId();
    nextFrameAnimationCallbacks[animId] = zonedCallback(cb);
    shouldStop = false;
    fpsCallback.start();
    return animId;
}
function cancelAnimationFrame(id) {
    delete nextFrameAnimationCallbacks[id];
}
//# sourceMappingURL=index.js.map; 
if (false ) {} 

/***/ }),
/* 420 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
console.log('Loading inspector modules...');

__webpack_require__(416);
__webpack_require__(417);
__webpack_require__(418);
console.log('Finished loading inspector modules.');
//# sourceMappingURL=inspector_modules.ios.js.map; 
if (false ) {} 

/***/ })
]]);